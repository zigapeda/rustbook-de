<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können - Die Programmiersprache Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box<T> auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc<T></a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können" id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können">Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen 
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte 
(values) im Gültigkeitsbereich (scope) in dem sie erstellt wurden zugreifen.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3><a class="header" href="#mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen" id="mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen">Mit Funktionsabschlüssen Verhaltensabstraktion erzeugen</a></h3>
<p>Lass uns an einem Beispiel einer Situation arbeiten, in der es nützlich ist, einen
Funktionsabschluss zu speichern, um ihn später auszuführen. In dieser Zeit werden
wir über Typinferenz, Merkmale (traits) und die Syntax von Funktionsabschlüssen
sprechen.</p>
<p>Ziehe diese hypothetische Situation in Betracht: Wir arbeiten für ein Start-up 
das eine App entwickelt die benutzerdefinierte Work-out-Trainingspläne generiert.
Das Backend ist in Rust geschrieben und der Algorithmus, der die Trainingspläne
erzeugt, berücksichtigt viele Faktoren: Das Alter des Benutzers, Body Mass Index,
Übungsvoreinstellungen, kürzlich erfolgte Work-outs und eine Zahl, die deren
Intensität festlegt. Der eigentliche Algorithmus ist für unser Beispiel nicht
wichtig. Bemerkenswert ist, dass die Berechnung ein paar Sekunden Zeit benötigt,
um die Wartezeit für den Benutzer zu verkürzen, wollen wir daher den Algorithmus
nur einmal aufrufen, und zwar dann, wenn es notwendig ist.</p>
<p>Den Aufruf des hypothetischen Algorithmus werden wir mit der Funktion
<code>simulated_expensive_calculation</code> die im Codeblock 13-1 gezeigt wird und
<code>rechnet langsam...</code>, ausgibt, zwei Sekunden lang wartet und dann die Nummer
zurückgibt die wir übergeben haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;rechnet langsam...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-1: Eine Funktion die für eine hypothetische
Berechnung steht, die etwa 2 Sekunden Laufzeit benötigt.</span></p>
<p>Als Nächstes folgt die Hauptfunktion <code>main</code>, welche die für unser Beispiel
relevanten Teile beinhalten wird. Diese Funktion stellt den Code dar, den die App
aufrufen wird, wenn ein Benutzer einen Trainingsplan anfordert. Da die
Interaktion mit dem Frontend für die Benutzung von Funktionsabschlüssen nicht
von Bedeutung ist, werden Werte die Eingaben (inputs) repräsentieren fest
einprogrammiert (hardcoded) und Ausgaben (outputs) einfach mit <code>print</code>
ausgegeben.</p>
<p>Das sind die benötigten Eingaben:</p>
<ul>
<li>Eine Intensitätszahl mit der die Benutzer festlegen können ob ein Training
von leichter oder hoher Intensität sein soll.</li>
<li>Eine Zufallszahl, die für Abwechslung im Trainingsplan sorgt.</li>
</ul>
<p>Ausgegeben wird der empfohlene Trainingsplan. Codeblock 13-2 zeigt die
Funktion <code>main</code> die wir benutzen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span><span class="boring">
</span>fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-2: Eine Funktion <code>main</code> mit fest
einprogrammierten Werten, um Eingaben zu simulieren und Zufallszahlen zu
erzeugen</span></p>
<p>Die Variable <code>simulated_user_specified_value</code> wurde als 10 fest einprogrammiert
und die Variable <code>simulated_random_number</code> zur Vereinfachung als 7. In einem
tatsächlichen Programm würden wir die Intensitäts-Zahl vom App-Frontend bekommen
und wir würden die Kiste (crate) <code>rand</code> benutzen um eine Zufallszahl zu
erzeugen, so wie wir es im Ratespiel-Beispiel in Kapitel 2 bereits gemacht
haben. Die Funktion <code>main</code> ruft eine Funktion <code>generate_workout</code> mit
simulierten Eingabewerten auf.</p>
<p>Nun da wir einen Kontext haben, lass uns zum Algorithmus kommen. Die Funktion
<code>generate_workout</code> im Codeblock 13-3 beinhaltet die Anwendungslogik der App
mit der wir in diesem Beispiel am häufigsten zu tun haben werden, die folgenden
Veränderungen werden diese Funktion betreffen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Mach heute {} Liegestütze!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Als nächstes {} Sit-ups!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span><span class="boring">
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Die Anwendungslogik, die Trainingspläne anhand
der Eingaben und durch Aufrufe der Funktion <code>simulated_expensive_calculation</code>
ausgibt</span></p>
<p>Der Code im Codeblock 13-3 ruft die langsame Berechnungsfunktion mehrfach auf.
Der erste <code>if</code>-Block verwendet <code>simulated_expensive_calculation</code> zweifach, das
<code>if</code> im äußeren <code>else</code> verwendet die Berechnung nicht und der Code im zweiten
<code>else</code> einmal.</p>
<p>Das gewünschte Verhalten der Funktion <code>generate_workout</code> ist, als Erstes zu
überprüfen, ob der Benutzer ein Training von niedriger Intensität möchte
(gekennzeichnet durch eine Zahl kleiner 25) oder ein Training von hoher
Intensität (eine Zahl größer oder gleich 25). </p>
<p>Trainingspläne von niedriger Intensität empfehlen eine mittels simulierten 
Algorithmus berechnete Anzahl von Liegestützen und Sit-ups.</p>
<p>Falls der Benutzer ein Training von hoher Intensität anfordert, gibt es eine 
zusätzliche Logik: Ergibt der Wert der ermittelten Zufallszahl 3, wird die App
dem Benutzer eine Trinkpause empfehlen, falls sich eine andere Zahl ergibt,
werden dem Benutzer einige Minuten Lauftraining, berechnet durch den simulierten 
Algorithmus, empfohlen.</p>
<p>Lass uns nun annehmen, dass das Datenforschungsteam einige Änderungen anordnet.
Das Programm funktioniert zwar soweit wie gewünscht, aber
<code>simulated_expensive_calculation</code> wird unnötigerweise mehrfach aufgerufen.
Wir sollen daher den Programmcode umformen und vereinfachen, damit die Funktion
nur noch einmal aufgerufen wird, wenn es notwendig ist.</p>
<h4><a class="header" href="#umformen-refactoring-mit-funktionen" id="umformen-refactoring-mit-funktionen">Umformen (refactoring) mit Funktionen</a></h4>
<p>Wir könnten den Programmcode auf viele Arten umstrukturieren, aber zuerst, werden
wir versuchen den doppelten Aufruf der Funktion <code>simulated_expensive_calculation</code>
in eine Variable zu extrahieren, wie es im Codeblock 13-4 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result);
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(&quot;Heute, {} Minuten Lauftrainig!&quot;, expensive_result);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-4: Extraktion der Aufrufe von
<code>simulated_expensive_calculation</code> zu einem Ort und Speichern des Ergebnisses in
der Variable <code>expensive_result</code></span></p>
<p>Diese Änderung vereinigt alle Aufrufe von <code>simulated_expensive_calculation</code> und
löst das Problem mit deren unnötigen doppelten Aufruf im ersten <code>if</code>-Block.
Leider rufen wir nun die Funktion auf und warten in jeden Fall auf das Ergebnis,
sogar im inneren <code>if</code>-Block der den Ergebniswert überhaupt nicht verwendet.</p>
<p>Wir wollen den Code an einer Stelle in unserem Programm definieren, aber
ausschließlich dort ausführen, wo wir das Ergebnis tatsächlich brauchen.</p>
<h4><a class="header" href="#umformen-mit-funktionsabschlüssen-um-programmcode-zu-speichern" id="umformen-mit-funktionsabschlüssen-um-programmcode-zu-speichern">Umformen mit Funktionsabschlüssen um Programmcode zu speichern</a></h4>
<p>Anstatt die Funktion <code>simulated_expensive_calculation</code> vor den <code>if</code>-Blöcken
immer aufzurufen, können wir einen <em>Funktionsabschluss</em> definieren und diesen
anstatt des Resultates in einer Variable abspeichern, wie es im 
Codeblock 13-5 gezeigt wird. Eigentlich können wir den gesamten Rumpf von
<code>simulated_expensive_calculation</code> in einen Funktionsabschluss verschieben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definition eines Funktionsabschlusses 
und dessen Speicherung in der Variable <code>expensive_closure</code></span></p>
<p>Die Definition des Funktionsabschlusses folgt dem <code>=</code> um es der Variable
<code>expensive_closure</code> zuzuweisen. Wir beginnen mit einem Paar vertikaler
Pipes (<code>|</code>), worin wir die Parameter des Funktionsabschlusses spezifizieren.
Diese Syntax wurde ausgewählt, da sie so ähnlich ist wie die Definition von
Funktionsabschlüssen in Ruby und Smalltalk. Dieser Funktionsabschluss hat einen
Parameter <code>num</code>: Sollten mehrere Parameter benötigt werden, würden wir diese mit
Kommata getrennt schreiben wie <code>|param1, param2|</code>.</p>
<p>Hinter den Parameter kommen geschweifte Klammern <code>{}</code> die den Rumpf des
Funktionsabschlusses beinhalten. Diese Klammern sind optional, wenn der Rumpf nur
einen Ausdruck beinhaltet. Zum Schluss benötigen wir nach den geschweiften
Klammern ein Semikolon aufgrund der <code>let</code>-Anweisung. Der Wert, der vom
Funktionsabschluss zurückgegeben wird, ist der Wert der letzten Zeile
im Rumpf des Funktionsabschlusses (<code>num</code>), da diese Zeile nicht mit einem
Semikolon endet, wie auch bei Funktionsrümpfen.</p>
<p>Merke, die <code>let</code>-Anweisung bedeutet, dass <code>expensive_closure</code> die <em>Definition</em>
einer anonymen Funktion beinhaltet und nicht den <em>Wert des Ergebnisses</em> des
Aufrufs der anonymen Funktion. Wir benutzen, zur Erinnerung, einen
Funktionsabschluss, da wir den aufzurufenden Programmcode an einer Stelle
definieren, speichern und ihn später aufrufen wollen. Dieser Programmteil ist nun in
<code>expensive_closure</code> gespeichert.</p>
<p>Da wir nun einen Funktionsabschluss definiert haben, können wir nun den Code im
<code>if</code>-Block so ändern, damit der Funktionsabschluss aufgerufen wird um dessen
Code auszuführen und einen Ergebniswert zu erhalten. Der Aufruf eines
Funktionsabschlusses gleicht dem einer Funktion: Wir geben den Variablennamen
an, der den Funktionsabschluss enthält, gefolgt von den Argumentwerten in
Klammern, die wir verwenden möchten, wie in Codeblock 13-6 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-6: Aufruf der neu definierten
<code>expensive_closure</code></span></p>
<p>Nun wird die langsame Berechnung nur noch an einer Stelle aufgerufen und wir
führen sie nur durch, wenn wir das Ergebnis benötigten.</p>
<p>Wir haben jedoch eines der Probleme von Codeblock 13-3 wieder eingeführt.
Im ersten <code>if</code>-Block rufen wir den Funktionsabschluss mehrfach auf und lassen
somit den Benutzer doppelt solange warten als notwendig. Wir könnten das Problem
beheben, indem wir eine lokale Variable definieren die das Ergebnis des
Funktionsabschluss-Aufrufs hält. Funktionsabschlüsse bieten uns eine andere
Lösung. Wir werden diese Lösung in Kürze erklären, aber lass uns zuerst über die
fehlenden Typzuweisungen in der Definition des Funktionsabschlusses und den
Merkmalen (traits) von Funktionsabschlüssen sprechen.</p>
<h3><a class="header" href="#typinferenz-und-zuweisung-bei-funktionsabschlüssen" id="typinferenz-und-zuweisung-bei-funktionsabschlüssen">Typinferenz und Zuweisung bei Funktionsabschlüssen</a></h3>
<p>Bei Funktionsabschlüssen musst du die Typen der Parameter und Rückgabewerte nicht,
wie bei Funktionen, mit Anmerkungen versehen. Für Funktionen sind Typanmerkungen 
erforderlich, da sie Bestandteil einer expliziten Benutzerschnittstelle sind.
Die starre Festlegung dieser Schnittstelle ist wichtig, damit sichergestellt
ist, dass jeder damit übereinstimmt, welche Arten von Werten von der Funktion
entgegengenommen und zurückgegeben werden. Funktionsabschlüsse werden hingegen nicht
in einer Schnittstelle verwendet, sie werden in einer Variable gespeichert und 
aufgerufen, ohne sie zu benennen und Benutzern unserer Bibliothek (library)
zugänglich zu machen.</p>
<p>Funktionsabschlüsse sind für gewöhnlich kurz und eher in einem begrenzten Kontext
relevant, als in einem beliebigen Szenario. Innerhalb dieses beschränkten
Einsatzbereichs ist der Compiler verlässlich in der Lage, Typen, Parameter und
Rückgabewerte zu inferieren, ähnlich wie er meistens bei Variablen die Typen
herleiten kann.</p>
<p>Den Programmierer die Typen in diesen kurzen, anonymen Funktionen anmerken zu
lassen wäre nur störend und überflüssig, da der Compiler bereits über die
dafür notwendigen Informationen verfügt.</p>
<p>Wir können wie bei Variablen Typanmerkungen angeben, wenn wir die Klarheit
und Aussagekraft über das notwendige Maß hinaus erhöhen möchten.
Das Anmerken der Typen für den in Codeblock 13-5 definierten Funktionsabschluss
würde wie die Definition in Codeblock 13-7 aussehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span><span class="boring">   
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring"> 
</span><span class="boring">
</span><span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let simulated_user_specified_value = 10;
</span><span class="boring">  let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">  generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-7: Hinzufügen optionaler Typanmerkungen
der Parameter- und Rückgabewert-Typen im Funktionsabschluss
</span></p>
<p>Die Syntax eines Funktionsabschlusses mit Typanmerkungen sieht der Syntax einer
Funktion sehr ähnlich. Es folgt ein vertikaler Vergleich der Syntax einer
Funktionsdefinition, die 1 zu ihrem Parameter addiert und einem
Funktionsabschluss mit dem gleichen Verhalten. Wir haben einige Abstände hinzugefügt,
um die relevanten Teile besser darzustellen. Dies zeigt wie ähnlich die Syntax
von Funktionen der von Funktionsabschlüssen ist, abgesehen von Pipes und der 
Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Typanmerkungen. Bei der dritten Zeile
werden die Typanmerkungen in der Definition des Funktionsabschlusses weggelassen,
in der vierten Zeile das Gleiche ohne Klammern – da diese optional sind da der
Rumpf des Funktionsabschlusses nur einen Ausdruck beinhaltet. Dies sind alles
gültige Ausdrücke die sich beim Aufruf gleich Verhalten. Für <code>add_one_v3</code> und
<code>add_one_v4</code> wird der Aufruf zum Kompilieren des Codes benötigt, da die Typen
hier abhängig von der Benutzung bestimmt werden.</p>
<p>Bei Funktionsabschlüssen wird für jeden Parameter und für den Rückgabewert ein
konkreter Typ abgeleitet. Codeblock 13-8 zeigt zum Beispiel die Definition eines
kurzen Funktionsabschlusses, der nur den Wert zurückgibt, den er als Parameter
erhält. Dieser Funktionsabschluss ist abgesehen von seinem Zweck als Beispiel zu
dienen nicht weiter nützlich. Beachte, dass wir der Definition keine
Typanmerkungen hinzugefügt haben. Wenn wir nun versuchen, die Funktion zweimal
aufzurufen, einmal mit <code>String</code> und einmal mit <code>u32</code>, erhalten wir eine
Fehlermeldung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-8: Versuchter Aufruf eines Funktionsabschluss
den zwei unterschiedliche Typen zugewiesen wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `std::string::String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben und daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3><a class="header" href="#speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits" id="speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits">Speichern von Funktionsabschlüssen unter Verwendung generischer Parameter und <code>Fn</code>-Merkmalen (traits)</a></h3>
<p>Lass uns auf unser Trainingsplan-Erstellungsprogramm zurückkommen. Im Codeblock
13-6 hat unser Programm, noch immer häufiger als notwendig, den
Funktionsabschluss <code>expensive_closure</code> aufgerufen. Eine Möglichkeit, dieses
Problem zu beheben, besteht darin, das Ergebnis des Funktionsabschlusses in
einer Variable zu speichern und diese Variable zu benutzen, wann immer wir das
Resultat brauchen. Diese Methode würde allerdings zu ziemlich viel wiederholtem
Code führen.</p>
<p>Glücklicherweise steht uns eine andere Lösung zur Verfügung. Wir können eine
Struktur (struct) anlegen die den Funktionsabschluss und dessen Rückgabewert
hält. Die Struktur wird den Funktionsabschluss nur dann ausführen, wenn
wir ein Ergebnis benötigen, und sie wird unseren Rückgabewert zwischenspeichern
damit der Rest unseres Programmcodes nicht mehr für das Speichern und 
Wiederverwenden verantwortlich ist. Dieses Muster (pattern) ist dir vielleicht
als <em>Memoisation</em> (memoization) oder <em>Lazy Evaluation</em> bekannt.</p>
<p>Um eine Struktur für unseren Funktionsabschluss zu erstellen, müssen wir dessen
Typ spezifizieren, da die Definition einer Struktur den Typ aller ihrer Felder
kennen muss. Jede Instanz eines Funktionsabschlusses besitzt ihren einzigartigen
anonymen Typ, der selbst wenn zwei Funktionsabschlüsse identische Signaturen
haben, immer noch als verschieden betrachtet wird. Um Strukturen, Aufzählungen
(enums) oder Funktionen zu definieren, die Funktionsabschlüsse verwenden,
benutzen wir generische Datentypen (generics) und Merkmalsabgrenzungen (trait bounds),
die wir bereits im Kapitel 10 besprochen haben.</p>
<p>Die <code>Fn</code>-Merkmale werden von der Standardbibliothek (standard library) zur
Verfügung gestellt. Alle Funktionsabschlüsse implementieren mindestens eines der
Merkmale: <code>Fn</code>, <code>FnMut</code> oder <code>FnOnce</code>. Wir werden den Unterschied dieser
Merkmale im Abschnitt <a href="#mit-funktionsabschl%C3%BCssen-die-umgebung-erfassen">„Mit Funktionsabschlüssen die Umgebung
erfassen“</a> besprechen. 
Für unser Beispiel können wir das <code>Fn</code>-Merkmal benutzen.</p>
<p>Den <code>Fn</code>-Merkmalsabgrenzungen fügen wir Typanmerkungen für die Typen, die mit dem
Funktionsabschluss übereinstimmen müssen, hinzu. In diesem Fall hat unser
Funktionsabschluss einen Parameter vom Typ <code>u32</code> und gibt einen <code>u32</code> zurück,
daher spezifizieren wir die Merkmalsabgrenzung mit <code>Fn(u32) -&gt; u32</code>.</p>
<p>Codeblock 13-9 zeigt die Definition der Struktur <code>Cacher</code>, die einen
Funktionsabschluss und optional einen Rückgabewert hält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-9: Definition einer Struktur <code>Cacher</code>, die
einen Funktionsabschluss in <code>calculation</code> enthält und in <code>value</code> optional ein
Resultat</span></p>
<p>Die Struktur <code>Cacher</code> hat ein Feld <code>calculation</code> vom generischen Datentyp <code>T</code>.
Die Merkmalsabgrenzungen auf <code>T</code> legen das <code>Fn</code>-Merkmal für den
Funktionsabschluss fest. Jeder Funktionsabschluss, den wir im Feld <code>calculation</code>
speichern, muss einen <code>u32</code>-Parameter (spezifiziert innerhalb runder Klammern
hinter <code>Fn</code>) haben und ein <code>u32</code> (festgelegt nach dem <code>-&gt;</code>) zurückgeben.</p>
<blockquote>
<p>Merke: Auch Funktionen können alle drei <code>Fn</code>-Merkmale implementieren.
Falls eine Problemstellung das Erfassen eines Wertes der Umgebung nicht erfordert,
können wir eine Funktion anstatt eines Funktionsabschlusses benutzen, der etwas
benötigt, um für ihn das <code>Fn</code>-Merkmal zu implementieren.</p>
</blockquote>
<p>Das Feld <code>value</code> hat den Typ <code>Option&lt;u32&gt;</code>. Bevor wir den Funktionsabschluss
ausführen, hat <code>value</code> den Wert <code>None</code>. Wenn Programmcode mit einem <code>Cacher</code> nach dem
<em>Ergebnis</em> des Funktionsabschlusses fragt, wird der <code>Cacher</code> zu diesem Zeitpunkt
den Funktionsabschluss ausführen und das Ergebnis in einer <code>Some</code>-Variante im
Feld <code>value</code> speichern. Wenn der Code später wieder nach dem Resultat des
Funktionsabschlusses fragt, wird anstatt der erneuten Ausführung der Berechnung
der <code>Cacher</code> den Wert zurückgeben, der in der <code>Some</code>-Variante enthalten ist.</p>
<p>Im Codeblock 13-10, wird die Logik um das soeben beschriebene Feld <code>value</code>
definiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-10: Die Zwischenspeicherungs-Logik von <code>Cacher</code></span></p>
<p>Wir möchten, dass <code>Cacher</code> die Felder der Struktur verwaltet, anstatt den
aufrufenden Code die Werte unter Umständen direkt ändern zu lassen, sodass diese
Felder privat sind.</p>
<p>Die Funktion <code>Cacher::new</code> nimmt einen generischen Datentyp-Parameter <code>T</code>,
welchen wir so definiert haben, dass er dieselbe Merkmalsabgrenzung wie die
<code>Cacher</code>-Struktur hat. Anschließend gibt <code>Cacher::new</code> eine <code>Cacher</code>-Instanz aus
die den Funktionsabschluss enthält der im <code>calculation</code>-Feld spezifiziert wurde
und den Wert <code>None</code> in seinem <code>value</code>-Feld enthält da wir den Funktionsabschluss
bisher noch nicht ausgeführt haben.</p>
<p>Wenn der aufrufende Code das Auswertungsergebnis des Funktionsabschlusses
benötigt, ruft er die Methode <code>value</code> auf, anstatt direkt den Funktionsabschluss.
Diese Methode überprüft, ob wir bereits einen Rückgabewert in <code>self.value</code>
in einen <code>Some</code> gespeichert haben, falls ja, gibt es den Wert, der in <code>Some</code>
enthalten ist zurück ohne den Funktionsabschluss erneut auszuführen.</p>
<p>Falls <code>self.value</code> ein <code>None</code> ist, ruft der Programmcode den Funktionsabschluss
auf, der in <code>self.calculation</code> gespeichert ist, speichert das Resultat in
<code>self.value</code> für seine zukünftige Verwendung und gibt den Wert zurück.</p>
<p>Codeblock 13-11 zeigt wie wir die <code>Cacher</code>-Struktur in der Funktion
<code>generate_workout</code> vom Codeblock 13-6 verwenden können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result.value(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-11: Die Verwendung von <code>Cacher</code> in der
Funktion <code>generate_workout</code> zur Abstraktion der Zwischenspeicherungs-Logik</span></p>
<p>Anstatt den Funktionsabschluss direkt in einer Variable zu speichern, speichern
wir eine neue Instanz von <code>Cacher</code> die den Funktionsabschluss beinhaltet. An
jeder Stelle, an der wir ein Resultat benötigen, rufen wir dann die Methode
<code>value</code> an der <code>Cacher</code>-Instanz auf. Egal ob wir nun die Methode <code>value</code>
mehrmals aufrufen oder gar nicht wird die aufwendige Berechnung nur einmal 
ausgeführt.</p>
<h3><a class="header" href="#einschränkungen-der-cacher-implementierung" id="einschränkungen-der-cacher-implementierung">Einschränkungen der <code>Cacher</code>-Implementierung</a></h3>
<p>Das Zwischenspeichern von Werten ist allgemein eine nützliche Vorgehensweise,
die wir möglicherweise auch an anderen Programmteilen mit verschieden
Funktionsabschlüssen verwenden möchten. Jedoch gibt es zwei Probleme der aktuellen
Implementierung von <code>Cacher</code>, die eine Wiederverwendung in verschiedenen Kontexten
erschweren würden.</p>
<p>Das erste Problem ist, dass eine <code>Cacher</code>-Instanz davon ausgeht, dass sie immer
den gleichen Wert für den <code>arg</code>-Parameter der Methode <code>value</code> bekommt. Das
bedeutet, dass dieser Test fehlschlagen wird:</p>
<pre><pre class="playground"><code class="language-rust panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span>    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}    
</span><span class="boring">}
</span></code></pre></pre>
<p>Dieser Test erzeugt eine neue <code>Cacher</code>-Instanz mit einem Funktionsabschluss, der
den Wert zurückgibt, den er erhalten hat. Wir rufen nun die <code>Cacher</code>-Instanz
mit der Methode <code>value</code> auf, zuerst mit dem <code>arg</code>-Wert 1 und dann mit dem
<code>arg</code>-Wert 2 und erwarten, dass beim zweiten Aufruf 2 zurückgegeben wird.</p>
<p>Führe diesen Test mit der Implementierung von <code>Cacher</code> vom Codeblock 13-9 und
13-10 durch und der Test wird an <code>assert_eq!</code> mit folgender Meldung
fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Das Problem ist, dass die <code>Cacher</code>-Instanz beim ersten Aufruf von <code>c.value</code> mit 1
den Wert <code>Some(1)</code> in <code>self.value</code> gespeichert hat. Egal was wir danach der
<code>value</code>-Methode als Wert  mitgeben, wir werden immer 1 zurückbekommen.</p>
<p>Versuche <code>Cacher</code> so zu verändern, dass es anstatt eines Wertes eine Hash-Tabelle
(hash map) enthält. Die Schlüssel (keys) der Hash-Tabelle werden die <code>arg</code>-Werte
die mitgegeben werden sein und die Werte der Hash-Tabelle werden das Resultat des Aufrufs des
Funktionsabschlusses mit dem jeweiligen Schlüssel sein. Anstatt <code>value</code> direkt
zu betrachten, ob es einen <code>Some</code> oder <code>None</code> enthält, wird die <code>value</code>-Funktion
nach <code>arg</code> in der Hash-Tabelle suchen und den Wert, falls vorhanden, zurückgeben.
Falls der Wert nicht vorhanden ist, wird der <code>Cacher</code> den Funktionsabschluss
aufrufen und den Rückgabewert in der Hash-Tabelle zusammen mit seinem <code>arg</code>-Wert
speichern.</p>
<p>Das zweite Problem mit der derzeitigen Implementierung von <code>Cacher</code> ist, dass
sie nur Funktionsabschlüsse annimmt die einen Parameter vom Typ <code>u32</code> haben und 
ein <code>u32</code> zurückgeben. Möglicherweise möchten wir zum Beispiel Ergebnisse von
Funktionsabschlüssen zwischenspeichern die einen Zeichenketten-Anteilstyp (string
slice) nehmen und <code>usize</code>-Werte zurückgeben. Um dieses Problem zu beheben,
versuche generische Datentypen zu verwenden, um die <code>Cacher</code>-Funktionalität
flexibler zu machen.</p>
<h3><a class="header" href="#mit-funktionsabschlüssen-die-umgebung-erfassen" id="mit-funktionsabschlüssen-die-umgebung-erfassen">Mit Funktionsabschlüssen die Umgebung erfassen</a></h3>
<p>Im Trainingsplan-Erstellungs-Beispiel haben wir Funktionsabschlüsse nur als
anonyme Inline-Funktionen verwendet, Funktionsabschlüsse verfügen jedoch über
eine Fähigkeit die Funktionen nicht haben: Sie können ihre Umgebung erfassen und
auf Variablen die im selben Gültigkeitsbereich definiert wurden zugreifen.</p>
<p>Codeblock 13-12 beinhaltet ein Beispiel eines Funktionsabschlusses der in einer
Variable <code>equal_to_x</code> gespeichert ist und eine Variable <code>x</code> aus ihrer Umgebung
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-12: Beispiel eines Funktionsabschlusses, der
sich auf eine Variable im umgebenden Gültigkeitsbereich bezieht.</span></p>
<p>Auch wenn <code>x</code> hier keiner der Parameter von <code>equal_to_x</code> ist, darf der
Funktionsabschluss <code>equal_to_x</code> die Variable <code>x</code> benutzen, die im gleichen
Gültigkeitsbereich definiert wurde wie <code>equal_to_x</code>.</p>
<p>Mit Funktionen können wir dasselbe nicht machen. Wenn wir es wie im folgenden
Beispiel versuchen wird der Programmcode nicht kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir bekommen eine Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead
</code></pre>
<p>Der Compiler erinnert uns sogar daran, dass dies nur mit Funktionsabschlüssen
funktioniert!</p>
<p>Wenn ein Funktionsabschluss einen Wert aus seiner Umgebung erfasst, benutzt er
Speicher, um die Werte im Funktionsabschluss-Rumpf für die Benutzung zu halten.
Diesen zusätzlichen Aufwand der Speichernutzung wollen wir, wenn wir
Code ausführen möchten der seine Umgebung nicht erfasst, nicht verursachen. Da
Funktionen ihre Umgebung niemals erfassen können, kann das Definieren und
Ausführen von Funktionen auch nie diesen Speichernutzungsmehraufwand
verursachen.</p>
<p>Es gibt drei Möglichkeiten wie Funktionsabschlüsse ihre Umgebung erfassen
können, den drei Möglichkeiten entsprechend wie Funktionen ein Parameter
erhalten können: Eigentümerschaft übernehmen (taking ownership), veränderliches
Ausleihen (borrowing mutably) und unveränderliches Ausleihen (borrowing immutably).
Diese sind wie folgt, in den drei <code>Fn</code>-Merkmalen codiert:</p>
<ul>
<li><code>FnOnce</code> verbraucht die Variablen, die vom umgebenden Gültigkeitsbereich
erfasst werden, dieser Bereich wird als Funktionsabschluss-Umgebung
(closure’s <em>enviroment</em>) bezeichnet. Um die erfassten Variablen verbrauchen
zu können, muss der Funktionsabschluss die Eigentümerschaft dieser Variablen
übernehmen und sie bei dessen Definition, in den Funktionsabschluss verschieben
(move). Der Namensteil <code>Once</code> repräsentiert die Tatsache, dass der
Funktionsabschluss nur einmal die Eigentümerschaft der gleichen Variablen
übernehmen kann, daher kann er nur einmal aufgerufen werden.</li>
<li><code>FnMut</code> kann die Funktionsabschluss-Umgebung verändern, da es Werte
veränderlich ausleiht.</li>
<li><code>Fn</code> leiht Werte des umgebenden Gültigkeitsbereiches unveränderlich aus.</li>
</ul>
<p>Wenn du einen Funktionsabschluss erstellst, schließt Rust, welches Merkmal
verwendet werden soll, aus der Verwendungsweise der vom Funktionsabschluss 
erfassten Variablen. Alle Funktionsabschlüsse implementieren <code>FnOnce</code>, da sie
mindestens einmal aufgerufen werden können. Funktionsabschlüsse, die erfasste
Variablen nicht verschieben, implementieren zusätzlich <code>FnMut</code> und
Funktionsabschlüsse, die keinen veränderlichen Zugriff auf die erfassten Werte
benötigen, implementieren des weiteren <code>Fn</code>. Im Codeblock 13-12, leiht der
Funktionsabschluss <code>equal_to_x</code> den Parameter <code>x</code> unveränderlich (dadurch hat
<code>equal_to_x</code> das <code>Fn</code>-Merkmal), da der Funktionsabschluss-Rumpf den
Variablenwert <code>x</code> nur liest.</p>
<p>Falls du erzwingen möchtest, dass ein Funktionsabschluss die Eigentümerschaft
der aus dem umgebenden Gültigkeitsbereich verwendeten Werte übernimmt, kannst du
vor der Parameterliste das Schlüsselwort <code>move</code> verwenden. Diese Technik ist vor
allem dann nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread) 
übergeben wird, um die Daten so zu verschieben, dass sie dem neuen Strang
gehören.</p>
<p>Weitere Beispiele für <code>move</code> bei Funktionsabschlüssen folgen in Kapitel 16, wenn
wir über Parallelität sprechen. Einstweilen ist hier der Programmcode von
Codeblock 13-12 mit dem Schlüsselwort <code>move</code>, das der Funktionsabschlussdefinition
hinzugefügt wurde und Vektoren statt Ganzzahlen (integers) verwendet, da
Ganzzahlen kopiert und nicht verschoben werden. Beachte, dass dieser Programmcode
noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir erhalten folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);
  |                                                   ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.

</code></pre>
<p>Der Wert <code>x</code> wurde bei der Funktionsabschlussdefinition in diesen hineinbewegt,
da wir das Schlüsselwort <code>move</code> angegeben haben. Der Funktionsabschluss hat
dadurch die Eigentümerschaft von <code>x</code> und <code>main</code> kann daher <code>x</code> nicht mehr 
im <code>println!</code>-Statement benutzen. Durch Entfernen von <code>println!</code> wird dieser
Fehler behoben.</p>
<p>Wenn du eine <code>Fn</code>-Merkmalsabgrenzung spezifizierst, reicht es zumeist wenn du
mit <code>Fn</code> beginnst. Der Compiler wird dir mitteilen, wenn es notwendig ist
<code>FnMut</code> oder <code>FnOnce</code> anzugeben, basierend auf dem was im
Funktionsabschluss-Rumpf passiert. </p>
<p>Um Situationen zu veranschaulichen, die die Nützlichkeit von
Umgebung erfassenden Funktionsabschlüssen als Funktionsparameter demonstrieren,
fahren wir mit unserem nächsten Thema fort: Iteratoren.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/ferris.js"></script>
        

        

    </body>
</html>
