<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Programmiersprache Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box<T> auf Daten im Haldenspeicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc<T></a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Strängen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristiken objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#die-programmiersprache-rust" id="die-programmiersprache-rust">Die Programmiersprache Rust</a></h1>
<p><em>von Steve Klabnik und Carol Nichols, unter Mitarbeit der Rust-Gemeinschaft</em></p>
<p>Diese Version des Textes geht davon aus, dass du Rust 1.41.0 oder später mit
<code>edition=&quot;2018&quot;</code> in <em>Cargo.toml</em> in allen Projekten verwendest, um Rust 2018
Idiome zu verwenden. Siehe <a href="ch01-01-installation.html">Abschnitt „Installation“</a> zum Installieren
und Aktualisieren von Rust sowie <a href="appendix-05-editions.html">Anhang E</a> zu Informationen zu den
Ausgaben.</p>
<p>Ausgabe 2018 von Rust enthält einige Verbesserungen, die Rust ergonomischer und
einfacher zu lernen machen. Diese Fassung des Buchs enthält eine Reihe von
Änderungen, die diese Verbesserungen widerspiegeln:</p>
<ul>
<li>Kapitel 7 „Wachsende Projekte verwalten mit Paketen (packages), Kisten
(crates) und Modulen“ wurde größtenteils umgeschrieben. Das Modulsystem und
die Funktionsweise der Pfade in Ausgabe 2018 wurden konsistenter gestaltet.</li>
<li>Kapitel 10 hat die neuen Abschnitte „Merkmale als Parameter“ und
„Rückgabetypen die Merkmale implementieren“, die die neue Syntax von
<code>impl Trait</code> erklären.</li>
<li>Kapitel 11 hat einen neuen Abschnitt „Verwenden von <code>Result&lt;T, E&gt;</code> in Tests“,
der zeigt, wie man Tests schreibt, die den Operator <code>?</code> verwenden.</li>
<li>Der Abschnitt „Fortgeschrittene Lebensdauern“ in Kapitel 19 wurde entfernt,
weil die verwendeten Konstrukte durch Compiler-Verbesserungen noch
seltener geworden sind.</li>
<li>Der frühere Anhang D „Makros“ wurde um prozedurale Makros erweitert und in
den Abschnitt „Makros“ in Kapitel 19 verschoben.</li>
<li>Anhang A „Schlüsselwörter“ erläutert auch die neue Funktionalität der rohen
Bezeichner, die es ermöglicht, dass in Ausgabe 2015 und in Ausgabe 2018
geschriebener Programmcode zusammen verwendet werden kann.</li>
<li>Anhang D trägt jetzt den Titel „Nützliche Entwicklungswerkzeuge“ und umfasst
kürzlich veröffentlichte Werkzeuge, die dir beim Schreiben von Rust-Code
helfen.</li>
<li>Wir haben im gesamten Buch etliche kleine Fehler und unpräzise Formulierungen
korrigiert. Vielen Dank an die Leser, die sie gemeldet haben!</li>
</ul>
<p>Beachte, dass jeder kompilierbare Programmcode aus früheren Fassungen des Buchs
weiterhin kompiliert, wenn <code>edition=&quot;2018&quot;</code> nicht in <em>Cargo.toml</em> des Projekts
nicht angegeben wird, selbst wenn du die verwendete Rust-Compiler-Version
aktualisierst. Das ist die Rückwärtskompatibilitätsgarantie von Rust!</p>
<p>Die HTML-Version ist online verfügbar unter
https://doc.rust-lang.org/stable/book/ (englisches Original) und
https://rust-lang-de.github.io/rustbook-de/ (deutsche Übersetzung).
Wenn die Rust-Installation mit <code>rustup</code> erfolgt ist, kann das Buch offline mit
<code>rustup docs --book</code> geöffnet werden (nur in Englisch).</p>
<p>Der englische Text ist auch als <a href="https://nostarch.com/rust">Taschenbuch und E-Book bei No Starch
Press</a> erhältlich.</p>
<h1><a class="header" href="#vorwort" id="vorwort">Vorwort</a></h1>
<p>Es war nicht immer so klar, aber bei der Programmiersprache Rust geht es im
Grunde um <em>Befähigung</em>: Egal, welche Art von Code du jetzt schreibst, Rust
befähigt dich dazu, weiter zu gehen, mit Vertrauen in einer größeren Vielfalt
von Bereichen zu programmieren, als du es zuvor getan hast.</p>
<p>Denken wir zum Beispiel an systemnahe Arbeiten, bei denen Details wie
Speicherverwaltung, Datenrepräsentation und Nebenläufigkeit wichtig sind.
Traditionellerweise gilt dieser Bereich der Programmierung als geheimnisvoll
und nur wenigen Auserwählten zugänglich, die die erforderliche Erfahrung
gesammelt haben, um berüchtigte Fallstricke vermeiden zu können. Und selbst
diejenigen, die damit arbeiten, tun dies mit Sorgfalt, damit ihr Code nicht
angreifbar ist, abstürzt oder fehlerhaft ist.</p>
<p>Rust baut diese Barrieren ab, indem es die alten Fallstricke beseitigt und ein
freundliches, ausgefeiltes Instrumentarium zur Verfügung stellt, das dich auf
deinem Weg unterstützt. Programmierer, die in die systemnahen Kontrollebenen
„eintauchen“ müssen, können dies mit Rust tun, ohne das übliche Risiko von
Abstürzen oder Sicherheitslücken einzugehen und ohne die Finessen einer
wankelmütigen Werkzeugkette erlernen zu müssen. Besser noch, die Sprache ist so
konzipiert, dass sie dich auf natürliche Weise zu zuverlässigem Code führt, der
effizient in Bezug auf Geschwindigkeit und Speichernutzung ist.</p>
<p>Programmierer, die bereits mit systemnahem Code arbeiten, können Rust nutzen,
um ihre Ambitionen zu steigern. Beispielsweise ist die Einführung von
Parallelität in Rust ein relativ risikoarmes Unterfangen: Der Compiler fängt
die klassischen Fehler für dich ab. Und du kannst aggressivere Optimierungen in
deinem Code wagen mit der Gewissheit, keine versehentlichen Abstürze oder
Verwundbarkeiten einzuführen.</p>
<p>Aber Rust ist nicht auf systemnahe Programmierung beschränkt. Es ist
ausdrucksstark und ergonomisch genug, um das Schreiben von
Kommandozeilen-Anwendungen, Webservern und vielen anderen Arten an Code recht
angenehm zu machen – du wirst später in diesem Buch einfache Beispiele
dazu finden. Die Arbeit mit Rust ermöglicht es dir, Fähigkeiten zu entwickeln,
die von einer Domäne auf eine andere übertragen werden können; du kannst Rust
durch Schreiben einer Webanwendung erlernen und dann diese Fähigkeiten auf
deinen Raspberry Pi anwenden.</p>
<p>In diesem Buch wird das Potenzial von Rust zur Befähigung seiner Nutzer voll
ausgeschöpft. Es ist ein freundlicher und zugänglicher Text, der dir helfen
soll, nicht nur dein Wissen über Rust zu erweitern, sondern auch deine
Reichweite und dein Selbstvertrauen als Programmierer im Allgemeinen. Also
tauche ein, mach dich bereit zum Lernen – und willkommen in der
Rust-Gemeinschaft!</p>
<p>– Nicholas Matsakis und Aaron Turon</p>
<h1><a class="header" href="#einführung" id="einführung">Einführung</a></h1>
<p>Willkommen bei <em>Die Programmiersprache Rust</em>, einem einführenden Buch über
Rust. Die Programmiersprache Rust hilft dir, schnellere und zuverlässigere
Software zu schreiben. Ergonomie und systemnahe Kontrolle stehen beim Entwurf
von Programmiersprachen oft im Widerspruch – Rust stellt sich diesem
Konflikt. Durch den Ausgleich zwischen leistungsstarken, technischen
Möglichkeiten und einer großartigen Entwicklererfahrung bietet dir Rust die
Möglichkeit, Details systemnah (z.B. Speichernutzung) zu kontrollieren, ohne
den ganzen Ärger, der damit typischerweise einhergeht.</p>
<h2><a class="header" href="#für-wen-rust-ist" id="für-wen-rust-ist">Für wen Rust ist</a></h2>
<p>Rust ist für viele Menschen aus einer Vielzahl von Gründen ideal. Schauen wir
uns einige der wichtigsten Nutzergruppen an.</p>
<h3><a class="header" href="#entwicklerteams" id="entwicklerteams">Entwicklerteams</a></h3>
<p>Rust erweist sich als produktives Werkzeug in der Zusammenarbeit großer
Entwicklerteams mit unterschiedlichem Kenntnisstand in der
Systemprogrammierung. Systemnaher Code ist anfällig für eine Vielzahl subtiler
Fehler, die in den meisten anderen Sprachen nur durch ausgiebige Tests und
sorgfältige Überprüfung des Codes durch erfahrene Entwickler erkannt werden
können. In Rust spielt der Compiler eine Art Pförtnerrolle, indem er Code
mit diesen schwer fassbaren Fehlern verweigert zu kompilieren, darunter auch
Nebenläufigkeitsfehler. Mit der Arbeit an der Seite des Compilers kann sich
das Team auf die Programmlogik konzentrieren anstatt Fehler zu suchen.</p>
<p>Rust bringt auch zeitgemäße Entwicklerwerkzeuge in die Welt der
Systemprogrammierung:</p>
<ul>
<li>Cargo, das mitgelieferte Abhängigkeitsmanagement- und Bau-Werkzeug, macht das
Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten im gesamten
Rust-Ökosystem schmerzlos und konsistent.</li>
<li>Rustfmt gewährleistet einen einheitlichen Codierstil aller Entwickler.</li>
<li>Der Rust Sprachdienst (Language Server) ermöglicht Code-Vervollständigung und
im Code angezeigte Fehlermeldungen innerhalb der Entwicklungsumgebung (IDE).</li>
</ul>
<p>Durch den Einsatz dieser und anderer Werkzeuge des Rust-Ökosystems können
Entwickler produktiv arbeiten, während sie Code auf Systemebene schreiben.</p>
<h3><a class="header" href="#studenten" id="studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für Systemkonzepte interessieren. Mit
Rust haben viele Menschen etwas über Themen wie die Entwicklung von
Betriebssystemen gelernt. Die Gemeinschaft ist sehr einladend und beantwortet
gerne Fragen der Studenten. Durch Bemühungen wie dieses Buch will das Rust-Team
Systemkonzepte mehr Menschen zugänglich machen, insbesondere denen, die neu in
der Programmierung sind.</p>
<h3><a class="header" href="#unternehmen" id="unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, setzen Rust für eine Vielzahl von
Aufgaben in der Produktion ein. Zu diesen Aufgaben gehören
Kommandozeilenwerkzeuge, Webdienste, DevOps-Werkzeuge, eingebettete Geräte,
Audio- und Videoanalyse und -transkodierung, Kryptowährungen, Bioinformatik,
Suchmaschinen, Anwendungen für das Internet der Dinge, maschinelles Lernen und
sogar wesentliche Teile des Webbrowsers Firefox.</p>
<h3><a class="header" href="#open-source-entwickler" id="open-source-entwickler">Open-Source-Entwickler</a></h3>
<p>Rust ist für Menschen, die die Programmiersprache Rust, die Gemeinschaft,
Entwickler-Werkzeuge und Bibliotheken aufbauen möchten. Wir würden uns freuen,
wenn du zur Programmiersprache Rust beiträgst.</p>
<h3><a class="header" href="#menschen-die-geschwindigkeit-und-stabilität-schätzen" id="menschen-die-geschwindigkeit-und-stabilität-schätzen">Menschen, die Geschwindigkeit und Stabilität schätzen</a></h3>
<p>Rust ist für Menschen, die sich nach Schnelligkeit und Stabilität einer Sprache
sehnen. Unter Geschwindigkeit verstehen wir die Geschwindigkeit der Programme,
die du mit Rust schreiben kannst, und die Geschwindigkeit, mit der dich Rust
diese Programme schreiben lässt. Die Prüfungen des Rust-Compilers
gewährleisten Stabilität während du neue Funktionen hinzufügst und deinen Code
änderst. Dies steht im Gegensatz zu brüchigen Code-Altlasten in Sprachen ohne
diese Prüfungen, die Entwickler oft scheuen modifizieren zu müssen. Durch das
Streben nach kostenneutralen Abstraktionen, also Funktionalität auf höherer
Ebene, die zu genauso schnellem Code wie manuell geschriebener Code auf
niedrigerer Ebene kompiliert, bemüht sich Rust, sicheren Code auch zu schnellem
Code zu machen.</p>
<p>Die Sprache Rust hofft, auch viele andere Nutzer zu unterstützen; die hier
genannten sind nur einige der größten Interessensgruppen. Insgesamt ist es
Rusts größtes Bestreben, den Zielkonflikt zu beseitigen, den Programmierer
jahrzehntelang hingenommen haben, wenn sie Sicherheit <em>und</em> Produktivität bzw.
Geschwindigkeit <em>und</em> Ergonomie erreichen wollten. Versuche es mit Rust und
finde heraus, ob dessen Möglichkeiten für dich geeignet sind.</p>
<h2><a class="header" href="#für-wen-dieses-buch-gedacht-ist" id="für-wen-dieses-buch-gedacht-ist">Für wen dieses Buch gedacht ist</a></h2>
<p>In diesem Buch wird davon ausgegangen, dass du bereits Code in einer anderen
Programmiersprache geschrieben hast, es spielt aber keine Rolle in welcher. Wir
haben versucht, das Material einem breiten Publikum mit unterschiedlichem
Programmierhintergrund zugänglich zu machen. Wir verbringen nicht viel Zeit
damit, darüber zu sprechen, was Programmieren <em>ist</em> oder wie man darüber denkt.
Wenn Programmieren für dich ganz neu ist, wäre es besser, wenn du ein Buch
speziell zur Einführung in die Programmierung liest.</p>
<h2><a class="header" href="#wie-man-dieses-buch-verwendet" id="wie-man-dieses-buch-verwendet">Wie man dieses Buch verwendet</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass du es der Reihe nach von vorne
nach hinten lesen. Spätere Kapitel bauen auf den Konzepten früherer Kapitel
auf. Frühere Kapitel gehen möglicherweise nicht in die Einzelheiten eines
Themas ein, denn in der Regel werden wir es in einem späteren Kapitel erneut
aufgreifen.</p>
<p>Du findest in diesem Buch zwei Kapitelarten: Konzeptkapitel und
Projektkapitel. In Konzeptkapiteln erfährst du etwas über einen Aspekt von
Rust. In Projektkapiteln schreiben wir gemeinsam kleine Programme und wenden
das bisher Gelernte an. Die Kapitel 2, 12 und 20 sind Projektkapitel; die
übrigen sind Konzeptkapitel.</p>
<p>Kapitel 1 erklärt, wie man Rust installiert, wie man ein „Hallo Welt“-Programm
schreibt und wie man Cargo, den Paketmanager und das Bauwerkzeug von Rust,
benutzt. Kapitel 2 ist eine praktische Einführung in die Sprache Rust. Hier
werden Konzepte auf hohem Niveau behandelt, spätere Kapitel werden zusätzliche
Einzelheiten liefern. Wenn du dir schon jetzt die Hände schmutzig machen
willst, dann ist Kapitel 2 der richtige Ort dafür. Zunächst willst du
vielleicht sogar Kapitel 3 überspringen, in dem es um Rust-Funktionen geht, die
denen anderer Programmiersprachen ähneln, und direkt zu Kapitel 4 übergehen, um
mehr über den Eigentümerschaftsansatz von Rust zu erfahren. Wenn du jedoch ein
besonders akribischer Lerner bist, der lieber erst jedes Detail lernen will,
bevor er zum nächsten übergeht, willst du vielleicht Kapitel 2 überspringen und
direkt zu Kapitel 3 gehen und danach zu Kapitel 2 zurückkehren, um dann an
einem Projekt zu arbeiten und die gelernten Details anzuwenden.</p>
<p>Kapitel 5 bespricht Strukturen und Methoden, und Kapitel 6 behandelt
Aufzählungen, <code>match</code>-Ausdrücke und das <code>if let</code>-Kontrollflusskonstrukt. Du
wirst Strukturen und Aufzählungen verwenden, um benutzerdefinierte Typen in
Rust zu erstellen.</p>
<p>In Kapitel 7 erfährst du mehr über das Modulsystem von Rust und über die
Datenschutzregeln zum Organisieren deines Codes und dessen öffentlich
zugängliche Programmierschnittstelle (API). In Kapitel 8 werden einige gängige
Kollektionsdatenstrukturen, die die Standardbibliothek zur Verfügung stellt,
behandelt, z.B. Vektoren, Zeichenketten und Hashtabellen. Kapitel 9 befasst
sich mit Rusts Philosophie und Techniken der Fehlerbehandlung.</p>
<p>Kapitel 10 vertieft generische Datentypen, Merkmale und Lebensdauern, die dir
die Möglichkeit geben, Code zu schreiben, der für mehrere Typen passt. In
Kapitel 11 dreht sich alles um das Testen, das selbst mit den
Sicherheitsgarantien von Rust erforderlich ist, um eine korrekte Logik deines
Programms sicherzustellen. In Kapitel 12 werden wir unsere eigene
Implementierung für eine Teilfunktionalität des Kommandozeilenwerkzeugs <code>grep</code>
schreiben, das nach Text in Dateien sucht. Dazu werden wir viele Konzepte
anwenden, die wir in den vorangegangenen Kapiteln kennengelernt haben.</p>
<p>Kapitel 13 befasst sich mit Funktionsabschlüssen und Iteratoren, also
Sprachmerkmalen, die von funktionalen Programmiersprachen stammen. In Kapitel
14 werden wir einen genaueren Blick auf Cargo werfen und über bewährte
Vorgehensweisen beim Bereitstellen deiner Bibliotheken für andere sprechen. In
Kapitel 15 werden intelligente Zeiger, die die Standardbibliothek bereitstellt,
und Merkmale, die ihre Funktionalität ermöglichen, erörtert.</p>
<p>In Kapitel 16 gehen wir durch verschiedene Modelle der nebenläufigen
Programmierung und sprechen darüber, wie Rust dir hilft, furchtlos mit mehreren
Strängen zu programmieren. Kapitel 17 befasst sich mit dem Vergleich zwischen
Rust-Idiomen und den Prinzipien der objektorientierten Programmierung, mit
denen du vielleicht vertraut bist.</p>
<p>Kapitel 18 ist ein Nachschlagewerk zu Muster und Musterabgleich, einem
mächtigen Mittel zum Ausdrücken von Ideen in Rust-Programmen. Kapitel 19
enthält ein Sammelsurium an interessanten fortgeschrittenen Themen, darunter
unsicheres Rust, Makros und mehr zu Lebensdauer, Merkmalen, Typen, Funktionen
und Funktionsabschlüssen.</p>
<p>In Kapitel 20 werden wir ein Projekt abschließen, bei dem wir einen
systemnahen, nebenläufigen Webdienst implementieren!</p>
<p>Schließlich enthalten einige Anhänge nützliche Informationen über die Sprache
in einem eher referenzartigen Format. Anhang A enthält die Schlüsselwörter von
Rust, Anhang B die Operatoren und Symbole von Rust, Anhang C ableitbare
Merkmalen, die von der Standardbibliothek mitgebracht werden, Anhang D
nützliche Entwicklungswerkzeuge und Anhang E erläutert die Rust-Ausgaben.</p>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn du was überspringen
willst, nur zu! Möglicherweise musst du zu früheren Kapiteln zurückkehren, wenn
du irritiert bist. Aber tue was immer für dich passt.</p>
<p><span id="ferris"></span></p>
<p>Ein wichtiger Teil beim Lernen von Rust ist das Verstehen der Fehlermeldungen,
die der Compiler anzeigt: Diese leiten dich zum funktionierenden Code. Daher
werden wir viele Beispiele bringen, die nicht kompilieren, zusammen mit der
jeweiligen Fehlermeldung des Compilers. Wenn du also ein zufälliges Beispiel
eingibst und ausführen willst, lässt es sich möglicherweise nicht kompilieren!
Stelle sicher, dass du den umgebenden Text liest, um zu wissen, ob das
Beispiel, das du ausführen willst, für einen Fehler gedacht ist. Ferris gibt
dir einen Hinweis bei Code, der nicht funktionieren soll:</p>
<table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Dieser Code lässt sich nicht kompilieren!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Dieser Code bricht ab (panic)!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Dieser Codeblock enthält unsicheren Code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Dieser Code liefert nicht das gewünschte Verhalten.</td></tr>
</tbody></table>
<p>In den meisten Situationen führen wir dich zu einer funktionierenden
Codeversion, wenn er sich nicht kompilieren lässt.</p>
<h2><a class="header" href="#quellcode" id="quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wird, findest du unter
<a href="https://github.com/rust-lang-de/rustbook-de/tree/master/src">GitHub</a>.</p>
<h1><a class="header" href="#erste-schritte" id="erste-schritte">Erste Schritte</a></h1>
<p>Lass uns mit Rust loslegen! Es gibt viel zu lernen, aber irgendwo muss man
bekanntlich anfangen. In diesem Kapitel geht es um folgende Themen:</p>
<ul>
<li>Die Installation von Rust in Linux, macOS und Windows</li>
<li>Das Schreiben eines Programms, das <code>Hallo Welt!</code> ausgibt</li>
<li>Die Verwendung von <code>cargo</code>, Rusts Paketmanager und Bauwerkzeug </li>
</ul>
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<p>Der erste Schritt ist, Rust zu installieren. Wir werden Rust mittels <code>rustup</code>
herunterladen, einem Kommandozeilenwerkzeug für die Verwaltung von Rust-Versionen
und dazugehörigen Werkzeugen. Du wirst eine Internetverbindung für den Download
benötigen.</p>
<blockquote>
<p>Anmerkung: Falls du <code>rustup</code> aus irgendeinem Grund nicht verwenden möchtest,
schaue bitte auf der
<a href="https://www.rust-lang.org/tools/install">Webseite für die Rust-Installation</a> 
nach anderen Möglichkeiten.</p>
</blockquote>
<p>Die folgenden Schritte installieren die neueste stabile Version des
Rust-Compilers. Rust garantiert Stabilität und stellt somit sicher,
dass alle kompilierbaren Beispiele in diesem Buch auch mit neueren
Rust-Versionen kompilierbar bleiben werden. Die Konsolenausgabe
der Beispiele kann sich zwischen Versionen leicht unterscheiden,
weil Rust oft Fehlermeldungen und Warnungen verbessert.
Anders ausgedrückt, jede neuere stabile Version von Rust, die du
mithilfe dieser Schritte installierst, sollte wie erwartet mit dem
Inhalt dieses Buches funktionieren.</p>
<blockquote>
<h3><a class="header" href="#kommandozeilen-schreibweise" id="kommandozeilen-schreibweise">Kommandozeilen-Schreibweise</a></h3>
<p>In diesem Kapitel und im ganzen Buch werden wir einige Befehle auf der
Konsole zeigen. Alle Zeilen, die du in die Konsole eingeben sollst,
beginnen mit <code>$</code>. Du brauchst das <code>$</code>-Zeichen nicht einzugeben;
es weist nur auf den Beginn jedes Befehls hin. Zeilen, die nicht mit
<code>$</code> beginnen, zeigen normalerweise die Ausgabe eines vorherigen Befehls.
PowerShell-spezifische Beispiele werden außerdem <code>&gt;</code> anstelle von <code>$</code>
verwenden.</p>
</blockquote>
<h3><a class="header" href="#die-installation-von-rustup-in-linux-und-macos" id="die-installation-von-rustup-in-linux-und-macos">Die Installation von <code>rustup</code> in Linux und macOS</a></h3>
<p>Falls du Linux oder macOS verwendest, öffne ein Konsolenfenster und gib den
folgenden Befehl ein:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Dieser Befehl lädt ein Skript herunter und startet die Installation
von <code>rustup</code>, welches die neueste stabile Version von Rust installiert.
Du wirst ggf. aufgefordert, dein Passwort einzugeben. Falls die Installation
erfolgreich ist, erscheint die folgende Zeile:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Zusätzlich wirst du einen Programmbinder (linker) benötigen. Wahrscheinlich
ist bereits einer installiert, aber falls du versuchst, ein Rust-Programm
zu kompilieren und du dabei eine Fehlermeldung erhältst, dass ein
Programmbinder nicht ausgeführt werden konnte, dann bedeutet das, dass
kein Programmbinder auf deinem Rechner installiert ist und du das
nachholen musst. C-Compiler haben normalerweise den passenden Programmbinder
dabei. Schau in der Dokumentation deines Betriebssystems nach, wie du einen
C-Compiler installieren kannst. Auch bestehen einige verbreitete Rust-Pakete
aus C-Code und benötigen einen C-Compiler. Deshalb kann es sinnvoll sein,
bereits jetzt einen zu installieren.</p>
<h3><a class="header" href="#die-installation-von-rustup-in-windows" id="die-installation-von-rustup-in-windows">Die Installation von <code>rustup</code> in Windows</a></h3>
<p>Rufe <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> auf und folge
den Anweisungen, um Rust in Windows zu installieren. Während der Installation
wirst du eine Meldung erhalten mit der Aufforderung, ebenfalls die
C++-Bauwerkzeuge für Visual Studio 2013 oder neuer zu installieren.
Der leichteste Weg, um an die Bauwerkzeuge zu gelangen, ist die Installation
der <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Bauwerkzeuge für Visual Studio 2019</a>. Sobald du gefragt
wirst, welche Komponenten installiert werden sollen, wähle die „C++ build tools“
und zusätzlich das Windows 10 SDK und das englische Sprachpaket aus.</p>
<p>Der Rest dieses Buchs verwendet Befehle, die sowohl in <em>cmd.exe</em> als auch
in der PowerShell funktionieren. Falls es spezifische Unterschiede geben sollte,
werden wir diese erläutern.</p>
<h3><a class="header" href="#aktualisieren-und-deinstallieren" id="aktualisieren-und-deinstallieren">Aktualisieren und Deinstallieren</a></h3>
<p>Nachdem du Rust mithilfe von <code>rustup</code> installiert hast, ist es einfach,
auf die neueste Version zu aktualisieren. Führe folgenden Befehl auf der
Kommandozeile aus:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Um Rust und <code>rustup</code> zu deinstallieren, führe folgenden Befehl aus:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3><a class="header" href="#fehlersuche" id="fehlersuche">Fehlersuche</a></h3>
<p>Um zu überprüfen, ob du Rust erfolgreich installiert hast, führe folgenden
Befehl auf der Kommandozeile aus:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Du solltest die Versionsnummer, den Hashwert und das Datum der neuesten
stabilen Version in folgendem Format sehen:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Falls du diese Information sehen kannst, hast du Rust erfolgreich installiert.
Siehst du sie jedoch nicht und dein Betriebssystem ist Windows, prüfe ob Rust
in deiner Umgebungsvariable <code>%PATH%</code> eingetragen ist. Ist dies der Fall und Rust
funktioniert dennoch nicht, dann gibt es einige Orte, wo du Hilfe bekommen kannst.
Der einfachste ist der Kanal #beginners im <a href="https://discord.gg/rust-lang">offiziellen Rust Discord</a>.
Dort kannst du mit anderen Rustaceans (ein alberner Spitzname, den wir uns selbst
gegeben haben) chatten, die dir gerne weiterhelfen. Andere hilfreiche Quellen
sind <a href="https://users.rust-lang.org/">das Benutzerforum</a> and <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<h3><a class="header" href="#lokale-dokumentation" id="lokale-dokumentation">Lokale Dokumentation</a></h3>
<p>Die Rust-Installation enthält auch eine lokale Kopie der Dokumentation, sodass
du sie ohne Internetverbindung lesen kannst. Führe <code>rustup doc</code> aus, um die
lokale Dokumentation in deinem Browser zu öffnen.</p>
<p>Falls du dir nicht sicher bist, wie du einen Typ oder eine Funktion aus der
Standardbibliothek verwenden sollst, dann schau in der API-Dokumentation nach!</p>
<h2><a class="header" href="#hallo-welt" id="hallo-welt">Hallo Welt</a></h2>
<p>Nun, da du Rust installiert hast, lass uns dein erstes Rust-Programm schreiben.
Wenn man eine neue Sprache lernt, ist es üblich, ein kleines Programm zu
schreiben, das den Text <code>Hallo Welt!</code> auf dem Bildschirm ausgibt, also werden
wir hier das gleiche tun!</p>
<blockquote>
<p>Hinweis: Dieses Buch setzt grundlegende Vertrautheit mit der Kommandozeile
voraus. Rust stellt keine besonderen Anforderungen an deine Textbearbeitung
oder Werkzeuge oder an den Ort, an dem dein Code lebt. Wenn du also lieber
eine integrierte Entwicklungsumgebung (IDE) statt der Kommandozeile verwenden
möchtest, kannst du deine bevorzugte IDE verwenden. Viele IDEs bieten
mittlerweile einen gewissen Grad an Rust-Unterstützung; Einzelheiten findest
du in der Dokumentation der IDE. In jüngster Zeit hat sich das Rust-Team
darauf konzentriert, eine großartige IDE-Unterstützung zu ermöglichen, und an
dieser Front sind schnelle Fortschritte erzielt worden!</p>
</blockquote>
<h3><a class="header" href="#erstellen-eines-projektverzeichnisses" id="erstellen-eines-projektverzeichnisses">Erstellen eines Projektverzeichnisses</a></h3>
<p>Du beginnst damit, ein Verzeichnis zum Speichern deines Rust-Codes zu
erstellen. Es ist Rust egal, wo dein Code lebt, aber für die Übungen und
Projekte in diesem Buch schlagen wir vor, ein Verzeichnis <em>projects</em> in deinem
Hauptverzeichnis anzulegen und all deine Projekte dort abzulegen.</p>
<p>Öffne ein Terminal und gib die folgenden Befehle ein, um ein Verzeichnis
<em>projects</em> und ein Verzeichnis für das Projekt „Hallo Welt!“ innerhalb des
Verzeichnisses <em>projects</em> zu erstellen.</p>
<p>Gib dies für Linux, macOS und PowerShell unter Windows ein:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Für Windows CMD gib dies ein:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3><a class="header" href="#schreiben-und-ausführen-eines-rust-programms" id="schreiben-und-ausführen-eines-rust-programms">Schreiben und Ausführen eines Rust-Programms</a></h3>
<p>Als nächstes erstelle eine neue Quelldatei und nenne sie <em>main.rs</em>.
Rust-Dateien enden immer mit der Erweiterung <em>.rs</em>. Wenn du mehr als ein Wort
in deinem Dateinamen verwendest, verwende einen Unterstrich, um sie zu trennen.
Verwende zum Beispiel <em>hello_world.rs</em> statt <em>helloworld.rs</em>.</p>
<p>Öffne nun die Datei <em>main.rs</em>, die du gerade erstellt hast, und gib den Code in
Codeblock 1-1 ein.</p>
<p><span class="filename">Dateiname: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 1-1: Ein Programm, das <code>Hallo Welt!</code>
ausgibt</span></p>
<p>Speichere die Datei und gehe zurück zu deinem Terminalfenster. Gib unter Linux
oder MacOS die folgenden Befehle ein, um die Datei zu kompilieren und auszuführen:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hallo Welt!
</code></pre>
<p>Unter Windows gib den Befehl <code>.\main.exe</code> anstelle von <code>./main</code> ein:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hallo Welt!
</code></pre>
<p>Unabhängig von deinem Betriebssystem sollte die Zeichenfolge <code>Hallo Welt!</code> auf
dem Terminal ausgegeben werden. Wenn du diese Ausgabe nicht siehst, lies im
Abschnitt <a href="ch01-01-installation.html#fehlersuche">„Fehlersuche“</a> des Installationsabschnitts nach,
wie du Hilfe erhalten kannst.</p>
<p>Wenn <code>Hallo Welt!</code> ausgegeben wurde, herzlichen Glückwunsch! Du hast offiziell
ein Rust-Programm geschrieben. Das macht dich zu einem Rust-Programmierer
– willkommen!</p>
<h3><a class="header" href="#anatomie-eines-rust-programms" id="anatomie-eines-rust-programms">Anatomie eines Rust-Programms</a></h3>
<p>Lass uns im Detail Revue passieren, was gerade in deinem „Hallo Welt!“-Programm
passiert ist. Hier ist das erste Teil des Puzzles:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Diese Zeilen definieren eine Funktion in Rust. Die Funktion <code>main</code> ist eine
Besonderheit: Sie ist immer der erste Code, der in jedem ausführbaren
Rust-Programm ausgeführt wird. Die erste Zeile deklariert eine Funktion namens
<code>main</code>, die keine Parameter hat und nichts zurückgibt. Wenn es Parameter gäbe,
würden sie innerhalb der Klammern <code>()</code> stehen.</p>
<p>Beachte auch, dass der Funktionsrumpf in geschweifte Klammern <code>{}</code> eingehüllt
ist. Rust erfordert diese um alle Funktionsrümpfe. Es ist guter Stil, die
öffnende geschweifte Klammer in dieselbe Zeile wie die Funktionsdeklaration zu
platzieren und dazwischen ein Leerzeichen einzufügen.</p>
<p>Zum Zeitpunkt der Erstellung dieses Artikels ist ein automatisches
Formatierungswerkzeug namens <code>rustfmt</code> in Entwicklung. Wenn du dich an einen
Standardstil in allen Rust-Projekten halten willst, wird <code>rustfmt</code> deinen Code
in einem bestimmten Stil formatieren. Das Rust-Team plant, dieses Tool
schließlich in den Standard-Rust-Vertrieb wie <code>rustc</code> aufzunehmen. Je nachdem,
wann du dieses Buch liest, könnte es also bereits auf deinem Computer
installiert sein! Weitere Einzelheiten findest du in der Online-Dokumentation.</p>
<p>Innerhalb der Funktion <code>main</code> befindet sich der folgende Code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hallo Welt!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Diese Zeile erledigt die ganze Arbeit in diesem kleinen Programm: Sie gibt Text
auf dem Bildschirm aus. Hier gibt es vier wichtige Details zu beachten.</p>
<p>Erstens wird im Rust-Stil mit vier Leerzeichen eingerückt, nicht mit einem
Tabulator.</p>
<p>Zweitens ruft <code>println!</code> ein Rust-Makro auf. Wenn es stattdessen eine Funktion
aufrufte, würde diese als <code>println</code> (ohne <code>!</code>) angegeben werden. Wir werden die
Rust-Makros in Kapitel 19 ausführlicher besprechen. Im Moment musst du nur
wissen, dass die Verwendung eines <code>!</code> bedeutet, dass du ein Makro anstelle
einer normalen Funktion aufrufst.</p>
<p>Drittens siehst du die Zeichenkette &quot;Hallo Welt!&quot;. Wir übergeben diese
Zeichenkette als Argument an <code>println!</code>, und die Zeichenkette wird auf dem
Bildschirm ausgegeben.</p>
<p>Viertens beenden wir die Zeile mit einem Semikolon (<code>;</code>), was anzeigt, dass
dieser Ausdruck beendet ist und der nächste beginnen kann. Die meisten Zeilen
eines Rust-Codes enden mit einem Semikolon.</p>
<h3><a class="header" href="#kompilieren-und-ausführen-sind-getrennte-schritte" id="kompilieren-und-ausführen-sind-getrennte-schritte">Kompilieren und Ausführen sind getrennte Schritte</a></h3>
<p>Du hast gerade ein neu erstelltes Programm ausgeführt, also lass uns jeden
Schritt in diesem Prozess untersuchen.</p>
<p>Bevor du ein Rust-Programm ausführst, musst du es mit dem Rust-Compiler
kompilieren, indem du den Befehl <code>rustc</code> eingibst und ihm den Namen deiner
Quelldatei übergibst, so wie hier:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Wenn du einen C- oder C++-Hintergrund hast, wirst du feststellen, dass dies
ähnlich wie <code>gcc</code> oder <code>clang</code> ist. Nach erfolgreicher Kompilierung gibt Rust
eine ausführbare Binärdatei aus.</p>
<p>Unter Linux, MacOS und PowerShell unter Windows kannst du die ausführbare Datei
sehen, indem du den Befehl <code>ls</code> in deiner Konsole eingibst. Unter Linux und
MacOS siehst du zwei Dateien. Mit PowerShell unter Windows siehst du die
gleichen drei Dateien, die du mit CMD sehen würdest.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>Mit CMD unter Windows würdest du Folgendes eingeben:</p>
<pre><code class="language-cmd">&gt; dir /B %= die Option /B bewirkt, dass nur die Dateinamen angezeigt werden =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Dies zeigt die Quellcodedatei mit der Erweiterung <em>.rs</em>, die ausführbare Datei
(<em>main.exe</em> unter Windows, aber <em>main</em> auf allen anderen Plattformen) und, bei
Verwendung von Windows, eine Datei mit Debugging-Informationen mit der
Erweiterung <em>.pdb</em>. Von hier aus führst du die Datei <em>main</em> oder <em>main.exe</em>
aus, so wie hier:</p>
<pre><code class="language-console">$ ./main # oder .\main.exe unter Windows
</code></pre>
<p>Wenn <em>main.rs</em> dein „Hallo Welt!“-Programm wäre, würde diese Zeile „Hallo
Welt!“ in deinem Terminal ausgeben.</p>
<p>Wenn du mit einer dynamischen Sprache wie Ruby, Python oder JavaScript besser
vertraut bist, bist du es möglicherweise nicht gewohnt, ein Programm in
getrennten Schritten zu kompilieren und auszuführen. Rust ist eine <em>vorab
kompilierte</em> (ahead-of-time compiled) Sprache, d.h. du kannst ein Programm
kompilieren und die ausführbare Datei an jemand anderen weitergeben, und dieser
kann das Programm auch ohne Installation von Rust ausführen. Wenn du jemandem
eine <em>.rb</em>-, <em>.py</em>- oder <em>.js</em>-Datei gibst, muss er eine Ruby-, Python- bzw.
JavaScript-Implementierung installiert haben. Aber in diesen Sprachen benötigst
du nur einen Befehl, um dein Programm zu kompilieren und auszuführen. Beim
Sprachdesign ist alles ein Kompromiss.</p>
<p>Einfach mit <code>rustc</code> zu kompilieren ist für einfache Programme in Ordnung, aber
wenn dein Projekt wächst, wirst du alle Optionen verwalten und es einfach
machen wollen, deinen Code weiterzugeben. Als Nächstes stellen wir dir das
Cargo-Tool vor, das dir beim Schreiben von Rust-Programmen aus der realen Welt
helfen wird.</p>
<h2><a class="header" href="#hallo-cargo" id="hallo-cargo">Hallo Cargo</a></h2>
<p>Cargo ist das Bau-System (build system) und der Paketmanager von Rust. Die
meisten Rust-Entwickler verwenden dieses Werkzeug, um ihre Rust-Projekte zu
verwalten, weil Cargo viele Aufgaben für dich erledigt, z.B. Bauen deines
Codes, Herunterladen der Bibliotheken, von denen dein Code abhängt, und das
Bauen dieser Bibliotheken. (Wir nennen Bibliotheken, die dein Code benötigt,
<em>Abhängigkeiten</em> (dependencies).)</p>
<p>Die einfachsten Rust-Programme, wie das, das wir bisher geschrieben haben,
haben keine Abhängigkeiten. Wenn wir also das „Hallo Welt!“-Projekt mit Cargo
gebaut hätten, würde es nur den Teil von Cargo verwenden, der für das Bauen
deines Codes zuständig ist. Wenn du komplexere Rust-Programme schreibst, wirst
du Abhängigkeiten hinzufügen, und wenn du ein Projekt mit Cargo beginnst, wird
das Hinzufügen von Abhängigkeiten viel einfacher sein.</p>
<p>Da die überwiegende Mehrheit der Rust-Projekte Cargo verwendet, geht der Rest
dieses Buches davon aus, dass auch du Cargo verwendest. Cargo wird mit Rust
installiert, wenn du die offiziellen Installationsprogramme verwendet hast, die
im Abschnitt <a href="ch01-01-installation.html">„Installation“</a> besprochen werden. Wenn du Rust auf
eine andere Weise installiert hast, prüfe, ob Cargo installiert ist, indem du
Folgendes in dein Terminal eingibst:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Wenn du eine Versionsnummer siehst, hast du es! Wenn du einen Fehler siehst,
z.B. <code>command not found</code>, schaue in der Dokumentation zu deiner
Installationsmethode nach, um festzustellen, wie du Cargo separat installieren
kannst.</p>
<h3><a class="header" href="#projekt-mit-cargo-erstellen" id="projekt-mit-cargo-erstellen">Projekt mit Cargo erstellen</a></h3>
<p>Lass uns mit Cargo ein neues Projekt erstellen und uns ansehen, wie es sich von
unserem ursprünglichen „Hallo Welt!“-Projekt unterscheidet. Navigiere zurück zu
deinem <em>projects</em>-Verzeichnis (oder wo auch immer du dich entschieden hast,
deinen Code zu speichern). Führe dann auf einem beliebigen Betriebssystem die
folgenden Schritte aus:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Der erste Befehl erstellt ein neues Verzeichnis namens <em>hello_cargo</em>. Wir haben
unser Projekt <em>hello_cargo</em> genannt und Cargo erstellt seine Dateien in einem
Verzeichnis mit demselben Namen.</p>
<p>Gehe in das Verzeichnis <em>hello_cargo</em> und liste die Dateien auf. Du wirst
sehen, dass Cargo zwei Dateien und ein Verzeichnis für uns generiert hat: Eine
Datei <em>Cargo.toml</em> und ein Verzeichnis <em>src</em> mit einer Datei <em>main.rs</em> darin.</p>
<p>Es hat auch ein neues Git-Repository zusammen mit einer Datei <em>.gitignore</em>
initialisiert. Git-Dateien werden nicht erzeugt, wenn du <code>cargo new</code> innerhalb
eines existierenden Git-Repositories ausführst; du kannst dieses Verhalten
überschreiben, indem du <code>cargo new --vcs=git</code> verwendest. </p>
<blockquote>
<p>Hinweis: Git ist ein gebräuchliches Versionskontrollsystem. Du kannst <code>cargo new</code> anpassen, um ein anderes Versionskontrollsystem oder kein
Versionskontrollsystem zu verwenden, indem du das Flag <code>--vcs</code> verwendest.
Führe <code>cargo new --help</code> aus, um die verfügbaren Optionen zu sehen.</p>
</blockquote>
<p>Öffne <em>Cargo.toml</em> in einem Texteditor deiner Wahl. Es sollte ähnlich wie der
Code in Codeblock 1-2 aussehen.</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p><span class="caption">Codeblock 1-2: Inhalt von <em>Cargo.toml</em> erzeugt durch
<code>cargo new</code></span></p>
<p>Diese Datei liegt im Format <a href="https://toml.io"><em>TOML</em></a> (<em>Tom's Obvious, Minimal
Language</em>) vor, welches das Konfigurationsformat von Cargo ist.</p>
<p>Die erste Zeile <code>[package]</code> ist eine Abschnittsüberschrift, die anzeigt, dass
die folgenden Anweisungen ein Paket konfigurieren. Wenn wir weitere
Informationen zu dieser Datei hinzufügen, werden wir weitere Abschnitte
hinzufügen.</p>
<p>Die nächsten vier Zeilen legen die Konfigurationsinformationen fest, die Cargo
benötigt, um dein Programm zu kompilieren: Den Namen, die Version, wer es
geschrieben hat und die zu verwendende Rust-Ausgabe. Cargo erhält deinen Namen
und die E-Mail-Informationen von deiner Umgebung. Wenn diese Informationen
nicht korrekt sind, korrigiere die Informationen jetzt und speichere dann die
Datei. Über den Schlüssel <code>edition</code> sprechen wir in Anhang E.</p>
<p>Die letzte Zeile <code>[dependencies]</code> ist der Anfang eines Abschnitts, in dem du
alle Abhängigkeiten deines Projekts auflisten kannst. In Rust werden
Code-Pakete als <em>Kisten</em> (crates) bezeichnet. Wir werden keine anderen Kisten
für dieses Projekt benötigen, aber wir werden es im ersten Projekt in Kapitel 2
tun, also werden wir dann diesen Abhängigkeits-Abschnitt verwenden.</p>
<p>Öffne nun <em>src/main.rs</em> und wirf einen Blick darauf:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo hat für dich ein „Hello, world!“-Programm generiert, genau wie das, das
wir in Codeblock 1-1 geschrieben haben! Die Unterschiede zwischen unserem
vorherigen Projekt und dem Projekt, das Cargo generiert, bestehen bisher darin,
dass Cargo den Code im Verzeichnis <em>src</em> abgelegt hat, und wir haben eine
Konfigurationsdatei <em>Cargo.toml</em> im obersten Verzeichnis.</p>
<p>Cargo erwartet, dass deine Quelldateien innerhalb des <em>src</em>-Verzeichnisses
liegen. Das Projektverzeichnis der obersten Ebene ist nur für README-Dateien,
Lizenzinformationen, Konfigurationsdateien und alles andere, was nicht mit
deinem Code zusammenhängt. Das Verwenden von Cargo hilft dir, deine Projekte zu
organisieren. Es gibt einen Platz für alles und alles ist an seinem Platz.</p>
<p>Wenn du ein Projekt begonnen hast, das Cargo nicht verwendet, wie wir es mit
dem Projekt „Hallo Welt!“ getan haben, kannst du es in ein Projekt umwandeln,
das Cargo verwendet. Verschiebe den Projektcode in das Verzeichnis <em>src</em> und
erstelle eine entsprechende <em>Cargo.toml</em>-Datei.</p>
<h3><a class="header" href="#bauen-und-ausführen-eines-cargo-projekts" id="bauen-und-ausführen-eines-cargo-projekts">Bauen und Ausführen eines Cargo-Projekts</a></h3>
<p>Schauen wir uns nun an, was anders ist, wenn wir das „Hello, world!“-Programm
mit Cargo bauen und ausführen. Von deinem <em>hello_cargo</em>-Verzeichnis aus baust
du dein Projekt, indem du den folgenden Befehl eingibst:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Dieser Befehl erstellt eine ausführbare Datei in <em>target/debug/hello_cargo</em>
(oder <em>target\debug\hello_cargo.exe</em> unter Windows) und nicht in deinem
aktuellen Verzeichnis. Mit diesem Befehl kannst du die ausführbare Datei
ausführen:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # oder .\target\debug\hello_cargo.exe unter Windows
Hello, world!
</code></pre>
<p>Wenn alles gut geht, sollte <code>Hello, world!</code> im Terminal ausgegeben werden. Wenn
<code>cargo build</code> zum ersten Mal ausgeführt wird, erzeugt Cargo auch eine neue
Datei auf der obersten Ebene: <em>Cargo.lock</em>. Diese Datei verfolgt die genauen
Versionen der Abhängigkeiten in deinem Projekt. Dieses Projekt hat keine
Abhängigkeiten, daher ist die Datei etwas spärlich. Du musst diese Datei
niemals manuell ändern; Cargo verwaltet ihren Inhalt für dich.</p>
<p>Wir haben gerade ein Projekt mit <code>cargo build</code> gebaut und es mit
<code>./target/debug/hello_cargo</code> ausgeführt, aber wir können auch <code>cargo run</code>
verwenden, um den Code zu kompilieren und dann die resultierende ausführbare
Datei mit einem einzigen Befehl auszuführen:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Beachte, dass wir diesmal keine Ausgabe gesehen haben, die darauf hinweist,
dass Cargo <code>hello_cargo</code> kompiliert hat. Cargo fand heraus, dass sich die
Dateien nicht geändert hatten, also ließ es einfach die Binärdatei laufen. Wenn
du deinen Quellcode geändert hättest, hätte Cargo das Projekt vor der
Ausführung neu kompiliert, und du hättest diese Ausgabe gesehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo bietet auch einen Befehl namens <code>cargo check</code>. Dieser Befehl überprüft
schnell deinen Code, um sicherzustellen, dass er kompiliert, erzeugt aber keine
ausführbare Datei:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Warum willst du keine ausführbare Datei? Häufig ist <code>cargo check</code> viel
schneller als <code>cargo build</code>, weil es den Schritt der Erstellung einer
ausführbaren Datei überspringt. Wenn du deine Arbeit während des Schreibens des
Codes ständig überprüfst, wird das Verwenden von <code>cargo check</code> den Prozess
beschleunigen! Daher führen viele Rust-Entwickler während des Schreibens ihres
Programms regelmäßig <code>cargo check</code> aus, um sicherzustellen, dass das Programm
kompiliert. Dann lassen sie <code>cargo build</code> laufen, wenn sie bereit sind, die
ausführbare Datei zu benutzen.</p>
<p>Lasse uns zusammenfassen, was wir bisher über Cargo gelernt haben:</p>
<ul>
<li>Wir können ein Projekt bauen mit <code>cargo build</code>.</li>
<li>Wir können ein Projekt in einem Schritt bauen und ausführen mit <code>cargo run</code>.</li>
<li>Wir können ein Projekt bauen, ohne eine Binärdatei zu erzeugen, um auf Fehler
zu prüfen, mit <code>cargo check</code>.</li>
<li>Anstatt das Ergebnis des Bauvorgangs im selben Verzeichnis wie unser Code
abzulegen, legt Cargo es im Verzeichnis <em>target/debug</em> ab.</li>
</ul>
<p>Ein zusätzlicher Vorteil der Verwendung von Cargo ist, dass die Befehle
unabhängig vom Betriebssystem sind, mit dem du arbeitest. Daher werden wir an
dieser Stelle keine spezifischen Anweisungen für Linux und MacOS gegenüber
Windows mehr geben.</p>
<h3><a class="header" href="#bauen-einer-freigabe-release" id="bauen-einer-freigabe-release">Bauen einer Freigabe (release)</a></h3>
<p>Wenn dein Projekt schließlich zur Freigabe bereit ist, kannst du <code>cargo build --release</code> verwenden, um es mit Optimierungen zu kompilieren. Dieser Befehl
erzeugt eine ausführbare Datei in <em>target/release</em> anstelle von <em>target/debug</em>.
Durch die Optimierungen läuft dein Rust-Code schneller, aber wenn du sie
einschaltest, verlängert sich die Zeit, die dein Programm zum Kompilieren
benötigt. Aus diesem Grund gibt es zwei verschiedene Profile: Eines für die
Entwicklung, wenn du schnell und oft neu bauen willst, und ein anderes für das
Erstellen des endgültigen Programms, das du einem Benutzer gibst, das nicht
wiederholt neu gebaut wird und das so schnell wie möglich läuft. Wenn du einen
Laufzeit-Benchmark deines Codes durchführst, stelle sicher, dass du <code>cargo build --release</code> ausführst und den Benchmark mit der ausführbaren Datei in
<em>target/release</em> durchführst.</p>
<h3><a class="header" href="#cargo-als-konvention" id="cargo-als-konvention">Cargo als Konvention</a></h3>
<p>Bei einfachen Projekten bietet Cargo nicht viel mehr Wert als das bloße
Verwenden von <code>rustc</code>, aber es wird sich in dem Maße bewähren, wie deine
Programme immer komplizierter werden. Bei komplexen Projekten, die aus mehreren
Kisten bestehen, ist es viel einfacher, das Bauen von Cargo koordinieren zu
lassen.</p>
<p>Auch wenn das Projekt <code>hello_cargo</code> einfach ist, so verwendet es jetzt einen
Großteil der realen Werkzeuge, die du im Rest deiner Rust-Karriere verwenden
wirst. Tatsächlich kannst du, um an bestehenden Projekten zu arbeiten, die
folgenden Befehle verwenden, um den Code mit Git auszuchecken, in das
Verzeichnis dieses Projekts zu wechseln und zu bauen:</p>
<pre><code class="language-console">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Weitere Informationen über Cargo findest du unter <a href="https://doc.rust-lang.org/cargo/">seiner Dokumentation</a>.</p>
<h2><a class="header" href="#zusammenfassung" id="zusammenfassung">Zusammenfassung</a></h2>
<p>Du hast deine Rust-Reise bereits gut begonnen! In diesem Kapitel hast du
gelernt, wie es geht:</p>
<ul>
<li>Installiere die neueste stabile Version von Rust mit <code>rustup</code>.</li>
<li>Aktualisiere auf eine neuere Rust-Version.</li>
<li>Öffne die lokal installiere Dokumentation.</li>
<li>Schreibe und führe ein „Hallo Welt!“-Programm aus, direkt mittels <code>rustc</code>.</li>
<li>Schreibe und führe ein neues Projekt aus mittels Cargo-Konventionen.</li>
</ul>
<p>Dies ist ein guter Zeitpunkt, ein umfangreicheres Programm zu erstellen, um
sich an das Lesen und Schreiben von Rust-Code zu gewöhnen. In Kapitel 2 werden
wir also ein Ratespielprogramm erstellen. Wenn du lieber damit beginnen
möchtest, zu lernen, wie gängige Programmierkonzepte in Rust funktionieren,
lies Kapitel 3 und kehre dann zu Kapitel 2 zurück.</p>
<h1><a class="header" href="#ein-ratespiel-programmieren" id="ein-ratespiel-programmieren">Ein Ratespiel programmieren</a></h1>
<p>Lass uns den Sprung in Rust wagen, indem wir gemeinsam ein praktisches Projekt
durcharbeiten! Dieses Kapitel führt dich in einige gängige Rust-Konzepte ein,
indem es dir zeigt, wie du diese in einem realen Programm verwenden kannst. Du
lernst <code>let</code>, <code>match</code>, Methoden, assoziierte Funktionen, das Verwenden externer
Kisten (crates) und mehr kennen! In den folgenden Kapiteln werden diese Ideen
ausführlicher behandelt. In diesem Kapitel wirst du die Grundlagen üben.</p>
<p>Wir werden ein klassisches Programmierproblem für Anfänger implementieren: Ein
Ratespiel. Und so funktioniert es: Das Programm erzeugt eine zufällige ganze
Zahl zwischen 1 und 100. Dann wird es den Spieler auffordern, eine Schätzung
einzugeben. Nachdem eine Schätzung eingegeben wurde, zeigt das Programm an, ob
die Schätzung zu niedrig oder zu hoch ist. Wenn die Schätzung korrekt ist, gibt
das Spiel eine Glückwunschnachricht aus und beendet sich.</p>
<h2><a class="header" href="#aufsetzen-eines-neuen-projekts" id="aufsetzen-eines-neuen-projekts">Aufsetzen eines neuen Projekts</a></h2>
<p>Um ein neues Projekt aufzusetzen, gehe in das Verzeichnis <em>projects</em>, das du in
Kapitel 1 erstellt hast, und erstelle ein neues Projekt mit Cargo, wie folgt:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Der erste Befehl <code>cargo new</code> nimmt den Namen des Projekts (<code>guessing_game</code>) als
erstes Argument. Der zweite Befehl wechselt in das Verzeichnis des neuen
Projekts.</p>
<p>Schaue dir die generierte Datei <em>Cargo.toml</em> an:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Wenn die Informationen zum Autor, die Cargo aus deiner Umgebung erhalten hat,
nicht korrekt sind, korrigiere dies in der Datei und speichere sie erneut.</p>
<p>Wie du in Kapitel 1 gesehen hast, generiert <code>cargo new</code> ein „Hello,
world!“-Programm für dich. Sieh dir die Datei <em>src/main.rs</em> an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Kompilieren wir nun dieses „Hello, world!“-Programm und führen es im gleichen
Schritt aus mit dem Befehl <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Der Befehl <code>run</code> ist praktisch, wenn du ein Projekt schnell iterieren musst,
wie wir es in diesem Spiel tun werden, indem du jede Iteration schnell testest,
bevor du zur nächsten übergehst.</p>
<p>Öffne die Datei <em>src/main.rs</em> erneut. Du wirst den gesamten Code in diese Datei
schreiben.</p>
<h2><a class="header" href="#verarbeiten-einer-schätzung" id="verarbeiten-einer-schätzung">Verarbeiten einer Schätzung</a></h2>
<p>Der erste Teil des Ratespielprogramms fragt nach einer Benutzereingabe,
verarbeitet diese Eingabe und überprüft, ob die Eingabe in der erwarteten Form
vorliegt. Zu Beginn erlauben wir dem Spieler, eine Schätzung einzugeben. Gib
den Code aus Codeblock 2-1 in <em>src/main.rs</em> ein.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Du hast geschätzt: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Codeblock 2-1: Code, der eine Schätzung vom Benutzer
erhält und ausgibt</span></p>
<p>Dieser Code enthält eine Menge Informationen, also gehen wir ihn Zeile für
Zeile durch. Um eine Benutzereingabe zu erhalten und das Ergebnis dann als
Ausgabe auszugeben, müssen wir die Bibliothek <code>io</code> (input/output) in den
Gültigkeitsbereich bringen. Die <code>io</code>-Bibliothek stammt aus der
Standardbibliothek (die als <code>std</code> bekannt ist):</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Standardmäßig bringt Rust im <a href="https://doc.rust-lang.org/std/prelude/index.html"><em>Präludium</em></a> nur einige wenige Typen in
den Gültigkeitsbereich jedes Programms. Wenn ein Typ, den du verwenden willst,
nicht im Präludium ist, musst du diesen Typ explizit mit einer <code>use</code>-Anweisung
in den Gültigkeitsbereich bringen. Das Verwenden der Bibliothek <code>std::io</code>
bietet dir eine Reihe von nützlichen Funktionalitäten, einschließlich der
Möglichkeit, Benutzereingaben entgegenzunehmen.</p>
<p>Wie du in Kapitel 1 gesehen hast, ist die Funktion <code>main</code> der Einstiegspunkt in
das Programm:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Die Syntax <code>fn</code> deklariert eine neue Funktion, die Klammern <code>()</code> zeigen an,
dass es keine Parameter gibt, und die geschweifte Klammer <code>{</code> beginnt den Rumpf
der Funktion.</p>
<p>Wie du auch in Kapitel 1 gelernt hast, ist <code>println!</code> ein Makro, das eine
Zeichenkette auf dem Bildschirm ausgibt:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Dieser Code gibt eine Eingabeaufforderung aus, die angibt, um was für ein Spiel
es sich handelt, und den Benutzer zur Eingabe auffordert.</p>
<h3><a class="header" href="#speichern-von-werten-mit-variablen" id="speichern-von-werten-mit-variablen">Speichern von Werten mit Variablen</a></h3>
<p>Als Nächstes erstellen wir einen Ort, an dem die Benutzereingabe gespeichert
wird, wie hier:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Jetzt wird das Programm interessant! Es ist viel los in dieser kleinen Zeile.
Beachte, dass dies eine <code>let</code>-Anweisung ist, die benutzt wird, um eine
<em>Variable</em> zu erzeugen. Hier ist ein weiteres Beispiel:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Diese Zeile erzeugt eine neue Variable namens <code>foo</code> und bindet sie an den Wert
der Variablen <code>bar</code>. In Rust sind Variablen standardmäßig unveränderlich
(immutable). Wir werden dieses Konzept im Abschnitt <a href="ch03-01-variables-and-mutability.html">„Variablen und
Veränderlichkeit“</a> in Kapitel 3 ausführlich
besprechen. Das folgende Beispiel zeigt, wie man <code>mut</code> vor dem Variablennamen
verwendet, um eine Variable veränderlich zu machen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 5; // unveränderlich
let mut bar = 5; // veränderlich
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Anmerkung: Die Syntax <code>//</code> beginnt einen Kommentar, der bis zum Ende der
Zeile weitergeht. Rust ignoriert alles in Kommentaren. Diese werden in
Kapitel 3 ausführlicher besprochen.</p>
</blockquote>
<p>Kommen wir zurück zum Programm des Ratespiels. Du weißt jetzt, dass <code>let mut guess</code> eine veränderliche Variable namens <code>guess</code> einführt. Auf der anderen
Seite des Gleichheitszeichens (<code>=</code>) steht der Wert, an den <code>guess</code> gebunden
ist, was das Ergebnis des Aufrufs von <code>String::new</code> ist, einer Funktion, die
eine neue Instanz eines <code>String</code> zurückgibt. <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> ist ein von der
Standardbibliothek bereitgestellter Zeichenketten-Typ, der ein
wachstumsfähiges, UTF-8-kodiertes Stück Text ist.</p>
<p>Die Syntax <code>::</code> in der Zeile <code>::new</code> zeigt an, dass <code>new</code> eine <em>assoziierte
Funktion</em> (associated function) vom Typ <code>String</code> ist. Eine assoziierte Funktion
ist auf einem Typ, in diesem Fall <code>String</code>, und nicht auf einer bestimmten
Instanz eines <code>String</code> implementiert. Einige Sprachen nennen dies eine
<em>statische Methode</em>.</p>
<p>Diese Funktion <code>new</code> erzeugt eine neue, leere Zeichenkette. Du wirst eine
Funktion <code>new</code> bei vielen Typen finden, weil es ein gebräuchlicher Name für
eine Funktion ist, die einen neuen Wert irgendeiner Art erzeugt.</p>
<p>Zusammenfassend lässt sich sagen, dass die Zeile <code>let mut guess = String::new();</code> eine veränderlich Variable erzeugt hat, die derzeit an eine
neue, leere Instanz eines <code>String</code> gebunden ist. Uff!</p>
<p>Erinnere dich, dass wir die Ein-/Ausgabefunktionalität aus der
Standardbibliothek mit <code>use std::io;</code> in der ersten Zeile des Programms
eingebunden haben. Jetzt rufen wir die Funktion <code>stdin</code> aus dem Modul <code>io</code> auf:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Hätten wir nicht die Zeile <code>use std::io</code> an den Anfang des Programms gestellt,
hätten wir diesen Funktionsaufruf als <code>std::io::stdin</code> schreiben können. Die
Funktion <code>stdin</code> gibt eine Instanz von <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a> zurück, was
ein Typ ist, der eine Standardeingaberessource (handle to the standard input)
für dein Terminal darstellt.</p>
<p>Der nächste Teil des Codes <code>.read_line(&amp;mut guess)</code> ruft die Methode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> der Standardeingaberessource auf, um eine Eingabe vom
Benutzer zu erhalten. Wir übergeben auch ein Argument an <code>read_line</code>:
<code>&amp;mut guess</code>.</p>
<p>Die Aufgabe von <code>read_line</code> ist es, alles, was der Benutzer in die
Standardeingabe eingibt, in eine Zeichenkette zu übernehmen, daher nimmt es
diese Zeichenkette als Argument. Das Zeichenketten-Argument muss veränderlich
sein, damit die Methode den Inhalt der Zeichenkette durch Hinzufügen der
Benutzereingabe ändern kann.</p>
<p>Das <code>&amp;</code> zeigt an, dass es sich bei diesem Argument um eine <em>Referenz</em> handelt,
die dir eine Möglichkeit bietet, mehrere Teile deines Codes auf einen Datenteil
zugreifen zu lassen, ohne dass du diese Daten mehrfach in den Speicher kopieren
musst. Referenzen sind eine komplexe Funktionalität, und einer der
Hauptvorteile von Rust ist, wie sicher und einfach es ist, Referenzen zu
verwenden. Du musst nicht viele dieser Details kennen, um dieses Programm
fertigzustellen. Im Moment musst du nur wissen, dass Referenzen wie Variablen
standardmäßig unveränderlich sind. Daher musst du <code>&amp;mut guess</code> anstatt <code>&amp;guess</code>
schreiben, um sie veränderlich zu machen. (In Kapitel 4 werden Referenzen
ausführlicher erklärt.)</p>
<h3><a class="header" href="#behandeln-potentieller-fehler-mit-dem-typ-result" id="behandeln-potentieller-fehler-mit-dem-typ-result">Behandeln potentieller Fehler mit dem Typ <code>Result</code></a></h3>
<p>Wir arbeiten noch immer an dieser Codezeile. Obwohl wir jetzt eine dritte
Textzeile besprechen, ist sie immer noch Teil einer einzigen logischen
Codezeile. Der nächste Teil ist diese Methode:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Wenn du eine Methode mit der Syntax <code>.foo()</code> aufrufst, ist es oft ratsam, einen
Zeilenumbruch und weitere Leerzeichen anzugeben, um lange Zeilen aufzuteilen.
Wir hätten diesen Code auch so schreiben können:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Fehler beim Lesen der Zeile&quot;);
</code></pre>
<p>Eine lange Zeile ist jedoch schwer zu lesen, daher ist es am besten, sie
aufzuteilen. Lass uns nun besprechen, was diese Zeile bewirkt. </p>
<p>Wie bereits erwähnt, schreibt <code>read_line</code> das, was der Benutzer eingibt, in die
Zeichenkette, die wir ihm übergeben, aber sie gibt auch einen Wert zurück
– in diesem Fall ein <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Rust hat eine Reihe von
Typen namens <code>Result</code> in seiner Standardbibliothek: Ein generisches
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> sowie spezifische Versionen für Untermodule, z.B.
<code>io::Result</code>.</p>
<p>Die <code>Result</code>-Typen sind <a href="ch06-00-enums.html"><em>Aufzählungen</em></a> (enumerations), die oft als
<em>enums</em> bezeichnet werden. Eine Aufzählung ist ein Typ, der einen festen Satz
von Werten haben kann, und diese Werte werden die <em>Varianten</em> (variants) der
Aufzählung genannt. In Kapitel 6 werden Aufzählungen ausführlicher behandelt.</p>
<p>Für <code>Result</code> sind die Varianten <code>Ok</code> und <code>Err</code>. Die Variante <code>Ok</code> gibt an, dass
die Operation erfolgreich war, und innerhalb von <code>Ok</code> steht der erfolgreich
generierte Wert. Die Variante <code>Err</code> bedeutet, dass die Operation fehlgeschlagen
ist, und <code>Err</code> enthält Informationen darüber, wie oder warum die Operation
fehlgeschlagen ist.</p>
<p>Der Zweck dieser <code>Result</code>-Typen ist es, Informationen zur Fehlerbehandlung zu
kodieren. Für Werte vom Typ <code>Result</code> sind, wie für Werte jedes Typs, Methoden
definiert. Eine Instanz von <code>io::Result</code> hat eine <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">Methode <code>expect</code></a>,
die du aufrufen kannst. Wenn diese <code>io::Result</code>-Instanz ein <code>Err</code>-Wert ist,
wird <code>expect</code> das Programm zum Absturz bringen und die Meldung anzeigen, die du
als Argument an <code>expect</code> übergeben hast. Wenn die Methode <code>read_line</code> ein <code>Err</code>
zurückgibt, ist dies wahrscheinlich das Ergebnis eines Fehlers, der vom
zugrundeliegenden Betriebssystem herrührt. Wenn diese <code>io::Result</code>-Instanz ein
<code>Ok</code>-Wert ist, wird <code>expect</code> den Wert, den <code>Ok</code> hält, als Rückgabewert
verwenden, damit du ihn verwenden kannst. In diesem Fall ist dieser Wert die
Anzahl der Bytes, die der Benutzer in die Standardeingabe eingegeben hat.</p>
<p>Wenn du nicht <code>expect</code> aufrufst, wird das Programm kompiliert, aber du erhältst
eine Warnung:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warnt, dass du den von <code>read_line</code> zurückgegebenen <code>Result</code>-Wert nicht
verwendet hast, was darauf hinweist, dass das Programm einen möglichen Fehler
nicht behandelt hat.</p>
<p>Der richtige Weg, die Warnung zu unterdrücken, ist, tatsächlich eine
Fehlerbehandlung zu schreiben, aber da du dieses Programm einfach nur abstürzen
lassen willst, wenn ein Problem auftritt, kannst du <code>expect</code> verwenden. In
Kapitel 9 erfährst du, wie man sich von Fehlern erholt.</p>
<h3><a class="header" href="#ausgeben-von-werten-mit-println-platzhaltern" id="ausgeben-von-werten-mit-println-platzhaltern">Ausgeben von Werten mit <code>println!</code>-Platzhaltern</a></h3>
<p>Abgesehen von der schließenden geschweiften Klammer gibt es in dem bisher
hinzugefügten Code nur noch eine weitere Zeile zu besprechen, nämlich die
folgende: </p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span>    println!(&quot;Du hast geschätzt: {}&quot;, guess);
<span class="boring">}
</span></code></pre>
<p>Diese Zeile gibt die Zeichenkette aus, in der wir die Eingabe des Benutzers
gespeichert haben. Der Satz geschweifte Klammern <code>{}</code> ist ein Platzhalter:
Stelle dir <code>{}</code> wie kleine Krebszangen vor, die einen Wert an Ort und Stelle
halten. Mit geschweiften Klammern kannst du mehr als einen Wert ausgeben: Der
erste Satz geschweifte Klammern enthält den ersten Wert, der nach der
Formatierungszeichenkette aufgeführt ist, der zweite Satz enthält den zweiten
Wert usw. Das Ausgeben mehrerer Werte in einem Aufruf von <code>println!</code> würde
folgendermaßen aussehen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} und y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code würde <code>x = 5 und y = 10</code> ausgeben.</p>
<h3><a class="header" href="#testen-des-ersten-teils" id="testen-des-ersten-teils">Testen des ersten Teils</a></h3>
<p>Testen wir den ersten Teil des Ratespiels. Führe ihn mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Rate die Zahl!
Bitte gib deine Schätzung ein.
6
Du hast geschätzt: 6
</code></pre>
<p>An diesem Punkt ist der erste Teil des Spiels abgeschlossen: Wir erhalten
eine Eingabe über die Tastatur und geben sie dann aus.</p>
<h2><a class="header" href="#generieren-einer-geheimzahl" id="generieren-einer-geheimzahl">Generieren einer Geheimzahl</a></h2>
<p>Als nächstes müssen wir eine Geheimzahl generieren, die der Benutzer zu erraten
versucht. Die Geheimzahl sollte jedes Mal anders sein, damit das Spiel mehr als
einmal Spaß macht. Lass uns eine Zufallszahl zwischen 1 und 100 verwenden,
damit das Spiel nicht zu schwierig wird. Rust enthält noch keine
Zufallszahl-Funktionalität in seiner Standardbibliothek. Das Rust-Team stellt
jedoch eine <a href="https://crates.io/crates/rand">Kiste <code>rand</code></a> zur Verfügung.</p>
<h3><a class="header" href="#verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten" id="verwenden-einer-kiste-um-mehr-funktionalität-zu-erhalten">Verwenden einer Kiste um mehr Funktionalität zu erhalten</a></h3>
<p>Denke daran, dass eine Kiste eine Sammlung von Rust-Quellcode-Dateien ist. Das
Projekt, das wir gebaut haben, ist eine <em>binäre Kiste</em> (binary crate), die eine
ausführbare Datei ist. Die Kiste <code>rand</code> ist eine <em>Bibliotheks-Kiste</em> (library
crate), die Code enthält, der in anderen Programmen verwendet werden soll.</p>
<p>Das Verwenden von externen Kisten ist der Bereich, in dem Cargo glänzt. Bevor
wir Code schreiben können, der <code>rand</code> benutzt, müssen wir die Datei
<em>Cargo.toml</em> so modifizieren, dass die Kiste <code>rand</code> als Abhängigkeit
eingebunden wird. Öffne jetzt diese Datei und füge die folgende Zeile unten
unter der Überschrift des Abschnitts <code>[dependencies]</code> hinzu, den Cargo für dich
erstellt hat:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>In der Datei <em>Cargo.toml</em> ist alles, was nach einer Überschrift folgt, Teil
eines Abschnitts, der so lange andauert, bis ein anderer Abschnitt beginnt. Im
Abschnitt <code>[dependencies]</code> teilst du Cargo mit, von welchen externen Kisten
dein Projekt abhängt und welche Versionen dieser Kisten du benötigst. In diesem
Fall spezifizieren wir die Kiste <code>rand</code> mit dem semantischen
Versionsspezifikator <code>0.5.5</code>. Cargo versteht <a href="https://semver.org/lang/de/">semantische
Versionierung</a> (manchmal auch <em>SemVer</em> genannt), was ein Standard zum
Schreiben von Versionsnummern ist. Die Zahl <code>0.5.5</code> ist eigentlich die
Abkürzung für <code>^0.5.5</code>, was bedeutet „jede Version, die eine öffentliche API
hat, die mit Version 0.5.5 kompatibel ist“. </p>
<p>Lass uns nun, ohne den Code zu ändern, das Projekt bauen, wie in Codeblock 2-2
gezeigt.</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Codeblock 2-2: Die Ausgabe beim Ausführen von <code>cargo build</code> nach dem Hinzufügen der Kiste rand als Abhängigkeit</span></p>
<p>Möglicherweise siehst du unterschiedliche Versionsnummern (aber dank SemVer
sind sie alle mit dem Code kompatibel!), unterschiedliche Zeilen (je nach
Betriebssystem) und die Zeilen können in einer anderen Reihenfolge erscheinen.</p>
<p>Jetzt, wo wir eine externe Abhängigkeit haben, holt Cargo die neuesten
Versionen von allem aus der <em>Registry</em>, das eine Kopie der Daten von
<a href="https://crates.io/">Crates.io</a> ist. Crates.io ist der Ort, an dem die Menschen im
Rust-Ökosystem ihre Open-Source-Rustprojekte für andere zur Nutzung
bereitstellen.</p>
<p>Nach dem Aktualisieren der Registry überprüft Cargo den Abschnitt
<code>[dependencies]</code> und lädt alle Kisten herunter, die du noch nicht hast. In
diesem Fall, obwohl wir nur <code>rand</code> als Abhängigkeit aufgelistet haben, hat
Cargo auch <code>libc</code> und <code>rand_core</code> geschnappt, weil <code>rand</code> von diesen abhängig
ist, um zu funktionieren. Nachdem die Kisten heruntergeladen wurden, kompiliert
Rust sie und kompiliert dann das Projekt mit den verfügbaren Abhängigkeiten.</p>
<p>Wenn du gleich wieder <code>cargo build</code> ausführst, ohne irgendwelche Änderungen
vorzunehmen, erhältst du keine Ausgabe außer der Zeile <code>Finished</code>. Cargo weiß,
dass es die Abhängigkeiten bereits heruntergeladen und kompiliert hat, und du
hast in deiner Datei <em>Cargo.toml</em> nichts daran geändert. Cargo weiß auch, dass
du nichts an deinem Code geändert hast, also wird dieser auch nicht neu
kompiliert. Ohne etwas zu tun zu haben, wird es einfach beendet.</p>
<p>Wenn du die Datei <em>src/main.rs</em> öffnest, eine triviale Änderung vornimmst und
sie dann speicherst und neu baust, siehst du nur zwei Zeilen Ausgabe:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Diese Zeilen zeigen, dass Cargo nur den Build mit deiner winzigen Änderung an
der Datei <em>src/main.rs</em> aktualisiert. Deine Abhängigkeiten haben sich nicht
geändert, sodass Cargo weiß, dass es wiederverwenden kann, was es bereits
heruntergeladen und kompiliert hat. Es baut nur deinen Teil des Codes neu.</p>
<h4><a class="header" href="#sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock" id="sicherstellen-reproduzierbarer-builds-mit-der-datei-cargolock">Sicherstellen reproduzierbarer Builds mit der Datei <em>Cargo.lock</em></a></h4>
<p>Cargo verfügt über einen Mechanismus, der sicherstellt, dass du jedes Mal, wenn
du oder jemand anderes deinen Code baut, dasselbe Artefakt neu erstellen
kannst: Cargo wird nur die Versionen der von dir angegebenen Abhängigkeiten
verwenden, bis du etwas anderes angibst. Was passiert z.B., wenn nächste Woche
Version 0.5.6 der Kiste <code>rand</code> herauskommt und eine wichtige Fehlerbehebung
enthält, aber auch eine Regression, die deinen Code bricht?</p>
<p>Die Antwort auf dieses Problem ist die Datei <em>Cargo.lock</em>, die beim ersten
Ausführen von <code>cargo build</code> erstellt wurde und sich jetzt in deinem
<em>guessing_game</em>-Verzeichnis befindet. Wenn du ein Projekt zum ersten Mal baust,
ermittelt Cargo alle Versionen der Abhängigkeiten, die den Kriterien
entsprechen, und schreibt sie dann in die Datei <em>Cargo.lock</em>. Wenn du dein
Projekt in der Zukunft baust, wird Cargo sehen, dass die Datei <em>Cargo.lock</em>
existiert und die dort angegebenen Versionen verwenden, anstatt die ganze
Arbeit der Versionsfindung erneut zu machen. Auf diese Weise erhältst du
automatisch einen reproduzierbaren Build. Mit anderen Worten, dein Projekt
bleibt dank der Datei <em>Cargo.lock</em> auf <code>0.5.5</code>, bis du explizit die
Versionsnummer erhöhst.</p>
<h4><a class="header" href="#aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten" id="aktualisieren-einer-kiste-um-eine-neue-version-zu-erhalten">Aktualisieren einer Kiste, um eine neue Version zu erhalten</a></h4>
<p>Wenn du eine Kiste aktualisieren <em>willst</em>, bietet Cargo einen weiteren Befehl
<code>update</code> an, der die Datei <em>Cargo.lock</em> ignoriert und alle neuesten Versionen,
die deinen Spezifikationen entsprechen, in <em>Cargo.toml</em> herausfindet. Wenn das
funktioniert, wird Cargo diese Versionen in die Datei <em>Cargo.lock</em> schreiben.</p>
<p>Standardmäßig sucht Cargo jedoch nur nach Versionen, die größer als <code>0.5.5</code> und
kleiner als <code>0.6.0</code> sind. Wenn die Kiste <code>rand</code> zwei neue Versionen <code>0.5.6</code> und
<code>0.6.0</code> veröffentlicht hat, würdest du folgendes sehen, wenn du <code>cargo update</code>
ausführst:</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -&gt; v0.5.6
</code></pre>
<p>An diesem Punkt würdest du auch eine Änderung in deiner Datei <em>Cargo.lock</em>
bemerken, die feststellt, dass die Version der Kiste <code>rand</code>, die du jetzt
benutzt, <code>0.5.6</code> ist.</p>
<p>Wenn du die <code>rand</code>-Version <code>0.6.0</code> oder irgendeine Version aus der
<code>0.6.x</code>-Serie verwenden wolltest, müsstest du stattdessen die Datei
<em>Cargo.toml</em> anpassen, damit sie wie folgt aussieht:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.6.0&quot;
</code></pre>
<p>Wenn du das nächste Mal <code>cargo build</code> ausführst, wird Cargo die Registry der
verfügbaren Kisten aktualisieren und deine <code>rand</code>-Anforderungen entsprechend
der von dir angegebenen neuen Version neu bewerten.</p>
<p>Es gibt noch viel mehr über <a href="http://doc.crates.io">Cargo</a> und <a href="http://doc.crates.io/crates-io.html">seinem
Ökosystem</a> zu sagen, das wir in Kapitel 14 besprechen werden, aber
für den Moment ist das alles, was du wissen musst. Cargo macht es sehr einfach,
Bibliotheken wiederzuverwenden, sodass die Rust-Entwickler in der Lage sind,
kleinere Projekte zu schreiben, die aus einer Reihe von Paketen
zusammengestellt werden.</p>
<h3><a class="header" href="#generieren-einer-zufallszahl" id="generieren-einer-zufallszahl">Generieren einer Zufallszahl</a></h3>
<p>Nun, da du die Kiste <code>rand</code> zu <em>Cargo.toml</em> hinzugefügt hast, lass uns mit
<code>rand</code> beginnen. Der nächste Schritt ist <em>src/main.rs</em> zu ändern, wie in
Codeblock 2-3 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);

    println!(&quot;Bitte gib deine Schätzung ein.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Du hast geschätzt: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Codeblock 2-3: Hinzufügen von Code zum Generieren einer
Zufallszahl</span></p>
<p>Zuerst fügen wir eine Zeile <code>use</code> hinzu: <code>use rand::Rng</code>. Das Merkmal (trait)
<code>Rng</code> definiert Methoden, die Zufallszahlengeneratoren implementieren, und
dieses Merkmal muss im Gültigkeitsbereich sein, damit wir diese Methoden
verwenden können. In Kapitel 10 werden Merkmale im Detail behandelt.</p>
<p>Als nächstes fügen wir zwei Zeilen in der Mitte hinzu. Die Funktion
<code>rand::thread_rng</code> gibt uns den speziellen Zufallszahlengenerator, den wir
verwenden werden: Einen, der lokal zum aktuellen Ausführungsstrang (thread) ist
und vom Betriebssystem initialisiert (seeded) wird. Dann rufen wir die Methode
<code>gen_range</code> des Zufallszahlengenerators auf. Diese Methode wird durch das
Merkmal <code>Rng</code> definiert, das wir mit der Anweisung <code>use rand::Rng</code> in den
Gültigkeitsbereich gebracht haben. Die Methode <code>gen_range</code> nimmt zwei Zahlen
als Argumente und generiert eine Zufallszahl zwischen ihnen. Sie ist inklusiv
an der unteren Grenze, aber exklusiv an der oberen Grenze, also müssen wir <code>1</code>
und <code>101</code> angeben, um eine Zahl zwischen 1 und 100 anzufordern.</p>
<blockquote>
<p>Hinweis: Du wirst nicht immer wissen, welche Merkmale du verwenden sollst und
welche Methoden und Funktionen einer Kiste du aufrufen musst. Anleitungen zur
Verwendung einer Kiste findest du in der Dokumentation jeder Kiste. Eine
weitere nette Funktionalität von Cargo ist, dass du das Kommando <code>cargo doc --open</code> ausführen kannst, das die von all deinen Abhängigkeiten
bereitgestellte Dokumentation lokal bereitstellt und in deinem Browser
öffnet. Wenn du an anderen Funktionen der Kiste <code>rand</code> interessiert bist,
führe zum Beispiel <code>cargo doc --open</code> aus und klicke auf <code>rand</code> in der
Seitenleiste links.</p>
</blockquote>
<p>Die zweite Zeile, die wir in der Mitte des Codes hinzugefügt haben, gibt die
Geheimzahl aus. Das ist hilfreich während wir das Programm entwickeln, um es
testen zu können, aber wir werden es aus der finalen Version entfernen. Es ist
kein echtes Spiel, wenn das Programm die Antwort ausgibt, sobald es startet!</p>
<p>Versuche, das Programm einige Male auszuführen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 7
Bitte gib deine Schätzung ein.
4
Du hast geschätzt: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 83
Bitte gib deine Schätzung ein.
5
Du hast geschätzt: 5
</code></pre>
<p>Du solltest verschiedene Zufallszahlen erhalten und sie sollten alle zwischen 1
und 100 sein. Großartige Arbeit!</p>
<h2><a class="header" href="#vergleichen-der-schätzung-mit-der-geheimzahl" id="vergleichen-der-schätzung-mit-der-geheimzahl">Vergleichen der Schätzung mit der Geheimzahl</a></h2>
<p>Jetzt, da wir eine Benutzereingabe und eine Zufallszahl haben, können wir sie
vergleichen. Dieser Schritt ist in Codeblock 2-4 dargestellt. Beachte, dass
sich dieser Code noch nicht ganz kompilieren lässt, wie wir erklären werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --abschneiden--
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span>
    println!(&quot;Du hast geschätzt: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
    }
}
</code></pre>
<p><span class="caption">Codeblock 2-4: Behandeln der möglichen Rückgabewerte beim
Vergleich zweier Zahlen</span></p>
<p>Das erste neue Element hier ist eine weitere <code>use</code>-Anweisung, die einen Typ
namens <code>std::cmp::Ordering</code> aus der Standardbibliothek in den
Gültigkeitsbereich bringt. Wie <code>Result</code> ist <code>Ordering</code> eine weitere Aufzählung,
aber die Varianten für <code>Ordering</code> sind <code>Less</code>, <code>Greater</code> und <code>Equal</code>. Dies sind
die drei Ergebnisse, die möglich sind, wenn man zwei Werte vergleicht.</p>
<p>Dann fügen wir unten fünf neue Zeilen hinzu, die den Typ <code>Ordering</code> verwenden.
Die <code>cmp</code>-Methode vergleicht zwei Werte und kann auf alles, was verglichen
werden kann, angewendet werden. Sie braucht eine Referenz auf das, was du
vergleichen willst: Hier wird <code>guess</code> mit <code>secret_number</code> verglichen. Dann gibt
sie eine Variante der <code>Ordering</code>-Aufzählung zurück, die wir mit der
<code>use</code>-Anweisung in den Gültigkeitsbereich gebracht haben. Wir verwenden einen
<a href="ch06-02-match.html"><code>match</code></a>-Ausdruck, um zu entscheiden, was als nächstes zu tun ist,
basierend darauf, welche <code>Ordering</code>-Variante vom Aufruf von <code>cmp</code> mit den
Werten in <code>guess</code> und <code>secret_number</code> zurückgegeben wurde.</p>
<p>Ein <code>match</code>-Ausdruck besteht aus <em>Zweigen</em> (arms). Ein Zweig besteht aus einem
<em>Muster</em> (pattern) und dem Code, der ausgeführt werden soll, wenn der Wert, der
am Anfang des <code>match</code>-Ausdrucks steht, zum Muster dieses Zweigs passt. Rust
nimmt den Wert, der bei <code>match</code> angegeben wurde, und schaut nacheinander durch
das Muster jedes Zweigs. Das <code>match</code>-Konstrukt und die Muster sind mächtige
Funktionalitäten in Rust, mit denen du eine Vielzahl von Situationen ausdrücken
kannst, auf die dein Code stoßen könnte, und die sicherstellen, dass du sie
alle behandelst. Diese Funktionalitäten werden ausführlich in Kapitel 6 bzw.
Kapitel 18 behandelt.</p>
<p>Gehen wir ein Beispiel dafür durch, was mit dem hier verwendeten
<code>match</code>-Ausdruck geschehen würde. Angenommen, der Benutzer hat 50 geschätzt und die
zufällig generierte Geheimzahl ist diesmal 38. Wenn der Code 50 mit 38
vergleicht, gibt die <code>cmp</code>-Methode <code>Ordering::Greater</code> zurück, weil 50 größer
als 38 ist. Der <code>match</code>-Ausdruck erhält den Wert <code>Ordering::Greater</code> und
beginnt mit der Überprüfung des Musters jedes Zweigs. Er schaut auf das Muster
<code>Ordering::Less</code> des ersten Zweigs und sieht, dass der Wert <code>Ordering::Greater</code>
nicht mit <code>Ordering::Less</code> übereinstimmt, also ignoriert er den Code in diesem
Zweig und geht zum nächsten Zweig über. Das Muster <code>Ordering::Greater</code> des
nächsten Zweigs <em>passt</em> zu <code>Ordering::Greater</code>! Der dazugehörige Code in diesem
Zweig wird ausgeführt und <code>Zu groß!</code> auf den Bildschirm ausgegeben. Der
<code>match</code>-Ausdruck endet, weil er in diesem Szenario nicht auf den letzten Zweig
zu schauen braucht.</p>
<p>Der Code in Codeblock 2-4 lässt sich jedoch noch nicht kompilieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.51
   Compiling rand_core v0.4.0
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected reference `&amp;std::string::String`
              found reference `&amp;{integer}`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Kernbotschaft besagt, dass es <em>nicht übereinstimmende Typen</em> (mismatched
types) gibt. Rust hat ein starkes, statisches Typsystem. Es hat jedoch auch
eine Typ-Inferenz. Als wir <code>let mut guess = String::new()</code> schrieben, konnte
Rust daraus schließen, dass <code>guess</code> ein <code>String</code> sein sollte, und zwang uns
nicht, den Typ anzugeben. Die <code>secret_number</code> hingegen ist ein Zahlentyp.
Einige Zahlentypen können einen Wert zwischen 1 und 100 haben: <code>i32</code>, eine
32-Bit-Zahl; <code>u32</code>, eine 32-Bit-Zahl ohne Vorzeichen; <code>i64</code>, eine 64-Bit-Zahl;
sowie andere. Rust verwendet standardmäßig <code>i32</code>, was der Typ von
<code>secret_number</code> ist, es sei denn, du fügst an anderer Stelle Typinformationen
hinzu, die Rust veranlassen würden, auf einen anderen numerischen Typ zu
schließen. Der Grund für den Fehler liegt darin, dass Rust eine Zeichenkette
und einen Zahlentyp nicht vergleichen kann.</p>
<p>Letztendlich wollen wir den <code>String</code>, den das Programm als Eingabe liest, in
einen echten Zahlentyp umwandeln, damit wir ihn numerisch mit der Geheimzahl
vergleichen können. Das können wir tun, indem wir eine weitere Zeile zum
<code>main</code>-Funktionsrumpf hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span>    // --abschneiden--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);

    println!(&quot;Du hast geschätzt: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
    }
}
</code></pre>
<p>Die Zeile lautet:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);
</code></pre>
<p>Wir erstellen eine Variable mit dem Namen <code>guess</code>. Aber warte, hat das Programm
nicht bereits eine Variable namens <code>guess</code>? Ja, aber Rust erlaubt uns, den
vorherigen Wert von <code>guess</code> mit einem neuen Wert zu <em>beschatten</em> (shadow).
Diese Funktionalität wird häufig in Situationen verwendet, in denen du einen
Wert von einem Typ in einen anderen Typ konvertieren möchtest. Durch das
Beschatten können wir den Variablennamen <code>guess</code> wiederverwenden, anstatt uns
zu zwingen, zwei eindeutige Variablen zu erstellen, z.B. <code>guess_str</code> und
<code>guess</code>. (Kapitel 3 behandelt das Beschatten ausführlicher.)</p>
<p>Wir binden <code>guess</code> an den Ausdruck <code>guess.trim().parse()</code>. Das <code>guess</code> im
Ausdruck bezieht sich auf das ursprüngliche <code>guess</code>, das ein <code>String</code> mit der
Eingabe darin war. Die <code>trim</code>-Methode der <code>String</code>-Instanz wird alle
Leerzeichen am Anfang und am Ende entfernen. Obwohl <code>u32</code> nur numerische
Zeichen enthalten kann, muss der Benutzer die <span
class="keystroke">Eingabetaste</span> drücken, um <code>read_line</code>
zufriedenzustellen. Wenn der Benutzer die <span
class="keystroke">Eingabetaste</span> drückt, wird der Zeichenkette ein
Zeilenumbruchszeichen hinzugefügt. Wenn der Benutzer z.B. <span
class="keystroke">5</span> eingibt und die <span
class="keystroke">Eingabetaste</span> drückt, sieht <code>guess</code> wie folgt aus:
<code>5\n</code>. Das <code>\n</code> steht für „Zeilenumbruch“ (newline), das Ergebnis des Drückens
der <span class="keystroke">Eingabetaste</span>. Die <code>trim</code>-Methode entfernt
<code>\n</code>, was nur <code>5</code> ergibt.</p>
<p>Die <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code>-Methode für Zeichenketten</a> zerlegt eine Zeichenkette in
eine Art Zahl. Da diese Methode eine Vielzahl von Zahlentypen parsen kann,
müssen wir Rust den genauen Zahlentyp mitteilen, den wir wollen, indem wir <code>let guess: u32</code> verwenden. Der Doppelpunkt (<code>:</code>) nach <code>guess</code> sagt Rust, dass wir
den Typ der Variablen annotieren werden. Rust hat ein paar eingebaute
Zahlentypen; <code>u32</code>, das du hier siehst, ist eine vorzeichenlose
32-Bit-Ganzzahl. Es ist eine gute Standardwahl für eine kleine positive Zahl.
Über andere Zahlentypen erfährst du in Kapitel 3. Zusätzlich bedeuten die
Annotation <code>u32</code> in diesem Beispielprogramm und der Vergleich mit
<code>secret_number</code>, dass Rust daraus ableiten wird, dass <code>secret_number</code> ebenfalls
ein <code>u32</code> sein sollte. Nun wird also der Vergleich zwischen zwei Werten
desselben Typs durchgeführt!</p>
<p>Der Aufruf von <code>parse</code> könnte leicht einen Fehler verursachen. Wenn die
Zeichenkette zum Beispiel <code>A👍%</code> enthielte, gäbe es keine Möglichkeit, dies in
eine Zahl umzuwandeln. Da dies fehlschlagen könnte, gibt die <code>parse</code>-Methode
einen <code>Result</code>-Typ zurück, ähnlich wie die <code>read_line</code>-Methode (weiter oben in
<a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-dem-typ-result">„Behandeln potentieller Fehler mit dem Typ
<code>Result</code>“</a>). Wir werden
dieses <code>Result</code> auf die gleiche Weise behandeln, indem wir erneut <code>expect</code>
verwenden. Wenn <code>parse</code> eine <code>Err</code>-Variante von <code>Result</code> zurückgibt, weil es
keine Zahl aus der Zeichenkette erzeugen konnte, wird der <code>expect</code>-Aufruf das
Spiel zum Absturz bringen und die Nachricht ausgeben, die wir ihm geben. Wenn
<code>parse</code> die Zeichenkette erfolgreich in eine Zahl umwandeln kann, gibt es die
<code>Ok</code>-Variante von <code>Result</code> zurück, und <code>expect</code> gibt die Zahl zurück, die wir
vom <code>Ok</code>-Wert erwarten.</p>
<p>Lassen wir das Programm jetzt laufen!</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 58
Bitte gib deine Schätzung ein.
  76
Du hast geschätzt: 76
Zu groß!
</code></pre>
<p>Schön! Auch wenn vor der Schätzung Leerzeichen eingegeben wurden, fand das
Programm dennoch heraus, dass der Benutzer 76 geschätzt hat. Führe das Programm
einige Male aus, um das unterschiedliche Verhalten bei verschiedenen
Eingabearten zu überprüfen: Schätze die Zahl richtig, schätze eine zu große Zahl
und schätze eine zu kleine Zahl.</p>
<p>Der Großteil des Spiels funktioniert jetzt, aber der Benutzer kann nur <em>eine</em>
Schätzung anstellen. Ändern wir das, indem wir eine Schleife hinzufügen!</p>
<h2><a class="header" href="#zulassen-mehrerer-schätzungen-mittels-schleife" id="zulassen-mehrerer-schätzungen-mittels-schleife">Zulassen mehrerer Schätzungen mittels Schleife</a></h2>
<p>Das Schlüsselwort <code>loop</code> erzeugt eine Endlosschleife. Wir fügen diese jetzt
hinzu, um den Benutzern mehr Chancen zu geben, die Zahl zu erraten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    // --abschneiden--

    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);

    loop {
        println!(&quot;Bitte gib deine Schätzung ein.&quot;);

        // --abschneiden--

<span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; println!(&quot;Du hast gewonnen!&quot;),
        }
    }
}
</code></pre>
<p>Wie du sehen kannst, haben wir alles ab der Eingabeaufforderung für die
Schätzung in eine Schleife verschoben. Achte darauf, die Zeilen innerhalb der
Schleife jeweils um weitere vier Leerzeichen einzurücken und das Programm
erneut auszuführen. Beachte, dass es ein neues Problem gibt, weil das Programm
genau das tut, was wir ihm gesagt haben: Frage für immer nach einer weiteren
Schätzung! Es sieht nicht so aus, als könne der Benutzer das Programm beenden!</p>
<p>Der Benutzer könnte das Programm jederzeit mit dem Tastaturkürzel <span
class="keystroke">Strg+c</span> unterbrechen. Aber es gibt noch eine andere
Möglichkeit, diesem unersättlichen Monster zu entkommen, wie in der
<code>parse</code>-Diskussion in <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> erwähnt: Wenn der
Benutzer eine Antwort ohne Zahl eingibt, stürzt das Programm ab. Der Benutzer
kann das ausnutzen, um das Programm zu beenden, wie hier gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 59
Bitte gib deine Schätzung ein.
45
Du hast geschätzt: 45
Zu klein!
Bitte gib deine Schätzung ein.
60
Du hast geschätzt: 60
Zu groß!
Bitte gib deine Schätzung ein.
59
Du hast geschätzt: 59
Du hast gewonnen!
Bitte gib deine Schätzung ein.
quit
thread 'main' panicked at 'Bitte gib eine Zahl ein!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:999:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Mit der Eingabe von <code>quit</code> wird das Spiel tatsächlich beendet, aber das gilt
auch für alle anderen Eingaben, die keine Zahlen sind. Dies ist jedoch, gelinde
gesagt, suboptimal. Wir wollen, dass das Spiel automatisch beendet wird, wenn
die richtige Zahl erraten wird.</p>
<h3><a class="header" href="#beenden-nach-einer-korrekten-schätzung" id="beenden-nach-einer-korrekten-schätzung">Beenden nach einer korrekten Schätzung</a></h3>
<p>Programmieren wir das Spiel so, dass es beendet wird, wenn der Benutzer
gewinnt, indem wir eine <code>break</code>-Anweisung hinzufügen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Bitte gib eine Zahl ein!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">
</span>        // --abschneiden--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Das Hinzufügen der <code>break</code>-Zeile nach <code>Du hast gewonnen!</code> bewirkt, dass das
Programm die Schleife verlässt, wenn der Benutzer die Geheimzahl richtig errät.
Die Schleife zu verlassen bedeutet auch, das Programm zu beenden, da die
Schleife der letzte Teil von <code>main</code> ist.</p>
<h3><a class="header" href="#behandeln-ungültiger-eingaben" id="behandeln-ungültiger-eingaben">Behandeln ungültiger Eingaben</a></h3>
<p>Um das Verhalten des Spiels weiter zu verfeinern, sollten wir das Programm
nicht abstürzen lassen, wenn der Benutzer keine gültige Zahl eingibt, sondern
dafür sorgen, dass das Spiel ungültige Zahlen ignoriert, damit der Benutzer
weiter raten kann. Das können wir erreichen, indem wir die Zeile ändern, in der
<code>guess</code> von <code>String</code> in <code>u32</code> umgewandelt wird, wie in Codeblock 2-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --abschneiden--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Du hast geschätzt: {}&quot;, guess);

        // --abschneiden--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Du hast gewonnen!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 2-5: Ignorieren einer ungültigen Zahl und
Auffordern zu einer weiteren Schätzung, anstatt das Programm zum Absturz zu
bringen</span></p>
<p>Das Umstellen von einem <code>expect</code>-Aufruf zu einem <code>match</code>-Ausdruck ist der
allgemeine Übergang vom Absturz bei einem Fehler zur Behandlung des Fehlers.
Denke daran, dass <code>parse</code> einen <code>Result</code>-Typ zurückgibt und <code>Result</code> eine
Aufzählung ist, die die Varianten <code>Ok</code> und <code>Err</code> hat. Wir benutzen hier einen
<code>match</code>-Ausdruck, wie wir es mit dem <code>Ordering</code>-Ergebnis der <code>cmp</code>-Methode
getan haben.</p>
<p>Wenn <code>parse</code> in der Lage ist, die Zeichenkette erfolgreich in eine Zahl
umzuwandeln, gibt es einen <code>Ok</code>-Wert zurück, der die resultierende Zahl
enthält. Dieser <code>Ok</code>-Wert wird mit dem Muster des ersten Zweigs übereinstimmen
und der <code>match</code>-Ausdruck wird nur den <code>num</code>-Wert zurückgeben, der durch <code>parse</code>
erzeugt und in den <code>Ok</code>-Wert eingefügt wurde. Diese Zahl wird in der neuen
<code>guess</code>-Variable, die wir erzeugen, genau dort landen, wo wir sie haben wollen.</p>
<p>Wenn <code>parse</code> <em>nicht</em> in der Lage ist, die Zeichenkette in eine Zahl
umzuwandeln, gibt es einen <code>Err</code>-Wert zurück, der mehr Informationen über den
Fehler enthält. Der <code>Err</code>-Wert stimmt nicht mit dem <code>Ok(num)</code>-Muster im ersten
<code>match</code>-Zweig überein, aber er stimmt mit dem <code>Err(_)</code>-Muster im zweiten Zweig
überein. Der Unterstrich <code>_</code> ist ein Sammelbehälter; in diesem Beispiel sagen
wir, dass alle <code>Err</code>-Werte übereinstimmen sollen, egal welche Informationen sie
enthalten. Das Programm wird also den Code <code>continue</code> des zweiten Zweigs
ausführen, der das Programm anweist, zur nächsten <code>loop</code>-Iteration zu gehen und
nach einer weiteren Schätzung zu fragen. Effektiv ignoriert das Programm also
alle Fehler, die bei <code>parse</code> auftreten könnten!</p>
<p>Jetzt sollte alles im Programm wie erwartet funktionieren. Lass es uns
versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Rate die Zahl!
Die Geheimzahl ist: 61
Bitte gib deine Schätzung ein.
10
Du hast geschätzt: 10
Zu klein!
Bitte gib deine Schätzung ein.
99
Du hast geschätzt: 99
Zu groß!
Bitte gib deine Schätzung ein.
foo
Bitte gib deine Schätzung ein.
61
Du hast geschätzt: 61
Du hast gewonnen!
</code></pre>
<p>Fantastisch! Mit einem winzigen letzten Feinschliff beenden wir das Ratespiel.
Denke daran, dass das Programm immer noch die Geheimzahl ausgibt. Das hat beim
Testen gut funktioniert, aber es ruiniert das Spiel. Löschen wir das
<code>println!</code>, das die Geheimzahl ausgibt. Codeblock 2-6 zeigt den finalen Code.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Bitte gib deine Schätzung ein.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Du hast geschätzt: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Codeblock 2-6: Vollständiger Code des
Ratespiels</span></p>
<h2><a class="header" href="#zusammenfassung-1" id="zusammenfassung-1">Zusammenfassung</a></h2>
<p>An diesem Punkt hast du das Ratespiel erfolgreich aufgebaut. Herzlichen
Glückwunsch!</p>
<p>Dieses Projekt war eine praktische Möglichkeit, dich mit vielen neuen
Rust-Konzepten vertraut zu machen: <code>let</code>, <code>match</code>, Methoden, assoziierte
Funktionen, das Verwenden von externen Kisten und mehr. In den nächsten
Kapiteln erfährst du mehr über diese Konzepte im Detail. Kapitel 3 behandelt
Konzepte, über die die meisten Programmiersprachen verfügen, z.B. Variablen,
Datentypen und Funktionen, und zeigt, wie man sie in Rust verwendet. Kapitel 4
untersucht die Eigentümerschaft, eine Funktionalität, die Rust von anderen
Sprachen unterscheidet. In Kapitel 5 werden Strukturen (structs) und die
Methodensyntax besprochen und in Kapitel 6 wird die Funktionsweise von
Aufzählungen erläutert.</p>
<h1><a class="header" href="#allgemeine-programmierkonzepte" id="allgemeine-programmierkonzepte">Allgemeine Programmierkonzepte</a></h1>
<p>Dieses Kapitel behandelt Konzepte, die in fast jeder Programmiersprache
vorkommen, und wie sie in Rust funktionieren. Viele Programmiersprachen haben
in ihrem Kern viel gemeinsam. Keines der in diesem Kapitel vorgestellten
Konzepte ist einzigartig für Rust, aber wir werden sie im Kontext von Rust
besprechen und die Konventionen beim Verwenden dieser Konzepte erklären.</p>
<p>Insbesondere lernst du etwas über Variablen, Basistypen (basic types),
Funktionen, Kommentare und Kontrollfluss (control flow). Diese Grundlagen
werden in jedem Rust-Programm vorhanden sein, und wenn du sie früh lernst,
erhältst du eine starke Basis, auf der du aufbauen kannst.</p>
<blockquote>
<h4><a class="header" href="#schlüsselwörter" id="schlüsselwörter">Schlüsselwörter</a></h4>
<p>Die Sprache Rust hat eine Reihe von <em>Schlüsselwörtern</em> (keywords), die wie in
anderen Sprachen nur der Sprache selbst vorbehalten sind. Denke daran, dass
du diese Wörter nicht als Namen von Variablen oder Funktionen verwenden
kannst. Die meisten der Schlüsselwörter haben spezielle Bedeutungen und du
wirst sie für verschiedene Aufgaben in deinen Rust-Programmen verwenden;
einige wenige haben aktuell noch keine Funktionalität, die mit ihnen
verbunden ist, sondern wurden für Funktionalität reserviert, die in Zukunft
zu Rust hinzugefügt werden könnte. Eine Liste der Schlüsselwörter findest du
in <a href="appendix-01-keywords.html">Anhang A</a>.</p>
</blockquote>
<h2><a class="header" href="#variablen-und-veränderlichkeit" id="variablen-und-veränderlichkeit">Variablen und Veränderlichkeit</a></h2>
<p>Wie in Kapitel 2 erwähnt, sind Variablen standardmäßig unveränderlich. Dies ist
einer der vielen Stupser, die Rust dir gibt, um deinen Code so zu schreiben,
dass du die Vorteile von Sicherheit (safety) und einfacher Nebenläufigkeit
(easy concurrency) nutzt, die Rust bietet. Du hast jedoch immer noch die
Möglichkeit, deine Variablen veränderlich (mutable) zu machen. Lass uns
untersuchen, wie und warum Rust dich dazu ermutigt, die Unveränderlichkeit
(immutability) zu bevorzugen, und warum du manchmal vielleicht aussteigen
möchtest.</p>
<p>Wenn eine Variable unveränderlich ist, kannst du deren Wert nicht mehr ändern,
sobald ein Wert gebunden ist. Um dies zu veranschaulichen, lass uns ein neues
Projekt namens <em>variables</em> in deinem <em>projects</em>-Verzeichnis anlegen, indem wir
<code>cargo new variables</code> aufrufen.</p>
<p>Öffne dann in deinem neuen <em>variables</em>-Verzeichnis die Datei <em>src/main.rs</em> und
ersetze dessen Code durch folgenden Code, der sich noch nicht kompilieren
lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 5;
    println!(&quot;Der Wert von x ist: {}&quot;, x);
    x = 6;
    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Speichere und starte das Programm mit <code>cargo run</code>. Du solltest eine
Fehlermeldung erhalten, wie in dieser Ausgabe gezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!(&quot;Der Wert von x ist: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieses Beispiel zeigt, wie der Compiler dir hilft, Fehler in deinen Programmen
zu finden. Auch wenn Kompilierfehler frustrierend sein können, bedeuten sie
nur, dass dein Programm noch nicht sicher das tut, was du willst; sie bedeuten
<em>nicht</em>, dass du kein guter Programmierer bist! Erfahrene Rust-Entwickler
bekommen ebenfalls noch Kompilierfehler.</p>
<p>Die Fehlermeldung <code>cannot assign twice to immutable variable x</code> weist darauf
hin, dass du versucht hast, der unveränderlichen Variablen <code>x</code> einen zweiten
Wert zuzuweisen.</p>
<p>Es ist wichtig, dass wir Fehler zur Kompilierzeit erhalten, wenn wir versuchen,
einen Wert zu ändern, den wir zuvor als unveränderlich bezeichnet haben, weil
genau diese Situation zu Fehlern führen kann. Wenn ein Teil unseres Codes von
der Annahme ausgeht, dass sich ein Wert niemals ändern wird, und ein anderer
Teil unseres Codes diesen Wert ändert, ist es möglich, dass der erste Teil des
Codes nicht das tut, wozu er entwickelt wurde. Die Ursache für diese Art von
Fehler kann im Nachhinein schwer aufzuspüren sein, besonders wenn das zweite
Stück Code den Wert nur <em>gelegentlich</em> ändert.</p>
<p>In Rust garantiert der Compiler, dass sich ein Wert tatsächlich nicht ändert,
wenn du angibst, dass er sich nicht ändern darf. Das bedeutet, dass du beim
Lesen und Schreiben von Code nicht darauf achten musst, wie und wo sich ein
Wert ändern könnte. Dein Code ist somit leichter zu durchdenken.</p>
<p>Aber Veränderlichkeit kann sehr nützlich sein. Variablen sind nur standardmäßig
unveränderlich; wie du es in Kapitel 2 gemacht hast, kannst du sie veränderlich
machen, indem du vor den Variablennamen <code>mut</code> angibst. Zusätzlich zur
Möglichkeit, diesen Wert zu ändern, vermittelt <code>mut</code> den zukünftigen Lesern des
Codes die Absicht, indem es anzeigt, dass andere Teile des Codes den Wert
dieser Variablen ändern werden.</p>
<p>Lass uns zum Beispiel <em>src/main.rs</em> wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;Der Wert von x ist: {}&quot;, x);
    x = 6;
    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Wenn wir das Programm jetzt ausführen, bekommen wir dies:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
Der Wert von x ist: 5
Der Wert von x ist: 6
</code></pre>
<p>Wir dürfen den Wert, an den sich <code>x</code> bindet, von <code>5</code> auf <code>6</code> ändern, wenn <code>mut</code>
verwendet wird. In einigen Fällen wirst du eine Variable veränderlich machen
wollen, weil es den Code bequemer zu schreiben macht, als wenn er nur
unveränderliche Variablen hätte.</p>
<p>Es gibt mehrere Kompromisse, die zusätzlich zur Vermeidung von Fehlern in
Betracht gezogen werden müssen. In Fällen, in denen du beispielsweise große
Datenstrukturen verwendest, kann es schneller sein, eine vorhandene Instanz zu
mutieren, als neu zugewiesene Instanzen zu kopieren und zurückzugeben. Bei
kleineren Datenstrukturen kann es einfacher sein, neue Instanzen zu erstellen
und in einem funktionelleren Programmierstil zu schreiben, sodass eine
geringere Performanz ein lohnender Nachteil sein kann, um diese Klarheit zu
erlangen.</p>
<h3><a class="header" href="#unterschiede-zwischen-variablen-und-konstanten" id="unterschiede-zwischen-variablen-und-konstanten">Unterschiede zwischen Variablen und Konstanten</a></h3>
<p>Den Wert einer Variable nicht ändern zu können, könnte dich an ein anderes
Programmierkonzept erinnert haben, das die meisten anderen Sprachen haben:
<em>Konstanten</em>. Wie unveränderliche Variablen sind Konstanten Werte, die an einen
Namen gebunden sind und sich nicht ändern dürfen, aber es gibt einige
Unterschiede zwischen Konstanten und Variablen.</p>
<p>Erstens ist es dir nicht erlaubt, <code>mut</code> mit Konstanten zu verwenden. Konstanten
sind nicht nur von vornherein unveränderlich – sie sind immer
unveränderlich.</p>
<p>Du deklarierst Konstanten mit dem Schlüsselwort <code>const</code> anstelle des
Schlüsselworts <code>let</code> und der Typ des Wertes <em>muss</em> annotiert werden. Wir sind
dabei, Typen und Typ-Annotationen im nächsten Abschnitt
<a href="ch03-02-data-types.html">„Datentypen“</a> zu behandeln, also mach dir jetzt keine Gedanken
über die Details. Du musst nur wissen, dass du den Typ immer annotieren musst.</p>
<p>Konstanten können in jedem Gültigkeitsbereich deklariert werden, auch im
globalen Gültigkeitsbereich, was sie für Werte nützlich macht, über die viele
Teile des Codes Bescheid wissen müssen.</p>
<p>Der letzte Unterschied besteht darin, dass Konstanten nur auf einen konstanten
Ausdruck gesetzt werden dürfen, nicht auf das Ergebnis eines Funktionsaufrufs
oder einen anderen Wert, der nur zur Laufzeit berechnet werden könnte.</p>
<p>Hier ist ein Beispiel für eine Konstantendeklaration, bei der der Name der
Konstanten <code>MAX_POINTS</code> lautet und ihr Wert auf 100.000 gesetzt ist. (Rusts
Namenskonvention für Konstanten ist, nur Großbuchstaben mit Unterstrichen
zwischen den Wörtern zu verwenden, und Unterstriche können in numerische
Literale eingefügt werden, um die Lesbarkeit zu verbessern.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<p>Konstanten sind für die gesamte Laufzeit eines Programms in dem
Gültigkeitsbereich gültig, in dem sie deklariert wurden. Damit sind sie eine
nützliche Wahl für Werte in deiner Anwendungsdomäne, über die mehrere Teile des
Programms Bescheid wissen müssen, z.B. die maximale Punktzahl, die jeder
Spieler eines Spiels erhalten darf, oder die Lichtgeschwindigkeit.</p>
<p>Das Benennen von hartkodierten Werten, die im gesamten Programm als Konstanten
verwendet werden, ist nützlich, um die Bedeutung dieses Wertes zukünftigen
Code-Betreuern zu vermitteln. Es ist auch hilfreich, nur eine Stelle in deinem
Code zu haben, die du ändern musst, wenn der hartkodierte Wert in Zukunft
aktualisiert werden müsste.</p>
<h3><a class="header" href="#beschatten-shadowing" id="beschatten-shadowing">Beschatten (shadowing)</a></h3>
<p>Wie du in der Anleitung zum Ratespiel im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung
mit der Geheimzahl“</a> in Kapitel 2
gesehen hast, kannst du eine neue Variable mit dem gleichen Namen wie eine
vorherige Variable deklarieren, und die neue Variable beschattet die vorherige
Variable. Die Rust-Entwickler sagen, dass die erste Variable von der zweiten
<em>beschattet</em> (shadowed) wird, was bedeutet, dass der Wert der zweiten Variable
das ist, was erscheint, wenn die Variable verwendet wird. Wir können eine
Variable beschatten, indem wir denselben Variablenamen verwenden und das
Schlüsselwort <code>let</code> wie folgt wiederholen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Dieses Programm bindet zunächst <code>x</code> an den Wert <code>5</code>. Dann beschattet es <code>x</code>,
indem es <code>let x =</code> wiederholt, den ursprünglichen Wert nimmt und <code>1</code> addiert,
sodass der Wert von <code>x</code> dann <code>6</code> ist. Die dritte Anweisung <code>let</code> beschattet
ebenfalls <code>x</code>, indem sie den vorherigen Wert mit <code>2</code> multipliziert, um für <code>x</code>
den Endwert <code>12</code> zu erhalten. Wenn wir dieses Programm ausführen, wird es
folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
Der Wert von x ist: 12
</code></pre>
<p>Beschatten unterscheidet sich vom Markieren einer Variable mit <code>mut</code>, weil wir
einen Kompilierfehler erhalten, wenn wir versehentlich versuchen, diese
Variable neu zuzuweisen, ohne das Schlüsselwort <code>let</code> zu verwenden. Durch das
Verwenden von <code>let</code> können wir einige wenige Transformationen an einem Wert
durchführen, aber die Variable ist unveränderlich, nachdem diese
Transformationen abgeschlossen sind.</p>
<p>Der andere Unterschied zwischen <code>mut</code> und Beschatten besteht darin, dass wir,
weil wir effektiv eine neue Variable erstellen, wenn wir das Schlüsselwort
<code>let</code> erneut verwenden, den Typ des Wertes ändern können, aber denselben Namen
wiederverwenden. Nehmen wir zum Beispiel an, unser Programm bittet einen
Benutzer, durch Eingeben von Leerzeichen zu zeigen, wie viele Leerzeichen er
zwischen irgendeinem Text haben möchte, aber wir möchten diese Eingabe in
Wirklichkeit als Zahl speichern:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaces = &quot;   &quot;;
let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>Dieses Konstrukt ist erlaubt, weil die erste Variable <code>spaces</code> ein String-Typ
ist und die zweite Variable <code>spaces</code>, die eine brandneue Variable ist, die
zufällig den gleichen Namen wie die erste hat, ein Zahlentyp ist. Das
Beschatten erspart es uns also, uns verschiedene Namen auszudenken, z.B.
<code>spaces_str</code> und <code>spaces_num</code>; stattdessen können wir den einfacheren Namen
<code>spaces</code> wiederverwenden. Wenn wir jedoch versuchen, dafür <code>mut</code> zu verwenden,
wie hier gezeigt, erhalten wir einen Kompilierfehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut spaces = &quot;   &quot;;
spaces = spaces.len();

<span class="boring">}
</span></code></pre></pre>
<p>Der Fehler besagt, dass es uns nicht erlaubt ist, den Typ einer Variable zu
mutieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Nachdem wir nun untersucht haben, wie Variablen funktionieren, wollen wir uns
weitere Datentypen ansehen, die sie haben können.</p>
<h2><a class="header" href="#datentypen" id="datentypen">Datentypen</a></h2>
<p>Jeder Wert in Rust ist von einem bestimmten <em>Datentyp</em>, der Rust mitteilt,
welche Art von Daten angegeben wird, damit es weiß, wie es mit diesen Daten
arbeiten soll. Wir werden uns zwei Datentyp-Untermengen ansehen: Skalar und
Verbund.</p>
<p>Denk daran, dass Rust eine <em>statisch typisierte</em> Sprache ist, was bedeutet,
dass es die Typen von allen Variablen zur Kompilierzeit kennen muss. Der
Compiler kann normalerweise auf der Grundlage des Wertes und wie wir ihn
verwenden ableiten, welchen Typ wir verwenden wollen. Wenn mehrere Typen
möglich sind, wie zum Beispiel als wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung
mit der Geheimzahl“</a> eine
Zeichenkette (<code>String</code>) mittels <code>parse</code> zu einem numerischen Typ umwandelten,
müssen wir eine Typ-Annotation ergänzen, wie hier:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir diese Typ-Annotation nicht angeben, zeigt Rust den folgenden Fehler
an, was bedeutet, dass der Compiler mehr Informationen von uns benötigt, um
zu wissen welchen Typ wir verwenden wollen:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Für andere Datentypen wirst du andere Typ-Annotationen sehen.</p>
<h3><a class="header" href="#skalare-typen" id="skalare-typen">Skalare Typen</a></h3>
<p>Ein <em>skalarer</em> Typ stellt einen einzelnen Wert dar. Rust hat vier primäre
skalare Typen: Ganze Zahlen, Fließkommazahlen, boolesche Werte (Wahrheitswerte)
und Zeichen. Du erkennst diese vielleicht aus anderen Programmiersprachen. Lass
uns darüber sprechen, wie sie in Rust funktionieren.</p>
<h4><a class="header" href="#ganzzahl-typen" id="ganzzahl-typen">Ganzzahl-Typen</a></h4>
<p>Eine <em>ganze Zahl</em> ist eine Zahl ohne Bruchteilkomponente. Wir verwendeten eine
ganze Zahl in Kapitel 2, den Typ <code>u32</code>. Diese Typdeklaration gibt an, dass der
Wert, dem sie zugeordnet ist, eine 32 Bit große ganze Zahl ohne Vorzeichen ist
(vorzeichenbehaftete Ganzzahl-Typen beginnen mit <code>i</code> anstatt <code>u</code>). Tabelle 3-1
zeigt die in Rust eingebauten Ganzzahl-Typen. Jede Variante in den Spalten
Vorzeichenbehaftet und Vorzeichenlos (zum Beispiel <code>i16</code>) kann benutzt werden,
um den Typ eines ganzzahligen Wertes zu deklarieren.</p>
<p><span class="caption">Tabelle 3-1: Ganzzahlige Typen in Rust</span></p>
<table><thead><tr><th align="right">Länge</th><th>Vorzeichenbehaftet</th><th>Vorzeichenlos</th></tr></thead><tbody>
<tr><td align="right">8 Bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td align="right">16 Bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td align="right">32 Bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td align="right">64 Bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td align="right">128 Bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td align="right">arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Jede Variante kann entweder vorzeichenbehaftet oder vorzeichenlos sein und hat
eine explizite Größe. <em>Vorzeichenbehaftet</em> (signed) und <em>vorzeichenlos</em>
(unsigned) beziehen sich darauf, ob es möglich ist, dass die Zahl negativ ist
– in anderen Worten, ob die Zahl ein Vorzeichen haben muss
(vorzeichenbehaftet) oder ob sie immer nur positiv sein wird und daher ohne
Vorzeichen dargestellt werden kann (vorzeichenlos). Es ist wie das Schreiben
von Zahlen auf Papier: Wenn das Vorzeichen eine Rolle spielt, wird die Zahl mit
einem Plus- oder Minuszeichen geschrieben; wenn man jedoch davon ausgehen kann,
dass die Zahl positiv ist, wird sie ohne Vorzeichen geschrieben.
Vorzeichenbehaftete Zahlen werden unter Verwendung der
<a href="https://de.wikipedia.org/wiki/Zweierkomplement">Zweierkomplementdarstellung</a>
gespeichert.</p>
<p>Jede vorzeichenbehaftete Variante kann Zahlen von -(2<sup>n - 1</sup>) bis
einschließlich 2<sup>n - 1</sup> - 1 speichern, wobei <em>n</em> die Anzahl an Bits
ist, die diese Variante benutzt. Ein <code>i8</code> kann also Zahlen von -(2<sup>7</sup>)
bis 2<sup>7</sup> - 1 speichern, was -128 bis 127 entspricht. Vorzeichenlose
Varianten können Zahlen von 0 bis 2<sup>n</sup> - 1 speichern, also kann ein
<code>u8</code> Zahlen von 0 bis 2<sup>8</sup> - 1 speichern, was 0 bis 255 entspricht.</p>
<p>Zusätzlich hängen die Typen <code>isize</code> und <code>usize</code> von der Art des Computers ab,
auf dem dein Programm läuft: 64 Bit wenn du dich auf einer 64-Bit-Architektur
befindest und 32 Bit auf einer 32-Bit-Architektur.</p>
<p>Du kannst ganzzahlige Literale in jeder der in Tabelle 3-2 gezeigten Formen
schreiben. Beachte, dass alle Zahlenliterale mit Ausnahme des Byte-Literals
einen Typ-Suffix erlauben, z.B. <code>57u8</code> und <code>_</code> als visuelles Trennzeichen, z.B.
<code>1_000</code>.</p>
<p><span class="caption">Tabelle 3-2: Ganzzahl-Literale in Rust</span></p>
<table><thead><tr><th>Ganzahl-Literal</th><th>Beispiel</th></tr></thead><tbody>
<tr><td>Dezimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Oktal</td><td><code>0o77</code></td></tr>
<tr><td>Binär</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (nur <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>Woher weist du also, welche Ganzzahlart zu verwenden ist? Wenn du dir unsicher
bist, sind Rusts Standards im Allgemeinen eine gute Wahl und ganzzahlige Typen
sind standardmäßig <code>i32</code>: dieser Typ ist im Allgemeinen am schnellsten, selbst
auf 64-Bit-Systemen. Die primäre Situation in der du <code>isize</code> oder <code>usize</code>
benutzen würdest, ist die Indizierung einer Kollektionsart (collection).</p>
<blockquote>
<h5><a class="header" href="#ganzzahlüberlauf" id="ganzzahlüberlauf">Ganzzahlüberlauf</a></h5>
<p>Nehmen wir an, du hast eine Variable vom Typ <code>u8</code>, die Werte zwischen 0 und
255 annehmen kann. Wenn du versuchst, die Variable auf einen Wert außerhalb
dieses Bereiches zu ändern, z.B. auf 256, tritt ein Ganzzahlüberlauf auf.
Rust hat einige interessante Regeln, die dieses Verhalten betreffen. Wenn du
im Fehlersuchmodus (debug mode) kompilierst, fügt Rust Prüfungen auf
Ganzzahlüberläufe ein, was dazu führt, dass dein Programm zur Laufzeit
<em>abbricht</em> (panic), falls dieses Verhalten auftritt. Rust verwendet den
Begriff „panic“, wenn ein Programm durch einen Fehler abgebrochen wird; wir
werden Programmabbrüche im Abschnitt <a href="ch09-01-unrecoverable-errors-with-panic.html">„Nicht behebbare Fehler mit
<code>panic!</code>“</a> in Kapitel 9 näher betrachten.</p>
<p>Wenn du mit dem Schalter <code>--release</code> im Freigabemodus (release mode)
kompilierst, fügt Rust <em>keine</em> Prüfungen auf Ganzzahlüberläufe, die das
Programm abbrechen, ein. Wenn ein Überlauf auftritt, führt Rust stattdessen
einen <em>Zweier-Komplement-Umbruch</em> durch. Kurz gesagt, Werte die größer als
der Maximalwert den der Typ enthalten kann sind, werden umgebrochen zum
kleinsten Wert den der Typ enthalten kann. Im Falle eines <code>u8</code> wird 256 zu 0,
257 zu 1 und so weiter. Das Programm wird nicht abbrechen, aber die Variable
wird wahrscheinlich einen anderen Wert annehmen, als du erwartest. Sich auf
das Verhalten von Ganzzahlüberläufen zu verlassen wird als Fehler angesehen.
Wenn du explizit umbrechen willst, kannst du den Typ <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a>
aus der Standardbibliothek verwenden.</p>
</blockquote>
<h4><a class="header" href="#fließkomma-typen" id="fließkomma-typen">Fließkomma-Typen</a></h4>
<p>Rust hat auch zwei primitive Typen für <em>Fließkommazahlen</em>, das sind Zahlen mit
Dezimalkomma. Die Fließkomma-Typen in Rust sind <code>f32</code> und <code>f64</code>, die 32 Bit
bzw. 64 Bit groß sind. Der Standardtyp ist <code>f64</code>, da er auf modernen CPUs
ungefähr die gleiche Geschwindigkeit wie <code>f32</code> hat, aber eine höhere Präzision
ermöglicht.</p>
<p>Hier ist ein Beispiel, das Fließkommazahlen in Aktion zeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Fließkommazahlen werden nach dem IEEE-754-Standard dargestellt. Der Typ <code>f32</code>
ist eine Fließkommazahl mit einfacher Genauigkeit und <code>f64</code> mit doppelter
Genauigkeit.</p>
<h4><a class="header" href="#numerische-operationen" id="numerische-operationen">Numerische Operationen</a></h4>
<p>Rust unterstützt grundlegende mathematische Operationen, die man bei allen
Zahlentypen erwartet: Addition, Subtraktion, Multiplikation, Division und
Restberechnung. Der folgende Code zeigt, wie du die einzelnen Typen in einer
<code>let</code>-Anweisung verwenden würdest:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraktion
    let difference = 95.5 - 4.3;

    // Multiplikation
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;

    // Restberechnung
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Jeder Ausdruck in diesen Anweisungen verwendet einen mathematischen Operator
und wird zu einem einzelnen Wert ausgewertet, der dann an eine Variable
gebunden wird. <a href="appendix-02-operators.html">Anhang B</a> enthält eine Liste aller Operatoren, die
Rust anbietet.</p>
<h4><a class="header" href="#der-boolesche-typ" id="der-boolesche-typ">Der boolesche Typ</a></h4>
<p>Wie in den meisten anderen Programmiersprachen hat ein boolescher Typ in Rust
zwei mögliche Werte: <code>true</code> (wahr) und <code>false</code> (falsch). Boolesche Werte sind
ein Byte groß. In Rust wird der boolesche Typ mit <code>bool</code> spezifiziert. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // mit expliziter Typ-Annotation
}
</code></pre></pre>
<p>Hauptsächlich werden boolesche Werte in Bedingungen verwendet, z.B. im
<code>if</code>-Ausdruck. Wie <code>if</code>-Ausdrücke in Rust funktionieren werden wir im Abschnitt
<a href="ch03-05-control-flow.html">„Kontrollfluss“</a> erläutern.</p>
<h4><a class="header" href="#der-zeichen-typ" id="der-zeichen-typ">Der Zeichen-Typ</a></h4>
<p>Bislang haben wir nur mit Zahlen gearbeitet, aber Rust unterstützt auch
Buchstaben. Rusts Typ <code>char</code> ist der primitivste alphabetische Typ der Sprache,
der folgende Code zeigt eine Möglichkeit, ihn zu verwenden. (Beachte, dass
<code>char</code>-Literale mit einfachen Anführungszeichen angegeben werden, im Gegensatz
zu Zeichenketten-Literalen, die doppelte Anführungszeichen verwenden.)</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Der Typ <code>char</code> von Rust ist vier Bytes groß und stellt einen Unicode-Skalarwert
dar, was bedeutet, dass er viel mehr als nur ASCII darstellen kann.
Akzentuierte Buchstaben, chinesische, japanische und koreanische Zeichen, Emoji
und Leerzeichen mit Null-Breite sind gültige <code>char</code>-Werte in Rust.
Unicode-Skalarwerte reichen von <code>U+0000</code> bis <code>U+D7FF</code> und von <code>U+E000</code> bis
einschließlich <code>U+10FFFF</code>. Ein „Zeichen“ ist jedoch nicht wirklich ein Konzept
in Unicode, deine menschliche Intuition dafür, was ein „Zeichen“ ist, stimmt
möglicherweise nicht mit dem überein, was ein <code>char</code> in Rust ist. Wir werden
dieses Thema in <a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings)
ablegen“</a> in Kapitel 8 im Detail besprechen.</p>
<h3><a class="header" href="#verbund-typen" id="verbund-typen">Verbund-Typen</a></h3>
<p><em>Verbund-Typen</em> (compound types) können mehrere Werte zu einem Typ gruppieren.
Rust hat zwei primitive Verbund-Typen: Tupel (tuples) und Arrays (arrays).</p>
<h4><a class="header" href="#der-tupel-typ" id="der-tupel-typ">Der Tupel-Typ</a></h4>
<p>Ein Tupel ist eine allgemeine Möglichkeit, eine Reihe von Werten mit einer
Vielzahl von Typen zu einem Verbund-Typ zusammenzufassen. Tupel haben eine
feste Länge: Einmal deklariert, können sie weder wachsen noch schrumpfen.</p>
<p>Wir erzeugen ein Tupel, indem wir eine durch Kommata getrennte Liste von Werten
innerhalb von Klammern schreiben. Jede Position im Tupel hat einen Typ und die
Typen der verschiedenen Werte im Tupel müssen nicht gleich sein. In diesem
Beispiel haben wir optionale Typ-Annotationen angegeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Die Variable <code>tup</code> bindet das gesamte Tupel, da ein Tupel als ein einziges
Verbundelement betrachtet wird. Um die einzelnen Werte aus einem Tupel
herauszubekommen, können wir den Musterabgleich verwenden, um einen Tupelwert
zu destrukturieren, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Dieses Programm erzeugt zunächst ein Tupel und bindet es an die Variable <code>tup</code>.
Dann benutzt es ein Muster mit <code>let</code>, um <code>tup</code> zu nehmen und in drei separate
Variablen <code>x</code>, <code>y</code> und <code>z</code> umzuwandeln. Dies nennt man <em>destrukturieren</em>
(destructuring), weil es das einzelne Tupel in drei Teile zerlegt. Schließlich
gibt das Programm den Wert von <code>y</code> aus, der <code>6.4</code> ist.</p>
<p>Zusätzlich zum Destrukturieren durch Musterabgleich können wir direkt auf ein
Tupelelement zugreifen, indem wir einen Punkt (<code>.</code>) gefolgt vom Index des
Wertes, auf den wir zugreifen wollen, verwenden. Zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Dieses Programm erzeugt ein Tupel <code>x</code> und erstellt dann neue Variablen für
jedes Element, indem es ihre jeweiligen Indizes verwendet. Wie bei den meisten
Programmiersprachen ist der erste Index in einem Tupel 0.</p>
<h4><a class="header" href="#der-array-typ" id="der-array-typ">Der Array-Typ</a></h4>
<p>Eine andere Möglichkeit, eine Kollektion mit mehreren Werten zu haben, ist mit
einem <em>Array</em>. Im Gegensatz zu einem Tupel muss jedes Element eines Arrays den
gleichen Typ haben. Arrays in Rust unterscheiden sich von Arrays in einigen
anderen Sprachen, weil Arrays in Rust eine feste Länge haben, wie Tupel.</p>
<p>In Rust werden die in ein Array eingehenden Werte als kommagetrennte Liste in
eckige Klammern geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Arrays sind nützlich, wenn du deine Daten eher auf dem Stapelspeicher als im
Haldenspeicher abgelegt haben möchtest (auf den Stapelspeicher und den
Haldenspeicher gehen wir in Kapitel 4 näher ein) oder wenn du
sicherstellen willst, dass du immer eine feste Anzahl von Elementen hast. Ein
Array ist jedoch nicht so flexibel wie der Vektortyp. Ein Vektor ist ein
ähnlicher Kollektionstyp, der von der Standardbibliothek zur Verfügung gestellt
wird und der in seiner Größe wachsen oder schrumpfen kann. Wenn du dir nicht
sicher bist, ob du ein Array oder einen Vektor verwenden sollst, solltest du
wahrscheinlich einen Vektor verwenden. In Kapitel 8 werden Vektoren
ausführlicher besprochen.</p>
<p>Ein Beispiel dafür, wann du ein Array statt eines Vektors verwenden möchtest,
ist in einem Programm, das die Namen der Monate des Jahres kennen muss. Es ist
sehr unwahrscheinlich, dass ein solches Programm Monate hinzufügen oder
entfernen muss, sodass du ein Array verwenden kannst, weil du weißt, dass es
immer 12 Elemente enthalten wird:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Du würdest den Typ eines Arrays mit eckigen Klammern schreiben und innerhalb
der Klammern den Typ jedes Elements, ein Semikolon und dann die Anzahl der
Elemente im Array angeben, etwa so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist <code>i32</code> der Typ aller Elemente. Nach dem Semikolon gibt die Zahl <code>5</code> an,
dass das Array fünf Elemente enthält.</p>
<p>Das Angeben eines Array-Typs auf diese Weise ähnelt einer alternativen Syntax
für die Initialisierung eines Arrays: Wenn du ein Array erstellen möchtest, das
für jedes Element den gleichen Wert enthält, kannst du den Anfangswert, gefolgt
von einem Semikolon und dann die Länge des Arrays in eckigen Klammern angeben,
wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>Das Array mit dem Namen <code>a</code> wird <code>5</code> Elemente enthalten, die alle anfänglich
auf den Wert <code>3</code> gesetzt werden. Dies ist dasselbe wie das Schreiben von
<code>let a = [3, 3, 3, 3, 3];</code>, aber in einer prägnanteren Weise.</p>
<h5><a class="header" href="#zugriff-auf-array-elemente" id="zugriff-auf-array-elemente">Zugriff auf Array-Elemente</a></h5>
<p>Ein Array ist ein einzelnes Stück Speicher, das auf den Stapelspeicher gelegt
wird. Du kannst auf Elemente eines Arrays mit Hilfe der Indizierung wie folgt
zugreifen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>In diesem Beispiel erhält die Variable mit dem Namen <code>first</code> den Wert <code>1</code>, weil
das der Wert am Index <code>[0]</code> im Array ist. Die Variable mit dem Namen <code>second</code>
wird den Wert <code>2</code> vom Index <code>[1]</code> im Array erhalten.</p>
<h5><a class="header" href="#ungültiger-array-element-zugriff" id="ungültiger-array-element-zugriff">Ungültiger Array-Element-Zugriff</a></h5>
<p>Was passiert, wenn du versuchst, auf ein Element eines Arrays zuzugreifen, das
sich hinter dem Ende des Arrays befindet? Angenommen, du änderst das Beispiel
in den folgenden Code, der sich kompilieren lässt, aber mit einem Fehler
abbricht, wenn er ausgeführt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;Der Wert von element ist: {}&quot;, element);
}
</code></pre>
<p>Die Ausführung dieses Codes mit <code>cargo run</code> ergibt folgendes Ergebnis:</p>
<pre><code class="language-console">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Das Kompilieren ergab keinen Fehler, aber das Programm führte zu einem
<em>Laufzeitfehler</em> und wurde nicht erfolgreich beendet. Wenn du versuchst, auf
ein Element über die Indizierung zuzugreifen, wird Rust prüfen, ob der von dir
angegebene Index kleiner als die Array-Länge ist. Wenn der Index größer oder
gleich der Array-Länge ist, wird Rust das Programm abbrechen.</p>
<p>Dies ist das erste Beispiel für die Umsetzung der Sicherheitsprinzipien von
Rust. In vielen Low-Level-Sprachen wird diese Art der Überprüfung nicht
durchgeführt und wenn du einen falschen Index angibst, kann auf ungültigen
Speicher zugegriffen werden. Rust schützt dich vor dieser Art von Fehlern,
indem es das Programm sofort beendet, anstatt den Speicherzugriff zuzulassen
und fortzusetzen. In Kapitel 9 wird mehr über die Fehlerbehandlung von Rust
gesprochen.</p>
<h2><a class="header" href="#funktionen" id="funktionen">Funktionen</a></h2>
<p>Funktionen sind im Rust-Code allgegenwärtig. Du hast bereits eine der
wichtigsten Funktionen in der Sprache gesehen: Die Funktion <code>main</code>, die der
Einstiegspunkt vieler Programme ist. Du hast auch das Schlüsselwort <code>fn</code>
gesehen, mit dem du neue Funktionen deklarieren kannst.</p>
<p>Rust-Code verwendet die <em>Schlangenschrift</em>-Stil-Konvention (snake case) für
Funktions- und Variablennamen. In Schlangenschrift sind alle Buchstaben klein
geschrieben und Unterstriche separieren Wörter. Hier ist ein Programm, das eine
Beispiel-Funktionsdefinition enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Eine andere Funktion.&quot;);
}
</code></pre></pre>
<p>Funktionsdefinitionen in Rust beginnen mit <code>fn</code> und haben einen Satz Klammern
nach dem Funktionsnamen. Die geschweiften Klammern teilen dem Compiler mit,
wo der Funktionsrumpf beginnt und endet.</p>
<p>Wir können jede Funktion, die wir definiert haben, aufrufen, indem wir ihren
Namen gefolgt von einem Satz Klammern eingeben. Da <code>another_function</code> im
Programm definiert ist, kann sie von innerhalb der <code>main</code>-Funktion aufgerufen
werden. Beachte, dass wir <code>another_function</code> <em>nach</em> der <code>main</code>-Funktion im
Quellcode definiert haben; wir hätten sie auch vorher definieren können. Rust
interessiert es nicht, wo du deine Funktionen definierst, nur dass sie irgendwo
definiert sind.</p>
<p>Lass uns ein neues Binärprojekt namens „functions“ anfangen, um Funktionen
weiter zu erforschen. Platziere das Beispiel <code>another_function</code> in
<em>src/main.rs</em> und lass es laufen. Du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hallo Welt!
Eine andere Funktion.
</code></pre>
<p>Die Zeilen werden in der Reihenfolge ausgeführt, in der sie in der
<code>main</code>-Funktion erscheinen. Zuerst wird die Nachricht „Hallo Welt!“ ausgegeben
und dann wird <code>another_function</code> aufgerufen und ihre Nachricht ausgegeben.</p>
<h3><a class="header" href="#funktionsparameter" id="funktionsparameter">Funktionsparameter</a></h3>
<p>Funktionen können auch so definiert werden, dass sie <em>Parameter</em> haben, das
sind spezielle Variablen, die Teil der Funktionssignatur sind. Wenn eine
Funktion Parameter hat, kannst du sie mit konkreten Werten für diese Parameter
versehen. Technisch gesehen werden die konkreten Werte <em>Argumente</em> genannt,
aber in lockeren Gesprächen neigen Leute dazu, die Worte <em>Parameter</em> und
<em>Argument</em> entweder für die Variablen in der Definition einer Funktion oder für
die konkreten Werte, die beim Aufruf einer Funktion übergeben werden,
synonym zu verwenden.</p>
<p>Die folgende umgeschriebene Version von <code>another_function</code> zeigt, wie Parameter
in Rust aussehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Versuche, dieses Programm auszuführen; du solltest die folgende Ausgabe
erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die Deklaration <code>another_function</code> hat einen Parameter namens <code>x</code>. Der Typ von
<code>x</code> wird als <code>i32</code> angegeben. Wenn <code>5</code> an <code>another_function</code> übergeben wird,
setzt das Makro <code>println!</code> <code>5</code> an die Stelle, an der sich das Paar geschweifter
Klammern in der Formatierungszeichenkette befand.</p>
<p>In Funktionssignaturen <em>musst</em> du den Typ jedes Parameters deklarieren. Dies
ist eine bewusste Designentscheidung von Rust: Das Erfordernis von
Typ-Annotationen in Funktionsdefinitionen bedeutet, dass der Compiler sie
fast nie an anderer Stelle im Code benötigt, um herauszufinden, was du meinst.</p>
<p>Wenn eine Funktion mehrere Parameter haben soll, trenne die
Parameterdeklarationen mit Kommas, so wie hier:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;Der Wert von x ist: {}&quot;, x);
    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Dieses Beispiel erzeugt eine Funktion mit zwei Parametern, die beide vom Typ
<code>i32</code> sind. Die Funktion gibt dann die Werte in ihren beiden Parametern aus.
Beachte, dass nicht alle Funktionsparameter vom gleichen Typ sein müssen, das
ist in diesem Beispiel nur zufällig so.</p>
<p>Lass uns versuchen, diesen Code auszuführen. Ersetze das Programm, das sich
derzeit in der Datei <em>src/main.rs</em> deines „functions“-Projekts befindet, durch
das vorhergehende Beispiel und führe es mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Der Wert von x ist: 5
Der Wert von y ist: 6
</code></pre>
<p>Da wir die Funktion mit <code>5</code> als Wert für <code>x</code> aufgerufen haben und <code>6</code> als Wert
für <code>y</code> übergeben wird, werden die beiden Zeichenketten mit diesen Werten
ausgegeben.</p>
<h4><a class="header" href="#funktionsrümpfe-enthalten-anweisungen-und-ausdrücke" id="funktionsrümpfe-enthalten-anweisungen-und-ausdrücke">Funktionsrümpfe enthalten Anweisungen und Ausdrücke</a></h4>
<p>Funktionsrümpfe bestehen aus einer Reihe von Anweisungen, die optional mit
einem Ausdruck enden können. Bisher haben wir nur Funktionen ohne einen
endenden Ausdruck behandelt, aber du hast einen Ausdruck als Teil einer
Anweisung gesehen. Da Rust eine auf Ausdrücken basierende Sprache ist, ist dies
eine wichtige Unterscheidung, die es zu verstehen gilt. Andere Sprachen haben
nicht dieselben Unterscheidungen, deshalb wollen wir uns ansehen, was
Anweisungen und Ausdrücke sind und wie sich ihre Unterschiede auf die
Funktionsrümpfe auswirken.</p>
<p>Wir haben tatsächlich bereits Anweisungen und Ausdrücke verwendet.
<em>Anweisungen</em> (statements) sind Instruktionen, die eine Aktion ausführen und
keinen Wert zurückgeben. <em>Ausdrücke</em> (expressions) werten zu einem
resultierenden Wert aus. Sehen wir uns einige Beispiele an.</p>
<p>Eine Variable zu erstellen und ihr mit dem Schlüsselwort <code>let</code> einen Wert
zuzuweisen, ist eine Anweisung. In Codeblock 3-1 ist <code>let y = 6;</code> eine
Anweisung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-1: Eine Funktionsdeklaration <code>main</code>, die eine
Anweisung enthält</span></p>
<p>Auch Funktionsdefinitionen sind Anweisungen; das gesamte vorhergehende Beispiel
ist eine Anweisung für sich.</p>
<p>Anweisungen geben keine Werte zurück. Daher kannst du keine <code>let</code>-Anweisung
einer anderen Variablen zuweisen, wie es der folgende Code versucht; du wirst
einen Fehler erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = (let y = 6);
}

</code></pre></pre>
<p>Wenn du dieses Programm ausführst, wirst du in etwa folgenden Fehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>Die Anweisung <code>let y = 6</code> gibt keinen Wert zurück, also gibt es für <code>x</code> nichts,
woran <code>x</code> gebunden werden kann. Dies unterscheidet sich von dem, was in anderen
Sprachen wie C und Ruby geschieht, wo die Zuweisung den Wert der Zuweisung
zurückgibt. In diesen Sprachen kannst du <code>x = y = 6</code> schreiben und sowohl <code>x</code>
als auch <code>y</code> haben den Wert <code>6</code>; das ist in Rust nicht der Fall.</p>
<p>Ausdrücke werten zu etwas aus und machen den größten Teil des restlichen Codes
aus, den du in Rust schreiben wirst. Betrachte eine einfache mathematische
Operation, z.B. <code>5 + 6</code>, die ein Ausdruck ist, der zum Wert <code>11</code> ausgewertet
wird. Ausdrücke können Teil von Anweisungen sein: In Codeblock 3-1 ist die <code>6</code>
in der Anweisung <code>let y = 6;</code> ein Ausdruck, der den Wert <code>6</code> ergibt. Der Aufruf
einer Funktion ist ein Ausdruck. Der Aufruf eines Makros ist ein Ausdruck. Der
Block <code>{}</code>, den wir zum Erstellen neuer Gültigkeitsbereiche verwenden, ist ein
Ausdruck, zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Der Ausdruck</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>ist ein Block, der in diesem Fall zu <code>4</code> ausgewertet wird. Dieser Wert wird als
Teil der <code>let</code>-Anweisung an <code>y</code> gebunden. Beachte die Zeile <code>x + 1</code> ohne
Semikolon am Ende, was sich von den meisten Zeilen, die du bisher gesehen hast,
unterscheidet. Ausdrücke enthalten keine abschließenden Semikolons. Wenn du ein
Semikolon an das Ende eines Ausdrucks anfügst, machst du daraus eine Anweisung,
die dann keinen Wert zurückgibt.  Behalte dies im Hinterkopf, wenn du als
nächstes die Rückgabewerte von Funktionen und Ausdrücken untersuchst.</p>
<h3><a class="header" href="#funktionen-mit-rückgabewerten" id="funktionen-mit-rückgabewerten">Funktionen mit Rückgabewerten</a></h3>
<p>Funktionen können Werte an den Code zurückgeben, der sie aufruft. Wir benennen
keine Rückgabewerte, aber wir deklarieren ihren Typ nach einem Pfeil (<code>-&gt;</code>). In
Rust ist der Rückgabewert der Funktion gleichbedeutend mit dem Wert des letzten
Ausdrucks im Block des Funktionsrumpfs. Du kannst frühzeitig von einer Funktion
zurückkehren, indem du das Schlüsselwort <code>return</code> verwendest und einen Wert
angibst, aber die meisten Funktionen geben den letzten Ausdruck implizit
zurück. Hier ist ein Beispiel für eine Funktion, die einen Wert zurückgibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Es gibt keine Funktionsaufrufe, Makros oder gar <code>let</code>-Anweisungen in der
<code>five</code>-Funktion – nur die Zahl <code>5</code> selbst. Das ist eine vollkommen
gültige Funktion in Rust. Beachte, dass der Rückgabetyp der Funktion ebenfalls
angegeben ist, mit <code>-&gt; i32</code>. Versuche diesen Code auszuführen; die Ausgabe
sollte wie folgt aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die <code>5</code> in <code>five</code> ist der Rückgabewert der Funktion, weshalb der Rückgabetyp
<code>i32</code> ist. Lass uns dies genauer untersuchen. Es gibt zwei wichtige Teile:
Erstens zeigt die Zeile <code>let x = five();</code>, dass wir den Rückgabewert einer
Funktion verwenden, um eine Variable zu initialisieren. Da die Funktion <code>five</code>
den Wert <code>5</code> zurückgibt, ist diese Zeile die gleiche wie die folgende:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Zweitens hat die Funktion <code>five</code> keine Parameter und definiert den Typ des
Rückgabewertes, aber der Funktionsrumpf ist eine einsame <code>5</code> ohne Semikolon,
weil es ein Ausdruck ist, dessen Wert wir zurückgeben wollen.</p>
<p>Sehen wir uns ein weiteres Beispiel an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Beim Ausführen dieses Codes wird <code>Der Wert von x ist: 6</code> ausgegeben. Wenn wir
aber ein Semikolon an das Ende der Zeile mit <code>x + 1</code> setzen und es von einem
Ausdruck in eine Anweisung ändern, erhalten wir einen Fehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre></pre>
<p>Das Kompilieren dieses Codes führt zum folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Hauptfehlermeldung „nicht übereinstimmende Typen“ („mismatched types“)
offenbart das Kernproblem dieses Codes. Die Definition der Funktion <code>plus_one</code>
besagt, dass sie ein <code>i32</code> zurückgibt, aber Anweisungen werden nicht zu einem
Wert ausgewertet, was durch das leere Tupel <code>()</code> ausgedrückt wird. Daher wird
nichts zurückgegeben, was der Funktionsdefinition widerspricht und zu einem
Fehler führt. In dieser Ausgabe gibt Rust eine Meldung aus, die möglicherweise
helfen kann, dieses Problem zu beheben: Es wird vorgeschlagen, das Semikolon zu
entfernen, was den Fehler beheben würde.</p>
<h2><a class="header" href="#kommentare" id="kommentare">Kommentare</a></h2>
<p>Alle Programmierer bemühen sich, ihren Code leicht verständlich zu machen, aber
manchmal sind zusätzliche Erklärungen angebracht. In solchen Fällen versehen
Entwickler den Quellcode mit <em>Kommentaren</em>, welche der Compiler ignoriert
und für andere Entwickler nützlich sein können.</p>
<p>Dies ist ein einfacher Kommentar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hallo Welt
<span class="boring">}
</span></code></pre></pre>
<p>In Rust beginnt ein gewöhnlicher Kommentar mit zwei Schrägstrichen; der
Kommentar reicht dann bis zum Ende der Zeile. Für Kommentare, die über eine
einzelne Zeile hinausgehen, musst du bei jedem Zeilenanfang <code>//</code> angeben:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hier passiert etwas kompliziertes, so komplex dass wir
// mehrere Kommentarzeilen brauchen! Puh! Hoffentlich erklärt
// dieser Kommentar, was hier passiert.
<span class="boring">}
</span></code></pre></pre>
<p>Kommentare können auch am Ende einer Codezeile stehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // Heute habe ich Glück
}
</code></pre></pre>
<p>Gängiger ist jedoch die Schreibweise mit dem Kommentar über der Codezeile, die
er beschreibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Heute habe ich Glück
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust hat auch Dokumentations-Kommentare, welche im Bereich „Kisten (crate) auf
crates.io veröffentlichen“ in Kapitel 14 erklärt werden.</p>
<h2><a class="header" href="#kontrollfluss" id="kontrollfluss">Kontrollfluss</a></h2>
<p>Die Entscheidung, ob ein Code ausgeführt werden soll oder nicht, je nachdem, ob
eine Bedingung erfüllt ist, und die Entscheidung, einen Code wiederholt
auszuführen, solange eine Bedingung erfüllt ist, sind grundlegende Bausteine in
den meisten Programmiersprachen. Die gebräuchlichsten Konstrukte, mit denen du
den Kontrollfluss von Rust-Code kontrollieren kannst, sind <code>if</code>-Ausdrücke und
Schleifen.</p>
<h3><a class="header" href="#if-ausdrücke" id="if-ausdrücke"><code>if</code>-Ausdrücke</a></h3>
<p>Ein <code>if</code>-Ausdruck erlaubt es dir, deinen Code abhängig von Bedingungen zu
verzweigen. Du gibst eine Bedingung an und legst dann fest: „Wenn diese
Bedingung erfüllt ist, führe diesen Codeblock aus. Wenn die Bedingung nicht
erfüllt ist, darf dieser Codeblock nicht ausgeführt werden.“</p>
<p>Erstelle in deinem <em>projects</em>-Verzeichnis ein neues Projekt namens <em>branches</em>,
um den <code>if</code>-Ausdruck zu erforschen. Gibt in der Datei <em>src/main.rs</em> folgendes
ein:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;Bedingung war wahr&quot;);
    } else {
        println!(&quot;Bedingung war falsch&quot;);
    }
}
</code></pre></pre>
<p>Alle <code>if</code>-Ausdrücke beginnen mit dem Schlüsselwort <code>if</code>, auf das eine Bedingung
folgt. In diesem Fall prüft die Bedingung, ob die Variable <code>number</code> einen Wert
kleiner als 5 hat oder nicht. Der Codeblock, den wir ausführen wollen, wenn die
Bedingung wahr ist, wird unmittelbar nach der Bedingung in geschweifte Klammern
gesetzt. Codeblöcke, die mit den Bedingungen in <code>if</code>-Ausdrücken verbunden sind,
werden manchmal auch als <em>Zweige</em> (arms) bezeichnet, genau wie die Zweige in
<code>match</code>-Ausdrücken, die wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#vergleichen-der-sch%C3%A4tzung-mit-der-geheimzahl">„Vergleichen der Schätzung mit der
Geheimzahl“</a> in Kapitel 2 besprochen
haben.</p>
<p>Optional können wir auch einen <code>else</code>-Ausdruck angeben, was wir hier gemacht
haben, um dem Programm einen alternativen Codeblock zur Ausführung zu geben,
falls die Bedingung als falsch ausgewertet wird. Wenn du keinen <code>else</code>-Ausdruck
angibst und die Bedingung falsch ist, überspringt das Programm einfach den
<code>if</code>-Block und geht zum nächsten Codeteil über.</p>
<p>Versuche, diesen Code auszuführen; du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war wahr
</code></pre>
<p>Lass uns versuchen, den Wert von <code>number</code> in einen Wert zu ändern, der die
Bedingung <code>falsch</code> macht, um zu sehen, was passiert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;Bedingung war wahr&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;Bedingung war falsch&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>Führe das Programm erneut aus und sieh dir die Ausgabe an:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Bedingung war falsch
</code></pre>
<p>Es ist auch erwähnenswert, dass die Bedingung in diesem Code ein <code>bool</code> sein
<em>muss</em>. Wenn die Bedingung kein <code>bool</code> ist, erhalten wir einen Fehler. Versuche
zum Beispiel, den folgenden Code auszuführen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;Zahl war drei&quot;);
    }
}
</code></pre></pre>
<p>Die <code>if</code>-Bedingung wird diesmal zum Wert <code>3</code> ausgewertet und Rust wirft einen
Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler gibt an, dass Rust ein <code>bool</code> erwartet, aber eine ganze Zahl
erhalten hat. Im Gegensatz zu Sprachen wie Ruby und JavaScript wird Rust nicht
automatisch versuchen, nicht-boolsche Typen in ein Boolean zu konvertieren. Du
musst explizit sein und immer <code>if</code> mit einer Booleschen Bedingung versehen.
Wenn wir beispielsweise wollen, dass der <code>if</code>-Codeblock nur ausgeführt wird,
wenn eine Zahl ungleich <code>0</code> ist, können wir den <code>if</code>-Ausdruck wie folgt ändern:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;Zahl war etwas anderes als Null&quot;);
    }
}
</code></pre></pre>
<p>Wenn du diesen Code ausführst, wird <code>Zahl war etwas anderes als Null</code>
ausgegeben.</p>
<h4><a class="header" href="#behandeln-mehrerer-bedingungen-mit-else-if" id="behandeln-mehrerer-bedingungen-mit-else-if">Behandeln mehrerer Bedingungen mit <code>else if</code></a></h4>
<p>Du kannst mehrere Bedingungen verwenden, indem du <code>if</code> und <code>else</code> in einem
<code>else if</code>-Ausdruck kombinierst. Zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;Zahl ist durch 4 teilbar&quot;);
    } else if number % 3 == 0 {
        println!(&quot;Zahl ist durch 3 teilbar&quot;);
    } else if number % 2 == 0 {
        println!(&quot;Zahl ist durch 2 teilbar&quot;);
    } else {
        println!(&quot;Zahl ist nicht durch 4, 3 oder 2 teilbar&quot;);
    }
}
</code></pre></pre>
<p>Dieses Programm hat vier mögliche Wege, die es nehmen kann. Nachdem du es
ausgeführt hast, solltest du folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Zahl ist durch 3 teilbar
</code></pre>
<p>Wenn dieses Programm ausgeführt wird, prüft es der Reihe nach jeden
<code>if</code>-Ausdruck und führt den ersten Block aus, für den die Bedingung wahr ist. 
Beachte, dass, obwohl 6 durch 2 teilbar ist, wir weder die Ausgabe <code>Zahl ist durch 2 teilbar</code> sehen, noch sehen wir den Text <code>Zahl ist nicht durch 4, 3 oder 2 teilbar</code> aus dem <code>else</code>-Block. Das liegt daran, dass Rust den Block nur für
die erste wahre Bedingung ausführt, und wenn es eine findet, prüft es den Rest
nicht mehr.</p>
<p>Das Verwenden von zu vielen <code>else if</code>-Ausdrücken kann deinen Code
unübersichtlich machen. Wenn du also mehr als einen Ausdruck hast, solltest du
deinen Code vielleicht überarbeiten. Kapitel 6 beschreibt ein leistungsfähiges
Rust-Verzweigungskonstrukt namens <code>match</code> für solche Fälle.</p>
<h4><a class="header" href="#verwenden-von-if-in-einer-let-anweisung" id="verwenden-von-if-in-einer-let-anweisung">Verwenden von <code>if</code> in einer <code>let</code>-Anweisung</a></h4>
<p>Weil <code>if</code> ein Ausdruck ist, können wir ihn auf der rechten Seite einer
<code>let</code>-Anweisung verwenden, wie in Codeblock 3-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;Der Wert der Zahl ist: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-2: Zuweisen des Ergebnisses eines
<code>if</code>-Ausdrucks an eine Variable</span></p>
<p>Die Variable <code>number</code> wird an einen Wert gebunden, der auf dem Ergebnis des
<code>if</code>-Ausdrucks basiert. Führe diesen Code aus, um zu sehen, was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Der Wert der Zahl ist: 5
</code></pre>
<p>Denke daran, dass Codeblöcke bis zum letzten Ausdruck in ihnen ausgewertet
werden, und auch Zahlen an sich sind Ausdrücke. In diesem Fall hängt der Wert
des gesamten <code>if</code>-Ausdrucks davon ab, welcher Codeblock ausgeführt wird. Dies
bedeutet, dass die Werte, die potentielle Ergebnisse eines <code>if</code>-Zweigs sein
können, vom gleichen Typ sein müssen; in Codeblock 3-2 waren die Ergebnisse
sowohl des <code>if</code>-Zweigs als auch des <code>else</code>-Zweigs <code>i32</code>-Ganzzahlen. Wenn die
Typen nicht übereinstimmen, wie im folgenden Beispiel, erhalten wir einen
Fehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;sechs&quot; };

    println!(&quot;Der Wert der Zahl ist: {}&quot;, number);
}
</code></pre></pre>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir einen Fehler. Die
<code>if</code>- und <code>else</code>-Zweige haben Werttypen, die inkompatibel sind, und Rust zeigt
genau an, wo das Problem im Programm zu finden ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;sechs&quot; };
  |                                 -          ^^^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Ausdruck im <code>if</code>-Block wird zu einer ganzen Zahl und der Ausdruck im
<code>else</code>-Block zu einer Zeichenkette ausgewertet. Dies wird nicht funktionieren,
da Variablen einen einzigen Typ haben müssen. Rust muss zur Kompilierzeit
definitiv wissen, welchen Typ die Variable <code>number</code> hat, damit es zur
Kompilierzeit überprüfen kann, ob ihr Typ überall gültig ist, wo wir <code>number</code>
verwenden. Rust wäre dazu nicht in der Lage, wenn der Typ von <code>number</code> erst zur
Laufzeit bestimmt würde; der Compiler wäre komplexer und würde weniger
Garantien über den Code geben, wenn er mehrere hypothetische Typen für jede
Variable verfolgen müsste.</p>
<h3><a class="header" href="#wiederholung-mit-schleifen" id="wiederholung-mit-schleifen">Wiederholung mit Schleifen</a></h3>
<p>Es ist oft hilfreich, einen Codeblock mehr als einmal auszuführen. Für diese
Aufgabe stellt Rust mehrere <em>Schleifen</em> (loops) zur Verfügung. Eine Schleife
durchläuft den Code innerhalb des Schleifenrumpfs bis zum Ende und beginnt dann
sofort wieder am Anfang. Um mit Schleifen zu experimentieren, machen wir ein
neues Projekt namens <em>loops</em>.</p>
<p>Rust hat drei Arten von Schleifen: <code>loop</code>, <code>while</code> und <code>for</code>. Probieren wir
jede einzelne aus.</p>
<h4><a class="header" href="#wiederholen-von-code-mit-loop" id="wiederholen-von-code-mit-loop">Wiederholen von Code mit <code>loop</code></a></h4>
<p>Das Schlüsselwort <code>loop</code> weist Rust an, einen Codeblock immer und immer wieder
auszuführen, und zwar für immer oder bis du ihm explizit sagst, dass er
aufhören soll.</p>
<p>Als Beispiel änderst du die Datei <em>src/main.rs</em> in deinem <em>loops</em>-Verzeichnis
so, dass sie wie folgt aussieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;nochmal!&quot;);
    }
}
</code></pre>
<p>Wenn wir dieses Programm ausführen, werden wir sehen, dass es immer und immer
wieder <code>nochmal!</code> ausgibt, bis wir das Programm manuell stoppen. Die meisten
Terminals unterstützen das Tastaturkürzel <span
class="keystroke">Strg+c</span>, um ein Programm zu unterbrechen, das in einer
Endlosschleife feststeckt. Probiere es aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
nochmal!
nochmal!
nochmal!
nochmal!
^Cnochmal!
</code></pre>
<p>Das Symbol <code>^C</code> steht für die Stelle, an der du <span
class="keystroke">Strg+c</span> gedrückt hast. Je nachdem, wo sich der Code in
der Schleife befand, als er das Unterbrechungssignal empfing, siehst du nach
dem <code>^C</code> das Wort <code>nochmal!</code> oder nicht.</p>
<p>Glücklicherweise bietet Rust eine weitere, zuverlässigere Möglichkeit, aus
einer Schleife auszubrechen. Du kannst das Schlüsselwort <code>break</code> innerhalb der
Schleife platzieren, um dem Programm mitzuteilen, wann es die Ausführung der
Schleife beenden soll. Erinnere dich, dass wir dies im Ratespiel im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#beenden-nach-einer-korrekten-sch%C3%A4tzung">„Beenden nach einer korrekten Schätzung“</a> in
Kapitel 2 getan haben, um das Programm zu beenden, wenn der Benutzer das Spiel
durch Erraten der richtigen Zahl gewonnen hat.</p>
<h4><a class="header" href="#rückgabe-von-werten-aus-schleifen" id="rückgabe-von-werten-aus-schleifen">Rückgabe von Werten aus Schleifen</a></h4>
<p>Eine der Verwendungen von <code>loop</code> besteht darin, eine Operation, von der du
weißt, dass sie fehlschlagen könnte, erneut zu versuchen, z.B. um zu prüfen, ob
ein Strang (thread) seine Arbeit abgeschlossen hat. Möglicherweise musst du
jedoch das Ergebnis dieser Operation an den Rest deines Codes weitergeben. Dazu
kannst du den Wert, der zurückgegeben werden soll, hinter dem <code>break</code>-Ausdruck
angeben, den du zum Beenden der Schleife verwendest; dieser Wert wird aus der
Schleife zurückgegeben, sodass du ihn verwenden kannst, wie hier gezeigt:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;Das Ergebnis ist {}&quot;, result);
}
</code></pre></pre>
<p>Vor der Schleife deklarieren wir eine Variable namens <code>counter</code> und
initialisieren sie mit <code>0</code>. Dann deklarieren wir eine Variable namens <code>result</code>,
die den von der Schleife zurückgegebenen Wert enthält. Bei jeder Iteration der
Schleife addieren wir <code>1</code> zur Variable <code>counter</code> und prüfen dann, ob der Zähler
gleich <code>10</code> ist. Wenn dies der Fall ist, verwenden wir das Schlüsselwort
<code>break</code> mit dem Wert <code>counter * 2</code>. Nach der Schleife verwenden wir ein
Semikolon, um die Anweisung zu beenden, die <code>result</code> den Wert zuweist.
Schließlich geben wir den Wert in <code>result</code> aus, der in diesem Fall <code>20</code>
beträgt.</p>
<h4><a class="header" href="#bedingte-schleifen-mit-while" id="bedingte-schleifen-mit-while">Bedingte Schleifen mit <code>while</code></a></h4>
<p>Oft ist es für ein Programm nützlich, eine Bedingung innerhalb einer Schleife
auszuwerten. Solange die Bedingung wahr ist, wird die Schleife durchlaufen.
Wenn die Bedingung nicht mehr wahr ist, ruft das Programm <code>break</code> auf und
stoppt die Schleife. Dieser Schleifentyp könnte durch eine Kombination von
<code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> implementiert werden; du kannst das jetzt in
einem Programm versuchen, wenn du möchtest.</p>
<p>Dieses Muster ist jedoch so weit verbreitet, dass Rust ein eingebautes
Sprachkonstrukt dafür hat, die sogenannte <code>while</code>-Schleife. In Codeblock 3-3
wird <code>while</code> verwendet: Das Programm durchläuft dreimal eine Schleife, in der
es jedes Mal abwärts zählt, und dann nach dem Ende der Schleife eine weitere
Nachricht ausgibt und sich beendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;ABHEBEN!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-3: Verwenden einer <code>while</code>-Schleife, um Code
auszuführen, solange eine Bedingung wahr ist</span></p>
<p>Dieses Konstrukt eliminiert eine Menge von Verschachtelungen, die notwendig
wären, wenn du <code>loop</code>, <code>if</code>, <code>else</code> und <code>break</code> verwenden würdest, und es ist
klarer. Solange eine Bedingung wahr ist, läuft der Code ab; andernfalls wird
die Schleife verlassen.</p>
<h4><a class="header" href="#wiederholen-anhand-einer-kollektion-mit-for" id="wiederholen-anhand-einer-kollektion-mit-for">Wiederholen anhand einer Kollektion mit <code>for</code></a></h4>
<p>Du kannst das <code>while</code>-Konstrukt verwenden, um die Elemente einer Kollektion,
z.B. ein Array, in einer Schleife zu durchlaufen. Sehen wir uns zum Beispiel
Codeblock 3-4 an.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;Der Wert ist: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-4: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>while</code>-Schleife</span></p>
<p>Hier zählt der Code die Elemente im Array aufwärts. Er beginnt bei Index <code>0</code>
und wiederholt bis er den letzten Index im Array erreicht (d.h. wenn
<code>index &lt; 5</code> nicht mehr wahr ist). Wenn du diesen Code ausführst, wird jedes
Element im Array ausgegeben:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
Der Wert ist: 10
Der Wert ist: 20
Der Wert ist: 30
Der Wert ist: 40
Der Wert ist: 50
</code></pre>
<p>Alle fünf Array-Werte erscheinen erwartungsgemäß im Terminal. Wenn <code>index</code> den
Wert <code>5</code> erreicht hat, stoppt die Schleife ihre Ausführung, bevor sie versucht,
einen sechsten Wert aus dem Array zu holen.</p>
<p>Aber dieser Ansatz ist fehleranfällig; wir könnten das Programm zum Abstürzen
bringen, wenn die Indexlänge falsch ist. Er ist auch langsam, weil der Compiler
Laufzeitcode erzeugt, der die bedingte Prüfung für jedes Element bei jeder
Iteration durch die Schleife durchführt.</p>
<p>Als prägnantere Alternative kannst du eine <code>for</code>-Schleife verwenden und für
jedes Element einer Kollektion etwas Code ausführen. Eine <code>for</code>-Schleife sieht
wie der Code in Codeblock 3-5 aus.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;Der Wert ist: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-5: Wiederholen anhand aller Elemente einer
Kollektion unter Verwendung einer <code>for</code>-Schleife</span></p>
<p>Wenn wir diesen Code ausführen, werden wir die gleiche Ausgabe wie in Codeblock
3-4 sehen. Noch wichtiger ist, dass wir jetzt die Sicherheit des Codes erhöht
und die Möglichkeit von Fehlern eliminiert haben, die dadurch entstehen
könnten, dass wir über das Ende des Arrays hinausgehen oder nicht weit genug
gehen und einige Elemente übersehen.</p>
<p>Wenn du beispielsweise im Code in Codeblock 3-4 die Definition des Arrays <code>a</code>
so geändert hast, dass es vier Elemente hat, aber vergessen hast, die Bedingung
auf <code>while index &lt; 4</code> zu aktualisieren, würde der Code abstürzen. Wenn du die
<code>for</code>-Schleife verwendest, brauchst du nicht daran zu denken, irgendeinen
anderen Code zu ändern, wenn du die Anzahl der Werte im Array änderst.</p>
<p>Die Sicherheit und Prägnanz der <code>for</code>-Schleifen machen sie zum am häufigsten
verwendeten Schleifenkonstrukt in Rust. Sogar in Situationen, in denen du einen
Code bestimmt oft laufen lassen willst, wie im Countdown-Beispiel, das in
Codeblock 3-3 eine <code>while</code>-Schleife verwendet hat, würden die meisten
Rust-Entwickler eine <code>for</code>-Schleife verwenden. Der Weg, dies zu erreichen, wäre
das Verwenden eines <code>Range</code>, ein von der Standardbibliothek zur Verfügung
gestellter Typ, der alle Zahlen in Folge generiert, beginnend mit einer Zahl
und endend vor einer anderen Zahl.</p>
<p>So würde der Countdown aussehen, wenn man eine <code>for</code>-Schleife und die Methode
<code>rev</code>, über die wir noch nicht gesprochen haben und die den <code>Range</code> umkehrt,
verwenden würde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;ABHEBEN!!!&quot;);
}
</code></pre></pre>
<p>Dieser Code ist ein bisschen schöner, nicht wahr?</p>
<h2><a class="header" href="#zusammenfassung-2" id="zusammenfassung-2">Zusammenfassung</a></h2>
<p>Du hast es geschafft! Das war ein beachtliches Kapitel: Du lerntest etwas über
Variablen, skalare und zusammengesetzte Datentypen, Funktionen, Kommentare,
<code>if</code>-Ausdrücke und Schleifen! Wenn du mit den in diesem Kapitel besprochenen
Konzepten üben willst, versuche, Programme zu bauen, um Folgendes zu tun:</p>
<ul>
<li>Temperaturen zwischen Fahrenheit und Celsius umrechnen.</li>
<li>Die n-te Fibonacci-Zahl berechnen.</li>
<li>Den Text des Weihnachtsliedes „Die Zwölf Weihnachtstage“ (The Twelve Days of
Christmas) ausgeben und dabei die Wiederholung im Lied nutzen.</li>
</ul>
<p>Wenn du bereit bist, weiterzumachen, werden wir in Rust über ein Konzept
sprechen, das es in anderen Programmiersprachen üblicherweise <em>nicht</em> gibt:
Eigentümerschaft (ownership).</p>
<h1><a class="header" href="#eigentümerschaft-ownership-verstehen" id="eigentümerschaft-ownership-verstehen">Eigentümerschaft (ownership) verstehen</a></h1>
<p>Eigentümerschaft (ownership) ist das wichtigste Alleinstellungsmerkmal von
Rust, und sie ermöglicht es Rust, Speichersicherheitsgarantien ohne Einsatz
einer automatischen Speicherbereinigung (garbage collector) zu geben. Deshalb
ist es wichtig zu verstehen, wie Eigentümerschaft in Rust funktioniert. In
diesem Kapitel werden wir uns neben der Eigentümerschaft weitere diesbezügliche
Funktionalitäten ansehen: Ausleihen (borrowing), Anteilstypen (slices) und wie
Rust Daten im Speicher anordnet.</p>
<h2><a class="header" href="#was-ist-eigentümerschaft-ownership" id="was-ist-eigentümerschaft-ownership">Was ist Eigentümerschaft (ownership)?</a></h2>
<p>Die zentrale Funktionalität von Rust ist <em>Eigentümerschaft</em> (ownership). Obwohl
diese Funktionalität einfach zu erklären ist, hat sie weitgehende Auswirkungen
auf den Rest der Sprache.</p>
<p>Alle Programme müssen den Arbeitsspeicher eines Rechners verwalten, während sie
ausgeführt werden. Einige Sprachen verfügen über eine automatische
Speicherbereinigung, die während der Programmausführung ständig nach nicht mehr
genutztem Speicher sucht. Bei anderen Sprachen muss der Programmierer selbst
den Speicher explizit reservieren und freigeben. Rust verwendet einen dritten
Ansatz: Der Speicher wird durch ein System aus Eigentümerschaft und einer Reihe
von Regeln verwaltet, die der Compiler zur Kompilierzeit überprüft. Keine
der Eigentümerschaftsfunktionalitäten verlangsamt dein Programm, während es
läuft.</p>
<p>Da die Eigentümerschaft für viele Programmierer ein neues Konzept ist, braucht
es etwas Zeit, sich daran zu gewöhnen. Die gute Nachricht ist, je mehr
Erfahrung du mit Rust und den Regeln der Eigentümerschaft gesammelt hast, desto
mehr kannst du auf natürliche Weise Code entwickeln, der sicher und effizient
ist. Bleib dran!</p>
<p>Wenn du Eigentümerschaft verstehst, hast du eine solide Grundlage, um die
Funktionalitäten zu verstehen, die Rust einzigartig machen. In diesem Kapitel
lernst du Eigentümerschaft kennen, indem du einige Beispiele durcharbeitest,
die sich auf eine sehr verbreitete Datenstruktur konzentrieren: Zeichenketten
(strings).</p>
<blockquote>
<h3><a class="header" href="#stapelspeicher-stack-und-haldenspeicher-heap" id="stapelspeicher-stack-und-haldenspeicher-heap">Stapelspeicher (stack) und Haldenspeicher (heap)</a></h3>
<p>In vielen Programmiersprachen musst du nicht sehr oft über Stapelspeicher und
Haldenspeicher nachdenken. Aber in einer Systemprogrammiersprache wie
Rust hat die Frage, ob ein Wert auf dem Stapelspeicher oder im Haldenspeicher
liegt, einen größeren Einfluss darauf, wie sich die Sprache verhält
und warum du bestimmte Entscheidungen treffen musst. Teile der
Eigentümerschaft werden später in diesem Kapitel in Bezug auf den
Stapelspeicher und den Haldenspeicher beschrieben, daher hier eine
kurze Erklärung zur Vorbereitung.</p>
<p>Sowohl Stapelspeicher als auch Haldenspeicher sind Teile des
Arbeitsspeichers, die deinem Code zur Laufzeit zur Verfügung stehen, aber sie
sind unterschiedlich strukturiert. Der Stapelspeicher speichert Werte in der
Reihenfolge, in der er sie erhält, und entfernt die Werte in umgekehrter
Reihenfolge. Dies wird als <em>zuletzt herein, zuerst hinaus</em> (last in, first
out) bezeichnet. Denke an einen Stapel Teller: Wenn du weitere Teller
hinzufügst, legst du sie auf den Stapel, und wenn du einen Teller benötigst,
nimmst du einen von oben. Das Hinzufügen oder Entfernen von Tellern aus der
Mitte oder von unten würde nicht so gut funktionieren! Das Hinzufügen von
Daten nennt man <em>auf den Stapel legen</em>, und das Entfernen von Daten nennt man
<em>vom Stapel nehmen</em>.</p>
<p>Alle im Stapelspeicher gespeicherten Daten müssen eine bekannte, feste Größe
haben. Daten mit einer zur Kompilierzeit unbekannten Größe oder einer Größe,
die sich ändern könnte, müssen stattdessen im Haldenspeicher
gespeichert werden. Der Haldenspeicher ist weniger organisiert: Wenn du
Daten in den Haldenspeicher legst, forderst du eine bestimmte Menge an
Speicherplatz an. Der Speicher-Allokator (memory allocator) sucht eine leere
Stelle im Haldenspeicher, die groß genug ist, markiert sie als in
Benutzung und gibt einen <em>Zeiger</em> (pointer) zurück, der die Adresse dieser
Stelle ist. Dieser Vorgang wird als <em>Allokieren im Haldenspeicher</em>
bezeichnet und manchmal mit <em>Allokieren</em> abgekürzt. Das Legen von Werten auf
den Stapelspeicher gilt nicht als Allokieren. Da es sich beim Zeiger um eine
bekannte, feste Größe handelt, kannst du den Zeiger auf den Stapelspeicher
legen, aber wenn du die eigentlichen Daten benötigst, musst du dem Zeiger
folgen.</p>
<p>Stell dir vor, du sitzt in einem Restaurant. Wenn du hineingehst, gibst du
die Anzahl der Personen deiner Gruppe an, und das Personal findet einen
leeren Tisch, der groß genug ist, und führt euch dorthin. Wenn jemand aus
deiner Gruppe zu spät kommt, kann er fragen, wo ihr Platz genommen habt, um
euch zu finden.</p>
<p>Das Legen auf den Stapelspeicher ist schneller als das Allokieren im
Haldenspeicher, da der Speicher-Allokator nie nach Platz zum Speichern
neuer Daten suchen muss; dieser Ort ist immer ganz oben auf dem Stapel. Im
Vergleich dazu erfordert das Allokieren von Speicherplatz im dynamischen
Speicher mehr Arbeit, da der Speicher-Allokator zunächst einen ausreichend
großen Platz für die Daten finden und dann Buch führen muss, um die nächste
Allokation vorzubereiten.</p>
<p>Der Zugriff auf Daten im Haldenspeicher ist langsamer als der Zugriff
auf Daten auf dem Stapelspeicher, da du einem Zeiger folgen musst, um dorthin
zu gelangen. Heutige Prozessoren sind schneller, wenn sie weniger im Speicher
herumspringen. Um die Analogie fortzusetzen, betrachte einen Kellner in einem
Restaurant, der an vielen Tischen Bestellungen aufnimmt. Es ist am
effizientesten, alle Bestellungen an einem Tisch aufzunehmen, bevor man zum
nächsten Tisch weitergeht. Eine Bestellung von Tisch A, dann eine Bestellung
von Tisch B, dann wieder eine von A und dann wieder eine von B aufzunehmen,
wäre ein viel langsamerer Vorgang. Umgekehrt kann ein Prozessor seine Arbeit
besser erledigen, wenn er mit Daten arbeitet, die nahe beieinander liegen
(wie sie auf dem Stapelspeicher liegen) und nicht weiter voneinander entfernt
(wie sie im Haldenspeicher liegen können). Das Allokieren einer großen
Menge an Platz im Haldenspeicher kann ebenfalls Zeit in Anspruch
nehmen.</p>
<p>Wenn dein Code eine Funktion aufruft, werden die an die Funktion übergebenen
Werte (einschließlich potentieller Zeiger auf Daten im Haldenspeicher)
und die lokalen Variablen der Funktion auf den Stapelspeicher gelegt. Wenn
die Funktion beendet ist, werden diese Werte vom Stapelspeicher genommen.</p>
<p>Das Nachverfolgen, welche Codeteile welche Daten im Haldenspeicher
verwenden, das Minimieren der Menge an doppelten Daten im Haldenspeicher
und das Aufräumen ungenutzter Daten im Haldenspeicher, damit
dir der Speicherplatz nicht ausgeht, sind alles Probleme, die durch
Eigentümerschaft gelöst werden. Wenn du Eigentümerschaft einmal verstanden
hast, brauchst du nicht mehr so oft über Stapelspeicher und Haldenspeicher 
nachzudenken. Aber zu wissen, dass die Verwaltung von Haldenspeicher-Daten
der Grund für Eigentümerschaft ist, kann helfen zu erklären,
warum es so funktioniert, wie es funktioniert.</p>
</blockquote>
<h3><a class="header" href="#eigentumsregeln" id="eigentumsregeln">Eigentumsregeln</a></h3>
<p>Lass uns zunächst einen Blick auf die Eigentumsregeln (ownership rules) werfen.
Behalte diese Regeln im Hinterkopf, während wir veranschaulichende Beispiele
durcharbeiten:</p>
<ul>
<li>Jeder Wert in Rust hat eine Variable, die als sein <em>Eigentümer</em> bezeichnet
wird.</li>
<li>Es kann immer nur einen Eigentümer zur gleichen Zeit geben.</li>
<li>Wenn der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert gelöscht.</li>
</ul>
<h3><a class="header" href="#gültigkeitsbereich-scope-einer-variable" id="gültigkeitsbereich-scope-einer-variable">Gültigkeitsbereich (scope) einer Variable</a></h3>
<p>Wir sind bereits in Kapitel 2 ein Beispiel für ein Rust-Programm durchgegangen.
Da wir nun über die grundlegende Syntax hinausgehen, werden wir nicht mehr den
gesamten <code>fn main() {</code>-Code in die Beispiele aufnehmen. Wenn du also
weitermachst, musst du die folgenden Beispiele manuell in eine Funktion <code>main</code>
einfügen. Folglich werden unsere Beispiele etwas prägnanter sein, damit wir uns
auf die eigentlichen Details konzentrieren können, anstatt auch den Code darum
herum betrachten zu müssen.</p>
<p>Als erstes Beispiel zu Eigentümerschaft werden wir uns den <em>Gültigkeitsbereich</em>
(scope) einiger Variablen ansehen. Der Gültigkeitsbereich ist der Bereich
innerhalb eines Programms, in dem ein Element gültig ist. Nehmen wir an, wir
haben eine Variable, die so aussieht:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Die Variable <code>s</code> bezieht sich auf ein Zeichenkettenliteral, wobei der Wert der
Zeichenkette fest in den Text unseres Programms kodiert ist. Die Variable ist
ab der Stelle, an der sie deklariert wurde, bis zum Ende des aktuellen
<em>Gültigkeitsbereichs</em> gültig. Codeblock 4-1 enthält Kommentare mit Anmerkungen,
wo die Variable <code>s</code> gültig ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s ist hier nicht gültig, es wurde noch nicht deklariert
    let s = &quot;Hallo&quot;;   // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                      // dieser Gültigkeitsbereich ist nun vorbei,
                       // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-1: Eine Variable und der Bereich, in dem sie
gültig ist</span></p>
<p>Mit anderen Worten, es gibt hier zwei wichtige Zeitpunkte:</p>
<ul>
<li>Wenn <code>s</code> <em>in den Gültigkeitsbereich</em> kommt, ist es gültig.</li>
<li>Es bleibt gültig, bis es <em>den Gültigkeitsbereich</em> verlässt.</li>
</ul>
<p>An diesem Punkt ist die Beziehung zwischen Gültigkeitsbereichen und wann
Variablen gültig sind ähnlich zu anderen Programmiersprachen. Nun werden wir
auf diesem Verständnis aufbauen, indem wir den Typ <code>String</code> einführen.</p>
<h3><a class="header" href="#der-typ-string" id="der-typ-string">Der Typ <code>String</code></a></h3>
<p>Um die Eigentumsregeln zu veranschaulichen, benötigen wir einen Datentyp, der
komplexer ist als die, die wir im Abschnitt <a href="ch03-02-data-types.html">„Datentypen“</a> in
Kapitel 3 behandelt haben. Die zuvor behandelten Typen werden alle auf den
Stapelspeicher gelegt und vom Stapelspeicher entfernt, wenn ihr
Gültigkeitsbereich beendet ist, aber wir wollen uns Daten ansehen, die im
Haldenspeicher gespeichert sind, und untersuchen, woher Rust weiß, wann
es diese Daten aufräumen muss.</p>
<p>Wir werden hier <code>String</code> als Beispiel nehmen und uns auf die Teile von <code>String</code>
konzentrieren, die sich auf die Eigentümerschaft beziehen. Diese Aspekte gelten
auch für andere komplexe Datentypen, unabhängig davon, ob sie von der
Standardbibliothek bereitgestellt oder von dir erstellt wurden. Wir werden
<code>String</code> in Kapitel 8 eingehender behandeln.</p>
<p>Wir haben bereits Zeichenkettenliterale gesehen, bei denen ein
Zeichenkettenwert fest in unserem Programm kodiert ist. Zeichenkettenliterale
sind praktisch, aber sie eignen sich nicht für jede Situation, in der wir Text
verwenden möchten. Ein Grund dafür ist, dass sie unveränderlich sind. Ein
anderer Grund ist, dass nicht jeder Zeichenkettenwert bekannt ist, wenn wir
unseren Code schreiben: Was ist zum Beispiel, wenn wir Benutzereingaben
entgegennehmen und speichern wollen? Für diese Situationen hat Rust einen
zweiten Zeichenkettentyp: <code>String</code>. Dieser Typ wird im Haldenspeicher
allokiert und kann so eine Textmenge speichern, die uns zur Kompilierzeit
unbekannt ist. Du kannst einen <code>String</code> aus einem Zeichenkettenliteral
erzeugen, indem du die Funktion <code>from</code> wie folgt verwendest:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Der doppelte Doppelpunkt (<code>::</code>) ist ein Operator, der es uns erlaubt, diese
spezielle Funktion <code>from</code> mit dem Namensraum des <code>String</code>-Typs zu benennen,
anstatt einen Namen wie <code>string_from</code> zu verwenden. Wir werden diese Syntax im
Abschnitt <a href="ch05-03-method-syntax.html">„Methodensyntax“</a> in Kapitel 5 näher betrachten, und
wenn wir in Kapitel 7 unter <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> über den Namensraum mit Modulen sprechen. </p>
<p>Diese Art von Zeichenkette kann <em>verändert</em> werden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

s.push_str(&quot; Welt!&quot;); // push_str() hängt ein Literal an eine Zeichenfolge an

println!(&quot;{}&quot;, s);    // Gibt `Hallo Welt!` aus
<span class="boring">}
</span></code></pre></pre>
<p>Was ist hier nun der Unterschied? Warum kann <code>String</code> verändert werden,
Literale jedoch nicht? Der Unterschied liegt darin, wie diese beiden Typen mit
dem Arbeitsspeicher umgehen.</p>
<h3><a class="header" href="#speicher-und-allokation" id="speicher-und-allokation">Speicher und Allokation</a></h3>
<p>Im Falle eines Zeichenkettenliterals kennen wir den Inhalt zum Zeitpunkt der
Kompilierung, sodass der Text direkt in die endgültige ausführbare Datei fest
kodiert wird. Aus diesem Grund sind Zeichenkettenliterale schnell und
effizient. Allerdings ergeben sich diese Eigenschaften nur aus der
Unveränderlichkeit des Zeichenkettenliterals. Leider können wir nicht für jedes
Stück Text, dessen Größe zum Zeitpunkt der Kompilierung unbekannt ist und
dessen Größe sich während der Ausführung des Programms ändern könnte, einen
Speicherblock in die Binärdatei packen.</p>
<p>Um mit dem Typ <code>String</code> einen veränderlichen, größenänderbaren Textabschnitt zu
unterstützen, müssen wir Speicher im Haldenspeicher allokieren, dessen
Größe zur Kompilierzeit unbekannt ist. Dies bedeutet:</p>
<ul>
<li>Der Speicher muss zur Laufzeit vom Speicher-Allokator angefordert werden.</li>
<li>Wir brauchen eine Möglichkeit, diesen Speicher an den Speicher-Allokator
zurückzugeben, wenn wir mit unserem <code>String</code> fertig sind.</li>
</ul>
<p>Der erste Teil wird von uns erledigt: Wenn wir <code>String::from</code> aufrufen, fordert
seine Implementierung den Speicher an, den sie benötigt. Dies ist in
Programmiersprachen ziemlich einheitlich.</p>
<p>Der zweite Teil ist jedoch anders. In Sprachen mit einer <em>automatischen
Speicherbereinigung</em> (garbage collector, GC) behält der GC den Überblick und
räumt Speicherplatz, der nicht mehr verwendet wird, auf; wir brauchen nicht
darüber nachzudenken. Ohne einen GC liegt es in unserer Verantwortung, zu
erkennen, wann Speicherplatz nicht mehr benutzt wird, und Code aufzurufen, der
ihn explizit zurückgibt, so wie wir es beim Anfordern auch getan haben. Dies
korrekt zu tun, war in der Vergangenheit ein schwieriges Programmierproblem.
Wenn wir es vergessen, verschwenden wir Speicher. Wenn wir es zu früh machen,
haben wir eine ungültige Variable. Wenn wir es zweimal machen, ist das auch ein
Fehler. Wir müssen eine <em>Allokierung</em> mit genau einer <em>Freigabe</em> paaren.</p>
<p>Rust geht einen anderen Weg: Der Speicher wird automatisch zurückgegeben,
sobald die Variable, die ihn besitzt, den Gültigkeitsbereich verlässt. Hier ist
eine Variante unseres Gültigkeitsbereich-Beispiels aus Codeblock 4-1, bei der
ein <code>String</code> anstelle eines Zeichenkettenliterals verwendet wird:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;Hallo&quot;); // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                                  // dieser Gültigkeitsbereich ist nun vorbei,
                                   // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p>Es gibt eine natürliche Stelle, an der wir den Speicher, den unser <code>String</code>
benötigt, an den Speicher-Allokator zurückgeben können: Wenn <code>s</code> den
Gültigkeitsbereich verlässt. Wenn eine Variable den Gültigkeitsbereich
verlässt, ruft Rust für uns eine spezielle Funktion auf: Diese Funktion heißt
<code>drop</code> und an dieser Stelle kann der Autor von <code>String</code> Code einfügen, um den
Speicher zurückzugeben. Rust ruft <code>drop</code> automatisch an der schließenden
geschweiften Klammer auf.</p>
<blockquote>
<p>Hinweis: In C++ wird dieses Muster der Freigabe von Ressourcen am Ende der
Lebensdauer eines Elements manchmal als <em>Ressourcenbelegung ist
Initialisierung</em> (resource acquisition is initialization, RAII) bezeichnet.
Die Funktion <code>drop</code> in Rust wird dir vertraut vorkommen, wenn du bereits
RAII-Muster verwendet hast.</p>
</blockquote>
<p>Dieses Muster hat einen tiefgreifenden Einfluss auf die Art und Weise, wie
Rust-Code geschrieben wird. Es mag im Moment einfach erscheinen, aber das
Verhalten von Code kann in komplizierteren Situationen unerwartet sein, wenn
wir wollen, dass mehrere Variablen Daten verwenden, die wir im dynamischen
Speicher allokiert haben. Lass uns jetzt einige dieser Situationen untersuchen.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-verschieben-move" id="wege-wie-variablen-und-daten-interagieren-verschieben-move">Wege, wie Variablen und Daten interagieren: Verschieben (move)</a></h4>
<p>Mehrere Variablen können in Rust auf unterschiedliche Weise mit denselben Daten
interagieren. Betrachten wir ein Beispiel mit einer ganzen Zahl in Codeblock
4-2.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-2: Zuweisen des ganzzahligen Wertes der
Variablen <code>x</code> an <code>y</code></span></p>
<p>Wir können wahrscheinlich erahnen, was das bewirkt: „Binde den Wert <code>5</code> an <code>x</code>;
dann erstelle eine Kopie des Wertes in <code>x</code> und binde ihn an <code>y</code>.“ Wir haben
jetzt zwei Variablen <code>x</code> und <code>y</code> und beide sind gleich <code>5</code>. Das ist in der Tat
der Fall, denn ganze Zahlen sind einfache Werte mit einer bekannten, festen
Größe, und diese beiden Werte <code>5</code> werden auf den Stapelspeicher gelegt.</p>
<p>Schauen wir uns nun die <code>String</code>-Variante an:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Dieser sieht dem vorherigen Code sehr ähnlich, sodass wir annehmen könnten,
dass die Funktionsweise die gleiche wäre: Das heißt, die zweite Zeile würde
eine Kopie des Wertes in <code>s1</code> erstellen und sie an <code>s2</code> binden. Aber das ist
nicht ganz das, was passiert.</p>
<p>Betrachte Abbildung 4-1, um zu sehen, was mit dem <code>String</code> unter der Haube
geschieht. Ein <code>String</code> besteht aus drei Teilen, die auf der linken Seite
dargestellt sind: Einem Zeiger auf den Speicherbereich, der den Inhalt der
Zeichenkette enthält, die Länge und die Kapazität. Dieser Datenblock wird auf
dem Stapelspeicher gespeichert. Auf der rechten Seite ist der Speicherbereich
im Haldenspeicher, der den Inhalt enthält.</p>
<img alt="String im Arbeitsspeicher" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-1: Speicherdarstellung eines <code>String</code> mit dem
Wert „Hallo“, gebunden an <code>s1</code></span></p>
<p>Die Länge gibt an, wie viel Speicherplatz in Bytes der Inhalt der Zeichenkette
derzeit belegt. Die Kapazität ist die Gesamtmenge des Speichers in Bytes, die
der <code>String</code> vom Speicher-Allokator erhalten hat. Der Unterschied zwischen
Länge und Kapazität ist von Bedeutung, aber nicht in diesem Zusammenhang,
deshalb ist es im Moment in Ordnung, die Kapazität zu ignorieren.</p>
<p>Wenn wir <code>s1</code> an <code>s2</code> zuweisen, werden die <code>String</code>-Daten kopiert, d.h. wir
kopieren den Zeiger, die Länge und die Kapazität, die sich auf dem
Stapelspeicher befinden. Wir kopieren nicht die Daten im Haldenspeicher,
auf die sich der Zeiger bezieht. Die Speicherdarstellung sieht also wie in
Abbildung 4-2 aus.</p>
<img alt="s1 und s2 zeigen auf denselben Wert" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-2: Speicherdarstellung der Variable <code>s2</code>, die
eine Kopie des Zeigers, der Länge und der Kapazität von <code>s1</code> hat</span></p>
<p>Die Darstellung sieht <em>nicht</em> wie Abbildung 4-3 aus, so wie der Speicher
aussehen würde, wenn Rust stattdessen auch die Daten im Haldenspeicher
kopieren würde. Würde Rust dies tun, könnte die Operation <code>s2 = s1</code> bei großen
Datenmengen im Haldenspeicher sehr teuer hinsichtlich der
Laufzeitperformanz werden.</p>
<img alt="s1 und s2 als vollständige Kopien" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-3: Eine weitere Möglichkeit für das, was
<code>s2 = s1</code> tun könnte, falls Rust auch die Daten im Haldenspeicher
kopieren würde</span></p>
<p>Vorhin sagten wir, dass Rust automatisch die Funktion <code>drop</code> aufruft und den
Haldenspeicher für diese Variable säubert, wenn eine Variable den
Gültigkeitsbereich verlässt. Abbildung 4-2 zeigt jedoch, dass beide Datenzeiger
auf dieselbe Stelle zeigen. Das ist ein Problem: Wenn <code>s2</code> und <code>s1</code> den
Gültigkeitsbereich verlassen, werden beide versuchen, den gleichen Speicher
freizugeben.</p>
<p>Dies wird als <em>doppelter Freigabefehler</em> (double free error) bezeichnet und ist
einer der Speichersicherheitsfehler, die wir zuvor erwähnt haben. Das
zweimalige Freigeben des Speichers kann zu einer Speicherverfälschung führen,
was potenziell zu Sicherheitslücken führen kann.</p>
<p>Um Speichersicherheit zu gewährleisten, gibt es noch ein weiteres Detail, was
Rust in dieser Situation macht. Anstatt zu versuchen, den allokierten Speicher
zu kopieren, sieht Rust <code>s1</code> als nicht mehr gültig an, und deshalb muss Rust
nichts freigeben, wenn <code>s1</code> den Gültigkeitsbereich verlässt. Schau dir an, was
passiert, wenn du versuchst, <code>s1</code> zu benutzen, nachdem <code>s2</code> erstellt wurde; es
wird nicht funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;

println!(&quot;{} Welt!&quot;, s1);
<span class="boring">}
</span></code></pre></pre>
<p>Du erhältst eine Fehlermeldung wie diese, wodurch Rust dich daran hindert, die
ungültige Referenz zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;Hallo&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{} Welt!&quot;, s1);
  |                          ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wenn du beim Arbeiten mit anderen Sprachen schon mal die Begriffe <em>flache
Kopie</em> (shallow copy) und <em>tiefe Kopie</em> (deep copy) gehört hast, hört sich das
Konzept des Kopierens des Zeigers, der Länge und der Kapazität ohne Kopieren
der Daten nach einer flachen Kopie an. Aber weil Rust auch die erste Variable
ungültig macht, wird es nicht als flache Kopie, sondern als <em>Verschieben</em>
(move) bezeichnet. In diesem Beispiel würden wir sagen, dass <code>s1</code> in <code>s2</code>
<em>verschoben</em> wurde. Was tatsächlich geschieht, ist in Abbildung 4-4
dargestellt.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-4: Speicherdarstellung, nachdem <code>s1</code> ungültig
gemacht wurde</span></p>
<p>Damit ist unser Problem gelöst! Da nur <code>s2</code> gültig ist, wenn es den
Gültigkeitsbereich verlässt, wird es allein den Speicher freigeben, und wir
sind fertig.</p>
<p>Darüber hinaus gibt es eine Entwurfsentscheidung, die damit impliziert ist:
Rust wird niemals automatisch „tiefe“ Kopien deiner Daten erstellen. Daher kann
man davon ausgehen, dass jedes <em>automatische</em> Kopieren im Hinblick auf die
Laufzeitperformanz kostengünstig ist.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-klonen-clone" id="wege-wie-variablen-und-daten-interagieren-klonen-clone">Wege, wie Variablen und Daten interagieren: Klonen (clone)</a></h4>
<p>Wenn wir die Daten von <code>String</code> im Haldenspeicher <em>tief</em> kopieren wollen,
nicht nur die Stapelspeicher-Daten, können wir eine gängige Methode namens
<code>clone</code> verwenden. Wir werden die Methodensyntax in Kapitel 5 besprechen, aber
da Methoden eine gängige Funktionalität vieler Programmiersprachen sind, hast
du sie wahrscheinlich schon einmal gesehen.</p>
<p>Hier ist ein Beispiel für die Methode <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Das funktioniert sehr gut und erzeugt explizit das in Abbildung 4-3 gezeigte
Verhalten, bei dem die Daten im Haldenspeicher <em>kopiert</em> werden.</p>
<p>Wenn du einen Aufruf von <code>clone</code> siehst, weißt du, dass irgendein beliebiger
Code ausgeführt wird und dass dieser Code teuer sein könnte. Es ist ein
visueller Indikator dafür, dass etwas anderes vor sich geht.</p>
<h4><a class="header" href="#nur-stapelspeicher-daten-kopieren-copy" id="nur-stapelspeicher-daten-kopieren-copy">Nur Stapelspeicher-Daten: Kopieren (copy)</a></h4>
<p>Es gibt noch einen weiteren Kniff, über den wir noch nicht gesprochen haben.
Folgender Code mit ganzen Zahlen, der teilweise in Codeblock 4-2 gezeigt wurde,
funktioniert und ist gültig:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Aber dieser Code scheint dem zu widersprechen, was wir gerade gelernt haben:
Wir haben keinen Aufruf von <code>clone</code>, aber <code>x</code> ist immer noch gültig und wurde
nicht in <code>y</code> verschoben.</p>
<p>Der Grund dafür ist, dass Typen wie ganze Zahlen, die zur Kompilierzeit eine
bekannte Größe haben, vollständig auf dem Stack gespeichert werden, so dass
Kopien der tatsächlichen Werte schnell erstellt werden können. Das bedeutet,
dass es keinen Grund gibt, warum wir verhindern wollen, dass <code>x</code> gültig ist,
nachdem wir die Variable <code>y</code> erstellt haben. Mit anderen Worten, es gibt hier
keinen Unterschied zwischen tiefen und flachen Kopien, also würde der Aufruf
<code>clone</code> nichts anderes tun als das übliche flache Kopieren, und wir können es
weglassen.</p>
<p>Rust hat eine spezielle Annotation, das Merkmal <code>Copy</code>, die wir an Typen wie
ganze Zahlen hängen können, die auf dem Stapelspeicher gespeichert sind (wir
werden in Kapitel 10 mehr über Merkmale sprechen). Wenn ein Typ das Merkmal
<code>Copy</code> hat, ist eine ältere Variable nach der Zuweisung noch verwendbar. Rust
lässt uns einen Typ nicht mit dem Merkmal <code>Copy</code> annotieren, wenn der Typ oder
einer seiner Teile das Merkmal <code>Drop</code> implementiert. Wenn der Typ eine
Sonderbehandlung braucht, wenn der Wert den Gültigkeitsbereich verlässt und wir
die Annotation <code>Copy</code> zu diesem Typ hinzufügen, erhalten wir einen
Kompilierfehler. Um zu erfahren, wie du die <code>Copy</code>-Annotation zu deinem Typ
hinzufügen kannst, siehe <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> in
Anhang C.</p>
<p>Welche Typen unterstützen also <code>Copy</code>? Du kannst die Dokumentation für einen
gegebenen Typ überprüfen, um sicherzugehen, aber als allgemeine Regel gilt,
dass jede Gruppierung von einfachen skalaren Werten <code>Copy</code> unterstützt, und
nichts, was eine Allokation erfordert oder irgendeine Form von Ressource ist,
<code>Copy</code> erlaubt. Hier sind einige Typen, die <code>Copy</code> unterstützen:</p>
<ul>
<li>Alle ganzzahligen Typen, z.B. <code>u32</code>.</li>
<li>Der boolesche Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>.</li>
<li>Alle Fließkomma-Typen, z.B. <code>f64</code>.</li>
<li>Der Zeichentyp <code>char</code>.</li>
<li>Tupel, wenn sie nur Typen enthalten, die auch <code>Copy</code> unterstützen. Zum
Beispiel unterstützt <code>(i32, i32)</code> <code>Copy</code>, nicht aber <code>(i32, String)</code>.</li>
</ul>
<h3><a class="header" href="#eigentümerschaft-und-funktionen" id="eigentümerschaft-und-funktionen">Eigentümerschaft und Funktionen</a></h3>
<p>Die Semantik für die Übergabe eines Wertes an eine Funktion ist ähnlich wie bei
der Zuweisung eines Wertes an eine Variable. Wenn eine Variable an eine
Funktion übergeben wird, wird sie verschoben oder kopiert, genau wie bei der
Zuweisung. Codeblock 4-3 enthält ein Beispiel mit einigen Anmerkungen, aus
denen hervorgeht, wo Variablen in den Gültigkeitsbereich fallen und wo nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;Hallo&quot;);  // s kommt in den Gültigkeitsbereich

    takes_ownership(s);             // Der Wert von s wird in die Funktion verschoben,
                                    // und ist daher hier nicht mehr gültig.

    let x = 5;                      // x kommt in den Gültigkeitsbereich

    makes_copy(x);                  // x würde in die Funktion verschoben werden,
                                    // aber i32 erlaubt Copy, also ist es in Ordnung,
                                    // danach immer noch x zu verwenden,

} // Hier verlässt x den Gültigkeitsbereich, dann s.
  // Aber weil der Wert von s verschoben wurde, passiert nichts Besonderes.

fn takes_ownership(some_string: String) { // some_string kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_string);
} // Hier verlässt some_string den Gültigkeitsbereich und `drop` wird aufgerufen.
  // Der zugehörige Speicherplatz wird freigegeben.

fn makes_copy(some_integer: i32) { // some_integer kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_integer);
} // Hier verlässt some_integer den Gültigkeitsbereich. Es passiert nichts Besonderes.
</code></pre></pre>
<p><span class="caption">Codeblock 4-3: Funktionen mit kommentierter
Eigentümerschaft und Gültigkeitsbereich</span></p>
<p>Wenn wir versuchen würden, <code>s</code> nach dem Aufruf von <code>takes_ownership</code> zu
verwenden, würde Rust einen Kompilierfehler anzeigen. Diese statischen
Prüfungen schützen uns vor Fehlern. Versuche, weiteren Code zu <code>main</code>
hinzuzufügen, der <code>s</code> und <code>x</code> verwendet, um zu sehen, wo du sie verwenden
kannst und wo die Eigentumsregeln dich daran hindern.</p>
<h3><a class="header" href="#rückgabewerte-und-gültigkeitsbereich" id="rückgabewerte-und-gültigkeitsbereich">Rückgabewerte und Gültigkeitsbereich</a></h3>
<p>Rückgabewerte können auch Eigentümerschaft übertragen. Codeblock 4-4 ist ein
Beispiel mit ähnlichen Anmerkungen wie die in Codeblock 4-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership verschiebt seinen
                                        // Rückgabewert in s1

    let s2 = String::from(&quot;Hallo&quot;);     // s2 kommt in den Gültigkeitsbereich

    let s3 = takes_and_gives_back(s2);  // s2 wird in takes_and_gives_back verschoben
                                        // und der Rückgabewert wird in s3 verschoben

} // Hier verlässt s3 den Gültigkeitsbereich und wird aufgeräumt.
  // s2 verlässt den Gültigkeitsbereich, wurde aber verschoben, es passiert also nichts.
  // s1 verlässt den Gültigkeitsbereich und wird aufgeräumt.

fn gives_ownership() -&gt; String {        // gives_ownership verschiebt seinen
                                        // Rückgabewert in die aufrufende Funktion

    let some_string = String::from(&quot;Hallo&quot;); // some_string kommt in den
                                             // Gültigkeitsbereich

    some_string                         // some_string wird zurückgegeben und
                                        // wird an die aufrufende Funktion verschoben
}

// takes_and_gives_back nimmt einen String entgegen und gibt einen zurück
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string kommt in den
                                                      // Gültigkeitsbereich

    a_string  // a_string wird zurückgegeben und
              // an die aufrufende Funktion verschoben
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-4: Übertragen der Eigentümerschaft an Rückgabewerten</span></p>
<p>Die Eigentümerschaft an einer Variable folgt jedes Mal dem gleichen Muster: Das
Zuweisen eines Wertes an eine andere Variable verschiebt diese. Wenn eine
Variable, die Daten im Haldenspeicher enthält, den Gültigkeitsbereich
verlässt, wird der Wert durch <code>drop</code> aufgeräumt, es sei denn, die Daten wurden
in das Eigentum einer anderen Variable verschoben.</p>
<p>Es ist etwas mühsam, das Eigentum zu übernehmen und es dann mit jeder Funktion
zurückzugeben. Was ist, wenn wir eine Funktion einen Wert nutzen lassen wollen,
aber nicht die Eigentümerschaft übergeben wollen? Es ist ziemlich lästig, dass
alles, was wir übergeben, auch wieder zurückgegeben werden muss, wenn wir es
wieder verwenden wollen, zusätzlich zu den Daten, die sich aus dem
Funktionsrumpf ergeben, die wir vielleicht auch zurückgeben wollen.</p>
<p>Es ist möglich, mehrere Werte mit Hilfe eines Tupels zurückzugeben, wie in
Codeblock 4-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() gibt die Länge der Zeichenkette zurück

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-5: Rückgeben der Eigentümerschaft an
Parametern</span></p>
<p>Aber das ist zu viel Zeremonie und zu viel Arbeit für ein Konzept, das
gebräuchlich sein sollte. Zum Glück hat Rust für uns eine Funktionalität zu
diesem Konzept, das <em>Referenzen</em> (references) genannt wird.</p>
<h2><a class="header" href="#referenzen-und-ausleihen-borrowing" id="referenzen-und-ausleihen-borrowing">Referenzen und Ausleihen (borrowing)</a></h2>
<p>Das Problem mit dem Tupelcode in Codeblock 4-5 ist, dass wir der aufrufenden
Funktion den <code>String</code> zurückgeben müssen, damit wir den <code>String</code> nach dem
Aufruf von <code>calculate_length</code> weiter verwenden können, weil der <code>String</code> in
<code>calculate_length</code> verschoben wurde.</p>
<p>Im Folgenden siehst du, wie du eine Funktion <code>calculate_length</code> definieren und
verwenden kannst, die eine Referenz auf ein Objekt als Parameter hat, anstatt
die Eigentümerschaft (ownership) des Wertes zu übernehmen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Beachte, dass der gesamte Tupelcode aus der Variablendeklaration und dem
Rückgabewert der Funktion verschwunden ist. Beachte des Weiteren, dass wir
<code>&amp;s1</code> an <code>calculate_length</code> übergeben und in seiner Definition <code>&amp;String</code> statt
<code>String</code> steht.</p>
<p>Das <code>&amp;</code>-Zeichen steht für eine <em>Referenz</em>, und sie ermöglicht es dir, sich auf
einen Wert zu beziehen, ohne dessen Eigentümerschaft zu übernehmen. Abbildung
4-5 zeigt die Speicherdarstellung.</p>
<img alt="&String s zeigt auf String s1" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">Abbildung 4-5: Eine Grafik mit <code>&amp;String s</code>, das auf
<code>String s1</code> zeigt</span></p>
<blockquote>
<p>Anmerkung: Das Gegenteil der Referenzierung durch <code>&amp;</code> ist die
<em>Dereferenzierung</em> (dereferencing), die mittels Dereferenzoperator <code>*</code>
erfolgt. Wir werden in Kapitel 8 einige Verwendungen des Dereferenzoperators
sehen und in Kapitel 15 Einzelheiten der Dereferenzierung besprechen.</p>
</blockquote>
<p>Schauen wir uns den Funktionsaufruf hier genauer an:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>&amp;s1</code> erlaubt es uns, eine Referenz zu erstellen, die auf den Wert
von <code>s1</code> <em>referenziert</em>, ihn aber nicht besitzt. Da sie diese nicht besitzt,
verfällt der Wert, auf den sie verweist, nicht, wenn die Referenz den
Gültigkeitsbereich verlässt.</p>
<p>Ebenso verwendet die Signatur der Funktion das Zeichen <code>&amp;</code>, um anzuzeigen, dass
der Typ des Parameters <code>s</code> eine Referenz ist. Lass uns einige erklärende
Anmerkungen ergänzen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;Hallo&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ist eine Referenz
                                           // auf eine Zeichenkette
    s.len()
} // Hier verlässt s den Gültigkeitsbereich. Aber weil es keine
  // Eigentümerschaft an dem hat, worauf es referenziert, passiert nichts.
</code></pre></pre>
<p>Der Gültigkeitsbereich, in dem die Variable <code>s</code> gültig ist, ist derselbe wie
der Gültigkeitsbereich aller Funktionsparameter, aber wir lassen nicht
verfallen, worauf die Referenz verweist, wenn sie den Gültigkeitsbereich
verlässt, weil wir keine Eigentümerschaft haben. Wenn Funktionen statt der
tatsächlichen Werte Referenzen als Parameter haben, brauchen wir die Werte
nicht zurückzugeben, um die Eigentümerschaft zurückzugeben, denn wir hatten nie
die Eigentümerschaft.</p>
<p>Referenzen als Funktionsparameter bezeichnen wir als <em>Ausleihen</em> (borrowing).
Wenn eine Person im richtigen Leben etwas besitzt, kannst du es von ihr
ausleihen. Wenn du fertig bist, musst du es zurückgeben.</p>
<p>Was passiert nun, wenn wir versuchen, etwas zu verändern, das wir uns
ausleihen? Versuche den Code in Codeblock 4-6. Achtung: Es funktioniert nicht!</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let s = String::from(&quot;Hallo&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-6: Versuch, einen ausgeliehenen Wert zu
verändern</span></p>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     some_string.push_str(&quot; Welt&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>So wie Variablen standardmäßig unveränderlich sind, so sind auch Referenzen
unveränderlich. Es ist uns nicht erlaubt, etwas zu verändern, auf das wir eine
Referenz haben.</p>
<h3><a class="header" href="#veränderliche-referenzen" id="veränderliche-referenzen">Veränderliche Referenzen</a></h3>
<p>Wir können den Fehler im Code von Codeblock 4-6 mit nur einer kleinen Änderung
beheben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Hallo&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre></pre>
<p>Zuerst mussten wir <code>s</code> ändern, um <code>mut</code> zu sein. Dann mussten wir eine
veränderliche Referenz mit <code>&amp;mut s</code> erstellen und eine veränderliche Referenz
mit <code>some_string: &amp;mut String</code> entgegennehmen.</p>
<p>Veränderliche Referenzen haben jedoch eine große Einschränkung: Du kannst nur
eine veränderliche Referenz auf einen bestimmten Datenwert in einem bestimmten
Gültigkeitsbereich haben. Dieser Code wird fehlschlagen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Beschränkung erlaubt das Verändern von Werten, aber auf eine sehr
kontrollierte Weise. Das ist etwas, womit neue Rust-Entwickler zu kämpfen
haben, denn in den meisten Sprachen kann man verändern, wann immer man will.</p>
<p>Diese Beschränkung hat den Vorteil, dass Rust Daten-Wettlaufsituation zur
Kompilierzeit verhindern kann. Eine <em>Daten-Wettlaufsituation</em> (data race) ist
ähnlich einer Wettlaufsituation (race condition) und tritt auf, wenn diese drei
Verhaltensweisen auftreten:</p>
<ul>
<li>Zwei oder mehr Zeiger greifen gleichzeitig auf dasselbe Datum zu.</li>
<li>Mindestens einer der Zeiger wird zum Schreiben auf das Datum verwendet.</li>
<li>Es kommt kein Mechanismus zur Anwendung, den Zugriff auf die Daten zu
synchronisieren.</li>
</ul>
<p>Daten-Wettlaufsituationen verursachen undefiniertes Verhalten und können
schwierig zu diagnostizieren und zu beheben sein, wenn du versuchst, sie zur
Laufzeit aufzuspüren; Rust verhindert dieses Problem, indem es Code mit
Daten-Wettlaufsituationen gar nicht erst kompiliert!</p>
<p>Wie immer können wir geschweifte Klammern verwenden, um einen neuen
Gültigkeitsbereich zu schaffen, der mehrere veränderliche Verweise erlaubt, nur
nicht <em>gleichzeitige</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

{
    let r1 = &amp;mut s;
} // r1 verlässt hier den Gültigkeitsbereich, sodass wir
  // problemlos eine neue Referenz erstellen können.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Eine ähnliche Regel gibt es für die Kombination von veränderlichen und
unveränderlichen Referenzen. Dieser Code führt zu einem Fehler:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s;     // kein Problem
let r2 = &amp;s;     // kein Problem
let r3 = &amp;mut s; // GROSSES PROBLEM

println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s;     // kein Problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s;     // kein Problem
6 |     let r3 = &amp;mut s; // GROSSES PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
  |                               -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Puh! Wir können auch keine veränderlichen Referenzen haben, solange wir eine
unveränderliche haben. Nutzer einer unveränderlichen Referenz erwarten nicht,
dass sich die Werte dahinter plötzlich ändern! Mehrere unveränderliche
Referenzen sind jedoch in Ordnung, da niemand, der die Daten nur liest, die
Möglichkeit hat, das Lesen der Daten durch andere zu beeinflussen.</p>
<p>Beachte, dass der Gültigkeitsbereich einer Referenz dort beginnt, wo sie
eingeführt wird, und sich bis zur letzten Verwendung dieser Referenz fortsetzt. 
Zum Beispiel kompiliert dieser Code, weil die letzte Verwendung der
unveränderlichen Referenzen vor der Einführung der veränderlichen Referenz
erfolgt:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s; // kein Problem
let r2 = &amp;s; // kein Problem
println!(&quot;{} und {}&quot;, r1, r2);
// r1 und r2 werden nach dieser Stelle nicht mehr verwendet

let r3 = &amp;mut s; // kein Problem
println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Die Gültigkeitsbereiche der unveränderlichen Referenzen <code>r1</code> und <code>r2</code> enden
nach dem <code>println!</code>, wo sie zuletzt verwendet werden, d.h. bevor die
veränderliche Referenz <code>r3</code> erstellt wird. Diese Gültigkeitsbereiche
überschneiden sich nicht, daher ist dieser Code zulässig.</p>
<p>Auch wenn das Ausleihen von Fehlern manchmal frustrierend sein kann, denke
daran, dass es der Rust-Compiler ist, der frühzeitig (zur Kompilierzeit und
nicht zur Laufzeit) auf einen möglichen Fehler hinweist und dir genau zeigt, wo
das Problem liegt. Dann musst du nicht aufspüren, warum deine Daten nicht so
sind, wie du dachtest.</p>
<h3><a class="header" href="#hängende-referenzen" id="hängende-referenzen">Hängende Referenzen</a></h3>
<p>In Sprachen mit Zeigern ist es leicht, fälschlicherweise einen <em>hängenden
Zeiger</em> (dangling pointer) zu erzeugen, also einen Zeiger, der auf eine Stelle
im Speicher verweist, die vielleicht an jemand anderem vergeben wurde, weil der
Speicher freigegeben wurde, während noch ein Zeiger auf diesen Speicher
bestehen bleibt. In Rust hingegen garantiert der Compiler, dass Referenzen
niemals hängende Referenzen sein können: Wenn du eine Referenz auf Daten hast,
stellt der Compiler sicher, dass die Daten nicht den Gültigkeitsbereich
verlassen, bevor die Referenz auf die Daten dies tut.</p>
<p>Versuchen wir, eine hängende Referenz zu erstellen, was Rust mit einem
Kompilierfehler verhindern wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;Hallo&quot;);

    &amp;s
}
</code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a 'static lifetime: `&amp;'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Fehlermeldung bezieht sich auf eine Funktionalität, die wir noch nicht
behandelt haben: Die Lebensdauer. Wir werden die Lebensdauer in Kapitel 10 im
Detail besprechen. Abgesehen von den Hinweisen zur Lebensdauer enthält die
Meldung den entscheidenden Hinweis, warum dieser Code nicht funktioniert:</p>
<blockquote>
<p>Hilfe: Der Rückgabetyp dieser Funktion enthält einen ausgeliehenen Wert, aber
es gibt keinen Wert der ausgeliehen werden kann.</p>
</blockquote>
<p>Lass uns einen genaueren Blick auf das werfen, was in jeder Phase unseres
<code>dangle</code>-Codes geschieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle gibt eine Referenz
                         // auf eine Zeichenkette zurück

    let s = String::from(&quot;Hallo&quot;); // s ist eine neue Zeichenkette

    &amp;s // wir geben einen Verweis auf die Zeichenkette s zurück
} // Hier verlässt s den Gültigkeitsbereich und wird verworfen.
  // Sein Speicherplatz wird aufgeräumt. Gefahr!
</code></pre></pre>
<p>Da <code>s</code> innerhalb <code>dangle</code> erzeugt wird, wird <code>s</code> wieder freigegeben, wenn der
Code von <code>dangle</code> zu Ende ist. Aber wir haben versucht, eine Referenz darauf
zurückzugeben. Das heißt, diese Referenz würde auf einen ungültigen <code>String</code>
verweisen. Das ist nicht gut! Rust lässt uns das nicht tun.</p>
<p>Die Lösung ist, den <code>String</code> direkt zurückzugeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;Hallo&quot;);

    s
}
</code></pre></pre>
<p>Dies funktioniert ohne Probleme. Die Eigentümerschaft wird nach außen
verschoben, und nichts wird freigegeben.</p>
<h3><a class="header" href="#regeln-für-referenzen" id="regeln-für-referenzen">Regeln für Referenzen</a></h3>
<p>Lass uns rekapitulieren, was wir über Referenzen gelernt haben:</p>
<ul>
<li>Zu jedem beliebigen Zeitpunkt kannst du <em>entweder</em> eine veränderliche
Referenz <em>oder</em> eine beliebige Anzahl unveränderlicher Referenzen haben.</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Als Nächstes werden wir uns mit einer anderen Art von Referenz befassen:
Anteilstypen (slice).</p>
<h2><a class="header" href="#der-anteilstyp-slice" id="der-anteilstyp-slice">Der Anteilstyp (slice)</a></h2>
<p>Ein weiterer Datentyp, für den keine Eigentümerschaft besteht, ist der
<em>Anteilstyp</em> (slice). Mit Anteilstypen kannst du auf eine zusammenhängende
Folge von Elementen in einer Kollektion verweisen, anstatt auf die gesamte
Kollektion.</p>
<p>Hier ist ein kleines Programmierproblem: Schreibe eine Funktion, die eine
Zeichenkette entgegennimmt und das erste Wort zurückgibt, das sie in dieser
Zeichenkette findet. Wenn die Funktion kein Leerzeichen in der Zeichenkette
findet, muss die gesamte Zeichenkette ein Wort sein, also sollte die gesamte
Zeichenkette zurückgegeben werden.</p>
<p>Lass uns über die Signatur dieser Funktion nachdenken:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Diese Funktion <code>first_word</code> hat einen <code>&amp;String</code> als Parameter. Wir wollen keine
Eigentümerschaft, also ist das in Ordnung. Aber was sollen wir zurückgeben? Wir
haben nicht wirklich eine Möglichkeit, über <em>einen Teil</em> einer Zeichenkette zu
sprechen. Wir könnten jedoch den Index des Wortendes zurückgeben. Versuchen wir
das, wie in Codeblock 4-7 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-7: Die Funktion <code>first_word</code>, die einen
Byte-Indexwert zum Parameter <code>String</code> zurückgibt</span></p>
<p>Da wir den <code>String</code> Zeichen für Zeichen durchgehen und prüfen müssen, ob ein
Wert ein Leerzeichen ist, wandeln wir unseren <code>String</code> mit der Methode
<code>as_bytes</code> in ein Byte-Array um:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Als nächstes erstellen wir einen Iterator über das Byte-Array, indem wir die
Methode <code>iter</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Auf Iteratoren werden wir in Kapitel 13 näher eingehen. Fürs Erste solltest du
wissen, dass <code>iter</code> eine Methode ist, die jedes Element in einer Kollektion
zurückgibt und dass <code>enumerate</code> das Ergebnis von <code>iter</code> umhüllt und stattdessen
jedes Element als Teil eines Tupels zurückgibt. Das erste Element des Tupels,
das von <code>enumerate</code> zurückgegeben wird, ist der Index, und das zweite Element
ist eine Referenz auf das Element. Das ist etwas bequemer, als den Index selbst
zu berechnen.</p>
<p>Da die Methode <code>enumerate</code> ein Tupel zurückgibt, können wir Muster verwenden,
um dieses Tupel zu zerlegen, so wie überall in Rust. In der <code>for</code>-Schleife
spezifizieren wir also ein Muster, das <code>i</code> für den Index im Tupel und <code>&amp;item</code>
für das einzelne Byte im Tupel hat. Da wir eine Referenz auf das Element aus
<code>.iter().enumerate()</code> erhalten, verwenden wir <code>&amp;</code> im Muster.</p>
<p>Innerhalb der <code>for</code>-Schleife suchen wir mit Hilfe der Byte-Literal-Syntax
<code>b' '</code> nach dem Byte, das das Leerzeichen repräsentiert. Wenn wir ein
Leerzeichen finden, geben wir die Position zurück. Andernfalls geben wir die
Länge der Zeichenkette zurück, indem wir <code>s.len()</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wir haben jetzt eine Möglichkeit, den Index des ersten Wortendes in der
Zeichenkette herauszufinden, aber es gibt ein Problem. Wir geben ein <code>usize</code>
für sich allein zurück, aber die Zahl ist nur aussagekräftig im Kontext des
<code>&amp;String</code>. Mit anderen Worten: Da es sich um einen vom <code>String</code> getrennten Wert
handelt, gibt es keine Garantie, dass er auch in Zukunft noch gültig ist.
Betrachte das Programm in Codeblock 4-8, das die Funktion <code>first_word</code> aus
Codeblock 4-7 verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s); // word erhält den Wert 5

    s.clear(); // leert die Zeichenkette und macht sie gleich &quot;&quot;

    // word hat noch immer den Wert 5, aber es gibt keine Zeichenkette mehr,
    // mit der wir den Wert 5 sinnvoll verwenden könnten.
    // word ist jetzt völlig ungültig!
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-8: Speichern des Ergebnisses des
Funktionsaufrufs <code>first_word</code> und anschließendes Ändern des Inhalts der
Zeichenkette</span></p>
<p>Dieses Programm kompiliert fehlerfrei und würde dies auch tun, wenn wir <code>word</code>
nach dem Aufruf von <code>s.clear()</code> benutzen würden. Da <code>word</code> überhaupt nicht mit
dem Zustand von <code>s</code> verbunden ist, enthält <code>word</code> immer noch den Wert <code>5</code>. Wir
könnten den Wert <code>5</code> mit der Variable <code>s</code> verwenden, um zu versuchen, das erste
Wort zu extrahieren, aber das wäre ein Fehler, weil sich der Inhalt von <code>s</code>
geändert hat, nachdem wir <code>5</code> in <code>word</code> gespeichert haben.</p>
<p>Sich darum kümmern zu müssen, dass der Index in <code>word</code> mit den Daten in <code>s</code>
konform ist, ist mühsam und fehleranfällig! Das Verwalten dieser Indizes ist
noch fehleranfälliger, wenn wir eine Funktion <code>second_word</code> schreiben. Ihre
Signatur müsste dann so aussehen:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Jetzt verfolgen wir einen Anfangs- <em>und</em> einen Endindex, und wir haben noch
mehr Werte, die aus Daten in einem bestimmten Zustand berechnet wurden, aber
überhaupt nicht an diesen Zustand gebunden sind. Wir haben jetzt drei
unverbundene Variablen, die synchron gehalten werden müssen.</p>
<p>Glücklicherweise hat Rust eine Lösung für dieses Problem:
Zeichenkettenanteilstypen</p>
<h3><a class="header" href="#zeichenkettenanteilstypen-string-slices" id="zeichenkettenanteilstypen-string-slices">Zeichenkettenanteilstypen (string slices)</a></h3>
<p>Ein <em>Zeichenkettenanteilstyp</em>  (string slice) ist ein Verweis auf einen Teil
eines <code>String</code>, und er sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo Welt&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..10];
<span class="boring">}
</span></code></pre></pre>
<p>Dies ist ähnlich zu einem Verweis auf den gesamten <code>String</code>, aber mit
zusätzlichem <code>[0..5]</code>. Es handelt sich nicht um eine Referenz auf den gesamten
<code>String</code>, sondern auf einen Teil des <code>String</code>.</p>
<p>Wir können Anteilstypen mit einem Bereich innerhalb Klammern erstellen, indem
wir <code>[starting_index..ending_index]</code> angeben, wobei <code>starting_index</code> die erste
Position im Anteilstyp ist und <code>ending_index</code> die Position hinter der letzten
Position im Anteilstyp. Intern speichert die Anteilstyp-Datenstruktur die
Startposition und die Länge des Anteilstyps, was <code>ending_index</code> minus
<code>starting_index</code> entspricht. Im Fall von <code>let world = &amp;s[6..10];</code> wäre <code>world</code>
also ein Anteilstyp, der einen Zeiger auf das 7. Byte (von 1 an gezählt) von
<code>s</code> mit einem Längenwert von 4 enthält.</p>
<p>Abbildung 4-6 zeigt dies.</p>
<p><img alt="world mit einem Zeiger auf das 6. Byte von String s und einer Länge von 4"
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-6: Zeichenkettenanteilstyp, der sich auf einen
Teil eines <code>String</code> bezieht</span></p>
<p>Wenn du mit der Bereichssyntax <code>..</code> in Rust beim ersten Index (Null) beginnen
willst, kannst du den Wert vor den zwei Punkte weglassen. Mit anderen Worten
sind diese gleich:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Ebenso kannst du den Endindex weglassen, wenn dein Anteilstyp das letzte Byte
des <code>String</code> enthält. Das bedeutet, dass diese gleich sind:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>Du kannst auch beide Werte weglassen, um einen Ausschnitt der gesamten
Zeichenkette zu beschreiben. Diese sind also gleichwertig:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Hinweis: Bereichsindizes bei Zeichenkettenanteilstypen müssen sich nach
gültigen UTF-8-Zeichengrenzen richten. Wenn du versuchst, einen
Zeichenkettenanteilstyp in der Mitte eines Mehrbyte-Zeichens zu erstellen,
wird dein Programm mit einem Fehler abbrechen. Bei der Einführung von
Zeichenkettenanteilstypen in diesem Abschnitt gehen wir nur von ASCII aus;
eine eingehendere Diskussion der UTF-8-Behandlung findet sich im Abschnitt
<a href="ch08-02-strings.html">„UTF-8-kodierten Text in Zeichenketten (strings) ablegen“</a> in
Kapitel 8.</p>
</blockquote>
<p>Mit all diesen Informationen im Hinterkopf schreiben wir <code>first_word</code> so um,
dass es einen Anteilstyp zurückgibt. Der Typ mit der Bedeutung
„Zeichenkettenanteilstyp“ wird <code>&amp;str</code> geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Den Index für das Wortende erhalten wir auf die gleiche Weise wie in Codeblock
4-7, indem wir nach dem ersten Vorkommen eines Leerzeichens suchen. Wenn wir
ein Leerzeichen finden, geben wir einen Zeichenkettenanteilstyp zurück, wobei
wir den Anfang der Zeichenkette und den Index des Leerzeichens als Anfangs-
bzw. Endindex verwenden.</p>
<p>Wenn wir nun <code>first_word</code> aufrufen, erhalten wir einen einzelnen Wert zurück,
der an die zugrundeliegenden Daten gebunden ist. Der Wert setzt sich aus einer
Referenz auf den Startpunkt des Anteilstyps und der Anzahl der Elemente im
Anteilstyp zusammen.</p>
<p>Die Rückgabe eines Anteilstyps würde auch für eine Funktion <code>second_word</code>
funktionieren:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Wir haben jetzt eine einfache API, die viel schwieriger durcheinanderzubringen
ist, weil der Compiler sicherstellt, dass die Referenzen auf den <code>String</code>
gültig bleiben. Erinnere dich an den Fehler im Programm in Codeblock 4-8, als
wir den Index bis zum Ende des ersten Wortes erhielten, dann aber die
Zeichenkette löschten, sodass unser Index ungültig wurde. Dieser Code war
logisch falsch, zeigte aber keine unmittelbaren Fehler. Die Probleme würden
sich später zeigen, wenn wir weiterhin versuchen würden, den ersten Wortindex
mit einer leeren Zeichenkette zu verwenden. Anteilstypen machen diesen Fehler
unmöglich und lassen uns viel früher wissen, dass wir ein Problem mit unserem
Code haben. Die Anteilstypen-Variante von <code>first_word</code> führt zu einem
Kompilierfehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Fehler!

    println!(&quot;Das erste Wort ist: {}&quot;, word);
}
</code></pre></pre>
<p>Hier ist der Kompilierfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Fehler!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Das erste Wort ist: {}&quot;, word);
   |                                        ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Erinnere dich an die Ausleihregeln, durch die wir, wenn wir eine
unveränderliche Referenz auf etwas haben, nicht noch eine veränderliche
Referenz anlegen können. Da <code>clear</code> den <code>String</code> abschneiden muss, muss es
eine veränderliche Referenz erhalten. Rust erlaubt dies nicht und die
Kompilierung schlägt fehl. Rust hat nicht nur die Benutzung unserer API
vereinfacht, sondern auch eine ganze Klasse von Fehlern zur Kompilierzeit
beseitigt!</p>
<h4><a class="header" href="#zeichenkettenliterale-sind-anteilstypen" id="zeichenkettenliterale-sind-anteilstypen">Zeichenkettenliterale sind Anteilstypen</a></h4>
<p>Erinnere dich, dass wir darüber sprachen, dass Zeichenkettenliterale in der
Binärdatei gespeichert werden. Jetzt, da wir über Anteilstypen Bescheid wissen,
können wir Zeichenkettenliterale richtig verstehen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo Welt!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Der Typ von <code>s</code> hier ist <code>&amp;str</code>: Es ist ein Anteilstyp, der auf diesen
speziellen Punkt der Binärdatei zeigt. Das ist auch der Grund, warum
Zeichenkettenliterale unveränderlich sind; <code>&amp;str</code> ist ein unveränderliche
Referenz.</p>
<h4><a class="header" href="#zeichenkettenanteilstypen-als-parameter" id="zeichenkettenanteilstypen-als-parameter">Zeichenkettenanteilstypen als Parameter</a></h4>
<p>Das Wissen, dass man Anteilstypen von Literalen und <code>String</code>-Werten erstellen
kann, führt uns zu einer weiteren Verbesserung von <code>first_word</code>, und das ist
ihre Signatur:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ein erfahrenerer Rust-Entwickler würde stattdessen die in Codeblock 4-9
gezeigte Signatur schreiben, da sie es uns erlaubt, dieselbe Funktion sowohl
auf <code>&amp;String</code>-Werte als auch auf <code>&amp;str</code>-Werte anzuwenden.</p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-9: Verbessern der Funktion <code>first_word</code> durch
Verwenden eines Zeichenkettenanteilstyps für den Typ des Parameters <code>s</code></span></p>
<p>Wenn wir einen Zeichenkettenanteilstyp haben, können wir diesen direkt
übergeben. Wenn wir einen <code>String</code> haben, können wir einen Anteilstyp des
gesamten <code>String</code> übergeben. Das Definieren einer Funktion, die einen
Zeichenkettenanteilstyp statt einer Referenz auf einen <code>String</code> entgegennimmt,
macht unsere API allgemeiner und nützlicher, ohne an Funktionalität einzubüßen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;Hallo Welt&quot;);

    // first_word funktioniert mit Anteilstypen von `String`
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;Hallo Welt&quot;;

    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
    let word = first_word(&amp;my_string_literal[..]);

    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
    // funktioniert dies auch ohne die Anteilstypensyntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#andere-anteilstypen" id="andere-anteilstypen">Andere Anteilstypen</a></h3>
<p>Zeichenkettenanteilstypen sind, wie du dir vorstellen kannst, spezifisch für
Zeichenketten. Es gibt aber auch einen allgemeineren Anteilstyp. Betrachte
dieses Array:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Genauso wie wir vielleicht auf einen Teil einer Zeichenkette verweisen möchten,
möchten wir vielleicht auf einen Teil eines Arrays verweisen. Wir würden das so
machen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Anteilstyp hat den Typ <code>&amp;[i32]</code>. Es funktioniert auf die gleiche Weise
wie bei Zeichenkettenanteilstypen, indem es eine Referenz auf das erste Element
und eine Länge speichert. Du wirst diese Art von Anteilstyp für alle möglichen
anderen Kollektionen verwenden. Wir werden diese Kollektionen im Detail
besprechen, wenn wir in Kapitel 8 über Vektoren sprechen.</p>
<h2><a class="header" href="#zusammenfassung-3" id="zusammenfassung-3">Zusammenfassung</a></h2>
<p>Die Konzepte von Eigentümerschaft, Ausleihen und Anteilstypen gewährleisten
Speichersicherheit zur Kompilierzeit in Rust-Programmen. Die Sprache Rust gibt
dir Kontrolle über die Speicherverwendung auf die gleiche Weise wie andere
Systemprogrammiersprachen, aber dadurch dass der Eigentümer der Daten diese
automatisch aufräumt, wenn der Eigentümer den Gültigkeitsbereich verlässt,
bedeutet dies, dass du keinen zusätzlichen Code schreiben und debuggen musst,
um diese Kontrolle zu erhalten.</p>
<p>Die Eigentümerschaft wirkt sich auf die Funktionsweise vieler anderer Teile von
Rust aus, deshalb werden wir im weiteren Verlauf des Buchs weiter über diese
Konzepte sprechen. Lass uns zu Kapitel 5 übergehen und uns das Gruppieren von
Datenteilen zu einer <code>struct</code> ansehen.</p>
<h1><a class="header" href="#strukturen-structs-für-zusammenhängende-daten-verwenden" id="strukturen-structs-für-zusammenhängende-daten-verwenden">Strukturen (structs) für zusammenhängende Daten verwenden</a></h1>
<p>Eine <em>Struktur</em> (struct) ist ein benutzerdefinierter Datentyp, mit dem man
mehrere zusammenhängende Werte, die eine sinnvolle Gruppe bilden,
zusammenpacken und benennen kann. Wenn du mit einer objektorientierten Sprache
vertraut bist, ist eine <em>Struktur</em> analog zu den Datenattributen eines Objekts.
In diesem Kapitel vergleichen wir Tupel mit Strukturen, stellen die
Unterschiede dar, zeigen die Verwendung von Strukturen und erörtern, wie
Methoden und zugehörige Funktionen definiert werden, um das mit den Daten einer
Struktur verbundene Verhalten zu spezifizieren. Strukturen und Aufzählungen
(enums) (siehe Kapitel 6) sind die Bausteine zum Erstellen neuer Typen in der
Domäne deines Programms, mit denen du die Vorteile der Kompilierzeit-Typprüfung
von Rust voll auszuschöpfen kannst.</p>
<h2><a class="header" href="#strukturen-structs-definieren-und-instanziieren" id="strukturen-structs-definieren-und-instanziieren">Strukturen (structs) definieren und instanziieren</a></h2>
<p>Strukturen (structs) ähneln Tupeln, die in Kapitel 3 besprochen wurden. Wie
bei Tupeln können die Teile einer Struktur verschiedene Typen haben. Anders als
bei Tupeln benennst du jedes Teil, damit ist klar, was die Werte bedeuten.
Durch diese Namen sind Strukturen flexibler als Tupel: Du musst dich nicht auf
die Reihenfolge der Daten verlassen, um die Werte einer Instanz zu
spezifizieren oder auf sie zuzugreifen.</p>
<p>Um eine Struktur zu definieren, geben wir das Schlüsselwort <code>struct</code> an und
benennen die gesamte Struktur. Der Name einer Struktur sollte die Bedeutung der
Daten beschreiben, die gruppiert werden. Dann definieren wir innerhalb
geschweifter Klammern die Namen und Typen der Datenteile, die wir <em>Felder</em>
nennen. Beispielsweise zeigt Codeblock 5-1 eine Struktur, die Informationen
über ein Benutzerkonto speichert.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-1: Definition der Struktur <code>User</code></span></p>
<p>Um eine Struktur zu verwenden, nachdem wir sie definiert haben, erstellen wir
eine <em>Instanz</em> dieser Struktur, indem wir für jedes Feld einen konkreten Wert
angeben. Wir erzeugen eine Instanz, indem wir den Namen der Struktur angeben
und dann in geschweiften Klammern die <code>Schlüssel: Wert</code>-Paare angeben, wobei
die Schlüssel die Namen der Felder und die Werte die Daten sind, die wir in
diesen Feldern speichern wollen. Wir müssen die Felder nicht in der gleichen
Reihenfolge angeben, in der wir sie in der Struktur deklariert haben. Anders
gesagt ist die Strukturdefinition wie eine allgemeine Typvorlage und Instanzen
füllen diese Vorlage mit bestimmten Daten aus, um Werte des Typs zu erzeugen.
Beispielsweise können wir einen bestimmten Benutzer deklarieren, wie in
Codeblock 5-2 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-2: Eine Instanz der Struktur <code>User</code>
erzeugen</span></p>
<p>Um auf einen bestimmten Wert in einer Struktur zuzugreifen, können wir die
Punktnotation verwenden. Wenn wir nur die E-Mail-Adresse dieses Benutzers
wollen, können wir <code>user1.email</code> überall dort einsetzen, wo wir diesen Wert
verwenden wollen. Wenn die Instanz veränderlich ist, können wir einen Wert
mittels Punktnotation verändern. Codeblock 5-3 gezeigt, wie der Wert im
Feld <code>email</code> einer veränderlichen <code>User</code>-Instanz geändert werden kann.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;andere-email@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-3: Wert im Feld <code>email</code> einer <code>User</code>-Instanz ändern</span></p>
<p>Beachte, dass die gesamte Instanz veränderlich sein muss. Rust erlaubt es
nicht, nur einzelne Felder als veränderlich zu markieren. Wie mit jedem
Ausdruck können wir eine neue Instanz der Struktur als letzten Ausdruck im
Funktionsrumpf erzeugen, um diese neue Instanz implizit zurückzugeben.</p>
<p>Codeblock 5-4 zeigt eine Funktion <code>build_user</code>, die eine <code>User</code>-Instanz mit der
angegebenen E-Mail und dem Benutzernamen zurückgibt. Das Feld <code>active</code> erhält
den Wert <code>true</code> und das Feld <code>sign_in_count</code> den Wert <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-4: Funktion <code>build_user</code>, die eine E-Mail und
einen Benutzernamen entgegennimmt und eine <code>User</code>-Instanz zurückgibt</span></p>
<p>Es ist sinnvoll, den Funktionsparametern dieselben Namen wie die der
Strukturfelder zu geben, jedoch ist das Wiederholen der Feldnamen <code>email</code> und
<code>username</code> etwas mühsam. Wenn die Struktur mehr Felder hätte, würde das
Wiederholen jedes Namens noch lästiger werden. Glücklicherweise gibt es eine
praktische Kurznotation!</p>
<h3><a class="header" href="#kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben" id="kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben">Kurznotation der Feld-Initialisierung verwenden, wenn Variablen und Felder den gleichen Namen haben</a></h3>
<p>Da die Parameter und die Strukturfelder in Codeblock 5-4 die gleichen Namen
haben, können wir die <em>Kurznotation der Feld-Initialisierung</em> (field init
shorthand syntax) verwenden, um die Funktion <code>build_user</code> so umzuschreiben,
dass sie sich unverändert gleich verhält, ohne <code>email</code> und <code>username</code> zu
wiederholen, siehe Codeblock 5-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-5: Funktion <code>build_user</code> mit Kurznotation der
Feld-Initialisierung, weil die Parameternamen <code>email</code> und <code>username</code> identisch
mit den Strukturfeldern sind</span></p>
<p>Hier erzeugen wir eine neue Instanz der Struktur <code>User</code>, die ein Feld namens
<code>email</code> hat. Wir wollen den Wert des Feldes <code>email</code> auf den Wert des Parameters
<code>email</code> der Funktion <code>build_user</code> setzen. Da das Feld <code>email</code> und der Parameter
<code>email</code> den gleichen Namen haben, brauchen wir nur <code>email</code> statt <code>email: email</code>
zu schreiben.</p>
<h3><a class="header" href="#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax" id="instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">Instanzen aus anderen Instanzen erzeugen mit der Strukturaktualisierungssyntax</a></h3>
<p>Oft ist es hilfreich, eine neue Instanz einer Struktur zu erstellen, die die
meisten Werte einer alten Instanz verwendet und nur einige davon verändert. Du
kannst dazu die <em>Strukturaktualisierungssyntax</em> (struct update syntax)
verwenden.</p>
<p>Zunächst zeigt Codeblock 5-6, wie wir eine neue <code>User</code>-Instanz <code>user2</code> ohne
Aktualisierungssyntax erstellen. Wir setzen neue Werte für <code>email</code> und
<code>username</code>, verwenden aber ansonsten die gleichen Werte von <code>user1</code>, die wir in
Codeblock 5-2 erstellt haben.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-6: Erstellen einer neuen <code>User</code>-Instanz unter
Verwendung einiger der Werte von <code>user1</code>.</span></p>
<p>Durch Verwenden der Strukturaktualisierungssyntax können wir dasselbe Ergebnis
mit weniger Code erreichen, wie Codeblock 5-7 zeigt. Die Syntax <code>..</code> gibt an,
dass die restlichen Felder, die nicht explizit gesetzt wurden, den gleichen
Wert haben sollen wie die Felder in der gegebenen Instanz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-7: Verwenden der
Strukturaktualisierungssyntax, um neue Werte für <code>email</code> und <code>username</code> in der
<code>User</code>-Instanz zu setzen und die restlichen Werte aus den Feldern der Instanz
<code>user1</code> zu übernehmen</span></p>
<p>Der Code in Codeblock 5-7 erzeugt auch eine Instanz <code>user2</code>, die andere Werte
für <code>email</code> und <code>username</code> hat, aber die gleichen Werte der Felder <code>active</code> und
<code>sign_in_count</code> wie <code>user1</code>.</p>
<h3><a class="header" href="#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen" id="verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">Verwenden von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu erzeugen</a></h3>
<p>Du kannst auch Strukturen definieren, die wie Tupel aussehen, sogenannte
<em>Tupel-Strukturen</em> (tuple structs). Tupel-Strukturen sind Strukturen, die
keine Feldnamen haben, sondern nur die Typen der Felder. Tupel-Strukturen sind
hilfreich, wenn du dem gesamten Tupel einen Namen geben und erreichen willst,
dass das Tupel einen anderen Typ als die anderen Tupel hat und Feldnamen wie in
einer regulären Struktur langatmig oder unnötig wären.</p>
<p>Um eine Tupel-Struktur zu definieren, starte mit dem Schlüsselwort <code>struct</code>,
gefolgt vom Strukturnamen und den Typen im Tupel. Nachfolgend ein Beispiel mit
Definition und Verwendung zweier Tupel-Strukturen <code>Color</code> und <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass die Werte <code>black</code> und <code>origin</code> unterschiedliche Typen haben, weil
sie Instanzen unterschiedlicher Tupel-Strukturen sind. Jede von dir definierte
Struktur ist ein eigenständiger Typ, auch wenn die Felder innerhalb der
Struktur die gleichen Typen haben. Zum Beispiel kann eine Funktion, die einen
Parameter vom Typ <code>Color</code> hat, keinen <code>Point</code> als Argument nehmen, obwohl beide
Typen aus drei <code>i32</code>-Werten bestehen. Ansonsten verhalten sich
Tupel-Struktur-Instanzen wie Tupel: Du kannst sie in ihre Einzelteile zerlegen,
indem du <code>.</code> gefolgt vom Index schreibst, um auf einen einzelnen Wert
zuzugreifen, und so weiter.</p>
<h3><a class="header" href="#einheitstyp" id="einheitstyp">Einheitstyp</a></h3>
<p>Du kannst auch Strukturen definieren, die gar keine Felder haben! Diese werden
<em>Einheitstyp</em> (unit-like structs) genannt, weil sie sich ähnlich zum leeren
Tupel <code>()</code> verhalten. Einheitstypen können in Situationen nützlich sein, in
denen du ein Merkmal (trait) zu einem Typ implementieren musst, du aber keine
Daten hast, die im Typ gespeichert werden sollen. Wir werden Merkmale in
Kapitel 10 besprechen.</p>
<blockquote>
<h3><a class="header" href="#eigentümerschaft-von-strukturdaten" id="eigentümerschaft-von-strukturdaten">Eigentümerschaft von Strukturdaten</a></h3>
<p>In der Strukturdefinition <code>User</code> in Codeblock 5-1 haben wir den Typ <code>String</code>
anstelle von <code>&amp;str</code> verwendet. Dies ist eine bewusste Entscheidung, denn wir
wollen, dass Instanzen dieser Struktur all ihre Daten besitzen und diese
Daten so lange gültig sind, wie die gesamte Struktur gültig ist.</p>
<p>Bei Strukturen ist es möglich, Referenzen auf Daten zu speichern, die im
Besitz von etwas anderem sind, aber das erfordert die Verwendung von
<em>Lebensdauern</em>, einer Rust-Funktionalität, die wir in Kapitel 10 besprechen
werden. Die Lebensdauer stellt sicher, dass die von einer Struktur
referenzierten Daten so lange gültig sind, wie die Struktur gültig ist.
Angenommen, du versuchst eine Referenz in einer Struktur zu speichern, ohne
eine Lebensdauer anzugeben, wird das nicht funktionieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;jemand@example.com&quot;,
        username: &quot;benutzername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p>Der Compiler wird sich beschweren, dass die Lebensdauer nicht angegeben ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`.

To learn more, run the command again with --verbose.
</code></pre>
<p>In Kapitel 10 werden wir klären, wie man diese Fehler behebt und Referenzen
in Strukturen speichern kann. Aber für den Moment werden wir Fehler wie diese
vermeiden, indem wir Typen wie <code>String</code> anstelle von Referenzen wie <code>&amp;str</code>
verwenden.</p>
</blockquote>
<h2><a class="header" href="#beispielprogramm-mit-strukturen-structs" id="beispielprogramm-mit-strukturen-structs">Beispielprogramm mit Strukturen (structs)</a></h2>
<p>Um besser zu verstehen, wann wir Strukturen verwenden können, schreiben wir ein
Programm, das die Fläche eines Rechtecks berechnet. Wir beginnen mit einzelnen
Variablen und schreiben das Programm dann um, bis wir stattdessen Strukturen
einsetzen.</p>
<p>Legen wir mit Cargo ein neues Binärprojekt namens <em>rectangles</em> an, das die
Breite und Höhe eines in Pixeln angegebenen Rechtecks nimmt und die Fläche des
Rechtecks berechnet.</p>
<p>Codeblock 5-8 zeigt ein kurzes Programm, das genau das in <em>src/main.rs</em> unseres
Projekts macht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-8: Berechnen der Fläche eines Rechtecks, das
durch separate Breiten- und Höhenvariablen beschrieben wird</span></p>
<p>Nun führe dieses Programm mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
Die Fläche des Rechtecks ist 1500 Quadratpixel.
</code></pre>
<p>Auch wenn Codeblock 5-8 funktioniert und die Fläche des Rechtecks durch
Aufrufen der Funktion <code>area</code> mit jeder Dimension herausfindet, können wir es
besser machen. Breite und Höhe hängen zusammen, sie beschreiben zusammen ein
Rechteck.</p>
<p>Das Problem dieses Codes wird bei der Signatur von <code>area</code> deutlich:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Funktion <code>area</code> soll die Fläche eines Rechtecks berechnen, aber die von uns
geschriebene Funktion hat zwei Parameter. Dass die Parameter zusammenhängen,
wird aber nirgendwo in unserem Programm ausgedrückt. Es wäre besser lesbar und
überschaubarer, Breite und Höhe zusammenzufassen. Eine Möglichkeit dazu haben
wir bereits im Abschnitt <a href="ch03-02-data-types.html#der-tupel-typ">„Der Tupel-Typ“</a> in Kapitel 3
vorgestellt: Der Einsatz von Tupeln.</p>
<h3><a class="header" href="#refaktorierung-mit-tupeln" id="refaktorierung-mit-tupeln">Refaktorierung mit Tupeln</a></h3>
<p>Codeblock 5-9 zeigt eine weitere Version unseres Programms, die Tupel
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-9: Breite und Höhe des Rechtecks werden mit
einem Tupel beschrieben</span></p>
<p>In einem Punkt ist dieses Programm besser. Das Tupel bringt etwas Struktur
hinein und wir geben jetzt nur noch ein Argument weiter. Andererseits ist
dieser Ansatz weniger deutlich: Tupel benennen ihre Elemente nicht, so dass
unsere Berechnung noch unübersichtlicher geworden ist, weil wir die Teile des
Tupels indizieren müssen.</p>
<p>Es spielt zwar keine Rolle, wenn wir bei der Flächenberechnung Breite und Höhe
verwechseln, aber wenn wir das Rechteck auf dem Bildschirm zeichnen wollten,
würde es eine Rolle spielen! Wir müssten berücksichtigen, dass <code>width</code> den
Tupelindex <code>0</code> und <code>height</code> den Tupelindex <code>1</code> hat. Wenn eine andere Person an
diesem Code arbeiten würde, müsste er das herausfinden und sich das ebenfalls
merken. Es wäre leicht, diese Werte zu vergessen oder zu verwechseln und Fehler
zu verursachen, weil wir die Bedeutung unserer Daten in unserem Code nicht
hinterlegt haben.</p>
<h3><a class="header" href="#refaktorierung-mit-strukturen-mehr-semantik" id="refaktorierung-mit-strukturen-mehr-semantik">Refaktorierung mit Strukturen: Mehr Semantik</a></h3>
<p>Verwenden wir Strukturen, um durch die Benennung der Daten deren Bedeutung
anzugeben. Wir können das verwendete Tupel in einen Datentyp mit einem Namen
für das Ganze sowie mit Namen für die Einzelteile umwandeln, wie in Codeblock
5-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-10: Definieren der Struktur <code>Rectangle</code></span></p>
<p>Hier haben wir eine Struktur definiert und sie <code>Rectangle</code> genannt. Innerhalb
der geschweiften Klammern haben wir die Felder <code>width</code> und <code>height</code> definiert,
die beide den Typ <code>u32</code> haben. Dann erzeugten wir in <code>main</code> eine Instanz von
<code>Rectangle</code> mit der Breite 30 und Höhe 50.</p>
<p>Unsere Funktion <code>area</code> hat nun einen Parameter, den wir <code>rectangle</code> genannt
haben und dessen Typ eine unveränderliche Ausleihe (immutable borrow) einer
Strukturinstanz <code>Rectangle</code> ist. Wie in Kapitel 4 erwähnt, wollen wir die
Struktur nur ausleihen, nicht aber deren Eigentümerschaft (ownership)
übernehmen. Auf diese Weise behält <code>main</code> seine Eigentümerschaft und kann
weiterhin <code>rect1</code> verwenden, weshalb wir <code>&amp;</code> in der Funktionssignatur und an
der Aufrufstelle verwenden.</p>
<p>Die Funktion <code>area</code> greift auf die Felder <code>width</code> und <code>height</code> der Instanz
<code>Rectangle</code> zu. Unsere Funktionssignatur für <code>area</code> sagt jetzt genau was wir
meinen: Berechne die Fläche von <code>Rectangle</code> unter Verwendung seiner Felder
<code>width</code> und <code>height</code>. Dies drückt aus, dass Breite und Höhe in Beziehung
zueinander stehen, und gibt den Werten beschreibende Namen, ohne die
Tupelindexwerte <code>0</code> und <code>1</code> zu verwenden. Das erhöht die Lesbarkeit.</p>
<h3><a class="header" href="#hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits" id="hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits">Hilfreiche Funktionalität mit abgeleiteten Merkmalen (derived traits)</a></h3>
<p>Es wäre schön, eine Instanz von <code>Rectangle</code> samt der Werte seiner Felder
ausgeben zu können, während wir unser Programm debuggen. In Codeblock 5-11
versuchen wir das Makro <code>println!</code> zu verwenden, das wir in den vorangegangenen
Kapiteln verwendet haben. Dies wird jedoch nicht funktionieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-11: Versuch, eine <code>Rectangle</code>-Instanz
auszugeben</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Das Makro <code>println!</code> kann diverse Formatierungen vornehmen. Die geschweiften
Klammern weisen <code>println!</code> an, die Formatierung <code>Display</code> zu verwenden, bei der
die Ausgabe direkt für den Endbenutzer bestimmt ist. Die primitiven Typen, die
wir bisher gesehen haben, implementieren <code>Display</code> standardmäßig, denn es gibt
nur eine Möglichkeit, dem Benutzer eine <code>1</code> oder einen anderen primitiven Typ
zu zeigen. Aber bei Strukturen ist die Formatierung, die <code>println!</code> verwenden
soll, weniger klar, da es mehrere Darstellungsmöglichkeiten gibt: Möchtest du
Kommas oder nicht? Möchtest du die geschweiften Klammern ausgeben? Sollen alle
Felder angezeigt werden? Aufgrund der vielen Möglichkeiten versucht Rust nicht
zu erraten, was wir wollen. Strukturen haben daher keine
Standardimplementierung von <code>Display</code>.</p>
<p>Wenn wir die Fehlerausgabe weiterlesen, werden wir diesen hilfreichen Hinweis
finden:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Lass es uns versuchen! Der Makroaufruf <code>println!</code> wird geändert in
<code>println!(&quot;rect1 ist {:?}&quot;, rect1);</code>. Wenn wir das Symbol <code>:?</code> innerhalb der
geschweiften Klammern angeben, teilen wir <code>println!</code> mit, dass wir das
Ausgabeformat <code>Debug</code> verwenden wollen. Das Merkmal <code>Debug</code> ermöglicht es, die
Struktur so auszugeben, dass Entwickler ihren Wert erkennen können, während sie
den Code debuggen.</p>
<p>Kompiliere den Code mit dieser Änderung. Verflixt! Wir erhalten immer noch
einen Fehler:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<p>Aber auch hier gibt uns der Compiler einen hilfreichen Hinweis:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust enthält durchaus eine Funktionalität zum Ausgeben von Debug-Informationen,
aber wir müssen diese explizit für unsere Struktur aktivieren. Dazu fügen wir
die Annotation <code>#[derive(Debug)]</code> unmittelbar vor der Strukturdefinition ein,
wie in Codeblock 5-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-12: Annotation zum Verwenden des Merkmals
<code>Debug</code> und Ausgeben der Instanz <code>Rectangle</code> mittels Debug-Formatierung</span></p>
<p>Wenn wir das Programm nun ausführen, werden wir keinen Fehler mehr erhalten und
folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle { width: 30, height: 50 }
</code></pre>
<p>Toll! Es ist nicht die schönste Ausgabe, aber sie zeigt die Werte aller Felder
dieser Instanz, was bei der Fehlersuche definitiv hilfreich ist. Bei größeren
Strukturen ist es hilfreich eine Ausgabe zu haben, die etwas leichter zu lesen
ist. In diesen Fällen können wir <code>{:#?}</code> anstelle von <code>{:?}</code> in der
<code>println!</code>-Meldung verwenden. Die Ausgabe sieht dann wie folgt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Rust stellt uns eine Reihe von Merkmalen zur Verfügung, die wir mit der
Annotation <code>derive</code> verwenden können, um damit unseren benutzerdefinierten
Typen nützliches Verhalten zu verleihen. Diese Merkmale und ihr Verhalten sind
in Anhang C aufgeführt. In Kapitel 10 werden wir behandeln, wie man diese
Merkmale mit benutzerdefiniertem Verhalten implementiert und wie man eigene
Merkmale erstellt.</p>
<p>Unsere Funktion <code>area</code> ist sehr spezifisch: Sie berechnet nur die Fläche von
Rechtecken. Es wäre hilfreich, dieses Verhalten enger mit unserer Struktur
<code>Rectangle</code> zu verbinden, da es zu keinem anderen Typ passt. Schauen wir uns
an, wie wir den Code weiter umgestalten und unsere Funktion <code>area</code> in eine
<em>Methode</em> <code>area</code> unseres Typs <code>Rectangle</code> verwandeln können.</p>
<h2><a class="header" href="#methodensyntax" id="methodensyntax">Methodensyntax</a></h2>
<p><em>Methoden</em> sind Funktionen recht ähnlich: Sie werden mit dem Schlüsselwort <code>fn</code>
und ihrem Namen deklariert, sie können Parameter und einen Rückgabewert haben,
und sie enthalten etwas Code, der ausgeführt wird, wenn sie aufgerufen werden. 
Methoden unterscheiden sich jedoch von Funktionen dadurch, dass sie im Kontext
einer Struktur (struct) (oder einer Aufzählung (enum) oder eines
Merkmalsobjektes (trait object), die wir in Kapitel 6 und 17 behandeln)
definiert werden und ihr erster Parameter stets <code>self</code> ist. <code>self</code>
repräsentiert die Instanz der Struktur zu der die Methode aufgerufen wird.</p>
<h3><a class="header" href="#definieren-von-methoden" id="definieren-von-methoden">Definieren von Methoden</a></h3>
<p>Lass uns die Funktion <code>area</code>, die eine <code>Rectangle</code>-Instanz als Parameter hat,
ändern und stattdessen eine Methode <code>area</code> auf der Struktur <code>Rectangle</code>
definieren, wie in Codeblock 5-13 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-13: Methode <code>area</code> der Struktur <code>Rectangle</code></span></p>
<p>Um die Funktion im Kontext von <code>Rectangle</code> zu definieren, beginnen wir mit dem
Block <code>impl</code> (Implementierung). Dann verschieben wir die Funktion <code>area</code> in die
geschweiften Klammern von <code>impl</code>, ändern den ersten (und in diesem Fall
einzigen) Parameter zu <code>self</code> und passen den Methodenrumpf entsprechend an. In 
<code>main</code>, wo wir die Funktion <code>area</code> aufrufen und <code>rect1</code> als Argument übergeben,
können wir stattdessen die <em>Methodensyntax</em> verwenden, um die Methode <code>area</code>
auf unserer <code>Rectangle</code>-Instanz aufzurufen. Die Methodensyntax bezieht sich auf
eine Instanz: Wir ergänzen einen Punkt, gefolgt vom Methodennamen, Klammern und
Argumenten.</p>
<p>In der Signatur von <code>area</code> verwenden wir <code>&amp;self</code> anstelle von
<code>rectangle: &amp;Rectangle</code>, denn Rust weiß, dass <code>self</code> den Typ <code>Rectangle</code> hat,
da die Methode innerhalb des Kontextes <code>impl Rectangle</code> liegt. Beachte, dass
wir immer noch das <code>&amp;</code> vor <code>self</code> verwenden müssen, so wie wir es bei
<code>&amp;Rectangle</code> getan haben. Methoden können die Eigentümerschaft von <code>self</code>
übernehmen, <code>self</code> unveränderlich ausleihen, wie wir es hier getan haben, oder
<code>self</code> veränderlich ausleihen, so wie bei jedem anderen Parameter auch.</p>
<p>Wir haben hier <code>&amp;self</code> aus dem gleichen Grund gewählt wie <code>&amp;Rectangle</code> in der
Funktionsvariante: Wir wollen keine Eigentümerschaft übernehmen, wir wollen die
Daten der Struktur nur lesen, nicht schreiben. Wenn wir die Instanzdaten ändern
wollten, müssten wir <code>&amp;mut self</code> als ersten Parameter verwenden. Es kommt nur
selten vor, dass eine Methode die Eigentümerschaft der Instanz übernimmt, indem
sie <code>self</code> als ersten Parameter verwendet. Diese Technik wird typischerweise
dann verwendet, wenn die Methode <code>self</code> in etwas anderes transformiert und man
verhindern will, dass der Aufrufer nach der Transformation die ursprüngliche
Instanz verwendet.</p>
<p>Der Hauptvorteil von Methoden gegenüber Funktionen liegt abgesehen davon, dass
bei jeder Methodendeklaration der Typ von <code>self</code> nicht ständig wiederholt
werden muss, in der Organisation. Wir haben alle Dinge, die wir mit einer
Instanz eines Typs tun können, in einen einzigen <code>impl</code> Block gepackt.
Zukünftige Nutzer unseres Codes müssen so nicht an verschiedenen Stellen in der
von uns bereitgestellten Bibliothek nach Fähigkeiten von <code>Rectangle</code> suchen.</p>
<blockquote>
<h3><a class="header" href="#wo-ist-der-operator--" id="wo-ist-der-operator--">Wo ist der Operator <code>-&gt;</code>?</a></h3>
<p>In C und C++ werden zwei verschiedene Operatoren für den Aufruf von Methoden
verwendet: Man verwendet <code>.</code>, wenn eine Methode direkt auf dem Objekt
aufgerufen wird, und <code>-&gt;</code>, wenn die Methode auf einem Zeiger auf das Objekt
aufrufen und der Zeiger zuerst dereferenziert werden muss. Anders gesagt,
wenn <code>object</code> ein Zeiger ist, ist <code>object-&gt;something()</code> ähnlich zu
<code>(*object).something()</code>.</p>
<p>Rust hat kein Äquivalent zum Operator <code>-&gt;</code>. Stattdessen hat Rust eine
Funktionalität namens <em>automatische Referenzierung und Dereferenzierung</em>
(automatic referencing and dereferencing). Der Aufruf von Methoden ist einer
der wenigen Orte in Rust, der dieses Verhalten aufweist.</p>
<p>Und so funktioniert es: Wenn du eine Methode mit <code>object.something()</code>
aufrufst, fügt Rust automatisch <code>&amp;</code>, <code>&amp;mut</code> oder <code>*</code> hinzu, sodass <code>object</code>
zur Signatur der Methode passt. Mit anderen Worten sind folgende Aufrufe
gleich:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>Der erste Aufruf sieht viel sauberer aus. Die automatische Referenzierung
funktioniert, weil Methoden einen eindeutigen Empfänger haben - den Typ von
<code>self</code>. Wenn man den Empfänger und den Namen einer Methode angibt, kann Rust
eindeutig herausfinden, ob die Methode lesend (<code>&amp;self</code>), veränderlich
(<code>&amp;mut self</code>) oder konsumierend (<code>self</code>) ist. Die Tatsache, dass Rust das
Ausleihen für die Methodenempfänger implizit macht, ist ein großer Beitrag
zur Ergonomie der Eigentümerschaft in der Praxis.</p>
</blockquote>
<h3><a class="header" href="#methoden-mit-mehreren-parametern" id="methoden-mit-mehreren-parametern">Methoden mit mehreren Parametern</a></h3>
<p>Lass uns den Umgang mit Methoden üben, indem wir eine zweite Methode zur
Struktur <code>Rectangle</code> implementieren. Diesmal soll eine zweite Instanz von
<code>Rectangle</code> entgegengenommen und <code>true</code> zurückgeben werden, wenn das zweite
<code>Rectangle</code> vollständig in <code>self</code> hineinpasst; andernfalls soll <code>false</code>
zurückgegeben werden. Das heißt, wir wollen in der Lage sein, das in Codeblock
5-14 gezeigte Programm zu schreiben, sobald wir die Methode <code>can_hold</code>
definiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Codeblock 5-14: Verwendung der noch nicht geschriebenen
Methode <code>can_hold</code></span></p>
<p>Die erwartete Ausgabe würde wie folgt aussehen, da beide Dimensionen von
<code>rect2</code> kleiner als die Dimensionen von <code>rect1</code> sind, aber <code>rect3</code> breiter als
<code>rect1</code> ist:</p>
<pre><code class="language-text">Umfasst rect1 rect2? true
Umfasst rect1 rect3? false
</code></pre>
<p>Wir wissen, dass wir eine Methode definieren wollen, also wird sie innerhalb
des Blocks <code>impl Rectangle</code> liegen. Die Methode wird <code>can_hold</code> heißen und sie
wird einen weiteren Parameter vom Typ <code>Rectangle</code> unveränderlich ausleihen. Wir
können den Typ des Parameters erkennen, indem wir uns den Code ansehen, der die
Methode aufruft: <code>rect1.can_hold(&amp;rect2)</code> nimmt <code>&amp;rect2</code> entgegen, also eine
unveränderliche Ausleihe von <code>rect2</code> vom Typ <code>Rectangle</code>. Das macht Sinn, da
wir <code>rect2</code> nur lesen müssen (anstatt zu schreiben, wofür wir eine
veränderliche Ausleihe bräuchten) und <code>main</code> die Eigentümerschaft an <code>rect2</code>
zurückerhalten soll, so dass wir es nach dem Aufruf der Methode <code>can_hold</code>
weiter verwenden können. Der Rückgabewert von <code>can_hold</code> ist ein boolescher
Wert und die Implementierung prüft, ob Breite und Höhe von <code>self</code> jeweils
größer als von <code>Rectangle</code> sind. Fügen wir die neue Methode <code>can_hold</code> zum
Block <code>impl</code> aus Codeblock 5-13 hinzu, wie in Codeblock 5-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-15: Implementierung der Methode <code>can_hold</code>
auf <code>Rectangle</code>, die eine weitere <code>Rectangle</code>-Instanz als Parameter hat</span></p>
<p>Wenn wir diesen Code mit der Funktion <code>main</code> in Codeblock 5-14 ausführen,
erhalten wir die gewünschte Ausgabe. Methoden können mehrere Parameter haben,
die wir in der Signatur nach dem Parameter <code>self</code> angeben. Diese Parameter
funktionieren genau wie Parameter in Funktionen.</p>
<h3><a class="header" href="#assoziierte-funktionen" id="assoziierte-funktionen">Assoziierte Funktionen</a></h3>
<p>Eine weitere nützliche Funktionalität von <code>impl</code>-Blöcken ist, dass wir darin
auch Funktionen <em>ohne</em> den Parameter <code>self</code> definieren können. Diese werden
<em>assoziierte Funktionen</em> (associated functions) genannt, weil sie mit der
Struktur assoziiert sind. Dabei handelt es sich um Funktionen, nicht um
Methoden, weil sie nicht auf einer Instanz der Struktur arbeiten können. Du
hast bereits die assoziierte Funktion <code>String::from</code> verwendet.</p>
<p>Assoziierte Funktionen werden oft als Konstruktoren verwendet, die eine neue
Instanz der Struktur zurückgeben. Zum Beispiel könnten wir eine assoziierte
Funktion bereitstellen, die einen eindimensionalen Parameter hat und diesen
sowohl als Breite als auch als Höhe verwendet, wodurch auf einfache Weise ein
quadratisches <code>Rectangle</code> erzeugt werden kann, ohne denselben Wert zweimal
angeben zu müssen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>Um diese assoziierte Funktion aufzurufen, verwenden wir die Syntax <code>::</code> mit dem
Strukturnamen, z.B. <code>let sq = Rectangle::square(3);</code>. Diese Funktion gehört zum
Namensraum der Struktur: Die Syntax <code>::</code> wird sowohl für assoziierte Funktionen
als auch für Namensräume, die von Modulen erzeugt werden, verwendet. Wir werden
die Module in Kapitel 7 besprechen.</p>
<h3><a class="header" href="#mehrere-impl-blöcke" id="mehrere-impl-blöcke">Mehrere <code>impl</code>-Blöcke</a></h3>
<p>Jede Struktur darf mehrere <code>impl</code>-Blöcke haben. Beispielsweise entspricht
Codeblock 5-15 dem in Codeblock 5-16 gezeigten Code, bei dem jede Methode in
einem eigenen <code>impl</code>-Block steht.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-16: Neuschreiben von Codeblock 5-15 unter
Verwendung mehrerer <code>impl</code>-Blöcke</span></p>
<p>Es ist nicht nötig, diese Methoden hier auf mehrere <code>impl</code>-Blöcke zu verteilen,
aber es handelt sich um eine gültige Syntax. Wir werden in Kapitel 10 einen
Fall sehen, bei dem mehrere <code>impl</code>-Blöcke hilfreich sind, wenn wir generische
Typen und Merkmale behandeln.</p>
<h2><a class="header" href="#zusammenfassung-4" id="zusammenfassung-4">Zusammenfassung</a></h2>
<p>Mit Strukturen kannst du benutzerdefinierte Typen erstellen, die in deiner
Domäne eine Bedeutung haben. Durch die Verwendung von Strukturen kannst du
zusammengehörige Datenteile miteinander verbunden halten und jedes Teil
benennen, um deinen Code verständlich zu machen. Mit Methoden kannst du das
Verhalten von Instanzen deiner Strukturen spezifizieren und mit assoziierten
Funktionen kannst du Funktionalität zum Namensraum deiner Struktur hinzufügen,
die ohne Instanz auskommen.</p>
<p>Aber Strukturen sind nicht die einzige Möglichkeit, benutzerdefinierte Typen zu
definieren: Wenden wir uns der Rust-Funktionalität Aufzählung zu, um ein
weiteres Werkzeug in deinen Werkzeugkasten zu legen.</p>
<h1><a class="header" href="#aufzählungen-enums-und-musterabgleich-pattern-matching" id="aufzählungen-enums-und-musterabgleich-pattern-matching">Aufzählungen (enums) und Musterabgleich (pattern matching)</a></h1>
<p>In diesem Kapitel werden wir uns mit <em>Aufzählungen</em> (enumerations, kurz: enums)
befassen. Aufzählungen erlauben es, einen Typ durch Aufzählung seiner möglichen
<em>Varianten</em> (variants) zu definieren. Zuerst werden wir eine Aufzählung
definieren und verwenden, um zu zeigen, wie eine Aufzählung mit Daten eine
Bedeutung kodieren kann. Als Nächstes werden wir eine besonders nützliche
Aufzählung untersuchen, die <code>Option</code> genannt wird und zum Ausdruck bringt, dass
ein Wert entweder etwas oder nichts sein kann. Dann sehen wir uns an, wie man
mit dem Musterabgleich (pattern matching) im Ausdruck <code>match</code> auf einfache
Weise unterschiedlichen Code für verschiedene Werte einer Aufzählung
auszuführen kann. Schließlich werden wir uns mit dem Konstrukt <code>if let</code>
befassen, einem weiteren bequemen und prägnanten Idiom, das dir zur Verfügung
steht, um mit Aufzählungen in deinem Code umzugehen.</p>
<p>Aufzählungen sind eine Funktionalität in vielen Sprachen, aber deren
Möglichkeiten unterscheiden sich in jeder Sprache. Rusts Aufzählungen sind den
<em>algebraischen Datentypen</em> in funktionalen Sprachen wie F#, OCaml und Haskell
am ähnlichsten.</p>
<h2><a class="header" href="#eine-aufzählung-enum-definieren" id="eine-aufzählung-enum-definieren">Eine Aufzählung (enum) definieren</a></h2>
<p>Schauen wir uns eine Situation an, die wir mit Code ausdrücken wollen, bei der
Aufzählungen (enums) nützlich und geeigneter sind als Strukturen (structs).
Angenommen, wir müssen mit IP-Adressen arbeiten. Aktuell werden zwei
Hauptstandards für IP-Adressen verwendet: Version vier und Version sechs. Das
sind die einzigen Möglichkeiten einer IP-Adresse, mit denen unser Programm zu
tun haben wird: Wir können alle möglichen Varianten <em>aufzählen</em>, daher auch der
Name der Aufzählung.</p>
<p>Jede IP-Adresse kann entweder eine Adresse der Version vier oder der Version
sechs sein, aber nicht beides gleichzeitig. Diese Eigenschaft der IP-Adressen
passt zur Aufzählungs-Datenstruktur, da Aufzählungswerte nur eine ihrer
Varianten sein können. Sowohl die Adressen der Version vier als auch der
Version sechs sind grundsätzlich immer noch IP-Adressen, so dass sie als der
gleiche Typ behandelt werden sollten, wenn der Code mit Situationen zu tun hat,
die für beide IP-Adressenarten gelten.</p>
<p>Wir können dieses Konzept im Code ausdrücken, indem wir eine Aufzählung
<code>IpAddrKind</code> definieren und die möglichen Varianten auflisten, die eine
IP-Adresse haben kann, <code>V4</code> und <code>V6</code>. Hier die Varianten der Aufzählung:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> ist jetzt ein benutzerdefinierter Datentyp, den wir an anderer
Stelle in unserem Code verwenden können.</p>
<h3><a class="header" href="#werte-in-aufzählungen" id="werte-in-aufzählungen">Werte in Aufzählungen</a></h3>
<p>Wir können Instanzen von beiden Varianten von <code>IpAddrKind</code> wie folgt erstellen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Beachte, dass die Varianten der Aufzählung mit dem Namensraum des Bezeichners
angegeben sind und wir einen doppelten Doppelpunkt verwenden, um die beiden zu
trennen. Das ist sinnvoll, weil beide Werte <code>IpAddrKind::V4</code> und
<code>IpAddrKind::V6</code> vom gleichen Typ sind: <code>IpAddrKind</code>. Wir können dann zum
Beispiel eine Funktion definieren, die jedes <code>IpAddrKind</code> annimmt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Und wir können diese Funktion mit beiden Varianten aufrufen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Aufzählungen haben noch weitere Vorteile. Wenn wir weiter über unseren
IP-Adresstyp nachdenken, haben wir im Moment keine Möglichkeit, den <em>Wert</em> der
tatsächlichen IP-Adresse zu speichern; wir wissen nur, um welche <em>Variante</em> es
sich handelt. Mit dem was du gerade erst in Kapitel 5 über Strukturen gelernt
hast, könntest du dieses Problem wie in Codeblock 6-1 dargestellt angehen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-1: Speichern des Wertes und der
<code>IpAddrKind</code>-Variante einer IP-Adresse mittels <code>struct</code></span></p>
<p>Hier haben wir eine Struktur <code>IpAddr</code> definiert, die zwei Felder hat:  Ein Feld
<code>kind</code> vom Typ <code>IpAddrKind</code> (die zuvor definierte Aufzählung) und ein Feld
<code>address</code> vom Typ <code>String</code>. Wir haben zwei Instanzen dieser Struktur erzeugt.
Die erste, <code>home</code>, hat die Variante <code>IpAddrKind::V4</code> und die zugehörige Adresse
<code>127.0.0.1</code>. Die zweite Instanz, <code>loopback</code>, hat die Variante <code>V6</code> von
<code>IpAddrKind</code> als ihren Wert für <code>kind</code> und die zugehörige Adresse <code>::1</code>. Wir
haben eine Struktur verwendet, um die Werte <code>kind</code> und <code>address</code> zu bündeln, so
dass jetzt die Variante mit dem Wert verbunden ist.</p>
<p>Wir können dasselbe Konzept prägnanter darstellen, indem wir nur eine
Aufzählung, anstelle einer Aufzählung innerhalb einer Struktur, verwenden,
indem wir Daten direkt in jede Aufzählungsvariante einfügen. Diese neue
Definition der Aufzählung <code>IpAddr</code> legt fest, dass sowohl die Variante <code>V4</code> als
auch <code>V6</code> zugehörige <code>String</code>-Werte haben:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir hängen die Daten direkt an jede Variante der Aufzählung an, so dass keine
zusätzliche Struktur erforderlich ist.</p>
<p>Es gibt noch einen weiteren Vorteil, eine Aufzählung statt einer Struktur zu
verwenden: Jede Variante kann verschiedene Typen und verschieden viele
zugehöriger Daten haben. IP-Adressen der Version vier haben stets vier
numerische Komponenten, die Werte zwischen 0 und 255 haben. Wenn wir
<code>V4</code>-Adressen als vier <code>u8</code>-Werte speichern und <code>V6</code>-Adressen als einen
<code>String</code>-Wert ausdrücken wollten, wäre das mit einer Struktur nicht möglich.
Aufzählungen lösen diesen Fall ganz einfach:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben verschiedene Möglichkeiten zur Definition von Datenstrukturen
gezeigt, die Version vier und sechs einer IP-Adresse speichern können.
Wie sich jedoch herausstellt, ist der Wunsch, IP-Adressen inklusive deren
Variante zu speichern, so verbreitet, dass <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">die Standardbibliothek eine
Definition bereitstellt</a>, die wir verwenden können! Schauen wir uns an,
wie die Standardbibliothek <code>IpAddr</code> definiert: Es hat genau die Aufzählung und
die Varianten, die wir definiert und verwendet haben, aber es bettet die
Adressdaten innerhalb der Varianten in Form von zwei verschiedenen Strukturen
ein, die für jede Variante unterschiedlich definiert sind:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code veranschaulicht, dass du jede Art von Daten in eine
Aufzählungsvariante einfügen kannst: Zeichenketten, numerische Typen,
Strukturen usw. Du kannst sogar eine weitere Aufzählung einfügen! Außerdem sind
Standardbibliothekstypen oft nicht viel komplizierter als das, was du dir
vielleicht ausdenkst. Beachte, dass wir, obwohl die Standardbibliothek eine
Definition für <code>IpAddr</code> enthält, konfliktfrei unsere eigene Definition
erstellen und verwenden können, da wir die Definition der Standardbibliothek
nicht in unseren Gültigkeitsbereich aufgenommen haben. Wir werden in Kapitel 7
mehr darauf eingehen, wie man Typen in den Gültigkeitsbereich aufnimmt.</p>
<p>Schauen wir uns ein weiteres Beispiel für eine Aufzählung in Codeblock 6-2 an:
In dieser Aufzählung ist eine Vielzahl von Typen in ihren Varianten eingebettet.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-2: Eine Aufzählung <code>Message</code>, deren Varianten
jeweils eine unterschiedliche Anzahl an Werttypen speichern</span></p>
<p>Diese Aufzählung hat vier Varianten mit unterschiedlichen Typen:</p>
<ul>
<li><code>Quit</code> hat überhaupt keine Daten.</li>
<li><code>Move</code> enthält eine anonyme Struktur.</li>
<li><code>Write</code> enthält einen einzelnen <code>String</code>.</li>
<li><code>ChangeColor</code> enthält drei <code>i32</code>-Werte.</li>
</ul>
<p>Die Definition einer Aufzählung mit Varianten wie in Codeblock 6-2 ist ähnlich
zur Definition verschiedener Arten von Strukturdefinitionen, außer dass die
Aufzählung nicht das Schlüsselwort <code>struct</code> verwendet und alle Varianten unter
dem Typ <code>Message</code> zusammengefasst sind. Die folgenden Strukturen könnten die
gleichen Daten aufnehmen wie die vorhergehenden Aufzählungsvarianten:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // leere Struktur
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // Tupelstruktur
struct ChangeColorMessage(i32, i32, i32); // Tupelstruktur
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Aber wenn wir die verschiedenen Strukturen verwenden würden, die jeweils ein
eigener Typ sind, könnten wir nicht so einfach eine Funktion definieren, die
eine dieser Nachrichtenarten entgegennimmt, wie wir es mit der in Codeblock 6-2
definierten Aufzählung <code>Message</code> gemacht haben, bei der es sich um einen
einzigen Typ handelt.</p>
<p>Es gibt noch eine weitere Ähnlichkeit zwischen Aufzählungen und Strukturen: So
wie wir Methoden für Strukturen mit <code>impl</code> definieren können, können wir auch
Methoden für Aufzählungen definieren. Hier ist eine Methode namens <code>call</code>, die
wir für unsere Aufzählung <code>Message</code> definieren könnten:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // Methodenrumpf
        }
    }

    let m = Message::Write(String::from(&quot;hallo&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Der Methodenrumpf würde <code>self</code> benutzen, um den Wert zu erhalten, auf den wir
die Methode aufgerufen haben. In diesem Beispiel haben wir eine Variable <code>m</code>
erstellt, die den Wert <code>Message::Write(String::from(&quot;hallo&quot;))</code> hat. Genau
diesen Wert wird <code>self</code> im Rumpf der Methode <code>call</code> haben, wenn <code>m.call()</code>
ausgeführt wird.</p>
<p>Sehen wir uns eine weitere Aufzählung in der Standardbibliothek an, die sehr
verbreitet und hilfreich ist: <code>Option</code></p>
<h3><a class="header" href="#die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten" id="die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten">Die Aufzählung <code>Option</code> und ihre Vorteile gegenüber Nullwerten</a></h3>
<p>Im vorigen Abschnitt haben wir uns angesehen, wie es die Aufzählung <code>IpAddr</code>
ermöglicht, Rusts Typsystem zu verwenden, um mehr Informationen als nur die
Daten in unserem Programm zu kodieren. Dieser Abschnitt befasst sich mit einer
Fallstudie zu <code>Option</code>, einer weiteren Aufzählung, die von der
Standardbibliothek definiert wird. Der Typ <code>Option</code> wird an vielen Stellen
verwendet, weil er das sehr häufige Szenario abbildet, in dem ein Wert etwas
oder nichts sein könnte. Im Sinne des Typsystems bedeutet das, dass der
Compiler überprüfen kann, ob du alle Fälle behandelt hast, die du behandelt
sollst. Diese Funktionalität kann Fehler vermeiden, die in anderen
Programmiersprachen extrem häufig auftreten.</p>
<p>Bei der Entwicklung von Programmiersprachen wird oft überlegt, welche
Funktionalität aufgenommen werden soll, aber auch die auszuschließende
Funktionalität ist wichtig. Rust hat nicht die Funktionalität „null“, die es in
vielen anderen Sprachen gibt. <em>Null</em> ist ein Wert, der bedeutet, dass kein Wert
vorhanden ist. In Sprachen mit null können sich Variablen immer in einem von
zwei Zuständen befinden: null oder nicht null.</p>
<p>In seinem Vortrag „Nullreferenzen: Der milliardenschwere Fehler“ von 2009 hat
Tony Hoare, der Erfinder von null, folgendes gesagt:</p>
<blockquote>
<p>Ich nenne es meinen milliardenschweren Fehler. Zu dieser Zeit entwarf ich das
erste umfangreiche Typsystem für Referenzen in einer objektorientierten
Sprache. Mein Ziel war es, sicherzustellen, dass jede Verwendung von
Referenzen absolut sicher sein sollte, wobei die Überprüfung automatisch
durch den Compiler durchgeführt wird. Aber ich konnte der Versuchung nicht
widerstehen, eine Nullreferenz einzuführen, nur weil sie so einfach
umzusetzen war. Dies hat zu unzähligen Fehlern, Schwachstellen und
Systemabstürzen geführt, die in den letzten vierzig Jahren wahrscheinlich
eine Milliarde Dollar Schmerz und Schaden verursacht haben.</p>
</blockquote>
<p>Das Problem mit Nullwerten besteht darin, dass du einen Fehler erhältst, wenn
du versuchst, einen Nullwert als Nicht-Nullwert zu verwenden. Da diese Null-
oder Nicht-Null-Eigenschaft allgegenwärtig ist, ist es extrem einfach, einen
derartigen Fehler zu machen.</p>
<p>Das Konzept, das die Null zum Ausdruck bringen will, ist jedoch nach wie vor
nützlich: Null ist ein Wert, der aktuell ungültig ist oder aus irgendeinem
Grund nicht vorhanden ist.</p>
<p>Das Problem liegt nicht wirklich im Konzept, sondern in der konkreten
Umsetzung. Als solches hat Rust keine Nullen, aber es hat eine Aufzählung, die
das Konzept des Vorhandenseins oder Nichtvorhandenseins eines Wertes abbilden
kann. Diese Aufzählung heißt <code>Option&lt;T&gt;</code> und ist
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">in der Standardbibliothek</a> wie folgt definiert:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Aufzählung <code>Option&lt;T&gt;</code> ist so nützlich, dass sie sogar im Präludium
enthalten ist; du musst sie nicht explizit in den Anwendungsbereich aufnehmen.
Dasselbe gilt für ihre Varianten: Du kannst <code>Some</code> und <code>None</code> direkt ohne
Präfix <code>Option::</code> verwenden. Die Aufzählung <code>Option&lt;T&gt;</code> ist dennoch nur eine
normale Aufzählung, und <code>Some(T)</code> und <code>None</code> sind nur Varianten des Typs
<code>Option&lt;T&gt;</code>.</p>
<p>Die Syntax <code>&lt;T&gt;</code> ist eine Funktionalität von Rust, über die wir noch nicht
gesprochen haben. Es handelt sich um einen generischen Typparameter, auf den
wir in Kapitel 10 näher eingehen werden. Für den Moment musst du nur wissen,
dass <code>&lt;T&gt;</code> bedeutet, dass die Variante <code>Some</code> der Aufzählung <code>Option</code> einen
Wert eines beliebigen Typs enthalten kann. Hier sind einige Beispiele für die
Verwendung von <code>Option</code>-Werten zur Aufnahme von Zahlentypen und
Zeichenkettentypen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;eine Zeichenkette&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>None</code> anstelle von <code>Some</code> verwenden, müssen wir Rust sagen, welchen
Typ von <code>Option&lt;T&gt;</code> wir haben, weil der Compiler nicht auf den Typ schließen
kann, den die Variante <code>Some</code> haben soll, wenn er nur einen Wert <code>None</code> sieht.</p>
<p>Wenn wir einen Wert <code>Some</code> haben, wissen wir, dass ein Wert vorhanden ist und
der Wert innerhalb von <code>Some</code> gehalten wird. Wenn wir einen Wert <code>None</code> haben,
bedeutet das in gewisser Weise dasselbe wie Null: Wir haben keinen gültigen
Wert. Warum ist nun besser <code>Option&lt;T&gt;</code> anstelle von Null zu verwenden?</p>
<p>Kurz gesagt, weil <code>Option&lt;T&gt;</code> und <code>T</code> (wobei <code>T</code> ein beliebiger Typ sein kann)
unterschiedliche Typen sind, erlaubt es der Compiler nicht <code>Option&lt;T&gt;</code> so zu
verwenden als wäre es definitiv ein gültiger Wert. Beispielsweise lässt sich
dieser Code nicht kompilieren, weil er versucht, ein <code>i8</code> mit einem
<code>Option&lt;i8&gt;</code> zu addieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir diesen Code ausführen, erhalten wir eine Fehlermeldung wie diese:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Stark! Tatsächlich bedeutet diese Fehlermeldung, dass Rust nicht versteht, wie
man ein <code>i8</code> und eine <code>Option&lt;i8&gt;</code> addiert, da es sich um unterschiedliche Typen
handelt. Wenn wir einen Wert eines Typs wie <code>i8</code> in Rust haben, stellt der
Compiler sicher, dass wir immer einen gültigen Wert haben. Wir können mit
Zuversicht vorgehen, ohne vor der Verwendung dieses Wertes auf Null prüfen zu
müssen. Nur wenn wir eine <code>Option&lt;i8&gt;</code> (oder einen anderen Werttyp) haben,
müssen wir befürchten, dass wir möglicherweise keinen Wert haben, und der
Compiler wird sicherstellen, dass wir diesen Fall behandeln, bevor wir den
Wert verwenden.</p>
<p>Mit anderen Worten musst du eine <code>Option&lt;T&gt;</code> in ein <code>T</code> konvertieren, bevor du
<code>T</code>-Operationen damit durchführen kannst. Im Allgemeinen hilft dies, eines der
häufigsten Probleme mit Null abzufangen: Anzunehmen, dass etwas nicht null ist,
obwohl es tatsächlich null ist.</p>
<p>Wenn du dir keine Sorgen machen musst, dass fälschlicherweise ein
Nicht-Null-Wert angenommen wird, hilft dir das mehr Vertrauen in deinen Code zu
haben. Um einen Wert zu haben, der möglicherweise null sein kann, musst du dich
explizit dafür entscheiden, indem du als Typ <code>Option&lt;T&gt;</code> verwendest. Wenn du
dann diesen Wert verwendest, musst du den Fall null explizit behandeln. Überall
dort, wo ein Wert nicht den Typ <code>Option&lt;T&gt;</code> hat, kannst du <em>sicher</em> sein, dass
der Wert nicht null ist. Dies war eine bewusste Konstruktionsentscheidung bei 
Rust, um die Verbreitung von Null einzuschränken und die Sicherheit von
Rust-Code zu erhöhen.</p>
<p>Wie erhältst du nun den <code>T</code>-Wert aus einer Variante <code>Some</code>, wenn du einen Wert
vom Typ <code>Option&lt;T&gt;</code> hast? Die Aufzählung <code>Option&lt;T&gt;</code> enthält eine große Anzahl
von Methoden, die in einer Vielzahl von Situationen nützlich sind; mehr dazu
findest du in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">der Dokumentation</a>. Sich mit den Methoden von <code>Option&lt;T&gt;</code>
vertraut zu machen, wird dir auf deiner Reise mit Rust äußerst nützlich sein.</p>
<p>Um einen <code>Option&lt;T&gt;</code>-Wert zu verwenden, benötigst du im Allgemeinen Code, der
jede Variante behandelt. Du möchtest einen Code, der nur läuft, wenn du einen
Wert <code>Some(T)</code> hast, und dieser Code darf das innere <code>T</code> benutzen. Du möchtest,
dass ein anderer Code ausgeführt wird, wenn du einen Wert <code>None</code> hast, und
dieser Code hat keinen <code>T</code>-Wert. Der Ausdruck <code>match</code> ist ein
Kontrollflusskonstrukt, das genau dies tut, wenn es mit Aufzählungen verwendet
wird: Es führt unterschiedlichen Code aus, je nachdem, welche Variante der
Aufzählung es hat, und dieser Code kann die Daten innerhalb des passenden
Wertes verwenden.</p>
<h2><a class="header" href="#der-kontrollflussoperator-match" id="der-kontrollflussoperator-match">Der Kontrollflussoperator <code>match</code></a></h2>
<p>Rust verfügt über einen extrem leistungsfähigen Kontrollflussoperator namens
<code>match</code>, der es dir ermöglicht, einen Wert mit einer Reihe von Mustern
abzugleichen und dann Code zum jeweils passenden Muster auszuführen. Muster
können sich aus Literalen, Variablennamen, Platzhaltern und vielen anderen
Dingen zusammensetzen. Kapitel 18 befasst sich mit all den verschiedenen
Musterarten und wie sie funktionieren. Die Mächtigkeit von <code>match</code> kommt von
der Ausdruckskraft der Muster und der Tatsache, dass der Compiler
sicherstellt, dass alle möglichen Fälle behandelt werden.</p>
<p>Stelle dir einen <code>match</code>-Ausdruck wie eine Münzsortiermaschine vor:  Die Münzen
rutschen eine Bahn mit unterschiedlich großen Löchern entlang, und jede Münze
fällt durch das erste Loch, in das sie hineinpasst. Auf die gleiche Weise
durchlaufen die Werte die Muster in einem <code>match</code>-Ausdruck und beim ersten
„passenden“ Muster fällt der Wert in den zugehörigen Codeblock, der ausgeführt
werden soll.</p>
<p>Da wir eben Münzen erwähnt haben, nehmen wir sie als Beispiel für die
Verwendung von <code>match</code>! Wir können eine Funktion schreiben, die eine unbekannte
Münze der Vereinigten Staaten nimmt und, ähnlich wie die Zählmaschine,
bestimmt, um welche Münze es sich handelt und ihren Wert in Cent zurückgibt,
wie hier in Codeblock 6-3 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-3: Eine Aufzählung und ein <code>match</code>-Ausdruck,
der die Varianten der Aufzählung als Muster hat</span></p>
<p>Lass uns den <code>match</code>-Ausdruck in der Funktion <code>value_in_cents</code> aufschlüsseln. 
Zuerst geben wir das Schlüsselwort <code>match</code> an, gefolgt von einem Ausdruck, der
in diesem Fall der Wert <code>coin</code> ist. Dies scheint einem Ausdruck sehr ähnlich zu
sein, der bei <code>if</code> verwendet wird, aber es gibt einen großen Unterschied: Bei
<code>if</code> muss der Ausdruck einen booleschen Wert zurückgeben, aber hier kann es
sich um einen beliebigen Typ handeln. Der Typ von <code>coin</code> ist in diesem Beispiel
die Aufzählung <code>Coin</code>, die wir in Zeile 1 definiert haben.</p>
<p>Als nächstes kommen die <code>match</code>-Zweige. Ein Zweig hat zwei Teile: Ein Muster
und etwas Code. Der erste Zweig hat als Muster den Wert <code>Coin::Penny</code>, dann den
Operator <code>=&gt;</code>, der das Muster und den auszuführenden Code trennt. Der Code ist
in diesem Fall nur der Wert <code>1</code>. Jeder Zweig wird durch ein Komma vom nächsten
getrennt.</p>
<p>Wenn der <code>match</code>-Ausdruck ausgeführt wird, gleicht er den resultierenden Wert
mit dem Muster jedes Zweigs ab, und zwar der Reihe nach. Wenn ein Muster zum
Wert passt, wird der zu diesem Muster gehörende Code ausgeführt. Wenn das
Muster nicht zum Wert passt, wird die Ausführung beim nächsten Zweig
fortgesetzt, ähnlich wie bei einer Münzsortiermaschine. Wir können so viele
Zweige haben, wie wir brauchen: In Codeblock 6-3 hat unser <code>match</code>-Ausdruck
vier Zweige.</p>
<p>Der zu jedem Zweig gehörende Code ist ein Ausdruck, und der resultierende Wert
des Ausdrucks im zugehörenden Zweig ist der Wert, der für den gesamten
<code>match</code>-Ausdruck zurückgegeben wird. </p>
<p>Geschweifte Klammern werden in der Regel nicht verwendet, wenn der Zweig-Code
kurz ist, so wie in Codeblock 6-3, wo jeder Zweig nur einen Wert zurückgibt.
Wenn du mehrere Codezeilen in einem Zweig ausführen möchtest, kannst du
geschweifte Klammern verwenden. Zum Beispiel würde der folgende Code jedes Mal
&quot;Glückspfennig!&quot; ausgeben, wenn die Methode mit <code>Coin::Penny</code> aufgerufen wird,
aber immer noch als letzten Wert des Blocks <code>1</code> zurückgeben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Glückspfennig!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#muster-die-werte-binden" id="muster-die-werte-binden">Muster, die Werte binden</a></h3>
<p>Ein weitere nützliche Funktionalität von <code>match</code>-Zweigen ist, dass sie Teile
der Werte binden können, die dem Muster entsprechen. Auf diese Weise können wir
Werte aus Aufzählungsvarianten extrahieren.</p>
<p>Lass uns als Beispiel eine unserer Aufzählungsvarianten so ändern, dass sie
Daten enthält. Von 1999 bis 2008 prägten die Vereinigten Staaten 25-Cent-Münzen
mit unterschiedlichem Aussehen auf einer Seite für jeden der 50 Staaten. Keine
andere Münze hatte ein Staaten-spezifisches Aussehen, sodass nur 25-Cent-Münzen
diese zusätzliche Eigenschaft haben. Wir können diese Information in unserer
Aufzählung unterbringen, indem wir die Variante <code>Quarter</code> so ändern, dass sie
einen <code>UsState</code>-Wert enthält, wie in Codeblock 6-4 umgesetzt.</p>
<pre><pre class="playground"><code class="language-rust">enum UsState {
    Alabama,
    Alaska,
    // --abschneiden--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-4: Aufzählung <code>Coin</code>, bei der die Variante
<code>Quarter</code> zusätzlich einen <code>UsState</code>-Wert enthält</span></p>
<p>Stellen wir uns vor, dass ein Freund von uns versucht, 25-Cent-Münzen aller 50
Staaten zu sammeln. Während wir unser Kleingeld nach Münzsorten sortieren,
geben wir auch den Namen des Staates der 25-Cent-Münze aus, sodass es unser
Freund in seine Sammlung aufnehmen kann, falls er es nicht hat. Im
<code>match</code>-Ausdruck für diesen Code fügen wir zum Muster der Variante
<code>Coin::Quarter</code> eine Variable <code>state</code> hinzu. Wenn der Zweig für <code>Coin::Quarter</code>
passt, wird die Variable <code>state</code> an den Wert der Eigenschaft der 25-Cent-Münze
gebunden. Dann können wir <code>state</code> im Code für diesen Zweig etwa so verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // um den Staat mit println! ausgeben zu können
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> aufrufen würden,
hätte <code>coin</code> den Wert <code>Coin::Quarter(UsState::Alaska)</code>. Gleichen wir den Wert
mit jedem der <code>match</code>-Zweige ab, passt keiner von ihnen, bis wir
<code>Coin::Quarter(state)</code> erreichen. An diesem Punkt wird <code>state</code> an den Wert
<code>UsState::Alaska</code> gebunden. Wir können dann diese Bindung im
<code>println!</code>-Ausdruck verwenden und so den inneren Zustandswert aus der
<code>Coin</code>-Aufzählungsvariante für <code>Quarter</code> herausholen.</p>
<h3><a class="header" href="#abgleich-mit-optiont" id="abgleich-mit-optiont">Abgleich mit <code>Option&lt;T&gt;</code></a></h3>
<p>Im vorigen Abschnitt wollten wir den inneren <code>T</code>-Wert aus dem Fall <code>Some</code>
herausholen, als wir <code>Option&lt;T&gt;</code> verwendet haben. Wir können <code>Option&lt;T&gt;</code> ebenso
mit <code>match</code> handhaben, wie wir es mit der Aufzählung <code>Coin</code> getan haben! Statt
Münzen zu vergleichen, werden wir die Varianten von <code>Option&lt;T&gt;</code> vergleichen,
aber die Art und Weise, wie der <code>match</code>-Ausdruck funktioniert, bleibt die
gleiche.</p>
<p>Nehmen wir an, wir wollen eine Funktion schreiben, die eine <code>Option&lt;i32&gt;</code> nimmt
und, falls ein Wert darin enthalten ist, zu diesem Wert 1 addiert. Wenn darin
kein Wert enthalten ist, soll die Funktion den Wert <code>None</code> zurückgeben und
nicht versuchen, irgendwelche Operationen durchzuführen.</p>
<p>Diese Funktion ist dank <code>match</code> sehr einfach zu schreiben und wird wie in
Codeblock 6-5 aussehen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-5: Eine Funktion, die einen <code>match</code>-Ausdruck
auf einer <code>Option&lt;i32&gt;</code> verwendet</span></p>
<p>Lass uns die erste Ausführung von <code>plus_one</code> näher betrachten. Wenn wir
<code>plus_one(five)</code> aufrufen, wird die Variable <code>x</code> im Rumpf von <code>plus_one</code> den
Wert <code>Some(5)</code> haben. Dann vergleichen wir das mit jedem <code>match</code>-Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Der Wert <code>Some(5)</code> passt nicht zum Muster <code>None</code>, also fahren wir mit dem
nächsten Zweig fort.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Passt <code>Some(5)</code> zu <code>Some(i)</code>? Aber ja, das tut es! Wir haben die gleiche
Variante. <code>i</code> bindet den in <code>Some</code> enthaltenen Wert, sodass <code>i</code> den Wert <code>5</code>
annimmt. Dann wird der Code im <code>match</code>-Zweig ausgeführt, also fügen wir 1 zum
Wert von <code>i</code> hinzu und erzeugen einen neuen <code>Some</code>-Wert mit der Summe <code>6</code>
darin.</p>
<p>Betrachten wir nun den zweiten Aufruf von <code>plus_one</code> in Codeblock 6-5, wo <code>x</code>
den Wert <code>None</code> hat. Wir betreten den <code>match</code>-Block und vergleichen mit dem
ersten Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Er passt! Es gibt keinen Wert zum Hinzufügen, also stoppt das Programm und gibt
den Wert <code>None</code> auf der rechten Seite von <code>=&gt;</code> zurück. Da der erste Zweig
passt, werden keine anderen Zweige abgeglichen.</p>
<p>Die Kombination von <code>match</code> und Aufzählungen ist in vielen Situationen
nützlich. Du wirst dieses Muster häufig in Rust-Code sehen: <code>match</code> mit einer
Aufzählung, eine Variable an die darin enthaltenen Daten binden und dann
dazugehörenden Code ausführen. Am Anfang ist es etwas knifflig, aber wenn man
sich erst einmal daran gewöhnt hat, wird man sich wünschen, es in allen
Sprachen zu haben. Es ist durchweg ein Benutzerfavorit.</p>
<h3><a class="header" href="#abgleiche-sind-vollständig" id="abgleiche-sind-vollständig">Abgleiche sind vollständig</a></h3>
<p>Es gibt noch einen weiteren Aspekt von <code>match</code>, den wir besprechen müssen.
Betrachte folgende Version unserer Funktion <code>plus_one</code>, die einen Fehler hat
und sich nicht kompilieren lässt:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben den Fall <code>None</code> nicht behandelt, daher wird dieser Code einen Fehler
verursachen. Glücklicherweise ist es ein Fehler, von dem Rust weiß, wie er
zu lösen ist. Wenn wir versuchen, diesen Code zu kompilieren, werden wir
diese Fehlermeldung bekommen:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust weiß, dass wir nicht alle möglichen Fälle abgedeckt haben, und es weiß
sogar, welches Muster wir vergessen haben! Abgleiche in Rust sind
<em>vollständig</em>: Wir müssen jede letzte Möglichkeit ausschöpfen, damit der Code
gültig ist! Speziell im Fall <code>Option&lt;T&gt;</code> schützt uns Rust davor, den Fall
<code>None</code> zu übersehen, und davon auszugehen, dass wir einen Wert haben, obwohl
vielleicht null vorliegt, und macht so den zuvor besprochenen Milliardenfehler
unmöglich.</p>
<h3><a class="header" href="#der-platzhalter-_" id="der-platzhalter-_">Der Platzhalter <code>_</code></a></h3>
<p>Rust hat auch ein Muster, das wir verwenden können, wenn wir nicht alle möglichen
Werte auflisten wollen. Zum Beispiel kann ein <code>u8</code> gültige Werte von 0 bis 255
haben. Wenn wir uns nur um die Werte 1, 3, 5 und 7 kümmern, wollen wir nicht 0,
2, 4, 6, 8, 9 bis hin zu 255 aufzählen müssen. Zum Glück müssen wir das nicht:
Wir können stattdessen das spezielle Muster <code>_</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;eins&quot;),
    3 =&gt; println!(&quot;drei&quot;),
    5 =&gt; println!(&quot;fünf&quot;),
    7 =&gt; println!(&quot;sieben&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>Das Muster <code>_</code> passt zu jedem Wert. Wenn wir es unter unsere anderen Zweige
setzen, wird <code>_</code> auf alle möglichen Fälle passen, die davor nicht angegeben
wurden. <code>()</code> ist nur der leere Wert, so dass im Fall <code>_</code> nichts passieren wird.
Damit können wir sagen, dass wir für alle möglichen Werte, die wir nicht vor
dem Platzhalter <code>_</code> auflisten, nichts tun wollen.</p>
<p>Der <code>match</code>-Ausdruck kann jedoch etwas wortreich sein, wenn wir uns nur um
<em>einen</em> der Fälle kümmern. Für diesen Fall bietet Rust <code>if let</code>.</p>
<p>Mehr über Muster und Abgleich findest du in <a href="ch18-00-patterns.html">Kapitel 18</a>.</p>
<h2><a class="header" href="#prägnanter-kontrollfluss-mit-if-let" id="prägnanter-kontrollfluss-mit-if-let">Prägnanter Kontrollfluss mit <code>if let</code></a></h2>
<p>Mit der Syntax <code>if let</code> kannst du <code>if</code> und <code>let</code> in einer weniger wortreichen
Weise kombinieren, um mit Werten umzugehen, die einem Muster entsprechen,
während der Rest ignoriert wird. Betrachte das Programm in Codeblock 6-6, das
auf einen <code>Option&lt;u8&gt;</code>-Wert passt, aber nur dann Code ausführen soll, wenn der
Wert 3 ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>match some_u8_value {
    Some(3) =&gt; println!(&quot;drei&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-6: Eine <code>match</code>-Ausdruck, der nur dann Code
ausführt, wenn der Wert <code>Some(3)</code> ist</span></p>
<p>Wir wollen etwas bei <code>Some(3)</code> machen, aber nichts mit allen anderen
<code>Some&lt;u8&gt;</code>-Werten oder dem Wert <code>None</code>. Um den <code>match</code>-Ausdruck zu
vervollständigen, müssen wir <code>_ =&gt; ()</code> ergänzen. Nachdem wir nur eine Variante
verarbeiten, bedeutet das relativ viel Code, den wir schreiben müssen.</p>
<p>Stattdessen könnten wir dies in kürzerer Form schreiben, indem wir <code>if let</code>
verwenden. Der folgende Code verhält sich genauso wie der <code>match</code>-Ausdruck in
Codeblock 6-6:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>if let</code> nimmt ein Muster und einen Ausdruck, getrennt durch ein
Gleichheitszeichen. Sie funktioniert auf gleiche Weise wie bei <code>match</code>, wo der
Ausdruck hinter <code>match</code> angegeben wird und das Muster der erste Zweig ist.</p>
<p>Die Verwendung von <code>if let</code> bedeutet weniger Tipparbeit, weniger Einrückung und
weniger Codeanteil. Du verlierst jedoch die Prüfung auf Vollständigkeit, die
<code>match</code> erzwingt. Die Wahl zwischen <code>match</code> und <code>if let</code> hängt davon ab, was
du in der speziellen Situation machst, und davon, ob ein Gewinn an Prägnanz ein
angemessener Kompromiss für den Verlust einer Prüfung auf Vollständigkeit ist.</p>
<p>Anders gesagt kannst du dir <code>if let</code> als syntaktischen Zucker für einen
<code>match</code>-Ausdruck vorstellen, der Code nur bei Übereinstimmung mit einem Muster
ausführt und alle anderen Werte ignoriert.</p>
<p>Wir können ein <code>else</code> an ein <code>if let</code> anhängen. Der Code-Block, der zum <code>else</code>
gehört, ist der gleiche wie der Code-Block, der zum <code>_</code>-Zweig im
<code>match</code>-Ausdruck gehören würde. Erinnere dich an die Aufzählung <code>Coin</code> in
Codeblock 6-4, wo die Variante <code>Quarter</code> auch einen <code>UsState</code>-Wert enthielt.
Wenn wir alle Nicht-25-Cent-Münzen zählen wollten, während wir die Eigenschaft
der 25-Cent-Münzen ausgeben, könnten wir das mit einem <code>match</code>-Ausdruck wie
diesem tun:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;25-Cent-Münze aus {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Oder wir könnten einen Ausdruck mit <code>if let</code> und <code>else</code> wie diesen verwenden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Wenn du eine Situation hast, in der dein Programm über eine Logik verfügt, die
mit einem <code>match</code>-Ausdruck zu wortreich auszudrücken wäre, denke daran, dass
<code>if let</code> ebenfalls in deinem Rust-Werkzeugkasten enthalten ist.</p>
<h2><a class="header" href="#zusammenfassung-5" id="zusammenfassung-5">Zusammenfassung</a></h2>
<p>Wir haben uns damit befasst, wie man Aufzählungen verwendet, um
benutzerdefinierte Typen zu erstellen, die zu einem Satz von Aufzählungswerten
gehören können. Wir haben gezeigt, wie der Typ <code>Option&lt;T&gt;</code> der
Standardbibliothek dir dabei hilft, das Typsystem zu verwenden, um Fehler zu
vermeiden. Wenn Aufzählungswerte Daten enthalten, kannst du diese Werte mit
<code>match</code> oder <code>if let</code> extrahieren und verwenden, je nachdem, wie viele Fälle du
behandeln musst.</p>
<p>Deine Rust-Programme können nun Konzepte in deiner Domäne mit Hilfe von
Strukturen und Aufzählungen ausdrücken. Das Erstellen benutzerdefinierter Typen
zur Verwendung in deiner API gewährleistet Typsicherheit: Der Compiler wird
sicherstellen, dass deine Funktionen nur Werte jenes Typs erhalten, den die
Funktion erwartet.</p>
<p>Um deinen Nutzern eine gut organisierte API zur Verfügung zu stellen, die
einfach zu benutzen ist und nur genau das offenbart, was deine Nutzer
benötigen, wenden wir uns nun den Modulen von Rust zu.</p>
<h1><a class="header" href="#wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen" id="wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen">Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></h1>
<p>Wenn du große Programme schreibst, ist es wichtig, deinen Code zu organisieren,
da es unmöglich wird, den Überblick über dein gesamtes Programm im Kopf zu
behalten. Durch Gruppieren verwandter Funktionen und Aufteilen von Code mit
unterschiedlichen Funktionalitäten wirst du klären, wo du Code findest, der
eine bestimmte Funktionalität implementiert, und an welcher Stelle du eine
Funktionalität ändern musst.</p>
<p>Die Programme, die wir bisher geschrieben haben, waren in einem Modul in einer
Datei. Wenn ein Projekt wächst, kannst du den Code organisieren, indem du ihn
in mehrere Module und dann in mehrere Dateien aufteilst. Ein Paket (package)
kann mehrere Binär-Kisten (binary crates) und optional eine Bibliotheks-Kiste
(library crate) enthalten. Wenn ein Paket wächst, kannst du Teile in separate
Kisten extrahieren, die zu externen Abhängigkeiten werden. Dieses Kapitel
behandelt all diese Techniken. Für sehr große Projekte aus einer Reihe von
zusammenhängenden Paketen, die sich gemeinsam weiterentwickeln, stellt Cargo
Arbeitsbereiche zur Verfügung, die wir im Abschnitt
<a href="ch14-03-cargo-workspaces.html">„Cargo-Arbeitsbereiche“</a> in Kapitel 14 behandeln werden.</p>
<p>Zusätzlich zur Gruppierungsfunktionalität ermöglicht die Kapselung von
Implementierungsdetails die Wiederverwendung von Code auf einer höheren Ebene:
Sobald du eine Operation implementiert hast, kann anderer Code diesen Code über
die öffentliche Schnittstelle des Codes aufrufen, ohne zu wissen, wie die
Implementierung funktioniert. Die Art und Weise, wie du Code schreibst,
definiert, welche Teile für anderen Code öffentlich sind und welche Teile
private Implementierungsdetails sind, deren Änderung du dir vorbehältst. Dies
ist eine weitere Möglichkeit, die Menge der Details, die man im Kopf behalten
muss, zu begrenzen.</p>
<p>Ein verwandtes Konzept ist der Gültigkeitsbereich (scope): Der verschachtelte
Kontext, in dem Code geschrieben wird, hat eine Reihe von Namen, die als „im
Gültigkeitsbereich“ (in scope) definiert sind. Beim Lesen, Schreiben und
Kompilieren von Code müssen Programmierer und Compiler wissen, ob sich ein
bestimmter Name an einer bestimmten Stelle auf eine Variable, Funktion,
Struktur (struct), Aufzählung (enum), Modul, Konstante oder ein anderes Element
bezieht und was dieses Element bedeutet. Du kannst Gültigkeitsbereiche
erstellen und verändern, welche Namen in oder außerhalb des Gültigkeitsbereichs
liegen. Du kannst nicht zwei Elemente mit gleichem Namen im selben
Gültigkeitsbereich haben; es sind Werkzeuge zur Lösung von Namenskonflikten
vorhanden.</p>
<p>Rust verfügt über eine Reihe von Funktionalitäten, mit denen du die
Organisation deines Codes verwalten kannst, z.B. welche Details offengelegt
werden, welche Details privat sind und welche Namen im jeweiligen
Gültigkeitsbereich deines Programms sind. Zu diesen Funktionalitäten, die
manchmal kollektiv als <em>Modulsystem</em> bezeichnet werden, gehören:</p>
<ul>
<li><strong>Pakete (packages):</strong> Eine Cargo-Funktionalität, mit der du Kisten bauen,
testen und gemeinsam nutzen kannst.</li>
<li><strong>Kisten (crates):</strong> Ein Baum von Modulen, der eine Bibliothek oder ein
ausführbares Programm erzeugt.</li>
<li><strong>Module</strong> und <strong><code>use</code></strong>: Ermöglicht dir, die Organisation, den
Gültigkeitsbereich und den Datenschutz von Pfaden zu steuern.</li>
<li><strong>Pfade:</strong> Eine Möglichkeit, ein Element zu benennen, z.B. eine Struktur,
eine Funktion oder ein Modul.</li>
</ul>
<p>In diesem Kapitel gehen wir auf all diese Funktionalitäten ein, besprechen, wie
sie zusammenwirken, und erklären, wie sie zur Verwaltung der
Gültigkeitsbereiche eingesetzt werden können. Am Ende solltest du ein solides
Verständnis des Modulsystems haben und in der Lage sein, mit den
Gültigkeitsbereichen wie ein Profi zu arbeiten!</p>
<h2><a class="header" href="#pakete-packages-und-kisten-crates" id="pakete-packages-und-kisten-crates">Pakete (packages) und Kisten (crates)</a></h2>
<p>Die ersten Bestandteile des Modulsystems, die wir behandeln werden, sind Pakete
(packages) und Kisten (crates). Eine Kiste ist eine Binärdatei oder eine
Bibliothek. Die <em>Kistenwurzel</em> (crate root) ist eine Quelldatei, bei der der
Rust-Compiler anfängt und die das Wurzelmodul deiner Kiste darstellt (Module
werden im Abschnitt <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">„Mit Modulen den Kontrollumfang und Datenschutz
steuern“</a> ausführlich erklärt). Ein <em>Paket</em> besteht aus einer oder
mehreren Kisten, die eine Reihe von Funktionalitäten bereitstellen. Ein Paket
enthält eine Datei <em>Cargo.toml</em>, die beschreibt, wie man diese Kisten baut.</p>
<p>Mehrere Regeln bestimmen, was ein Paket enthalten kann. Ein Paket darf <em>maximal
eine</em> Bibliothekskiste enthalten, nicht mehr. Sie kann so viele binäre Kisten
enthalten, wie du möchtest, aber sie muss mindestens eine Kiste enthalten
(egal ob Bibliothek oder binär).</p>
<p>Lass uns durchgehen, was passiert, wenn wir ein Paket erstellen. Zuerst geben
wir den Befehl <code>cargo new</code> ein:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Nachdem wir den Befehl eingegeben haben, erstellte Cargo eine Datei
<em>Cargo.toml</em> und gab uns ein Paket. Wenn man sich den Inhalt von <em>Cargo.toml</em>
ansieht, wird <em>src/main.rs</em> nicht erwähnt, weil Cargo einer Konvention folgt,
dass <em>src/main.rs</em> die Kistenwurzel einer binären Kiste mit dem gleichen Namen
wie das Paket ist. Ebenso weiß Cargo, dass, wenn im Paketverzeichnis
<em>src/lib.rs</em> enthalten ist, das Paket eine Bibliothekskiste mit dem gleichen
Namen wie das Paket enthält und <em>src/lib.rs</em> seine Kistenwurzel ist. Cargo
übergibt die Kistenwurzeldateien an <code>rustc</code>, um die Bibliothek oder Binärdatei
zu bauen.</p>
<p>Hier haben wir ein Paket, das nur <em>src/main.rs</em> enthält, was bedeutet, dass es
nur eine binäre Kiste namens <code>my-project</code> enthält. Wenn ein Paket
<em>src/main.rs</em> und <em>src/lib.rs</em> enthält, hat es zwei Kisten: Eine Bibliothek und
eine Binärdatei, beide mit dem gleichen Namen wie das Paket. Ein Paket kann
mehrere Binär-Kisten haben, indem Dateien im Verzeichnis <em>src/bin</em> abgelegt
werden: Jede Datei wird eine separate Binär-Kiste sein. Eine Kiste fasst
verwandte Funktionalitäten in einen Gültigkeitsbereich zusammen, sodass die
Funktionalität leicht von mehreren Projekten gemeinsam genutzt werden kann. Zum
Beispiel bietet die in <a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">Kapitel 2</a> verwendete Kiste <code>rand</code> eine
Funktionalität, die Zufallszahlen erzeugt. Wir können diese Funktionalität in
unseren eigenen Projekten nutzen, indem wir die Kiste <code>rand</code> in den
Gültigkeitsbereich unseres Projekts aufnehmen. Die gesamte Funktionalität, die
von der Kiste <code>rand</code> zur Verfügung gestellt wird, ist über den Namen <code>rand</code> der
Kiste zugänglich.</p>
<p>Das Beibehalten der Funktionalität einer Kiste in ihrem eigenen
Gültigkeitsbereich klärt, ob eine bestimmte Funktionalität in unserer Kiste
oder in der Kiste <code>rand</code> definiert ist, und verhindert potenzielle Konflikte.
Zum Beispiel bietet die Kiste <code>rand</code> ein Merkmal (trait) namens <code>Rng</code>. Wir
können auch eine Struktur (struct) mit dem Namen <code>Rng</code> in unserer eigenen Kiste
definieren. Da die Funktionalität einer Kiste im Namensraum des eigenen
Gültigkeitsbereichs ist, können wir <code>rand</code> als Abhängigkeit hinzufügen, ohne
dadurch den Compiler durcheinanderzubringen, worauf sich der Name <code>Rng</code>
bezieht. In unserer Kiste bezieht er sich auf <code>struct Rng</code>, die wir definiert
haben. Wir würden auf das Merkmal <code>Rng</code> aus der Kiste <code>rand</code> mit <code>rand::Rng</code>
zugreifen.</p>
<p>Lass uns weitermachen und über das Modulsystem sprechen!</p>
<h2><a class="header" href="#mit-modulen-den-kontrollumfang-und-datenschutz-steuern" id="mit-modulen-den-kontrollumfang-und-datenschutz-steuern">Mit Modulen den Kontrollumfang und Datenschutz steuern</a></h2>
<p>In diesem Abschnitt werden wir über Module und andere Teile des Modulsystems
sprechen, nämlich <em>Pfade</em>, die es dir erlauben, Elemente zu benennen; das
Schlüsselwort <code>use</code>, das einen Pfad in den Gültigkeitsbereich bringt; und das
Schlüsselwort <code>pub</code>, um Elemente öffentlich zu machen. Wir werden auch das
Schlüsselwort <code>as</code>, externe Pakete und den Stern-Operator (glob operator)
besprechen. Konzentrieren wir uns vorerst auf die Module!</p>
<p><em>Module</em> lassen uns Code innerhalb einer Kiste in Gruppen organisieren, um ihn
lesbar und leicht wiederverwendbar zu machen. Module kontrollieren auch den
<em>Datenschutz</em> (privacy) von Elementen, d.h. ob ein Element von einem externen
Code verwendet werden kann (<em>öffentlich</em>) oder ob es sich um ein internes
Implementierungsdetail handelt und nicht für die externe Verwendung verfügbar
ist (<em>privat</em>).</p>
<p>Als Beispiel schreiben wir eine Bibliothekskiste, die die Funktionalität eines
Restaurants bietet. Wir werden die Signaturen der Funktionen definieren, aber
ihre Rümpfe leer lassen, um uns auf die Organisation des Codes zu
konzentrieren, anstatt tatsächlich ein Restaurant im Code zu implementieren.</p>
<p>Im Gaststättengewerbe werden einige Teile eines Restaurants als <em>Vorderseite
des Hauses</em> und andere als <em>Hinterseite des Hauses</em> bezeichnet. Auf der
Vorderseite des Hauses sind die Kunden; hier setzen Gastgeber ihre Kunden hin,
Kellner nehmen Bestellungen auf und rechnen ab und Barkeeper machen die
Getränke. Auf der Hinterseite des Hauses arbeiten die Küchenchefs und Köche in
der Küche, Geschirrspüler waschen ab und Manager erledigen Verwaltungsarbeiten.</p>
<p>Um unsere Kiste so zu strukturieren, wie ein echtes Restaurant funktioniert,
können wir die Funktionen in verschachtelten Modulen organisieren. Erstelle
eine neue Bibliothek namens <code>restaurant</code>, indem du <code>cargo new --lib restaurant</code>
ausführst; dann schreibe den Code aus Codeblock 7-1 in <em>src/lib.rs</em>, um einige
Module und Funktionssignaturen zu definieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-1: Ein Modul <code>front_of_house</code>, das andere
Module enthält, die dann Funktionen enthalten</span></p>
<p>Wir definieren ein Modul, indem wir mit dem Schlüsselwort <code>mod</code> beginnen und
dann den Namen des Moduls angeben (in diesem Fall <code>front_of_house</code>) und
geschweifte Klammern um den Rumpf des Moduls setzen. Innerhalb von Modulen
können wir andere Module haben, wie in diesem Fall mit den Modulen <code>hosting</code>
und <code>serving</code>. Module können auch Definitionen für andere Elemente enthalten,
z.B. Strukturen, Aufzählungen, Konstanten, Merkmale oder – wie in
Codeblock 7-1 – Funktionen.</p>
<p>Durch die Verwendung von Modulen können wir verwandte Definitionen gruppieren
und benennen, warum sie verwandt sind. Programmierer, die diesen Code
verwenden, hätten es leichter, die Definitionen zu finden, die sie verwenden
wollten, da sie sich anhand der Gruppen im Code bewegen könnten, anstatt alle
Definitionen durchlesen zu müssen. Programmierer, die diesem Code neue
Funktionen hinzufügen, wüssten, wo sie den Code platzieren müssten, um das
Programm zu organisieren.</p>
<p>Vorhin haben wir erwähnt, dass <em>src/main.rs</em> und <em>src/lib.rs</em> als Kistenwurzel
bezeichnet werden. Der Grund für ihren Namen ist, dass der Inhalt dieser beiden
Dateien ein Modul namens <code>crate</code> an der Wurzel der Modulstruktur der Kiste
bilden, die als <em>Modulbaum</em> bekannt ist.</p>
<p>Codeblock 7-2 zeigt den Modulbaum für die Struktur in Codeblock 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Codeblock 7-2: Modulbaum für den Code in Codeblock
7-1</span></p>
<p>Dieser Baum zeigt, wie einige der Module ineinander verschachtelt sind (z.B.
ist <code>hosting</code> innerhalb von <code>front_of_house</code>). Der Baum zeigt auch, dass einige
Module <em>Geschwister</em> voneinander sind, was bedeutet, dass sie im selben Modul
definiert sind (<code>hosting</code> und <code>serving</code> sind innerhalb von <code>front_of_house</code>
definiert). Um die Familienmetapher fortzusetzen: Wenn Modul A innerhalb von
Modul B enthalten ist, sagen wir, dass Modul A das <em>Kind</em> (child) von Modul B
ist und dass Modul B das <em>Elter</em> (parent) von Modul A ist. Beachte, dass der
gesamte Modulbaum als Wurzel das implizite Modul namens <code>crate</code> hat.</p>
<p>Der Modulbaum könnte dich an den Verzeichnisbaum des Dateisystems auf deinem
Computer erinnern; dies ist ein sehr treffender Vergleich! Genau wie
Verzeichnisse in einem Dateisystem verwendest du Module, um deinen Code zu
organisieren. Und genau wie Dateien in einem Verzeichnis brauchen wir einen
Weg, unsere Module zu finden.</p>
<h2><a class="header" href="#mit-pfaden-auf-ein-element-im-modulbaum-verweisen" id="mit-pfaden-auf-ein-element-im-modulbaum-verweisen">Mit Pfaden auf ein Element im Modulbaum verweisen</a></h2>
<p>Um Rust zu zeigen, wo ein Element in einem Modulbaum zu finden ist, verwenden
wir einen Pfad, auf gleiche Weise wie beim Navigieren durch ein Dateisystem.
Wenn wir eine Funktion aufrufen wollen, müssen wir ihren Pfad kennen.</p>
<p>Ein Pfad kann zwei Formen annehmen:</p>
<ul>
<li>Ein <em>absoluter Pfad</em> startet bei einer Kistenwurzel, indem ein Kistenname
oder das Literal <code>crate</code> verwendet wird.</li>
<li>Ein <em>relativer Pfad</em> startet beim aktuellen Modul und benutzt <code>self</code>, <code>super</code>
oder einen Bezeichner im aktuellen Modul.</li>
</ul>
<p>Sowohl absolute als auch relative Pfade bestehen aus einem oder mehreren
Bezeichnern, die durch doppelte Doppelpunkte (<code>::</code>) getrennt sind.</p>
<p>Kommen wir auf das Beispiel in Codeblock 7-1 zurück. Wie rufen wir die Funktion
<code>add_to_waitlist</code> auf? Das ist dasselbe wie die Frage, wie der Pfad der
Funktion <code>add_to_waitlist</code> ist. In Codeblock 7-3 haben wir unseren Code etwas
vereinfacht, indem wir einige der Module und Funktionen entfernt haben. Wir
zeigen zwei Möglichkeiten, wie die Funktion <code>add_to_waitlist</code> von einer neuen
Funktion <code>eat_at_restaurant</code> aus aufgerufen werden kann, die in der
Kistenwurzel definiert ist. Die Funktion <code>eat_at_restaurant</code> ist Teil der
öffentlichen Programmierschnittstelle (API) unserer Bibliothekskiste, daher
markieren wir sie mit dem Schlüsselwort <code>pub</code>. Im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffnen">„Pfade mit dem
Schlüsselwort <code>pub</code> öffnen“</a> gehen wir näher auf <code>pub</code> ein. Beachte, dass
sich dieses Beispiel noch nicht kompilieren lässt; wir werden gleich erklären,
warum.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-3: Aufruf der Funktion <code>add_to_waitlist</code>
mittels absoluter und relativer Pfade</span></p>
<p>Beim ersten Aufruf der Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>
verwenden wir einen absoluten Pfad. Die Funktion <code>add_to_waitlist</code> ist in der
gleichen Kiste definiert wie <code>eat_at_restaurant</code>, daher können wir das
Schlüsselwort <code>crate</code> verwenden, um einen absoluten Pfad zu beginnen.</p>
<p>Nach <code>crate</code> geben wir jedes der aufeinanderfolgenden Module an, bis wir
<code>add_to_waitlist</code> erreichen. Du kannst dir ein Dateisystem mit der gleichen
Struktur vorstellen und wir würden den Pfad
<code>/front_of_house/hosting/add_to_waitlist</code> angeben, um das Programm
<code>add_to_waitlist</code> auszuführen; das Verwenden des Namens <code>crate</code>, um von der
Kistenwurzel aus zu beginnen, ist analog zu <code>/</code>, um vom
Dateisystem-Wurzelverzeichnis in deiner Eingabeaufforderung aus zu beginnen.</p>
<p>Beim zweiten Aufruf von <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> verwenden wir
einen relativen Pfad. Der Pfad beginnt mit <code>front_of_house</code>, dem Namen des
Moduls, das auf der gleichen Ebene des Modulbaums definiert ist wie
<code>eat_at_restaurant</code>. Hier wäre das Dateisystem-Äquivalent die Verwendung des
Pfades <code>front_of_house/hosting/add_to_waitlist</code>. Mit einem Namen zu beginnen
bedeutet, dass der Pfad relativ ist.</p>
<p>Die Überlegung, ob ein relativer oder absoluter Pfad verwendet wird, ist eine
Entscheidung, die du auf Basis deines Projekts treffen wirst. Die Entscheidung
sollte davon abhängen, ob du den Code für die Elementdefinition eher separat
oder zusammen mit dem Code ablegen möchtest, der das Element verwendet. Wenn
wir zum Beispiel das Modul <code>front_of_house</code> und die Funktion
<code>eat_at_restaurant</code> in ein Modul namens <code>customer_experience</code> verschieben,
müssten wir den absoluten Pfad in <code>add_to_waitlist</code> ändern, aber der relative
Pfad wäre immer noch gültig. Wenn wir jedoch die Funktion <code>eat_at_restaurant</code>
in ein separates Modul namens <code>dining</code> verschieben würden, würde der absolute
Pfad beim Aufruf <code>add_to_waitlist</code> gleich bleiben, aber der relative Pfad
müsste aktualisiert werden. Wir bevorzugen die Angabe absoluter Pfade, da es
wahrscheinlicher ist, dass Codedefinitionen und Elementaufrufe unabhängig
voneinander verschoben werden.</p>
<p>Lass uns versuchen, Codeblock 7-3 zu kompilieren, und herausfinden, warum er
sich noch nicht kompilieren lässt! Der Fehler, den wir erhalten, ist in
Codeblock 7-4 zu sehen.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">Codeblock 7-4: Kompilierfehler im Code in Codeblock
7-3</span></p>
<p>Die Fehlermeldungen besagen, dass das Modul <code>hosting</code> privat ist. Mit anderen
Worten, wir haben die korrekten Pfade für das Modul <code>hosting</code> und die Funktion
<code>add_to_waitlist</code> angegeben, aber Rust lässt sie uns nicht nutzen, weil es
keinen Zugriff auf die privaten Abschnitte hat.</p>
<p>Module sind nicht nur zum Organisieren deines Codes nützlich. Sie definieren
auch Rusts <em>Datenschutzbegrenzung</em> (privacy boundary): Die Zeile, die die
Implementierungsdetails kapselt, darf externen Code nicht kennen, aufrufen oder
sich auf ihn verlassen. Wenn du also ein Element wie eine Funktion oder
Struktur privat machen willst, lege es in einem Modul ab.</p>
<p>Die Art und Weise, wie der Datenschutz in Rust funktioniert, ist, dass alle
Elemente (Funktionen, Methoden, Strukturen, Aufzählungen, Module und
Konstanten) standardmäßig privat sind. Objekte in einem übergeordneten Modul
können die privaten Objekte in untergeordneten Modulen nicht verwenden, aber
Objekte in untergeordneten Modulen können die Objekte in ihren übergeordneten
Modulen verwenden. Der Grund dafür ist, dass untergeordnete Module ihre
Implementierungsdetails ein- und ausblenden, aber die untergeordneten Module
können den Gültigkeitsbereich sehen, in dem sie definiert sind. Um mit der
Restaurantmetapher fortzufahren, stelle dir die Datenschutzregeln wie das
Backoffice eines Restaurants vor: Was dort drinnen passiert, ist für
Restaurantkunden privat, aber Büroleiter können alles im Restaurant, in dem sie
arbeiten, sehen und tun.</p>
<p>Rust entschied sich dafür, das Modulsystem auf diese Weise funktionieren zu
lassen, sodass das Ausblenden innerer Implementierungsdetails die Vorgabe ist.
Auf diese Weise weißt du, welche Teile des inneren Codes du ändern kannst, ohne
den äußeren Code zu brechen. Aber du kannst innere Teile des Codes von
Kindmodulen für äußere Elternmodule freigeben, indem du das Schlüsselwort <code>pub</code>
verwendest, um ein Element öffentlich zu machen.</p>
<h3><a class="header" href="#pfade-mit-dem-schlüsselwort-pub-öffnen" id="pfade-mit-dem-schlüsselwort-pub-öffnen">Pfade mit dem Schlüsselwort <code>pub</code> öffnen</a></h3>
<p>Kehren wir zum Fehler in Codeblock 7-4 zurück, der uns sagte, das Modul
<code>hosting</code> sei privat. Wir wollen, dass die Funktion <code>eat_at_restaurant</code> im
übergeordneten Modul Zugriff auf die Funktion <code>add_to_waitlist</code> im
untergeordneten Modul hat, also markieren wir das Modul <code>hosting</code> mit dem
Schlüsselwort <code>pub</code>, wie in Codeblock 7-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolutet Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-5: Deklarieren des Moduls <code>hosting</code> als
<code>pub</code>, um es von <code>eat_at_restaurant</code> aus zu benutzen</span></p>
<p>Leider führt der Code in Codeblock 7-5 immer noch zu einem Fehler, wie
Codeblock 7-6 zeigt.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">Codeblock 7-6: Kompilierfehler im Code in Codeblock
7-5</span></p>
<p>Was ist passiert? Das Hinzufügen des Schlüsselworts <code>pub</code> vor <code>mod hosting</code>
macht das Modul öffentlich. Wenn wir auf <code>front_of_house</code> zugreifen können,
können wir mit dieser Änderung auch auf <code>hosting</code> zugreifen. Aber die <em>Inhalte</em>
von <code>hosting</code> sind immer noch privat; das Modul öffentlich zu machen, macht
seinen Inhalt nicht öffentlich. Das Schlüsselwort <code>pub</code> in einem Modul lässt
nur Code in seinen Vorgängermodulen auf dieses Modul verweisen.</p>
<p>Die Fehler in Codeblock 7-6 besagen, dass die Funktion <code>add_to_waitlist</code> privat
ist. Die Datenschutzregeln gelten für Strukturen, Aufzählungen, Funktionen und
Methoden sowie für Module.</p>
<p>Lasse uns auch die Funktion <code>add_to_waitlist</code> öffentlich machen, indem wir das
Schlüsselwort <code>pub</code> vor seiner Definition hinzufügen, wie in Codeblock 7-7.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Path
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-7: Das Hinzufügen des Schlüsselworts <code>pub</code> zu
<code>mod hosting</code> und <code>fn add_to_waitlist</code> lässt uns die Funktion in
<code>eat_at_restaurant</code> aufrufen</span></p>
<p>Jetzt kompiliert der Code! Schauen wir uns den absoluten und den relativen Pfad
an und prüfen wir noch einmal, warum das Hinzufügen des Schlüsselwortes <code>pub</code>
uns diese Pfade in <code>add_to_waitlist</code> im Hinblick auf die Datenschutzregeln
verwenden lässt.</p>
<p>Auf dem absoluten Pfad beginnen wir mit <code>crate</code>, der Wurzel des Modulbaums
unserer Kiste. Dann wird das Modul <code>front_of_house</code> in der Kistenwurzel
definiert. Das Modul <code>front_of_house</code> ist nicht öffentlich, aber weil die
<code>eat_at_restaurant</code>-Funktion im gleichen Modul wie <code>front_of_house</code> definiert
ist (d.h. <code>eat_at_restaurant</code> und <code>front_of_house</code> sind Geschwister), können
wir auf <code>front_of_house</code> von <code>eat_at_restaurant</code> aus zugreifen. Als nächstes
wird das Modul <code>hosting</code> mit <code>pub</code> gekennzeichnet. Wir können auf das
übergeordnete Modul von <code>hosting</code> zugreifen, also können wir auf <code>hosting</code>
zugreifen. Schließlich wird die Funktion <code>add_to_waitlist</code> mit <code>pub</code> markiert
und wir können auf ihr Elternmodul zugreifen, sodass dieser Funktionsaufruf
klappt!</p>
<p>Beim relativen Pfad ist die Logik die gleiche wie beim absoluten Pfad, mit
Ausnahme des ersten Schritts: Anstatt von der Kistenwurzel auszugehen, beginnt
der Pfad mit <code>front_of_house</code>. Das Modul <code>front_of_house</code> wird innerhalb
desselben Moduls wie <code>eat_at_restaurant</code> definiert, sodass der relative Pfad
ausgehend vom Modul, in dem <code>eat_at_restaurant</code> definiert ist, funktioniert.
Weil <code>hosting</code> und <code>add_to_waitlist</code> nun mit <code>pub</code> markiert sind, funktioniert
der Rest des Pfades, und dieser Funktionsaufruf ist gültig!</p>
<h3><a class="header" href="#relative-pfade-mit-super-beginnen" id="relative-pfade-mit-super-beginnen">Relative Pfade mit <code>super</code> beginnen</a></h3>
<p>Wir können auch relative Pfade konstruieren, die im Elternmodul beginnen, indem
wir <code>super</code> am Anfang des Pfades verwenden. Das ist so, als würde man einen
Dateisystempfad mit der Syntax <code>..</code> beginnen. Warum sollten wir das tun wollen?</p>
<p>Betrachte den Code in Codeblock 7-8, der die Situation nachbildet, in der ein
Koch eine falsche Bestellung korrigiert und persönlich zum Kunden bringt. Die
Funktion <code>fix_incorrect_order</code> ruft die Funktion <code>serve_order</code> auf, indem sie
den Pfad zu <code>serve_order</code> beginnend mit <code>super</code> angibt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-8: Aufrufen einer Funktion unter Verwendung
eines relativen Pfades, der mit <code>super</code> beginnt</span></p>
<p>Die Funktion <code>fix_incorrect_order</code> befindet sich im Modul <code>back_of_house</code>,
sodass wir <code>super</code> benutzen können, um zum Elternmodul von <code>back_of_house</code> zu
gelangen, was in diesem Fall die Wurzel <code>crate</code> ist. Von dort aus suchen wir
nach <code>serve_order</code> und finden es. Erfolg! Wir denken, dass das Modul
<code>back_of_house</code> und die Funktion <code>serve_order</code> wahrscheinlich in der gleichen
Beziehung zueinander bleiben und zusammenrücken werden, sollten wir uns dazu
entschließen, den Modulbaum der Kiste neu zu organisieren. Deshalb haben wir
<code>super</code> verwendet, sodass wir in Zukunft weniger Codestellen zu aktualisieren
haben, wenn dieser Code in ein anderes Modul verschoben wird.</p>
<h3><a class="header" href="#strukturen-und-aufzählungen-öffentlich-machen" id="strukturen-und-aufzählungen-öffentlich-machen">Strukturen und Aufzählungen öffentlich machen</a></h3>
<p>Wir können <code>pub</code> auch benutzen, um Strukturen und Aufzählungen als öffentlich
zu kennzeichnen, aber es gibt ein paar zusätzliche Details. Wenn wir <code>pub</code> vor
einer Struktur-Definition verwenden, machen wir die Struktur öffentlich, aber
die Felder der Struktur sind immer noch privat. Wir können jedes Feld von Fall
zu Fall öffentlich machen oder auch nicht. In Codeblock 7-9 haben wir eine
öffentliche Struktur <code>back_of_house::Breakfast</code> mit einem öffentlichen Feld
<code>toast</code>, aber einem privaten Feld <code>seasonal_fruit</code> definiert. Dies ist der Fall
in einem Restaurant, in dem der Kunde die Brotsorte auswählen kann, die zu
einer Mahlzeit gehört, aber der Küchenchef entscheidet, welche Früchte die
Mahlzeit begleiten, je nach Saison und Vorrat. Das verfügbare Obst ändert sich
schnell, sodass die Kunden nicht wählen oder gar sehen können, welches Obst sie
bekommen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;Pfirsiche&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Bestelle im Sommer ein Frühstück mit Roggentoast
    let mut meal = back_of_house::Breakfast::summer(&quot;Roggen&quot;);
    // Ändere unsere Meinung darüber, welche Brotsorte wir gerne hätten
    meal.toast = String::from(&quot;Weizen&quot;);
    println!(&quot;Ich möchte {}-Toast&quot;, meal.toast);

    // Die nächste Zeile lässt sich nicht kompilieren, wenn wir sie nicht
    // auskommentieren; wir dürfen die Früchte der Saison, die wir mit der
    // Mahlzeit bekommen, weder sehen noch verändern.
    // meal.seasonal_fruit = String::from(&quot;Heidelbeeren&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-9: Eine Struktur mit öffentlichen und
privaten Felder</span></p>
<p>Da das Feld <code>toast</code> in der Struktur <code>back_of_house::Breakfast</code> öffentlich ist,
können wir in <code>eat_at_restaurant</code> in das Feld <code>toast</code> schreiben und lesen,
indem wir die Punktnotation verwenden. Beachte, dass wir das Feld
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht verwenden können, weil
<code>seasonal_fruit</code> privat ist. Versuche, die Kommentarzeichen in der Zeile, die
den Feldwert <code>seasonal_fruit</code> modifiziert, zu entfernen, um zu sehen, welchen
Fehler du erhältst!</p>
<p>Beachte auch, dass, weil <code>back_of_house::Breakfast</code> ein privates Feld hat, die
Struktur eine öffentliche Funktion (hier haben wir sie <code>summer</code> genannt) zum
Erzeugen einer Instanz von <code>Breakfast</code> bereitstellen muss. Wenn <code>Breakfast</code>
keine solche Funktion hätte, könnten wir keine Instanz von <code>Breakfast</code> in
<code>eat_at_restaurant</code> erzeugen, weil wir den Wert des privaten Feldes
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht setzen könnten.</p>
<p>Wenn wir dagegen eine Aufzählung veröffentlichen, dann sind alle ihre
Varianten öffentlich. Wir brauchen nur das Schlüsselwort <code>pub</code> vor dem
Schlüsselwort <code>enum</code>, wie in Codeblock 7-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-10: Kennzeichnen einer Aufzählung als
öffentlich macht alle ihre Varianten öffentlich</span></p>
<p>Da wir die Aufzählung <code>Appetizer</code> öffentlich gemacht haben, können wir die
Varianten <code>Soup</code> und <code>Salad</code> in <code>eat_at_restaurant</code> verwenden. Aufzählungen
wären ohne öffentliche Varianten nicht sehr nützlich; es wäre ärgerlich, alle
Aufzählungs-Varianten stets mit <code>pub</code> annotieren zu müssen, daher sind die
Aufzählungs-Varianten standardmäßig öffentlich. Strukturen sind auch ohne
öffentliche Felder nützlich, daher folgen Strukturfelder standardmäßig der
allgemeinen Regel, dass alles privat ist, es sei denn, es wird mit <code>pub</code>
kommentiert.</p>
<p>Es gibt noch eine weitere Situation mit <code>pub</code>, die wir noch nicht behandelt
haben, und das ist unser letztes Modulsystem-Feature: Das Schlüsselwort <code>use</code>.
Zuerst werden wir <code>use</code> an sich behandeln, und dann zeigen wir, wie man <code>pub</code>
und <code>use</code> kombiniert.</p>
<h2><a class="header" href="#pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use" id="pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use">Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort <code>use</code></a></h2>
<p>Es mag den Anschein haben, als seien die Pfade, die wir bisher geschrieben
haben, um Funktionen aufzurufen, unangenehm lang und wiederholend. Zum Beispiel
mussten wir in Codeblock 7-7, unabhängig davon, ob wir den absoluten oder
relativen Pfad zur Funktion <code>add_to_waitlist</code> wählten, bei jedem Aufruf von
<code>add_to_waitlist</code> auch <code>front_of_house</code> und <code>hosting</code> angeben. Glücklicherweise
gibt es einen Weg, diesen Vorgang zu vereinfachen. Wir können einen Pfad mit
dem Schlüsselwort <code>use</code> einmalig in einen Gültigkeitsbereich bringen und dann
die Elemente in diesem Pfad so aufrufen, als ob es sich um lokale Elemente
handelt. In Codeblock 7-11 bringen wir das Modul
<code>crate::front_of_house::hosting</code> in den Gültigkeitsbereich der Funktion
<code>eat_at_restaurant</code>, sodass wir nur noch <code>hosting::add_to_waitlist</code> angeben
müssen, um die Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-11: Ein Modul mit <code>use</code> in den
Gültigkeitsbereich bringen</span></p>
<p>Das Angeben von <code>use</code> und einem Pfad in einem Gültigkeitsbereich ist ähnlich
dem Erstellen eines symbolischen Links im Dateisystem. Durch Hinzufügen von
<code>use crate::front_of_house::hosting</code> in der Kistenwurzel ist <code>hosting</code> nun ein
gültiger Name in diesem Gültigkeitsbereich, so als wäre das Modul <code>hosting</code> in
der Kistenwurzel definiert worden. Pfade, die mit <code>use</code> in den
Gültigkeitsbereich gebracht werden, überprüfen wie alle anderen Pfade auch die
Privatsphäre.</p>
<p>Du kannst ein Element auch mit <code>use</code> und einem relativen Pfad in den
Gültigkeitsbereich bringen. In Codeblock 7-12 wird gezeigt, wie ein relativer
Pfad angegeben werden kann, um dasselbe Verhalten wie in Codeblock 7-11 zu
erzielen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-12: Ein Modul mit <code>use</code> und einem relativen
Pfad in den Gültigkeitsbereich bringen</span></p>
<h3><a class="header" href="#idiomatische-use-pfade-erstellen" id="idiomatische-use-pfade-erstellen">Idiomatische <code>use</code>-Pfade erstellen</a></h3>
<p>In Codeblock 7-11 hast du dich vielleicht gefragt, warum wir <code>use crate::front_of_house::hosting</code> angegeben und dann <code>hosting::add_to_waitlist</code>
in <code>eat_at_restaurant</code> aufgerufen haben, anstatt den <code>use</code>-Pfad bis hin zur
Funktion <code>add_to_waitlist</code> anzugeben, um dasselbe Ergebnis zu erzielen wie in
Codeblock 7-13.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-13: Die Funktion <code>add_to_waitlist</code> mit <code>use</code>
in den Gültigkeitsbereich bringen ist nicht idiomatisch.</span></p>
<p>Obwohl sowohl Codeblock 7-11 als auch Codeblock 7-13 die gleiche Aufgabe
erfüllen, ist Codeblock 7-11 der idiomatische Weg, eine Funktion mit <code>use</code> in
den Gültigkeitsbereich zu bringen. Wenn wir das Elternmodul der Funktion mit
<code>use</code> in den Gültigkeitsbereich bringen, sodass wir das Elternmodul beim Aufruf
der Funktion angeben müssen, wird klar, dass die Funktion nicht lokal definiert
ist, während gleichzeitig die Wiederholung des vollständigen Pfades minimiert
wird. Im Code in Codeblock 7-13 ist unklar, wo <code>add_to_waitlist</code> definiert ist.</p>
<p>Wenn andererseits Strukturen, Aufzählungen und andere Elemente mit <code>use</code>
eingebracht werden, ist es idiomatisch, den vollständigen Pfad anzugeben.
Codeblock 7-14 zeigt den idiomatischen Weg, die Struktur <code>HashMap</code> der
Standardbibliothek in den Gültigkeitsbereich einer binären Kiste zu bringen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Codeblock 7-14: <code>HashMap</code> auf idiomatische Weise in den
Gültigkeitsbereich bringen</span></p>
<p>Es gibt keinen triftigen Grund für dieses Idiom: Es ist einfach eine
Konvention, die entstanden ist, und die Leute haben sich daran gewöhnt,
Rust-Code auf diese Weise zu lesen und zu schreiben.</p>
<p>Die Ausnahme von diesem Idiom ist, wenn wir zwei gleichnamige Elemente mit
<code>use</code> in den Gültigkeitsbereich bringen, denn das lässt Rust nicht zu. In
Codeblock 7-15 wird gezeigt, wie zwei <code>Result</code>-Typen mit gleichem Namen, aber
unterschiedlichen Elternmodulen in den Gültigkeitsbereich gebracht werden und
wie auf sie verwiesen werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --abschneiden--
    Ok(())
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --abschneiden--
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-15: Um zwei Typen mit dem gleichen Namen in
denselben Gültigkeitsbereich zu bringen, müssen ihre übergeordneten Module
angegeben werden.</span></p>
<p>Wie du sehen kannst, unterscheidet die Verwendung der übergeordneten Module die
beiden <code>Result</code>-Typen. Wenn wir stattdessen <code>use std::fmt::Result</code> und
<code>use std::io::Result</code> angeben würden, hätten wir zwei <code>Result</code>-Typen im selben
Gültigkeitsbereich und Rust wüsste nicht, welchen wir beim Verwenden von
<code>Result</code> meinten.</p>
<h3><a class="header" href="#mit-dem-schlüsselwort-as-neue-namen-vergeben" id="mit-dem-schlüsselwort-as-neue-namen-vergeben">Mit dem Schlüsselwort <code>as</code> neue Namen vergeben</a></h3>
<p>Es gibt eine andere Lösung für das Problem, zwei Typen desselben Namens mit
<code>use</code> in den gleichen Gültigkeitsbereich zu bringen: Hinter dem Pfad können wir
<code>as</code> und einen neuen lokalen Namen oder Alias für den Typ angeben. Codeblock
7-16 zeigt eine weitere Möglichkeit, den Code in Codeblock 7-15 zu schreiben,
indem einer der beiden <code>Result</code>-Typen mittels <code>as</code> umbenannt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --abschneiden--
    Ok(())
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --abschneiden--
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-16: Umbenennen eines Typs, wenn er mit dem
Schlüsselwort <code>as</code> in den Gültigkeitsbereich gebracht wird</span></p>
<p>In der zweiten <code>use</code>-Anweisung wählten wir den neuen Namen <code>IoResult</code> für den
Typ <code>std::io::result</code>, der nicht im Konflikt zum ebenfalls von uns in den
Gültigkeitsbereich gebrachten <code>Result</code> aus <code>std::fmt</code> steht. Codeblock 7-15
und Codeblock 7-16 gelten als idiomatisch, die Wahl liegt also bei dir!</p>
<h3><a class="header" href="#rück-exportieren-von-namen-mit-pub-use" id="rück-exportieren-von-namen-mit-pub-use">Rück-Exportieren von Namen mit <code>pub use</code></a></h3>
<p>Wenn wir einen Namen mit dem Schlüsselwort <code>use</code> in den Gültigkeitsbereich
bringen, ist der im neuen Gültigkeitsbereich verfügbare Name privat. Damit der
Code, der unseren Code aufruft, auf diesen Namen verweisen kann, als wäre er im
Gültigkeitsbereich dieses Codes definiert worden, können wir <code>pub</code> und <code>use</code>
kombinieren. Diese Technik wird <em>Rück-Exportieren</em> (re-exporting) genannt, weil
wir ein Element in den Gültigkeitsbereich bringen, dieses Element aber auch
anderen zur Verfügung stellen, um es in ihren Gültigkeitsbereich zu bringen.</p>
<p>Codeblock 7-17 zeigt den Code in Codeblock 7-11, wobei <code>use</code> im Wurzelmodul in
<code>pub use</code> geändert wurde.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-17: Bereitstellen eines Namens für externen
Code zum Verwenden in einem neuen Gültigkeitsbereich mit <code>pub use</code></span></p>
<p>Durch Verwenden von <code>pub use</code> kann jetzt externer Code die Funktion
<code>add_to_waitlist</code> unter Verwendung von <code>hosting::add_to_waitlist</code> aufrufen.
Hätten wir nicht <code>pub use</code> angegeben, könnte die Funktion <code>eat_at_restaurant</code>
in ihrem Gültigkeitsbereich <code>hosting::add_to_waitlist</code> aufrufen, aber externer
Code könnte diesen neuen Pfad nicht nutzen.</p>
<p>Der Rück-Export ist nützlich, wenn sich die interne Struktur deines Codes von
dem unterscheidet, wie Programmierer, die deinen Code
aufrufen, über die Domäne denken würden. In der Restaurantmetapher denken die
Betreiber des Restaurants zum Beispiel an die „Vorderseite des Hauses“ und die
„Rückseite des Hauses“. Mit <code>pub use</code> können wir unseren Code mit einer
Struktur schreiben, aber eine andere Struktur veröffentlichen. Auf diese Weise
ist unsere Bibliothek für Programmierer, die an der Bibliothek arbeiten, und
Programmierer, die die Bibliothek aufrufen, gut organisiert.</p>
<h3><a class="header" href="#verwenden-externer-pakete" id="verwenden-externer-pakete">Verwenden externer Pakete</a></h3>
<p>In Kapitel 2 programmierten wir ein Ratespielprojekt, das ein externes Paket
namens <code>rand</code> benutzte, um Zufallszahlen zu generieren. Um <code>rand</code> in unserem
Projekt zu verwenden, fügten wir diese Zeile zu <em>Cargo.toml</em> hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>Das Hinzufügen von <code>rand</code> als Abhängigkeit in <em>Cargo.toml</em> weist Cargo an, das
Paket <code>rand</code> und alle Abhängigkeiten von <a href="https://crates.io/">crates.io</a>
herunterzuladen und <code>rand</code> für unser Projekt verfügbar zu machen.</p>
<p>Um dann Definitionen von <code>rand</code> in den Gültigkeitsbereich unseres Pakets
aufzunehmen, haben wir eine Zeile mit <code>use</code> hinzugefügt, die mit dem
Kistennamen <code>rand</code> beginnt und die Elemente auflistet, die wir in den
Gültigkeitsbereich bringen wollten. Erinnere dich, dass wir im Abschnitt
<a href="ch02-00-guessing-game-tutorial.html#generieren-einer-geheimzahl">„Generieren einer Geheimzahl“</a> in Kapitel 2 das Merkmal <code>Rng</code> in den
Gültigkeitsbereich gebracht und die Funktion <code>rand::thread_rng</code> aufgerufen
haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1, 101);
<span class="boring">
</span><span class="boring">    println!(&quot;Die geheime Zahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Vermutung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen einer Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geraten: {}&quot;, guess);
</span>}
</code></pre></pre>
<p>Mitglieder der Rust-Gemeinschaft haben viele Pakete unter
<a href="https://crates.io/">crates.io</a> zur Verfügung gestellt und wenn du eines davon
in dein Paket aufnimmst, sind die gleichen Schritte erforderlich: Liste sie
in der Datei <em>Cargo.toml</em> deines Pakets auf und verwende <code>use</code>, um Elemente aus
ihren Kisten in den Gültigkeitsbereich zu bringen.</p>
<p>Beachte, dass die Standardbibliothek (<code>std</code>) ebenfalls eine Kiste ist, die
nicht zu unserem Paket gehört. Da die Standardbibliothek mit der Sprache Rust
ausgeliefert wird, brauchen wir <em>Cargo.toml</em> nicht zu ändern, um <code>std</code>
einzubinden. Aber wir müssen <code>use</code> verwenden, um Elemente von dort in den
Gültigkeitsbereich unseres Pakets zu bringen. Zum Beispiel würden wir für
<code>HashMap</code> diese Zeile verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>Dies ist ein absoluter Pfad, der mit <code>std</code>, dem Namen der
Standard-Bibliothekskiste, beginnt.</p>
<h3><a class="header" href="#verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen" id="verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen">Verschachtelte Pfade verwenden, um lange <code>use</code>-Listen zu vereinfachen</a></h3>
<p>Wenn wir mehrere in der gleichen Kiste oder im gleichen Modul definierte
Elemente verwenden, kann das Auflisten jedes Elements in einer eigenen Zeile
viel vertikalen Platz in unseren Dateien einnehmen. Zum Beispiel bringen diese
beiden <code>use</code>-Anweisungen, die wir im Ratespiel in Codeblock 2-4 hatten,
Elemente aus <code>std</code> in den Gültigkeitsbereich:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
use std::io;
<span class="boring">}
</span></code></pre></pre>
<p>Stattdessen können wir verschachtelte Pfade verwenden, um die gleichen Elemente
in einer Zeile in den Gültigkeitsbereich zu bringen. Wir tun dies, indem wir
den gemeinsamen Teil des Pfades angeben, gefolgt von zwei Doppelpunkten und
dann geschweiften Klammern um Liste der Pfadteile, die sich unterscheiden, wie
in Codeblock 7-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{cmp::Ordering, io};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-18: Angeben eines verschachtelten Pfades, um
mehrere Elemente mit demselben Präfix in den Gültigkeitsbereich zu
bringen</span></p>
<p>In größeren Programmen kann das Einbeziehen vieler Elemente aus derselben Kiste
oder demselben Modul in den Gültigkeitsbereich durch verschachtelte Pfade die
Anzahl der separaten <code>use</code>-Anweisungen um ein Vielfaches reduzieren!</p>
<p>Wir können einen verschachtelten Pfad auf jeder Ebene in einem Pfad verwenden,
was nützlich ist, wenn zwei <code>use</code>-Anweisungen kombiniert werden, die sich einen
Teilpfad teilen. Beispielsweise zeigt Codeblock 7-19 zwei <code>use</code>-Anweisungen:
Eine, die <code>std::io</code> in den Gültigkeitsbereich bringt, und eine, die
<code>std::io::Write</code> in den Gültigkeitsbereich bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-19: Zwei <code>use</code>-Anweisungen, bei denen eine
ein Teilpfad der anderen ist</span></p>
<p>Der gemeinsame Teil dieser beiden Pfade ist <code>std::io</code> und das ist der
vollständige erste Pfad. Um diese beiden Pfade zu einer einzigen
<code>use</code>-Anweisung zu verschmelzen, können wir <code>self</code> im verschachtelten Pfad
verwenden, wie in Codeblock 7-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-20: Zusammenfassen der Pfade aus Codeblock
7-19 zu einer <code>use</code>-Anweisung</span></p>
<p>Diese Zeile bringt <code>std::io</code> und <code>std::io::Write</code> in den Gültigkeitsbereich.</p>
<h3><a class="header" href="#der-stern-operator-glob" id="der-stern-operator-glob">Der Stern-Operator (glob)</a></h3>
<p>Wenn wir <em>alle</em> öffentlichen Elemente, die in einem Pfad definiert sind, in den
Gültigkeitsbereich bringen wollen, können wir diesen Pfad gefolgt von <code>*</code>, dem
Stern-Operator, angeben:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>Diese <code>use</code>-Anweisung bringt alle öffentlichen Elemente, die in
<code>std::collections</code> definiert sind, in den aktuellen Gültigkeitsbereich. Sei
vorsichtig beim Verwenden des Stern-Operators! Er kann es schwieriger machen,
zu erkennen, welche Namen in den Gültigkeitsbereich fallen und wo ein in deinem
Programm verwendeter Name definiert wurde.</p>
<p>Der Stern-Operator wird oft beim Testen verwendet, um alles, was getestet wird,
in das Modul <code>tests</code> zu bringen. Wir werden darüber im Abschnitt <a href="ch11-01-writing-tests.html">„Tests
schreiben“</a> in Kapitel 11 sprechen. Der Stern-Operator wird
manchmal auch als Teil des Präludiumsmusters (prelude pattern) verwendet: Siehe
<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">Standardbibliotheksdokumentation</a> für weitere Informationen
zu diesem Muster.</p>
<h2><a class="header" href="#module-in-verschiedene-dateien-aufteilen" id="module-in-verschiedene-dateien-aufteilen">Module in verschiedene Dateien aufteilen</a></h2>
<p>Bisher haben alle Beispiele in diesem Kapitel mehrere Module in einer Datei
definiert. Wenn Module groß werden, solltest du ihre Definitionen in eine
separate Datei verschieben, um die Navigation im Code zu erleichtern.</p>
<p>Beginnen wir beispielsweise mit dem Code in Codeblock 7-17 und verschieben das
Modul <code>front_of_house</code> in seine eigene Datei <em>src/front_of_house.rs</em>, indem wir
die Kistenwurzeldatei so ändern, dass sie den in Codeblock 7-21 gezeigten Code
enthält. In diesem Fall ist die Kistenwurzeldatei <em>src/lib.rs</em>, aber dieses
Vorgehensweise funktioniert auch mit binären Kisten, deren Kistenwurzeldatei
<em>src/main.rs</em> ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Codeblock 7-21: Deklarieren des Moduls <code>front_of_house</code>,
dessen Rumpf sich in <em>src/front_of_house.rs</em> befinden wird</span></p>
<p>Und <em>src/front_of_house.rs</em> erhält die Definitionen aus dem Modulrumpf von
<code>front_of_house</code>, wie in Codeblock 7-22 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">Codeblock 7-22: Definitionen innerhalb des Moduls
<code>front_of_house</code> in <em>src/front_of_house.rs</em></span></p>
<p>Das Verwenden eines Semikolons nach <code>mod front_of_house</code> anstelle eines Blocks
weist Rust an, den Inhalt des Moduls aus einer anderen Datei mit dem gleichen
Namen wie das Modul zu laden. Um mit unserem Beispiel fortzufahren und das
Modul <code>hosting</code> ebenfalls in seine eigene Datei zu extrahieren, ändern wir
<em>src/front_of_house.rs</em> so, dass es nur die Deklaration des Moduls <code>hosting</code>
enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>Dann erstellen wir ein Verzeichnis <em>src/front_of_house</em> und eine Datei
<em>src/front_of_house/hosting.rs</em>, die die im Modul <code>hosting</code> vorgenommenen
Definitionen enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house/hosting.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}
</span></code></pre></pre>
<p>Der Modulbaum bleibt derselbe und die Funktionsaufrufe in <code>eat_at_restaurant</code>
funktionieren ohne jede Änderung, auch wenn sich die Definitionen in
verschiedenen Dateien befinden. Mit dieser Technik kannst du Module in neue
Dateien verschieben, wenn diese größer werden.</p>
<p>Beachte, dass sich die Anweisung <code>pub use crate::front_of_house::hosting</code> in
<em>src/lib.rs</em> ebenfalls nicht geändert hat und dass <code>use</code> keinen Einfluss darauf
hat, welche Dateien als Teil der Kiste kompiliert werden. Das Schlüsselwort
<code>mod</code> deklariert Module und Rust sucht in einer Datei mit dem Modulnamen nach
dem Code, der zu diesem Modul gehört.</p>
<h2><a class="header" href="#zusammenfassung-6" id="zusammenfassung-6">Zusammenfassung</a></h2>
<p>Mit Rust kannst du ein Paket in mehrere Kisten und eine Kiste in Module
aufteilen, sodass du auf in einem Modul definierte Elemente aus einem anderen
Modul verweisen kannst. Du kannst dies tun, indem du absolute oder relative
Pfade angibst. Diese Pfade können mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich gebracht werden, sodass du einen kürzeren Pfad für mehrere
Verwendungen des Elements in diesem Geltungsbereich angeben kannst. Der
Modulcode ist standardmäßig privat, aber du kannst Definitionen öffentlich
machen, indem du das Schlüsselwort <code>pub</code> angibst.</p>
<p>Im nächsten Kapitel werden wir uns einige Kollektionsdatenstrukturen in der
Standardbibliothek ansehen, die du in deinem ordentlich organisierten Code
verwenden kannst.</p>
<h1><a class="header" href="#allgemeine-kollektionen" id="allgemeine-kollektionen">Allgemeine Kollektionen</a></h1>
<p>Die Standardbibliothek von Rust enthält eine Reihe sehr nützlicher
Datenstrukturen, die <em>Kollektionen</em> (collections) genannt werden. Die meisten
anderen Datentypen repräsentieren einen bestimmten Wert, aber Kollektionen
können mehrere Werte enthalten. Im Gegensatz zu den eingebauten Array- und
Tupel-Typen werden die Daten, auf die diese Kollektionen zeigen, im dynamischen
Speicher abgelegt, was bedeutet, dass die Datenmenge zur Kompilierzeit nicht
bekannt sein muss und während der Programmausführung wachsen oder schrumpfen
kann. Jede Kollektionsart hat unterschiedliche Fähigkeiten und Kosten, und die
Auswahl einer für deine aktuelle Situation geeigneten Kollektion ist eine
Fähigkeit, die du im Laufe der Zeit entwickeln wirst. In diesem Kapitel
besprechen wir drei Kollektionen, die sehr häufig in Rust-Programmen verwendet
werden:</p>
<ul>
<li>Ein <em>Vektor</em> erlaubt es dir, eine variable Anzahl von Werten nebeneinander zu
speichern.</li>
<li>Eine <em>Zeichenkette</em> ist eine Kollektion von Zeichen. Wir haben den Typ
<code>String</code> bereits kennengelernt, aber in diesem Kapitel werden wir ausführlich
darauf eingehen.</li>
<li>Eine <em>Hashtabelle</em> (hash map) erlaubt es dir, einen Wert mit einem
bestimmten Schlüssel zu assoziieren. Es ist eine spezielle Implementierung
der allgemeineren Datenstruktur, die <em>assoziatives Datenfeld</em> (map) genannt
wird.</li>
</ul>
<p>Informationen über weitere Kollektionsarten, die von der Standardbibliothek
bereitgestellt werden, findest du in <a href="https://doc.rust-lang.org/std/collections/index.html">der Dokumentation</a>.</p>
<p>Wir werden erörtern, wie Vektoren, Zeichenketten und Hashtabellen erstellt und
aktualisiert werden und was jede einzelne besonders macht.</p>
<h2><a class="header" href="#wertlisten-in-vektoren-ablegen" id="wertlisten-in-vektoren-ablegen">Wertlisten in Vektoren ablegen</a></h2>
<p>Der erste Kollektionstyp, den wir betrachten werden, ist <code>Vec&lt;T&gt;</code>, auch bekannt
als <em>Vektor</em>. Vektoren ermöglichen es dir, mehr als einen Wert in einer
einzigen Datenstruktur zu speichern and alle Werte nebeneinander im Speicher
abzulegen. Vektoren können nur Werte desselben Typs speichern. Sie sind nützlich,
wenn du eine Liste von Einträgen hast, z.B. die Textzeilen einer Datei oder die
Preise der Artikel in einem Einkaufswagen.</p>
<h3><a class="header" href="#erstellen-eines-neuen-vektors" id="erstellen-eines-neuen-vektors">Erstellen eines neuen Vektors</a></h3>
<p>Um einen neuen, leeren Vektor zu erstellen, können wir die Funktion <code>Vec::new</code>
aufrufen, wie in Codeblock 8-1 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-1: Erstellen eines neuen, leeren Vektors zur
Aufnahme von Werten des Typs <code>i32</code></span></p>
<p>Beachte, dass wir hier eine Typ-Annotation hinzugefügt haben. Da wir keine
Werte in diesen Vektor einfügen, weiß Rust nicht, welche Art von Elementen wir
zu speichern beabsichtigen. Dies ist ein wichtiger Punkt. Vektoren werden mit
Hilfe generischer Typen implementiert; wie du eigene generische Typen verwenden
kannst, wird in Kapitel 10 behandelt. Für den Moment sollst du wissen, dass der
von der Standardbibliothek bereitgestellte Typ <code>Vec&lt;T&gt;</code> jeden Typ enthalten
kann, und wenn ein bestimmter Vektor einen bestimmten Typ enthält, wird der Typ
in spitzen Klammern angegeben. In Codeblock 8-1 haben wir Rust gesagt, dass der
Vektor <code>Vec&lt;T&gt;</code> in <code>v</code> Elemente des Typs <code>i32</code> enthalten wird.</p>
<p>In realistischerem Code kann Rust oft auf den Typ des Wertes schließen, den du
nach dem Einfügen von Werten speichern möchtest, sodass du diese Art der
Annotation nur selten verwenden musst. Häufiger kommt es vor, einen <code>Vec&lt;T&gt;</code> zu
erstellen, der Anfangswerte hat, und Rust stellt der Einfachheit halber das
Makro <code>vec!</code> zur Verfügung. Das Makro erstellt einen neuen Vektor, der die von
dir angegebenen Werte enthält. Codeblock 8-2 erzeugt einen neuen <code>Vec&lt;i32&gt;</code>,
der die Werte <code>1</code>, <code>2</code> und <code>3</code> enthält. Als Integer-Typ wird <code>i32</code> verwendet,
weil das der Standard-Integer-Typ ist, wie wir im Abschnitt
<a href="ch03-02-data-types.html">„Datentypen“</a> in Kapitel 3 besprochen haben.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-2: Erstellen eines neuen Vektors mit
Werten</span></p>
<p>Da wir initiale <code>i32</code>-Werte angegeben haben, kann Rust daraus schließen, dass
<code>v</code> den Typ <code>Vec&lt;i32&gt;</code> hat, und die Typ-Annotation ist nicht notwendig. Als
Nächstes werden wir uns ansehen, wie man einen Vektor modifiziert.</p>
<h3><a class="header" href="#aktualisieren-eines-vektors" id="aktualisieren-eines-vektors">Aktualisieren eines Vektors</a></h3>
<p>Um einen Vektor zu erstellen und ihm dann Elemente hinzuzufügen, können wir die
Methode <code>push</code> verwenden, wie in Codeblock 8-3 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-3: Verwenden der Methode <code>push</code> zum
Hinzufügen von Werten zu einem Vektor</span></p>
<p>Wie bei jeder Variablen müssen wir, wenn wir ihren Wert ändern wollen, sie mit
dem Schlüsselwort <code>mut</code> als veränderlich markieren, wie in Kapitel 3
besprochen. Die Zahlen, die wir darin platzieren, sind alle vom Typ <code>i32</code>, und
Rust leitet dies aus den Daten ab, sodass wir die Annotation <code>Vec&lt;i32&gt;</code> nicht
benötigen.</p>
<h3><a class="header" href="#beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt" id="beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt">Beim Aufräumen eines Vektors werden seine Elemente aufgeräumt</a></h3>
<p>Wie bei jeder anderen Struktur wird ein Vektor freigegeben, wenn er den
Gültigkeitsbereich verlässt, wie in Codeblock 8-4 kommentiert wird.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // mache etwas mit v
} // &lt;- v verlässt den Gültigkeitsbereich und wird hier freigegeben
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-4: Zeigt, wo der Vektor und seine Elemente
aufgeräumt werden</span></p>
<p>Wenn der Vektor aufgeräumt wird, wird auch sein gesamter Inhalt aufgeräumt,
d.h. die ganzen Zahlen, die er enthält, werden beseitigt. Dies mag recht
einfach erscheinen, kann aber etwas komplizierter werden, wenn du anfängst,
Referenzen auf Elemente des Vektors einzuführen. Lass uns das als Nächstes
angehen!</p>
<h3><a class="header" href="#elemente-aus-vektoren-lesen" id="elemente-aus-vektoren-lesen">Elemente aus Vektoren lesen</a></h3>
<p>Da du jetzt weißt, wie man Vektoren erstellt, aktualisiert und aufräumt, ist es
ein guter nächster Schritt zu wissen, wie man ihre Inhalte ausliest. Es gibt
zwei Möglichkeiten, einen in einem Vektor gespeicherten Wert zu referenzieren. 
In den Beispielen haben wir zur besseren Lesbarkeit die Werttypen, die von den
Funktionen zurückgegeben werden, mit angegeben.</p>
<p>Codeblock 8-5 zeigt beide Zugriffsmethoden auf einen Wert in einem Vektor,
mittels Indexierungssyntax und die Methode <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;Das dritte Element ist {}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;Das dritte Element ist {}&quot;, third),
    None =&gt; println!(&quot;Es gibt kein drittes Element.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-5: Verwenden der Indexierungssyntax und der
Methode <code>get</code> für den Zugriff auf ein Element in einem Vektor</span></p>
<p>Beachte hier zwei Details. Erstens verwenden wir den Indexwert <code>2</code>, um das
dritte Element zu erhalten: Vektoren werden mit Zahlen indiziert, beginnend bei
null. Zweitens gibt es zwei Möglichkeiten, das dritte Element zu erhalten:
Entweder durch Verwendung von <code>&amp;</code> und <code>[]</code>, was eine Referenz ergibt, oder
durch die Methode <code>get</code> mit dem Index als Argument, was eine <code>Option&lt;&amp;T&gt;</code>
ergibt.</p>
<p>Rust hat zwei Möglichkeiten, ein Element zu referenzieren, sodass du bestimmen
kannst, wie sich das Programm verhalten soll, wenn du versuchst, einen
Indexwert zu verwenden, für den der Vektor kein Element enthält. Als Beispiel
wollen wir sehen, was ein Programm tut, wenn wir bei einem Vektor mit fünf
Elementen versuchen, auf ein Element mit Index 100 zuzugreifen, wie in
Codeblock 8-6 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-6: Versuch, auf das Element mit Index 100 in
einem Vektor zuzugreifen, der fünf Elemente enthält</span></p>
<p>Wenn wir diesen Code ausführen, wird die Variante <code>[]</code> das Programm abbrechen
lassen, weil es auf ein nicht existierendes Element verweist. Diese Methode
wird vorzugsweise verwendet, wenn du dein Programm abstürzen lassen möchtest,
wenn versucht wird, auf ein Element hinter dem Ende des Vektors zuzugreifen.</p>
<p>Wenn der Methode <code>get</code> ein Index außerhalb des Vektors übergeben wird, gibt sie
<code>None</code> zurück, ohne abzubrechen. Du würdest diese Methode verwenden, wenn der
Zugriff auf ein Element außerhalb des Bereichs des Vektors unter normalen
Umständen gelegentlich vorkommt. Dein Code wird dann eine Logik haben, die mit
<code>Some(&amp;element)</code> und <code>None</code> umgehen kann, wie in Kapitel 6 besprochen. Der
Index könnte zum Beispiel von einer Person stammen, die eine Zahl eingibt. Wenn
sie versehentlich eine zu große Zahl eingibt und das Programm einen <code>None</code>-Wert
erhält, kannst du dem Benutzer mitteilen, wie viele Elemente sich aktuell im
Vektor befinden und ihm eine weitere Chance geben, einen gültigen Wert
einzugeben. Das wäre benutzerfreundlicher, als das Programm wegen eines
Tippfehlers abstürzen zu lassen!</p>
<p>Wenn das Programm über eine gültige Referenz verfügt, stellt der
Ausleihenprüfer mittels Eigentümerschafts- und Ausleihregeln (siehe Kapitel 4)
sicher, dass diese Referenz und alle anderen Referenzen auf den Inhalt des
Vektors gültig bleiben. Erinnere dich an die Regel, die besagt, dass du keine
veränderlichen und unveränderlichen Referenzen im gleichen Gültigkeitsbereich
haben kannst. Diese Regel trifft in Codeblock 8-7 zu, wo wir eine
unveränderliche Referenz auf das erste Element in einem Vektor halten und
versuchen, am Ende ein Element hinzuzufügen, was nicht funktionieren wird, wenn
wir später in der Funktion versuchen auch auf dieses Element zuzugreifen.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;Das erste Element ist: {}&quot;, first);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-7: Versuch, ein Element zu einem Vektor
hinzuzufügen, während eine Referenz auf ein Element gehalten wird</span></p>
<p>Das Kompilieren dieses Codes führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Das erste Element ist: {}&quot;, first);
  |                                           ----- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Code in Codeblock 8-7 sieht so aus, als könnte er funktionieren: Warum
sollte sich eine Referenz auf das erste Element darum kümmern, was sich am
Ende des Vektors ändert? Dieser Fehler ist in der Funktionsweise von Vektoren
begründet: Das Hinzufügen eines neuen Elements am Ende des Vektors könnte die
Allokation neuen Speichers und das Kopieren der alten Elemente an die neue
Stelle erfordern, wenn nicht genügend Platz vorhanden ist, um alle Elemente
nebeneinander an der aktuellen Stelle des Vektors zu platzieren. In diesem Fall
würde die Referenz auf das erste Element auf einen freigegebenen Speicherplatz
verweisen. Die Ausleihregeln verhindern, dass Programme in diese Situation
geraten.</p>
<blockquote>
<p>Anmerkung: Weitere Einzelheiten zu den Implementierungsdetails des Typs
<code>Vec&lt;T&gt;</code> findest du in <a href="https://doc.rust-lang.org/nomicon/vec.html">„Das Rustonomicon“</a>.</p>
</blockquote>
<h3><a class="header" href="#iterieren-über-die-werte-in-einem-vektor" id="iterieren-über-die-werte-in-einem-vektor">Iterieren über die Werte in einem Vektor</a></h3>
<p>Wenn wir auf die Elemente eines Vektors der Reihe nach zugreifen wollen, können
wir über alle Elemente iterieren, anstatt Indizes zu verwenden, um auf jeweils
ein Element zur gleichen Zeit zuzugreifen. Codeblock 8-8 zeigt, wie man eine
<code>for</code>-Schleife verwendet, um unveränderliche Referenzen auf die Elemente eines
Vektors von <code>i32</code>-Werten zu erhalten und diese auszugeben.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-8: Ausgeben aller Elemente eines Vektors
durch Iterieren über die Elemente mittels <code>for</code>-Schleife</span></p>
<p>Wir können auch über veränderliche Referenzen der Elemente eines veränderlichen
Vektors iterieren, um Änderungen an allen Elementen vorzunehmen. Die
<code>for</code>-Schleife in Codeblock 8-9 addiert zu jedem Element <code>50</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-9: Iterieren über veränderliche Referenzen
der Elemente eines Vektors</span></p>
<p>Um den Wert, auf den sich die veränderliche Referenz bezieht, zu ändern, müssen
wir den Dereferenzierungsoperator (<code>*</code>) verwenden, um an den Wert in <code>i</code> zu
kommen, bevor wir den Operator <code>+=</code> verwenden können. Wir werden mehr über den
Dereferenzierungsoperator im Abschnitt <a href="ch15-02-deref.html#dem-zeiger-zum-wert-folgen-mit-dem-dereferenzierungsoperator">„Dem Zeiger zum Wert folgen mit dem
Dereferenzierungsoperator“</a> in Kapitel 15 sprechen.</p>
<h3><a class="header" href="#verwenden-einer-aufzählung-zum-speichern-mehrerer-typen" id="verwenden-einer-aufzählung-zum-speichern-mehrerer-typen">Verwenden einer Aufzählung zum Speichern mehrerer Typen</a></h3>
<p>Zu Beginn dieses Kapitels haben wir gesagt, dass Vektoren nur Werte desselben
Typs speichern können. Das kann unbequem sein; es gibt definitiv
Anwendungsfälle, in denen es notwendig ist, eine Liste von Einträgen
unterschiedlicher Typen zu speichern. Glücklicherweise werden die Varianten
einer Aufzählung unter dem gleichen Aufzählungstyp definiert. Wenn wir also
Elemente eines anderen Typs in einem Vektor speichern wollen, können wir eine
Aufzählung definieren und verwenden! Angenommen, wir möchten Werte aus einer
Zeile einer Tabellenkalkulationstabelle erhalten, in der einige Spalten der
Zeile ganze Zahlen, Fließkommazahlen und Zeichenketten enthalten.  Wir können
eine Aufzählung definieren, deren Varianten die verschiedenen Werttypen
enthalten, und dann werden alle Aufzählungsvarianten als derselbe Typ
angesehen: Der Typ der Aufzählung. Dann können wir einen Vektor erstellen, der
diese Aufzählung und damit letztlich verschiedene Typen enthält. Wir haben dies
in Codeblock 8-10 demonstriert.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blau&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-10: Definieren eines <code>enum</code>, um Werte
verschiedener Typen in einem Vektor zu speichern</span></p>
<p>Rust muss wissen, welche Typen zur Kompilierzeit im Vektor enthalten sein
werden, damit es genau weiß, wie viel Speicherplatz im Haldenspeicher
benötigt wird, um alle Elemente zu speichern. Ein zweiter Vorteil ist, dass wir
explizit festlegen können, welche Typen in diesem Vektor erlaubt sind. Wenn
Rust einen Vektor mit beliebigen Typen zuließe, bestünde die Möglichkeit, dass
einer oder mehrere Typen Fehler bei den an den Elementen des Vektors
durchgeführten Operationen verursachen würden. Das Verwenden einer Aufzählung
zusammen mit einem <code>match</code>-Ausdruck bedeutet, dass Rust zur Kompilierzeit
sicherstellt, dass jeder mögliche Fall behandelt wird, wie in Kapitel 6
besprochen.</p>
<p>Wenn du ein Programm schreibst und nicht weißt, welche Typen das Programm zur
Laufzeit in einen Vektor speichern wird, funktioniert der Aufzählungsansatz
nicht. Stattdessen kannst du ein Merkmalsobjekt (trait object) verwenden, das
wir in Kapitel 17 behandeln werden.</p>
<p>Nachdem wir nun einige der gängigsten Methoden zur Verwendung von Vektoren
besprochen haben, solltest du dir unbedingt die <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">API-Dokumentation</a> zu
den vielen nützlichen Methoden ansehen, die die Standardbibliothek für <code>Vec&lt;T&gt;</code>
mitbringt. Zum Beispiel gibt es zusätzlich zu <code>push</code> die Methode <code>pop</code>, die das
letzte Element entfernt und zurückgibt. Lass uns zum nächsten Kollektionstyp
übergehen: <code>String</code></p>
<h2><a class="header" href="#utf-8-kodierten-text-in-zeichenketten-strings-ablegen" id="utf-8-kodierten-text-in-zeichenketten-strings-ablegen">UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></h2>
<p>Wir haben in Kapitel 4 über Zeichenketten (strings) gesprochen, aber wir werden
uns jetzt eingehender damit befassen. Neue Rust-Entwickler haben gewöhnlich aus
einer Kombination von drei Gründen Probleme mit Zeichenketten: Rusts Neigung,
mögliche Fehler aufzudecken, Zeichenketten als eine kompliziertere
Datenstruktur, als viele Programmierer ihnen zugestehen, und UTF-8. Diese
Faktoren kombinieren sich in einer Weise, die schwierig erscheinen kann, wenn
man von anderen Programmiersprachen kommt.</p>
<p>Es ist hilfreich, Zeichenketten im Kontext von Kollektionen zu besprechen, da
Zeichenketten als Byte-Kollektion implementiert sind, sowie einige Methoden,
die nützliche Funktionalitäten bieten, wenn diese Bytes als Text interpretiert
werden. In diesem Abschnitt werden wir über <code>String</code>-Operationen sprechen, die
jeder Kollektionstyp hat, wie das Erstellen, Aktualisieren und Lesen. Wir
werden auch die Art und Weise besprechen, in der sich <code>String</code> von den anderen
Kollektionen unterscheidet, nämlich warum die Indexierung bei einem <code>String</code>
kompliziert ist, weil Menschen und Computer <code>String</code>-Daten unterschiedlich
interpretieren.</p>
<h3><a class="header" href="#was-ist-eine-zeichenkette" id="was-ist-eine-zeichenkette">Was ist eine Zeichenkette?</a></h3>
<p>Zuerst werden wir definieren, was wir mit dem Begriff <em>Zeichenkette</em> (string)
meinen. Rust hat nur einen einzigen Zeichenkettentyp in der Kernsprache,
nämlich den Zeichenkettenanteilstyp <code>str</code>, der üblicherweise in seiner
Ausleihenform <code>&amp;str</code> zu sehen ist. In Kapitel 4 sprachen wir über
<em>Zeichenkettenanteilstypen</em> (string slices), die Referenzen auf einige
UTF-8-kodierte Zeichenkettendaten sind, die anderswo gespeichert sind.
Zeichenkettenliterale werden beispielsweise in der Binärdatei des Programms
gespeichert und sind daher Zeichenkettenanteilstypen.</p>
<p>Der Typ <code>String</code>, der von Rusts Standardbibliothek zur Verfügung gestellt wird
und nicht in die Kernsprache kodiert ist, ist ein größenänderbarer,
veränderlicher, aneigenbarer, UTF-8-kodierter Zeichenkettentyp. Wenn
Rust-Entwickler von Zeichenketten in Rust sprechen, meinen sie normalerweise
den Typ <code>String</code> sowie den Zeichenkettenanteilstyp <code>&amp;str</code>, nicht nur einen
dieser Typen. Obwohl es in diesem Abschnitt weitgehend um <code>String</code> geht, werden
beide Typen in Rusts Standardbibliothek stark verwendet, und sowohl <code>String</code>
als auch Zeichenkettenanteilstypen sind UTF-8-kodiert.</p>
<p>Die Standardbibliothek von Rust enthält auch eine Reihe anderer
Zeichenkettentypen wie <code>OsString</code>, <code>OsStr</code>, <code>CString</code> und <code>CStr</code>.
Bibliothekskisten (library crates) können noch weitere Möglichkeiten zum
Speichern von Zeichenkettendaten bieten. Fällt dir auf, dass diese Namen alle
auf <code>String</code> oder <code>Str</code> enden? Sie beziehen sich auf aneigenbare und
ausgeliehene Varianten, genau wie die Typen <code>String</code> und <code>str</code>, die du zuvor
gesehen hast. Diese Zeichenkettentypen können z.B. Text in verschiedenen
Kodierungen speichern oder unterschiedliche Speicherdarstellungen haben. Diese
anderen Zeichenkettentypen werden in diesem Kapitel nicht besprochen; in ihrer
API-Dokumentation erfährst du mehr darüber, wie sie zu verwenden sind und wozu
jeder einzelne geeignet ist.</p>
<h3><a class="header" href="#erstellen-einer-neuen-zeichenkette" id="erstellen-einer-neuen-zeichenkette">Erstellen einer neuen Zeichenkette</a></h3>
<p>Viele Operationen, die für <code>Vec&lt;T&gt;</code> verfügbar sind, sind auch für <code>String</code>
vorhanden, beginnend mit der Funktion <code>new</code> zum Erstellen einer Zeichenkette,
wie in Codeblock 8-11 zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-11: Erstellen einer neuen, leeren
Zeichenkette</span></p>
<p>Diese Zeile erzeugt eine neue, leere Zeichenkette namens <code>s</code>, in die wir dann
Daten aufnehmen können. Oft werden wir einige initiale Daten haben, mit denen
wir die Zeichenkette füllen wollen. Dazu verwenden wir die Methode <code>to_string</code>,
die für jeden Typ verfügbar ist, der das Merkmal <code>Display</code> implementiert, wie
es bei Zeichenkettenliteralen der Fall ist. Codeblock 8-12 zeigt zwei
Beispiele.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = &quot;initialer Inhalt&quot;;

let s = data.to_string();

// die Methode funktioniert auch direkt für ein Literal:
let s = &quot;initialer Inhalt&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-12: Verwenden der Methode <code>to_string</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Dieser Code erzeugt eine Zeichenkette mit dem Inhalt <code>initialer Inhalt</code>.</p>
<p>Wir können auch die Funktion <code>String::from</code> verwenden, um einen <code>String</code> aus
einem Zeichenkettenliteral zu erzeugen. Der Code in Codeblock 8-13 ist
äquivalent zum Code in Codeblock 8-12, der <code>to_string</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initialer Inhalt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-13: Verwenden der Funktion <code>String::from</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Da Zeichenketten für so viele Dinge verwendet werden, können wir viele
verschiedene generische Programmierschnittstellen (APIs) für Zeichenketten
verwenden, was uns viele Möglichkeiten bietet. Einige von ihnen können
überflüssig erscheinen, aber sie alle haben ihren Platz! In diesem Fall machen
<code>String::from</code> und <code>to_string</code> dasselbe, also ist die Wahl eine Frage des
Stils.</p>
<p>Denke daran, dass Zeichenketten UTF-8-kodiert sind, sodass sie alle
ordnungsgemäß kodierten Daten aufnehmen können, wie in Codeblock 8-14 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hallo&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-14: Speichern von Begrüßungstexten in
verschiedenen Sprachen in Zeichenketten</span></p>
<p>All dies sind gültige <code>String</code>-Werte.</p>
<h3><a class="header" href="#aktualisieren-einer-zeichenkette" id="aktualisieren-einer-zeichenkette">Aktualisieren einer Zeichenkette</a></h3>
<p>Ein <code>String</code> kann an Größe zunehmen und sein Inhalt kann sich ändern, genau wie
der Inhalt eines <code>Vec&lt;T&gt;</code>, wenn du mehr Daten hineinschiebst. Darüber hinaus
kannst du bequem den Operator <code>+</code> oder das Makro <code>format!</code> verwenden, um
<code>String</code>-Werte aneinanderzuhängen.</p>
<h4><a class="header" href="#anhängen-an-eine-zeichenkette-mit-push_str-und-push" id="anhängen-an-eine-zeichenkette-mit-push_str-und-push">Anhängen an eine Zeichenkette mit <code>push_str</code> und <code>push</code></a></h4>
<p>Wir können einen <code>String</code> wachsen lassen, indem wir die Methode <code>push_str</code>
verwenden, um einen Zeichenkettenanteilstyp anzuhängen, wie in Codeblock 8-15
zu sehen ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-15: Anhängen eines Zeichenkettenanteilstyps
an einen <code>String</code> mit der Methode <code>push_str</code></span></p>
<p>Nach diesen beiden Zeilen enthält <code>s</code> den Wert <code>foobar</code>. Die Methode <code>push_str</code>
nimmt einen Zeichenkettenanteilstyp, weil wir nicht unbedingt die
Eigentümerschaft des Parameters übernehmen wollen. Zum Beispiel zeigt der Code
in Codeblock 8-16, dass es bedauerlich wäre, wenn wir nicht in der Lage wären,
<code>s2</code> zu verwenden, nachdem wir seinen Inhalt an <code>s1</code> angehängt haben.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 ist {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-16: Verwenden eines Zeichenkettenanteilstyps
nach dem Anhängen seines Inhalts an eine Zeichenkette</span></p>
<p>Wenn die Methode <code>push_str</code> die Eigentümerschaft von <code>s2</code> übernehmen würde,
könnten wir ihren Wert nicht in der letzten Zeile ausgeben. Dieser Code
funktioniert jedoch wie erwartet!</p>
<p>Die Methode <code>push</code> nimmt ein einzelnes Zeichen als Parameter und fügt es dem
<code>String</code> hinzu. Codeblock 8-17 zeigt Code, der den Buchstaben <code>l</code> mit der
Methode <code>push</code> zu einem <code>String</code> hinzufügt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-17: Hinzufügen eines Zeichens zu einem
<code>String</code>-Wert mit <code>push</code></span></p>
<p>Als Ergebnis dieses Codes wird <code>s</code> den Wert <code>lol</code> enthalten.</p>
<h4><a class="header" href="#aneinanderhängen-mit-dem-operator--und-dem-makro-format" id="aneinanderhängen-mit-dem-operator--und-dem-makro-format">Aneinanderhängen mit dem Operator <code>+</code> und dem Makro <code>format!</code></a></h4>
<p>Häufig möchtest du zwei vorhandene Zeichenketten kombinieren. Eine Möglichkeit
ist, den Operator <code>+</code> zu verwenden, wie in Codeblock 8-18 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo &quot;);
let s2 = String::from(&quot;Welt!&quot;);
let s3 = s1 + &amp;s2; // Beachte, s1 wurde hierher verschoben und
                   // kann nicht mehr verwendet werden
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-18: Verwenden des Operators <code>+</code>, um zwei
Zeichenketten zu einer neuen zu kombinieren</span></p>
<p>Die Zeichenkette <code>s3</code> wird als Ergebnis dieses Codes <code>Hallo Welt!</code> enthalten.
Der Grund, warum <code>s1</code> nach der Addition nicht mehr gültig ist und warum wir
eine Referenz auf <code>s2</code> verwendet haben, hat mit der Signatur der Methode zu
tun, die aufgerufen wird, wenn wir den Operator <code>+</code> verwenden. Der Operator <code>+</code>
benutzt die Methode <code>add</code>, deren Signatur ungefähr so aussieht:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Dies ist nicht die exakte Signatur aus der Standardbibliothek: In der
Standardbibliothek wird <code>add</code> mittels generischer Datentypen definiert. Hier
sehen wir uns die Signatur von <code>add</code> mit konkreten Typen an, die die
generischen Typen ersetzen; das passiert, wenn wir diese Methode mit
<code>String</code>-Werten aufrufen. Wir werden generische Datentypen in Kapitel 10
besprechen. Diese Signatur gibt uns den entscheidenden Hinweis, um die
kniffligen Stellen des Operators <code>+</code> zu verstehen.</p>
<p>Erstens hat <code>s2</code> ein <code>&amp;</code>, was bedeutet, dass wir aufgrund des Parameters <code>s</code> in
der Funktion <code>add</code> eine <em>Referenz</em> der zweiten Zeichenkette an die erste
Zeichenkette anhängen: Wir können nur einen <code>&amp;str</code> zu einem <code>String</code>
hinzufügen; wir können nicht zwei <code>String</code>-Werte miteinander addieren. Aber
warte – der Typ von <code>&amp;s2</code> ist <code>&amp;String</code>, nicht <code>&amp;str</code>, wie im zweiten
Parameter von <code>add</code> spezifiziert. Warum kompiliert also Codeblock 8-18?</p>
<p>Der Grund, warum wir <code>&amp;s2</code> im Aufruf von <code>add</code> verwenden können, ist, dass der
Compiler das Argument <code>&amp;String</code> in einen <code>&amp;str</code> umwandeln (coerce) kann.
Wenn wir die Methode <code>add</code> aufrufen, benutzt Rust eine <em>automatische
Umwandlung</em> (deref coercion), die hier <code>&amp;s2</code> in <code>&amp;s2[...]</code> umwandelt. Auf die
automatische Umwandlung werden wir in Kapitel 15 tiefer eingehen. Da <code>add</code>
nicht die Eigentümerschaft des Parameters <code>s</code> übernimmt, ist <code>s2</code> auch nach
dieser Operation immer noch ein gültiger <code>String</code>.</p>
<p>Zweitens können wir in der Signatur sehen, dass <code>add</code> die Eigentümerschaft von
<code>self</code> übernimmt, weil <code>self</code> <em>kein</em> <code>&amp;</code> hat. Das bedeutet, dass <code>s1</code> in
Codeblock 8-18 in den Aufruf von <code>add</code> verschoben wird und danach nicht mehr
gültig ist. Obwohl also <code>let s3 = s1 + &amp;s2;</code> so aussieht, als ob beide
Zeichenketten kopiert und eine neue erzeugt wird, übernimmt diese Anweisung
tatsächlich die Eigentümerschaft von <code>s1</code>, hängt eine Kopie des Inhalts von
<code>s2</code> an und gibt dann die Eigentümerschaft des Ergebnisses zurück. In anderen
Worten sieht es so aus, als würde es viele Kopien erstellen, das ist aber nicht
so; die Implementierung ist effizienter als Kopieren.</p>
<p>Wenn wir mehrere Zeichenketten aneinanderhängen wollen, wird das Verhalten des
Operators <code>+</code> unhandlich:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>An diesem Punkt wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Bei all den Zeichen <code>+</code>
und <code>&quot;</code> ist es schwer zu erkennen, was vor sich geht. Für kompliziertere
String-Kombinationen können wir das Makro <code>format!</code> verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Auch bei diesem Code wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Das Makro <code>format!</code>
arbeitet auf die gleiche Weise wie <code>println!</code>, aber anstatt das Ergebnis auf
den Bildschirm auszugeben, gibt es einen <code>String</code> mit dem Inhalt zurück. Die
Codevariante, die <code>format!</code> verwendet, ist viel leichter zu lesen und übernimmt
keine Eigentümerschaft seiner Parameter.</p>
<h3><a class="header" href="#indexierung-von-zeichenketten" id="indexierung-von-zeichenketten">Indexierung von Zeichenketten</a></h3>
<p>In vielen anderen Programmiersprachen ist das Zugreifen auf einzelne Zeichen in
einer Zeichenkette mittels Index eine gültige und gängige Operation. Wenn du
jedoch in Rust versuchst, mittels Indexierungssyntax auf Teile einer
Zeichenkette zuzugreifen, wirst du einen Fehler erhalten. Betrachte den
ungültigen Code in Codeblock 8-19.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let h = s1[0];


<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-19: Versuch, die Indexierungssyntax bei einer
Zeichenkette zu verwenden</span></p>
<p>Dieser Code führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Fehlermeldung und der Hinweis erzählen die Geschichte: Zeichenketten in
Rust unterstützen keine Indexierung. Aber warum nicht? Um diese Frage zu
beantworten, müssen wir uns ansehen, wie Rust Zeichenketten im Speicher ablegt.</p>
<h4><a class="header" href="#interne-darstellung" id="interne-darstellung">Interne Darstellung</a></h4>
<p>Ein <code>String</code> ist eine Hülle um einen <code>Vec&lt;u8&gt;</code>. Sehen wir uns einige unserer
korrekt kodierten UTF-8-Beispielzeichenketten aus Codeblock 8-14 an. Zuerst
diese:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In diesem Fall wird <code>hello.len()</code> gleich 4 sein, was bedeutet, dass der Vektor,
der die Zeichenkette „Hola“ speichert, 4 Bytes lang ist. Jeder dieser
Buchstaben benötigt 1 Byte in UTF-8-Kodierung. Aber was ist mit der folgenden
Zeile? (Beachte, dass diese Zeichenkette mit dem kyrillischen Großbuchstaben
„Ze“ beginnt, nicht mit der arabischen Zahl 3.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Auf die Frage, wie lang die Zeichenkette ist, könnte man sagen: 12. Die Antwort
von Rust lautet jedoch 24: Das ist die Anzahl der Bytes, die benötigt wird, um
„Здравствуйте“ in UTF-8 zu kodieren, da jeder Unicode-Skalarwert in dieser
Zeichenkette 2 Bytes Speicherplatz benötigt. Daher wird ein Index auf die Bytes
der Zeichenkette nicht immer mit einem gültigen Unicode-Skalarwert korrelieren.
Um das zu erläutern, betrachte diesen ungültigen Rust-Code:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];


<span class="boring">}
</span></code></pre></pre>
<p>Was sollte der Wert von<code>answer</code> sein? Sollte es <code>З</code> sein, der erste Buchstabe?
In der UTF-8-Kodierung von <code>З</code> ist das erste Byte <code>208</code> und das zweite <code>151</code>,
sodass <code>answer</code> eigentlich <code>208</code> sein müsste, aber <code>208</code> ist kein eigenständig
gültiges Zeichen. Die Rückgabe von <code>208</code> ist wahrscheinlich nicht das, was ein
Nutzer wünschen würde, wenn er nach dem ersten Buchstaben dieser Zeichenkette
fragte; das sind jedoch die einzigen Daten, die Rust beim Byte-Index 0 hat.
Nutzer wollen im Allgemeinen nicht, dass der Byte-Wert zurückgegeben wird,
selbst wenn die Zeichenkette nur lateinische Buchstaben enthält: Wenn
<code>&amp;&quot;hallo&quot;[0]</code> gültiger Code wäre, der den Byte-Wert zurückgibt, würde er <code>104</code>
zurückgeben, nicht <code>h</code>. Um zu vermeiden, dass ein unerwarteter Wert
zurückgegeben und Fehler verursacht werden, die nicht sofort entdeckt werden,
kompiliert Rust diesen Code überhaupt nicht und verhindert Missverständnisse
schon früh im Entwicklungsprozess.</p>
<h4><a class="header" href="#bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje" id="bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje">Bytes, skalare Werte und Graphemgruppen (grapheme clusters)! Oje!</a></h4>
<p>Ein weiterer Punkt bei UTF-8 ist, dass es eigentlich drei relevante
Möglichkeiten gibt, Zeichenketten aus Rusts Perspektive zu betrachten: Als
Bytes, als skalare Werte und als Graphemgruppen (das, was wir am ehesten als
<em>Buchstaben</em> bezeichnen würden).</p>
<p>Wenn wir uns das in der Devanagari-Schrift geschriebene Hindi-Wort „नमस्ते“
ansehen, wird es als ein Vektor von <code>u8</code>-Werten gespeichert, der wie folgt
aussieht:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Das sind 18 Bytes, so wie ein Computer diese Daten letztendlich speichert. Wenn
wir sie als Unicode-Skalarwerte betrachten, also als das, was der Typ <code>char</code> in
Rust ist, sehen diese Bytes wie folgt aus:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Es gibt hier sechs <code>char</code>-Werte, aber der vierte und der sechste sind keine
Buchstaben: Sie sind diakritische Zeichen, die für sich allein genommen keinen
Sinn ergeben. Wenn wir sie schließlich als Graphemgruppen betrachten, erhalten
wir das, was eine Person die vier Buchstaben nennen würde, aus denen das
Hindi-Wort besteht:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust bietet verschiedene Möglichkeiten zur Interpretation von rohen
Zeichenkettendaten, die von Computern gespeichert werden, sodass jedes Programm
die Interpretation wählen kann, die es benötigt, unabhängig davon, in welcher
menschlichen Sprache die Daten vorliegen. Ein letzter Grund, warum Rust uns
nicht erlaubt, eine Zeichenkette zu indexieren, um ein Zeichen zu erhalten,
ist, dass von Indexoperationen erwartet wird, dass sie immer in konstanter Zeit
(O(1)) erfolgen. Es ist jedoch nicht möglich, diese Zeitgarantie bei einem
<code>String</code> einzuhalten, da Rust den Inhalt von Anfang an bis zum Index durchgehen
müsste, um festzustellen, wie viele gültige Zeichen es gibt.</p>
<h3><a class="header" href="#anteilige-zeichenketten" id="anteilige-zeichenketten">Anteilige Zeichenketten</a></h3>
<p>Die Indexierung einer Zeichenkette ist oft eine schlechte Idee, weil nicht klar
ist, was der Rückgabetyp der Zeichenketten-Indexoperation sein soll: Ein
Byte-Wert, ein Zeichen, eine Graphemgruppe oder ein Zeichenkettenanteilstyp.
Daher bittet dich Rust, konkretere Angaben zu machen, wenn du wirklich Indexes
zum Erstellen von Zeichenkettenanteilstypen verwenden musst. Um bei der
Indexierung spezifischer zu sein und anzugeben, dass du einen
Zeichenkettenanteilstyp wünschst, kannst du statt der Indexierung mit <code>[]</code> mit
einer einzigen Nummer <code>[]</code> mit einem Bereich verwenden, um einen
Zeichenkettenanteilstyp zu erstellen, der bestimmte Bytes enthält:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Hier wird <code>s</code> ein <code>&amp;str</code> sein, das die ersten 4 Bytes der Zeichenkette enthält.
Vorhin haben wir bereits erwähnt, dass jedes dieser Zeichen 2 Bytes lang ist,
was bedeutet, dass <code>s</code> gleich <code>Зд</code> ist. Was würde passieren, wenn wir
<code>&amp;hello[0..1]</code> benutzen würden? Die Antwort: Rust würde das Programm zur
Laufzeit abbrechen, genauso als wenn mit einem ungültigen Index auf einen
Vektor zugegriffen würde:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Bei der Verwendung von Bereichen zum Erstellen von Zeichenkettenanteilstypen
ist Vorsicht geboten, da dies zum Absturz deines Programms führen kann.</p>
<h3><a class="header" href="#methoden-zum-iterieren-über-zeichenketten" id="methoden-zum-iterieren-über-zeichenketten">Methoden zum Iterieren über Zeichenketten</a></h3>
<p>Glücklicherweise kannst du auf andere Weise auf Elemente in einer Zeichenkette
zugreifen.</p>
<p>Wenn du Operationen mit einzelnen Unicode-Skalarwerten durchführen musst,
verwende am besten die Methode <code>chars</code>. Der Aufruf von <code>chars</code> auf „नमस्ते“
trennt sechs Werte vom Typ <code>char</code> heraus und gibt sie zurück, und du kannst
über das Ergebnis iterieren, um auf jedes Element zuzugreifen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code wird folgendes ausgeben:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>Die Methode <code>bytes</code> gibt jedes rohe Byte zurück, das für deinen
Verwendungszweck benötigt wird:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt die 18 Bytes aus, aus denen diese Zeichenkette besteht:</p>
<pre><code class="language-text">224
164
// --abschneiden--
165
135
</code></pre>
<p>Aber denke daran, dass gültige Unicode-Skalarwerte aus mehr als 1 Byte bestehen
können.</p>
<p>Graphemgruppen aus Zeichenketten auszulesen ist komplex, daher wird diese
Funktionalität nicht von der Standardbibliothek bereitgestellt. Kisten (crates)
sind unter <a href="https://crates.io/">crates.io</a> verfügbar, falls du diese
Funktionalität benötigst.</p>
<h3><a class="header" href="#zeichenketten-sind-nicht-so-einfach" id="zeichenketten-sind-nicht-so-einfach">Zeichenketten sind nicht so einfach</a></h3>
<p>Zusammenfassend kann man sagen, dass Zeichenketten kompliziert sind.
Verschiedene Programmiersprachen treffen unterschiedliche Entscheidungen
darüber, wie diese Komplexität dem Programmierer angezeigt wird. Rust hat sich
dafür entschieden, den korrekten Umgang mit Zeichenkettendaten zum
Standardverhalten für alle Rust-Programme zu machen, was bedeutet, dass
Programmierer sich im Vorfeld mehr Gedanken über den Umgang mit UTF-8-Daten
machen müssen. Dieser Zielkonflikt macht die Komplexität von Zeichenketten
größer als in anderen Programmiersprachen, aber er verhindert, dass du später
in deinem Entwicklungslebenszyklus mit Fehlern umgehen musst, wenn
Nicht-ASCII-Zeichen vorkommen.</p>
<p>Lass uns zu etwas weniger Kompliziertem übergehen: Hashtabellen!</p>
<h2><a class="header" href="#schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen" id="schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen">Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></h2>
<p>Die letzte unserer allgemeinen Kollektionen ist die <em>Hashtabelle</em> (hash map).
Der Typ <code>HashMap&lt;K, V&gt;</code> speichert eine Zuordnung von Schlüsseln vom Typ <code>K</code> zu
Werten vom Typ <code>V</code>. Er tut dies über eine <em>Hashfunktion</em> (hash function), die
bestimmt, wie er diese Schlüssel und Werte im Speicher ablegt. Viele
Programmiersprachen unterstützen diese Art Datenstruktur, aber sie verwenden
oft einen anderen Namen, z.B. Hash, Abbildung (map), Objekt, Hashtabelle (hash
table), Wörterbuch (dictionary) oder assoziatives Array (associative array), um
nur einige zu nennen. Hashtabellen sind nützlich, wenn du Daten nicht wie bei
Vektoren über einen Index nachschlagen willst, sondern über einen Schlüssel,
der ein beliebiger Typ sein kann. Beispielsweise könntest du in einem Spiel den
Spielstand jedes Teams in einer Hashtabelle vermerken, in der die Schlüssel den
Teamnamen und die Werte den Spielstand des jeweiligen Teams darstellen. Wenn du
den Namen eines Teams angibst, kannst du seine Punktzahl abrufen.</p>
<p>In diesem Abschnitt gehen wir die grundlegende Programmierschnittstelle (API)
von Hashtabellen durch, aber viele weitere Leckerbissen verbergen sich in den
Funktionen, die in der Standardbibliothek für <code>HashMap&lt;K, V&gt;</code> definiert sind.
Weitere Informationen findest du wie immer in der
Standardbibliotheksdokumentation.</p>
<h3><a class="header" href="#erstellen-einer-neuen-hashtabelle" id="erstellen-einer-neuen-hashtabelle">Erstellen einer neuen Hashtabelle</a></h3>
<p>Du kannst eine leere Hashtabelle mit <code>new</code> erstellen und Elemente mit <code>insert</code>
hinzufügen. In Codeblock 8-20 verfolgen wir die Ergebnisse zweier Mannschaften
mit den Namen Blau und Gelb. Das Team Blau startet mit 10 Punkten, das Team
Gelb mit 50 Punkten.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-20: Erstellen einer neuen Hashtabelle und
Einfügen einiger Schlüssel und Werte</span></p>
<p>Beachte, dass wir zuerst mit <code>use</code> die <code>HashMap</code> aus dem Kollektionsteil der
Standardbibliothek einbinden müssen. Von unseren drei allgemeinen Kollektionen
wird diese am seltensten verwendet, sodass sie nicht zu den Funktionalitäten
gehört, die automatisch in den Gültigkeitsbereich aufgenommen werden.
Hashtabellen werden auch weniger von der Standardbibliothek unterstützt; es
gibt zum Beispiel kein eingebautes Makro, um sie zu erzeugen.</p>
<p>Genau wie Vektoren speichern Hashtabellen ihre Daten im Haldenspeicher. 
Obige <code>HashMap</code> hat Schlüssel vom Typ <code>String</code> und Werte vom Typ <code>i32</code>.
Hashtabellen sind wie Vektoren homogen: Alle Schlüssel müssen den gleichen Typ
haben und alle Werte müssen den gleichen Typ haben.</p>
<p>Eine andere Möglichkeit, eine Hashtabelle zu erstellen, besteht im Verwenden
von Iteratoren und der Methode <code>collect</code> für einen Vektor von Tupeln, wobei
jedes Tupel aus einem Schlüssel und seinem Wert besteht. Auf Iteratoren und die
dazu gehörenden Methoden werden wir im Abschnitt <a href="ch13-02-iterators.html">„Eine Reihe von Elementen
verarbeiten mit Iteratoren“</a> in Kapitel 13 ausführlicher eingehen.
Die Methode <code>collect</code> sammelt Daten für zahlreiche Kollektionstypen,
einschließlich <code>HashMap</code>. Wenn wir z.B. die Teamnamen und Anfangsspielstände in
zwei getrennten Vektoren hätten, könnten wir die Methode <code>zip</code> verwenden, um
einen Vektor von Tupeln zu erstellen, in dem „Blau“ mit 10 gepaart ist, und so
weiter. Dann könnten wir die Methode <code>collect</code> verwenden, um diesen Vektor von
Tupeln in eine Hashtabelle umzuwandeln, wie in Codeblock 8-21 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams = vec![String::from(&quot;Blau&quot;), String::from(&quot;Gelb&quot;)];
let initial_scores = vec![10, 50];

let mut scores: HashMap&lt;_, _&gt; =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-21: Erstellen einer Hashtabelle aus einer
Liste von Teams und einer Liste von Spielständen</span></p>
<p>Die Typannotation <code>HashMap&lt;_, _&gt;</code> wird hier benötigt, weil <code>collect</code>
verschiedene Datenstrukturen als Rückgabetyp unterstützt und Rust nicht weiß,
welche du willst, es sei denn, du gibst sie an. Für die Typparameter der
Schlüssel- und Werttypen geben wir jedoch Unterstriche an, Rust kann anhand der
Datentypen in den Vektoren auf die Typen schließen, die die Hashtabelle
enthält. In Codeblock 8-21 wird der Schlüsseltyp <code>String</code> und der Werttyp <code>i32</code>
sein, genau wie die Typen in Codeblock 8-20.</p>
<h3><a class="header" href="#hashtabellen-und-eigentümerschaft" id="hashtabellen-und-eigentümerschaft">Hashtabellen und Eigentümerschaft</a></h3>
<p>Bei Typen wie <code>i32</code>, die das Merkmal <code>Copy</code> implementieren, werden die Werte in
die Hashtabelle kopiert. Bei aneigenbaren Werten wie <code>String</code> werden die Werte
verschoben und die Hashtabelle ist Eigentümer dieser Werte, wie in Codeblock
8-22 gezeigt wird.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Lieblingsfarbe&quot;);
let field_value = String::from(&quot;Blau&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name und field_value sind zu diesem Zeitpunkt ungültig.
// Versuche, sie zu benutzen und beobachte, welchen Kompilierfehler du erhältst!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-22: Zeigt, dass Schlüssel und Werte nach dem
Aufruf von <code>insert</code> Eigentum der Hashtabelle sind</span></p>
<p>Wir können die Variablen <code>field_name</code> und <code>field_value</code> nicht mehr verwenden,
nachdem sie mit dem Aufruf von <code>insert</code> in die Hashtabelle verschoben wurden.</p>
<p>Wenn wir Referenzen auf Werte in die Hashtabelle einfügen, werden die Werte
nicht in die Hashtabelle verschoben. Die Werte, auf die die Referenzen zeigen,
müssen mindestens so lange gültig sein, wie die Hashtabelle gültig ist. Wir
werden mehr über diese Fragen im Abschnitt <a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10 sprechen.</p>
<h3><a class="header" href="#zugreifen-auf-werte-in-einer-hashtabelle" id="zugreifen-auf-werte-in-einer-hashtabelle">Zugreifen auf Werte in einer Hashtabelle</a></h3>
<p>Wir können einen Wert aus der Hashtabelle herausholen, indem wir die Methode
<code>get</code> mit ihrem Schlüssel aufrufen, wie in Codeblock 8-23 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Geld&quot;), 50);

let team_name = String::from(&quot;Blau&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-23: Zugreifen auf den Spielstand von Team
Blau in der Hashtabelle</span></p>
<p>Hier wird <code>score</code> den Wert haben, der mit Team Blau assoziiert ist, und das
Ergebnis wird <code>Some(&amp;10)</code> sein. Das Ergebnis ist in <code>Some</code> eingepackt, weil
<code>get</code> eine <code>Option&lt;&amp;V&gt;</code> zurückgibt; wenn es keinen Wert für diesen Schlüssel in
der Hashtabelle gibt, gibt <code>get</code> den Wert <code>None</code> zurück. Das Programm muss die
<code>Option</code> auf eine Weise behandeln, die wir in Kapitel 6 besprochen haben.</p>
<p>Wir können über jedes Schlüssel-Wert-Paar in einer Hashtabelle auf ähnliche
Weise iterieren wie bei Vektoren, indem wir eine <code>for</code>-Schleife verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt alle Paare in einer beliebigen Reihenfolge aus:</p>
<pre><code class="language-text">Gelb: 50
Blau: 10
</code></pre>
<h3><a class="header" href="#aktualisieren-einer-hashtabelle" id="aktualisieren-einer-hashtabelle">Aktualisieren einer Hashtabelle</a></h3>
<p>Obwohl die Anzahl der Schlüssel und Werte wachsen kann, kann jedem Schlüssel
jeweils nur ein Wert zugeordnet werden. Wenn du die Daten in einer Hashtabelle
ändern willst, musst du entscheiden, wie der Fall zu behandeln ist, wenn einem
Schlüssel bereits ein Wert zugewiesen wurde. Du kannst den alten Wert durch den
neuen ersetzen und dabei den alten Wert völlig außer Acht lassen. Du kannst den
alten Wert behalten und den neuen Wert ignorieren und nur dann den neuen Wert
hinzufügen, wenn der Schlüssel noch <em>keinen</em> zugewiesenen Wert hat. Oder du
kannst den alten und neuen Wert kombinieren. Schauen wir uns an, wie diese
Varianten jeweils funktionieren!</p>
<h4><a class="header" href="#Überschreiben-eines-wertes" id="Überschreiben-eines-wertes">Überschreiben eines Wertes</a></h4>
<p>Wenn wir einen Schlüssel und einen Wert in eine Hashtabelle einfügen und dann
denselben Schlüssel mit einem anderen Wert einfügen, wird der mit diesem
Schlüssel assoziierte Wert ersetzt. Auch wenn der Code in Codeblock 8-24
zweimal <code>insert</code> aufruft, wird die Hashtabelle nur ein Schlüssel-Wert-Paar
enthalten, weil wir beide Male einen Wert für den Schlüssel des Teams Blau
einfügen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Blau&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-24: Ersetzen eines gespeicherten Wertes für
einen bestimmten Schlüssel</span></p>
<p>Dieser Code wird <code>{&quot;Blau&quot;: 25}</code> ausgeben. Der ursprüngliche Wert <code>10</code> wurde
überschrieben.</p>
<h4><a class="header" href="#nur-einen-wert-einfügen-wenn-der-schlüssel-keinen-wert-hat" id="nur-einen-wert-einfügen-wenn-der-schlüssel-keinen-wert-hat">Nur einen Wert einfügen, wenn der Schlüssel keinen Wert hat</a></h4>
<p>Es kommt oft vor, dass man zunächst prüfen will, ob ein bestimmter Schlüssel
einen Wert hat, und wenn dies nicht der Fall ist, einen Wert für ihn einzufügt.
Hashtabellen haben dafür eine spezielle Programmierschnittstelle (API) namens
<code>entry</code>, die den Schlüssel, den du prüfen willst, als Parameter nimmt. Der
Rückgabewert der Methode <code>entry</code> ist eine Aufzählung (enum) namens <code>Entry</code>, die
einen Wert repräsentiert, der existieren könnte oder auch nicht. Nehmen wir an,
wir wollen prüfen, ob der Schlüssel für das Team Gelb einen Wert hat. Wenn das
nicht der Fall ist, wollen wir den Wert 50 einfügen, und dasselbe gilt für das
Team Blau. Bei Verwendung von <code>entry</code> sieht der Code wie Codeblock 8-25 aus.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blau&quot;), 10);

scores.entry(String::from(&quot;Gelb&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blau&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-25: Verwenden der Methode <code>entry</code> zum
Einfügen, nur wenn der Schlüssel nicht bereits einen Wert hat</span></p>
<p>Die Methode <code>or_insert</code> von <code>Entry</code> ist so definiert, dass sie eine
veränderliche Referenz auf den Wert des entsprechenden <code>Entry</code>-Schlüssels
zurückgibt, wenn dieser Schlüssel existiert, andernfalls fügt sie den Parameter
als neuen Wert für diesen Schlüssel ein und gibt eine veränderliche Referenz
auf den neuen Wert zurück. Diese Technik ist viel sauberer, als die Logik
selbst zu schreiben, und sie harmoniert besser mit dem Ausleihenprüfer.</p>
<p>Der Code in Codeblock 8-25 gibt <code>{&quot;Gelb&quot;: 50, &quot;Blau&quot;: 10}</code> aus. Beim ersten
Aufruf von <code>entry</code> wird der Schlüssel von Team Gelb mit dem Wert 50 eingefügt,
da das Team Gelb noch keinen Wert hat. Der zweite Aufruf von <code>entry</code> wird die
Hashtabelle nicht verändern, da das Team Blau bereits den Wert 10 hat.</p>
<h4><a class="header" href="#aktualisieren-eines-wertes-auf-basis-des-alten-wertes" id="aktualisieren-eines-wertes-auf-basis-des-alten-wertes">Aktualisieren eines Wertes auf Basis des alten Wertes</a></h4>
<p>Ein weiterer gängiger Anwendungsfall für Hashtabellen besteht darin, den Wert
eines Schlüssels nachzuschlagen und ihn dann auf Basis des alten Wertes zu
aktualisieren. Beispielsweise zeigt Codeblock 8-26 einen Code, der zählt, wie
oft jedes Wort in einem Text vorkommt. Wir verwenden eine Hashtabelle mit den
Wörtern als Schlüssel und inkrementieren den Wert, um nachzuvollziehen, wie oft
wir dieses Wort schon gesehen haben. Wenn es das erste Mal ist, dass wir ein
Wort sehen, fügen wir zuerst den Wert 0 ein.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;Hallo Welt wunderbare Welt&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-26: Zählen des Vorkommens von Wörtern mit
Hilfe einer Hashtabelle, die Wörter speichert und zählt</span></p>
<p>Dieser Code wird <code>{&quot;Welt&quot;: 2, &quot;wunderbare&quot;: 1, &quot;Hallo&quot;: 1}</code> ausgeben. Die
Methode <code>or_insert</code> gibt tatsächlich eine veränderliche Referenz (<code>&amp;mut V</code>) auf
den Wert für diesen Schlüssel zurück. Hier speichern wir diese veränderliche
Referenz in der Variablen <code>count</code>. Um diesen Wert zuzuweisen, müssen wir also
zuerst <code>count</code> mittels Sternoperator (<code>*</code>) dereferenzieren. Die veränderliche
Referenz verlässt den Gültigkeitsbereich am Ende der <code>for</code>-Schleife, sodass all
diese Änderungen sicher sind und von den Ausleihregeln erlaubt werden.</p>
<h3><a class="header" href="#hash-funktionen" id="hash-funktionen">Hash-Funktionen</a></h3>
<p>Standardmäßig verwendet <code>HashMap</code> eine „kryptographisch starke“<sup class="footnote-reference"><a href="#siphash">1</a></sup>
Hash-Funktion, die gegen Denial-of-Service (DoS)-Attacken robust ist. Dies ist
nicht der schnellste verfügbare Hashing-Algorithmus, aber der Kompromiss
zugunsten einer höheren Sicherheit gegenüber einer geringeren Performanz ist es
Wert. Wenn du eine Performanzanalyse deines Codes machst und feststellst, dass
die Standard-Hash-Funktion für deine Zwecke zu langsam ist, kannst du zu einer
anderen Funktion wechseln, indem du eine andere Hash-Funktion angibst. Eine
Hash-Funktion ist ein Typ, der das Merkmal <code>BuildHasher</code> implementiert. Wir
werden in Kapitel 10 über Merkmale und ihre Implementierung sprechen. Du musst
nicht unbedingt deine eigene Hash-Funktion von Grund auf implementieren;
<a href="https://crates.io/">crates.io</a> verfügt über Bibliotheken, die von anderen
Rust-Nutzern bereitgestellt werden und viele gängige Hash-Funktionen
implementieren.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<h2><a class="header" href="#zusammenfassung-7" id="zusammenfassung-7">Zusammenfassung</a></h2>
<p>Vektoren, Zeichenketten und Hashtabellen bieten eine große Menge an
Funktionalität, die in Programmen benötigt wird, wenn du Daten speichern,
darauf zugreifen und sie verändern willst. Hier sind einige Übungen, für deren
Lösung du jetzt gerüstet sein solltest:</p>
<ul>
<li>Verwende bei einer Liste von ganzen Zahlen einen Vektor und gib den
Mittelwert (Durchschnittswert), den Median (wenn sortiert, den Wert in der
Mitte) und den Modus (den Wert, der am häufigsten vorkommt; eine Hashtabelle
ist hier hilfreich) der Liste zurück.</li>
<li>Wandle Zeichenketten in Schweinelatein (pig latin) um. Der erste Konsonant
jedes Wortes wird an das Ende des Wortes verschoben und „ay“ angehängt,
sodass „zuerst“ zu „uerst-zay“ wird. Bei Wörtern, die mit einem Vokal
beginnen, wird stattdessen „hay“ an das Ende angefügt („ansehen“ wird zu
„ansehen-hay“). Beachte die Details zur UTF-8-Kodierung!</li>
<li>Erstelle mit Hilfe einer Hashtabelle und Vektoren eine Textschnittstelle, die
es einem Benutzer ermöglicht, Mitarbeiternamen zu einer Abteilung in einem
Unternehmen hinzuzufügen. Zum Beispiel „Sally zur Technik hinzufügen“ oder
„Amir zum Vertrieb hinzufügen“. Lass den Benutzer dann eine alphabetisch
sortierte Liste aller Personen in einer Abteilung oder aller Personen in der
Firma nach Abteilung ausgeben.</li>
</ul>
<p>Die API-Dokumentation der Standard-Bibliothek beschreibt Methoden für Vektoren,
Zeichenketten und Hashtabellen, die für diese Übungen hilfreich sind!</p>
<p>Wir steigen in komplexere Programme ein, in denen Operationen fehlschlagen
können, daher ist es ein perfekter Zeitpunkt, auf die Fehlerbehandlung
einzugehen. Das werden wir als nächstes tun!</p>
<h1><a class="header" href="#fehlerbehandlung" id="fehlerbehandlung">Fehlerbehandlung</a></h1>
<p>Rusts Engagement für Zuverlässigkeit erstreckt sich auch auf die
Fehlerbehandlung. Fehler sind Gegebenheiten in Software, deshalb enthält Rust
eine Reihe von Funktionalitäten zur Behandlung von Situationen, in denen etwas
schiefgeht. In vielen Fällen verlangt Rust von dir, dass du die Möglichkeit
eines Fehlers anerkennst und Vorkehrungen ergreifst, damit dein Code kompiliert
werden kann. Diese Anforderung macht dein Programm robuster, da sichergestellt
wird, dass du Fehler entdeckst und diese angemessen behandelst, bevor dein Code
in Produktion gebracht wird!</p>
<p>Rust gruppiert Fehler in zwei Hauptkategorien: <em>Behebbare</em> (recoverable) und
<em>nicht behebbare</em> (unrecoverable) Fehler. Bei einem behebbaren Fehler, z.B.
„Datei nicht gefunden“, ist es sinnvoll, das Problem dem Benutzer zu melden und
den Vorgang erneut zu versuchen. Nicht behebbare Fehler sind immer Symptome von
Programmierfehlern, z.B. der Versuch, auf eine Stelle jenseits des Endes eines
Arrays zuzugreifen.</p>
<p>Die meisten Sprachen unterscheiden nicht zwischen diesen beiden Fehlerarten und
behandeln beide auf die gleiche Weise, indem sie Mechanismen wie die
Ausnahmebehandlung verwenden. Rust hat keine Ausnahmebehandlung. Stattdessen
hat es den Typ <code>Result&lt;T, E&gt;</code> für behebbare Fehler und das Makro <code>panic!</code>, das
die Ausführung stoppt, wenn das Programm auf einen nicht behebbaren Fehler
stößt. Dieses Kapitel behandelt zuerst das Aufrufen von <code>panic!</code> und spricht
dann über die Rückgabe von <code>Result&lt;T, E&gt;</code>-Werten. Darüber hinaus werden wir
Überlegungen anstellen, wann wir besser versuchen sollten, uns von einem Fehler
zu erholen, und wann die Ausführung zu stoppen.</p>
<h2><a class="header" href="#nicht-behebbare-fehler-mit-panic" id="nicht-behebbare-fehler-mit-panic">Nicht behebbare Fehler mit <code>panic!</code></a></h2>
<p>Manchmal passieren schlimme Dinge in deinem Code und du kannst nichts dagegen
tun. Für diese Fälle hat Rust das Makro <code>panic!</code>. Wenn das Makro <code>panic!</code>
ausgeführt wird, wird dein Programm eine Fehlermeldung ausgeben, den
Stapelspeicher abwickeln und aufräumen und sich dann beenden. Dies tritt am
häufigsten dann auf, wenn ein Fehler irgendeiner Art entdeckt wurde und dem
Programmierer nicht klar ist, wie er mit dem Fehler umgehen soll.</p>
<blockquote>
<h3><a class="header" href="#auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion" id="auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion">Auflösen des Stapelspeichers oder Abbrechen als Fehlerreaktion</a></h3>
<p>Wenn ein Programmabbruch auftritt, beginnt das Programm standardmäßig mit dem
<em>Abwickeln</em>, was bedeutet, dass Rust den Stapelspeicher wieder nach oben geht
und die Daten von jeder Funktion, auf die es trifft, bereinigt. Aber dieses
Zurückgehen und Aufräumen ist eine Menge Arbeit. Die Alternative ist der
sofortige <em>Abbruch</em> (abort), der das Programm ohne aufzuräumen beendet. Der
Speicher, den das Programm benutzt hat, muss dann vom Betriebssystem
aufgeräumt werden. Wenn du in deinem Projekt die resultierende Binärdatei so
klein wie möglich machen willst, kannst du für ein vorzeitiges Programmende
vom Abwickeln zum sofortigen Abbrechen umschalten, indem du <code>panic = 'abort'</code>
in den entsprechenden <code>[profile]</code>-Abschnitten in deiner <em>Cargo.toml</em>-Datei
hinzufügst. Wenn du beispielsweise im Freigabemodus (release mode) im
Fehlerfall sofort abbrechen möchtest, füge dies hinzu:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Versuchen wir <code>panic!</code> in einem einfachen Programm aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;abstürzen und verbrennen&quot;);
}
</code></pre></pre>
<p>Wenn du das Programm ausführst, wirst du in etwa das hier sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'abstürzen und verbrennen', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Der Aufruf von <code>panic!</code> verursacht die in den letzten beiden Zeilen enthaltene
Fehlermeldung. Die erste Zeile zeigt unsere Fehlermeldung und die Position in
unserem Quellcode, an der der Fehler aufgetreten ist: <em>src/main.rs:2:5</em> gibt
an, dass es sich um die zweite Zeile und dem fünften Zeichen in unserer Datei
<em>src/main.rs</em> handelt.</p>
<p>In diesem Fall ist die angegebene Zeile Teil unseres Codes und wenn wir uns
diese Zeile ansehen, sehen wir den Makroaufruf <code>panic!</code>. In anderen Fällen
könnte der Aufruf von <code>panic!</code> in Code erfolgen, den unser Code aufruft, und
der Dateiname und die Zeilennummer in der Fehlermeldung gehören zu Code von
jemand anderen, der das Makro <code>panic!</code> aufruft, nicht zu unserem Code, der
schließlich zum Aufruf von <code>panic!</code> geführt hat. Wir können die Aufrufhistorie
(backtrace) der Funktionen, von der der <code>panic!</code>-Aufruf kam, nutzen, um den
Codeteil zu ermitteln, der das Problem verursacht. Im Folgenden sehen wir uns
genauer an, was eine Aufrufhistorie ist.</p>
<h3><a class="header" href="#verwenden-einer-panic-aufrufhistorie" id="verwenden-einer-panic-aufrufhistorie">Verwenden einer <code>panic!</code>-Aufrufhistorie</a></h3>
<p>Sehen wir uns ein weiteres Beispiel an, bei dem der <code>panic!</code>-Aufruf von einer
Bibliothek kommt, weil wir einen Fehler in unserem Code haben, anstatt das
Makro direkt aufzurufen. Codeblock 9-1 enthält einen Code, der versucht, auf
ein Element per Index in einem Vektor zuzugreifen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-1: Versuch, auf ein Element jenseits des
Endes eines Vektors zuzugreifen, was einen Aufruf von <code>panic!</code> auslöst</span></p>
<p>Hier versuchen wir, auf das 100. Element unseres Vektors zuzugreifen (das bei Index 99
liegt, weil die Indexierung bei Null beginnt), der aber nur 3 Elemente hat. In dieser
Situation wird Rust das Programm abbrechen. Das Verwenden von <code>[]</code> soll ein Element
zurückgeben, aber wenn du einen ungültigen Index übergibst, gibt es kein Element, das
Rust hier korrekterweise zurückgeben könnte.</p>
<p>In C ist der Versuch, über das Ende einer Datenstruktur hinaus zu lesen, ein
undefiniertes Verhalten. Möglicherweise erhältst du den Wert im Speicher an der
der Datenstruktur entsprechenden Stelle, selbst wenn der Speicher nicht zu
dieser Struktur gehört. Dies wird als <em>Hinauslesen über den Puffer</em> (buffer
overread) bezeichnet und kann zu Sicherheitslücken führen, wenn ein Angreifer
in der Lage ist, den Index so zu manipulieren, dass er unerlaubterweise Daten
lesen kann, die nach der Datenstruktur gespeichert sind.</p>
<p>Um dein Programm vor dieser Art Verwundbarkeit zu schützen, wird Rust beim
Versuch, ein Element an einem Index zu lesen, der nicht existiert, die
Ausführung stoppen und die Fortsetzung verweigern. Versuchen wir es und sehen,
was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Dieser Fehler weist auf eine Datei hin, die wir nicht geschrieben haben:
<em>libcore/slice/mod.rs</em>. Das ist die Implementierung von <code>slice</code> im
Rust-Quellcode. Der Code, der ausgeführt wird, wenn wir <code>[]</code> auf unserem Vektor
<code>v</code> anwenden, befindet sich in <em>libcore/slice/mod.rs</em>, und das ist der Ort, an
dem <code>panic!</code> tatsächlich aufgerufen wird.</p>
<p>Die nächste Hinweiszeile sagt uns, dass wir die Umgebungsvariable
<code>RUST_BACKTRACE</code> setzen können, um eine Aufrufhistorie zur Fehlerursache zu
erhalten. Eine <em>Aufrufhistorie</em> ist eine Liste aller Funktionen, die aufgerufen
wurden, um an diesen Punkt zu gelangen. Aufrufhistorien in Rust funktionieren
wie in anderen Sprachen: Der Schlüssel zum Lesen der Aufrufhistorie liegt
darin, diese von oben beginnend zu lesen, bis du von dir geschriebene Dateien
siehst. Das ist die Stelle, an der das Problem entstanden ist. Die Zeilen
darüber sind Code, den dein Code aufgerufen hat; die Zeilen darunter sind Code,
der deinen Code aufgerufen hat. Diese Zeilen können Kern-Rust-Code,
Standard-Bibliothekscode oder Kisten (crates), die du verwendest, sein. Lass
uns versuchen, eine Aufrufhistorie zu erhalten, indem wir die Umgebungsvariable
<code>RUST_BACKTRACE</code> auf einen beliebigen Wert außer 0 setzen. Codeblock 9-2 zeigt
eine Ausgabe, wie du sie in etwa sehen wirst.</p>
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:84
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::ArgumentV1::show_usize
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1426
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:193
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:471
  11: rust_begin_unwind
             at src/libstd/panicking.rs:375
  12: core::panicking::panic_fmt
             at src/libcore/panicking.rs:84
  13: core::panicking::panic_bounds_check
             at src/libcore/panicking.rs:62
  14: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
  15: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
  16: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
  17: panic::main
             at src/main.rs:4
  18: std::rt::lang_start::{{closure}}
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:52
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:270
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:51
  25: std::rt::lang_start
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  26: panic::main
</code></pre>
<p><span class="caption">Codeblock 9-2: Aufrufhistorie, erzeugt durch einen Aufruf
von <code>panic!</code>, wenn die Umgebungsvariable <code>RUST_BACKTRACE</code> gesetzt ist</span></p>
<p>Das ist eine lange Ausgabe! Die genaue Ausgabe kann je nach Betriebssystem und
Rust-Version unterschiedlich sein. Um Aufrufhistorien mit diesen Informationen
zu erhalten, müssen Fehlersuchinfos (debug symbols) aktiviert sein.
Fehlersuchinfos sind standardmäßig aktiviert, wenn du <code>cargo build</code> oder
<code>cargo run</code> ohne Flag <code>--release</code> verwendest, wie wir es hier haben.</p>
<p>In der Ausgabe in Codeblock 9-2 zeigt Zeile 17 der Aufrufhistorie auf die Zeile
in unserem Projekt, die das Problem verursacht: Zeile 4 in <em>src/main.rs</em>. Wenn
wir nicht wollen, dass unser Programm abbricht, sollten wir bei der ersten
Zeile, die auf eine von uns geschriebenen Datei verweist, mit der Untersuchung
beginnen. In Codeblock 9-1, wo wir absichtlich Code geschrieben haben, der das
Programm abbricht, um zu demonstrieren, wie man Aufrufhistorien liest, lässt
sich der Abbruch beheben, indem kein Element mit Index 99 von einem Vektor mit
nur 3 Elementen gelesen wird. Wenn dein Code in Zukunft abbricht, musst du
herausfinden, bei welcher Aktion der Code mit welchen Werten abbricht und was
der Code stattdessen tun sollte.</p>
<p>In Abschnitt <a href="ch09-03-to-panic-or-not-to-panic.html">„Wann <code>panic!</code> verwenden und wann
nicht?“</a> später in diesem Kapitel kommen wir noch
einmal auf <code>panic!</code> zurück und wann wir <code>panic!</code> verwenden sollten und wann
nicht, um Fehlerfälle zu behandeln. Als Nächstes schauen wir uns an, wie man
sich mit <code>Result</code> von einem Fehler erholt.</p>
<h2><a class="header" href="#behebbare-fehler-mit-result" id="behebbare-fehler-mit-result">Behebbare Fehler mit <code>Result</code></a></h2>
<p>Die meisten Fehler sind nicht so schwerwiegend, dass das Programm ganz
abgebrochen werden müsste. Manchmal, wenn eine Funktion fehlschlägt, hat das
einen Grund, den man leicht erkennen und darauf reagieren kann. Wenn du
beispielsweise versuchst, eine Datei zu öffnen, und dieser Vorgang schlägt
fehl, weil die Datei nicht existiert, könntest du die Datei erstellen, anstatt
den Vorgang zu beenden.</p>
<p>Erinnere dich an <a href="ch02-00-guessing-game-tutorial.html#behandeln-potentieller-fehler-mit-dem-typ-result">„Behandeln potentieller Fehler mit dem Typ
<code>Result</code>“</a> in Kapitel 2, das die Aufzählung <code>Result</code> mit zwei
Varianten <code>Ok</code> und <code>Err</code> definiert, wie nachfolgend zu sehen ist:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> und <code>E</code> sind generische Typparameter: Wir werden generische Datentypen in
Kapitel 10 ausführlicher besprechen. Was du jetzt wissen musst, ist, dass <code>T</code>
den Typ des Wertes darstellt, der im Erfolgsfall innerhalb der <code>Ok</code>-Variante
zurückgegeben wird, und <code>E</code> den Typ des Fehlers, der im Fehlerfall innerhalb
der <code>Err</code>-Variante zurückgegeben wird. Da <code>Result</code> diese generischen
Typparameter hat, können wir den <code>Result</code>-Typ und die Funktionen, die die
Standardbibliothek darauf definiert hat, in vielen verschiedenen Situationen
verwenden, in denen der Erfolgswert und der Fehlerwert, den wir zurückgeben
wollen, unterschiedlich sein können.</p>
<p>Rufen wir eine Funktion auf, die einen <code>Result</code>-Wert zurückgibt, weil die
Funktion fehlschlagen könnte. In Codeblock 9-3 versuchen wir, eine Datei zu
öffnen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-3: Eine Datei öffnen</span></p>
<p>Woher wissen wir, dass <code>File::open</code> ein <code>Result</code> zurückgibt? Wir könnten uns
die <a href="https://doc.rust-lang.org/std/index.html">Standard-Bibliotheks-API-Dokumentation</a> ansehen oder wir
könnten den Compiler fragen! Wenn wir <code>f</code> eine Typ-Annotation geben, von der
wir wissen, dass sie <em>nicht</em> der Rückgabetyp der Funktion ist, und dann
versuchen, den Code zu kompilieren, wird der Compiler uns sagen, dass die
Typen nicht übereinstimmen. Die Fehlermeldung sagt uns dann, welchen Typ <code>f</code>
tatsächlich hat. Versuchen wir es! Wir wissen, dass der Rückgabetyp von
<code>File::open</code> nicht vom Typ <code>u32</code> ist, also lass uns die Anweisung <code>let f</code> wie
folgt ändern:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);



<span class="boring">}
</span></code></pre></pre>
<p>Der Versuch, zu kompilieren, liefert uns nun folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hallo.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dies sagt uns, dass die Funktion <code>File::open</code> den Rückgabetyp <code>Result&lt;T, E&gt;</code>
hat. Der generische Parameter <code>T</code> wurde hier mit dem Typ des Erfolgswertes
<code>std::fs::File</code>, der eine Dateiressource (file handle) ist, gefüllt. Der Typ
<code>E</code> für den Fehlerwert ist <code>std::io::Error</code>.</p>
<p>Dieser Rückgabetyp bedeutet, dass der Aufruf von <code>File::open</code> erfolgreich sein
könnte und eine Dateiressource zurückgibt, aus der wir lesen oder in die wir
schreiben können. Der Funktionsaufruf kann auch fehlschlagen: Zum Beispiel
könnte die Datei nicht existieren oder wir haben möglicherweise keine
Zugriffsberechtigung für die Datei. Die Funktion <code>File::open</code> muss eine
Möglichkeit haben, uns zu sagen, ob sie erfolgreich war oder fehlgeschlagen
ist, und uns gleichzeitig entweder die Dateiressource oder die
Fehlerinformationen liefern. Diese Informationen sind genau das, was die
Aufzählung <code>Result</code> übermittelt.</p>
<p>Falls <code>File::open</code> erfolgreich ist, wird der Wert der Variable <code>f</code> eine Instanz
von <code>Ok</code> sein, die eine Dateiressource enthält. Im Fehlerfall ist der Wert von
<code>f</code> eine Instanz von <code>Err</code>, die mehr Informationen über die Art des
aufgetretenen Fehlers enthält.</p>
<p>Wir müssen den Code in Codeblock 9-3 ergänzen, um abhängig vom Rückgabewert von
<code>File::open</code> unterschiedliche Aktionen durchzuführen. Codeblock 9-4 zeigt eine
Möglichkeit, <code>Result</code> mit Hilfe eines grundlegenden Werkzeugs, dem Ausdruck
<code>match</code>, den wir in Kapitel 6 besprochen haben, zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-4: Verwenden eines <code>match</code>-Ausdrucks zum
Behandeln der <code>Result</code>-Varianten, die zurückgegeben werden könnten</span></p>
<p>Beachte, dass die Aufzählung <code>Result</code> und ihre Varianten automatisch im
Gültigkeitsbereich verfügbar sind, genau wie bei der Aufzählung <code>Option</code>,
sodass wir in den <code>match</code>-Zweigen nicht mehr <code>Result::</code> vor den Varianten <code>Ok</code>
und <code>Err</code> angeben müssen.</p>
<p>Hier sagen wir Rust, dass wir, wenn das Ergebnis <code>Ok</code> ist, den inneren Wert
<code>file</code> aus der <code>Ok</code>-Variante zurückgeben, und dann weisen wir diese
Dateiressource der Variablen <code>f</code> zu. Nach dem <code>match</code> können wir die
Dateiressource zum Lesen und Schreiben verwenden.</p>
<p>Der andere Zweig von <code>match</code> behandelt den Fall, dass wir einen <code>Err</code>-Wert von
<code>File::open</code> erhalten. In diesem Beispiel haben wir uns dafür entschieden, das
Makro <code>panic!</code> aufzurufen. Wenn es keine Datei namens <em>hallo.txt</em> in unserem
aktuellen Verzeichnis gibt und wir diesen Code ausführen, sehen wir die
folgende Ausgabe des Makros <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Wie üblich sagt uns diese Ausgabe genau, was schiefgelaufen ist.</p>
<h3><a class="header" href="#abgleich-verschiedener-fehler" id="abgleich-verschiedener-fehler">Abgleich verschiedener Fehler</a></h3>
<p>Der Code in Codeblock 9-4 wird abbrechen, egal aus welchem Grund <code>File::open</code>
fehlschlug. Was wir stattdessen tun wollen, ist, bei verschiedenen
Fehlerursachen unterschiedliche Maßnahmen zu ergreifen: Wenn <code>File::open</code>
fehlgeschlagen ist, weil die Datei nicht existiert, wollen wir die Datei
erstellen und die Dateiressource der neuen Datei zurückgeben. Wenn <code>File::open</code>
aus irgendeinem anderen Grund fehlschlug, z.B. weil wir keine Berechtigung zum
Öffnen der Datei hatten, wollen wir immer noch, dass der Code abbricht, so wie
es in Codeblock 9-4 der Fall war. Schau dir Codeblock 9-5 an, der zusätzlich
einen inneren <code>match</code>-Ausdruck hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hallo.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, other_error)
            }
        },
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-5: Unterschiedliche Arten von Fehlern auf
unterschiedliche Weise behandeln</span></p>
<p>Der Typ des Wertes, den <code>File::open</code> innerhalb der Variante <code>Err</code> zurückgibt,
ist <code>io::Error</code>, eine Struktur (struct), die von der Standardbibliothek zur
Verfügung gestellt wird. Diese Struktur hat eine Methode <code>kind</code>, die wir
aufrufen können, um einen <code>io::ErrorKind</code>-Wert zu erhalten. Die Aufzählung
<code>io::ErrorKind</code> wird von der Standardbibliothek zur Verfügung gestellt und
enthält Varianten, die die verschiedenen Fehlerarten repräsentieren, die bei
einer <code>io</code>-Operation auftreten können. Die Variante, die wir verwenden wollen,
ist <code>ErrorKind::NotFound</code>, was bedeutet, dass die Datei, die wir zu öffnen
versuchen, noch nicht existiert. Wir werten also <code>f</code> aus, als auch
<code>error.kind()</code>.</p>
<p>Die Bedingung, die wir beim inneren Abgleich überprüfen wollen, ist, ob der von
<code>error.kind()</code> zurückgegebene Wert die Variante <code>NotFound</code> der Aufzählung
<code>ErrorKind</code> ist. Wenn das der Fall ist, versuchen wir, die Datei mit
<code>File::create</code> zu erstellen. Da <code>File::create</code> aber auch scheitern könnte,
brauchen wir einen zweiten Zweig im inneren <code>match</code>-Ausdruck. Wenn die Datei
nicht erstellt werden kann, wird eine andere Fehlermeldung ausgegeben. Der
zweite Zweig des äußeren <code>match</code> bleibt gleich, sodass das Programm bei jedem
Fehler außer dem Fehler der fehlenden Datei abbricht.</p>
<p>Das sind viele <code>match</code>! Der Ausdruck <code>match</code> ist sehr nützlich, aber auch sehr
primitiv. In Kapitel 13 erfährst du etwas über Funktionsabschlüsse (closures);
der Typ <code>Result&lt;T, E&gt;</code> hat viele Methoden, die einen Funktionsabschluss
akzeptieren und mittels <code>match</code>-Ausdrücke implementiert sind. Das Verwenden
dieser Methoden wird deinen Code prägnanter machen. Ein erfahrenerer
Rust-Entwickler könnte diesen Code anstelle von Codeblock 9-5 schreiben:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error);
        }
    });
}
</code></pre></pre>
<p>Obwohl dieser Code dasselbe Verhalten wie Codeblock 9-5 aufweist, enthält er
keine <code>match</code>-Ausdrücke und ist einfacher zu lesen. Kehre zu diesem Beispiel
zurück, nachdem du Kapitel 13 gelesen hast, und schlage die Methode
<code>unwrap_or_else</code> in der Standardbibliotheksdokumentation nach. Viele weitere
dieser Methoden können große, verschachtelte <code>match</code>-Ausdrücke vermeiden, wenn
du mit Fehlern zu tun hast.</p>
<h3><a class="header" href="#abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect" id="abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect">Abkürzungen zum Abbrechen im Fehlerfall: <code>unwrap</code> und <code>expect</code></a></h3>
<p>Das Verwenden von <code>match</code> funktioniert gut genug, aber es kann etwas wortreich
sein und vermittelt das Vorhaben nicht immer gut. Der Typ <code>Result&lt;T, E&gt;</code> bietet
viele Hilfsmethoden, um verschiedene Aufgaben zu erledigen. Eine dieser
Methoden, genannt <code>unwrap</code>, ist eine Abkürzungsmethode, die genauso
implementiert ist wie der Ausdruck <code>match</code>, den wir in Codeblock 9-4
geschrieben haben. Wenn der <code>Result</code>-Wert die Variante <code>Ok</code> ist, gibt <code>unwrap</code>
den Wert innerhalb <code>Ok</code> zurück. Wenn <code>Result</code> die Variante <code>Err</code> ist, ruft
<code>unwrap</code> das Makro <code>panic!</code> für uns auf. Hier ist ein Beispiel für <code>unwrap</code> in
Aktion:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Wenn wir diesen Code ohne eine Datei <em>hallo.txt</em> ausführen, werden wir die
Fehlermeldung des <code>panic!</code>-Aufrufs sehen, den die Methode <code>unwrap</code> macht:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Des Weiteren gibt es die Methode <code>expect</code>, die ähnlich wie <code>unwrap</code>
funktioniert und uns zusätzlich die <code>panic!</code>-Fehlermeldung angeben lässt. Das
Verwenden von <code>expect</code> anstelle von <code>unwrap</code> und das Angeben guter
Fehlermeldungen kann deine Absicht vermitteln und das Aufspüren der
Fehlerursache erleichtern. Die Syntax von <code>expect</code> sieht wie folgt aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).expect(&quot;Problem beim Öffnen von hallo.txt&quot;);
}
</code></pre></pre>
<p>Wir benutzen <code>expect</code> auf die gleiche Weise wie <code>unwrap</code>: Um die Dateiressource
zurückzugeben oder das Makro <code>panic!</code> aufzurufen. Die Fehlermeldung, die
<code>expect</code> beim Aufruf von <code>panic!</code> mitgibt, wird als Parameter an <code>expect</code>
übergeben, anstelle der standardmäßigen <code>panic!</code>-Nachricht, die <code>unwrap</code>
verwendet. So sieht sie aus:</p>
<pre><code class="language-text">thread 'main' panicked at 'Problem beim Öffnen von hallo.txt: Os { code: 2,
kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:4:13
</code></pre>
<p>Da diese Fehlermeldung mit dem von uns angegebenen Text <code>Problem beim Öffnen von hallo.txt</code> beginnt, ist es einfacher herauszufinden, woher diese
Fehlermeldung im Code kommt. Wenn wir <code>unwrap</code> an mehreren Stellen verwenden,
kann es länger dauern, genau herauszufinden, welches <code>unwrap</code> zum
Programmabbruch geführt hat, weil alle <code>unwrap</code>-Aufrufe die gleiche Nachricht
ausgeben.</p>
<h3><a class="header" href="#fehler-weitergeben" id="fehler-weitergeben">Fehler weitergeben</a></h3>
<p>Wenn du eine Funktion schreibst, deren Implementierung etwas aufruft, das
fehlschlagen könnte, kannst du, anstatt den Fehler innerhalb dieser Funktion
zu behandeln, den Fehler an den aufrufenden Code zurückgeben, damit dieser
entscheiden kann, was zu tun ist. Dies wird als <em>Weitergeben</em> (propagating) des
Fehlers bezeichnet und gibt dem aufrufenden Code mehr Kontrolle, wo mehr
Informationen und Logik zur Fehlerbehandlung vorhanden sein könnte, als im
Kontext deines Codes zur Verfügung steht.</p>
<p>Beispielsweise zeigt Codeblock 9-6 eine Funktion, die einen Benutzernamen aus
einer Datei liest. Wenn die Datei nicht existiert oder nicht gelesen werden
kann, gibt diese Funktion den Fehler an den Code zurück, der diese Funktion
aufgerufen hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hallo.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-6: Eine Funktion, die mit <code>match</code> Fehler an
den aufrufenden Code zurückgibt</span></p>
<p>Diese Funktion kann auf eine viel kürzere Art und Weise geschrieben werden,
aber wir wollen für den Anfang viel davon manuell zu machen, um die
Fehlerbehandlung zu erkunden; am Ende werden wir den kürzeren Weg zeigen. Sehen
wir uns zunächst den Rückgabetyp der Funktion an: <code>Result&lt;String, io::Error&gt;</code>.
Das bedeutet, dass die Funktion einen Wert vom Typ <code>Result&lt;T, E&gt;</code> zurückgibt,
wobei der generische Typ <code>T</code> mit dem konkreten Typ <code>String</code> und der generische
Typ <code>E</code> mit dem konkreten Typ <code>io::Fehler</code> gefüllt wurde. Wenn diese Funktion
erfolgreich ist, erhält der aufrufende Code einen <code>Ok</code>-Wert, der einen <code>String</code>
enthält – den Benutzernamen, den diese Funktion aus der Datei liest. Wenn
diese Funktion auf Probleme stößt, erhält der aufrufende Code einen <code>Err</code>-Wert,
der eine Instanz von <code>io::Error</code> enthält, mit weiteren Informationen darüber,
was die Probleme waren. Wir wählten <code>io::Error</code> als Rückgabetyp dieser
Funktion, weil dies zufällig der Typ des Fehlerwertes ist, der von beiden
Operationen zurückgegeben wird, die wir im Funktionsrumpf aufrufen und
fehlschlagen könnten: Die Funktion <code>File::open</code> und die Methode
<code>read_to_string</code>.</p>
<p>Der Funktionsrumpf beginnt mit dem Aufruf der Funktion <code>File::open</code>. Dann
behandeln wir den <code>Result</code>-Wert, der von <code>match</code> zurückgegeben wird, auf
ähnliche Weise wie bei <code>match</code> in Codeblock 9-4, allerdings anstatt <code>panic!</code> im
<code>Err</code>-Fall aufzurufen, beenden wir die Funktion vorzeitig und übergeben den
Fehlerwert von <code>File::open</code> als Fehlerwert dieser Funktion an den aufrufenden
Code. Wenn <code>File::open</code> erfolgreich ist, speichern wir die Dateiressource in
der Variable <code>f</code> und fahren fort.</p>
<p>Dann erstellen wir einen neuen <code>String</code> in der Variable <code>s</code> und rufen die
Methode <code>read_to_string</code> auf der Dateiressource in <code>f</code> auf, um den Inhalt der
Datei in <code>s</code> einzulesen. Die Methode <code>read_to_string</code> gibt ebenfalls ein
<code>Result</code> zurück, weil sie fehlschlagen könnte, obwohl <code>File::open</code> erfolgreich
war. Wir brauchen also ein weiteres <code>match</code>, um dieses <code>Result</code> zu verarbeiten:
Wenn <code>read_to_string</code> erfolgreich ist, dann war unsere Funktion erfolgreich und
wir geben den Benutzernamen aus der Datei zurück, die jetzt in <code>s</code> innerhalb
<code>Ok</code> enthalten ist. Wenn <code>read_to_string</code> fehlschlägt, geben wir den Fehlerwert
auf die gleiche Weise zurück, wie wir den Fehlerwert in <code>match</code> zurückgegeben
haben, das den Rückgabewert von <code>File::open</code> behandelt hat. Wir brauchen jedoch
nicht ausdrücklich <code>return</code> anzugeben, weil dies der letzte Ausdruck in der
Funktion ist.</p>
<p>Der Code, der diesen Code aufruft, wird dann damit zurechtkommen, entweder
einen <code>Ok</code>-Wert zu erhalten, der einen Benutzernamen enthält, oder einen
<code>Err</code>-Wert, der einen <code>io::Error</code> enthält. Wir wissen nicht, was der Aufrufcode
mit diesen Werten machen wird. Wenn der aufrufende Code einen <code>Err</code>-Wert
erhält, könnte er <code>panic!</code> aufrufen und das Programm zum Absturz bringen, einen
Standardbenutzernamen verwenden oder den Benutzernamen von irgendwo anders als
z.B. einer Datei nachschlagen. Wir haben nicht genug Informationen darüber, was
der aufrufende Code tatsächlich versucht, also propagieren wir alle Erfolgs-
und Fehlerinformationen nach oben, damit sie angemessen behandelt werden.
Dieses Muster der Fehlerweitergabe ist in Rust so verbreitet, dass Rust den
Fragezeichen-Operator <code>?</code> bereitstellt, um dies zu erleichtern.</p>
<h4><a class="header" href="#abkürzung-zum-weitergeben-von-fehlern-der-operator-" id="abkürzung-zum-weitergeben-von-fehlern-der-operator-">Abkürzung zum Weitergeben von Fehlern: Der Operator <code>?</code></a></h4>
<p>Codeblock 9-7 zeigt eine Implementierung von <code>read_username_from_file</code>, die
dasselbe Verhalten wie in Codeblock 9-6 hat, aber diese Implementierung
verwendet den <code>?</code>-Operator.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hallo.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-7: Eine Funktion, die Fehler an den
aufrufenden Code zurückgibt, indem sie den <code>?</code>-Operator verwendet</span></p>
<p>Das <code>?</code> hinter dem <code>Result</code>-Wert bewirkt fast das gleiche wie die
<code>match</code>-Ausdrücke, die wir zum Behandeln der <code>Result</code>-Werte in Codeblock 9-6
definiert haben. Wenn der Wert von <code>Result</code> ein <code>Ok</code> ist, wird der Wert
innerhalb <code>Ok</code> zurückgegeben und das Programm fortgesetzt. Wenn der Wert ein
<code>Err</code> ist, wird er als Funktionsergebnis zurückgegeben, als ob wir das
Schlüsselwort <code>return</code> verwendet hätten.</p>
<p>Es gibt einen Unterschied zwischen dem, was der <code>match</code>-Ausdruck aus Codeblock
9-6 tut, und dem, was der <code>?</code>-Operator tut: Fehlerwerte, bei denen der
<code>?</code>-Operator aufgerufen wird, durchlaufen die Funktion <code>from</code>, die im Merkmal
<code>From</code> der Standardbibliothek definiert ist und die zur Konvertierung von
Fehlern eines Typs in einen anderen verwendet wird. Wenn der <code>?</code>-Operator die
Funktion <code>from</code> aufruft, wird der empfangene Fehlertyp in den Fehlertyp
umgewandelt, der als Rückgabetyp der aktuellen Funktion definiert ist. Das ist
hilfreich, wenn eine Funktion einen einzigen Fehlertyp zurückgibt, um alle
möglichen Fehlerarten einer Funktion darzustellen, auch wenn Teile aus vielen
verschiedenen Gründen versagen könnten. Solange jeder Fehlertyp die Funktion
<code>from</code> implementiert, um festzulegen, wie er sich selbst in den
zurückzugebenden Fehlertyp konvertieren soll, kümmert sich der <code>?</code>-Operator
automatisch um die Konvertierung.</p>
<p>Im Zusammenhang mit Codeblock 9-7 gibt das <code>?</code> am Ende des Aufrufs von
<code>File::open</code> den Wert innerhalb eines <code>Ok</code> an die Variable <code>f</code> zurück. Wenn ein
Fehler auftritt, beendet der Operator vorzeitig die gesamte Funktion und gibt
dem aufrufenden Code einen <code>Err</code>-Wert zurück. Dasselbe gilt für das <code>?</code> am Ende
des <code>read_to_string</code>-Aufrufs.</p>
<p>Der <code>?</code>-Operator eliminiert viel umständlichen Code und macht die
Implementierung dieser Funktion einfacher. Wir können diesen Code sogar noch
weiter verkürzen, indem wir die Methodenaufrufe unmittelbar nach dem <code>?</code>
verketten, wie in Codeblock 9-8 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hallo.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-8: Verketten von Methodenaufrufen nach dem
<code>?</code>-Operator</span></p>
<p>Wir haben das Erstellen des neuen <code>String</code> in <code>s</code> an den Anfang der Funktion
verlegt; dieser Teil hat sich nicht geändert. Anstatt eine Variable <code>f</code> zu
erzeugen, haben wir den Aufruf von <code>read_to_string</code> direkt an das Ergebnis von
<code>File::open(&quot;hallo.txt&quot;)?</code> gehängt. Wir haben immer noch ein <code>?</code> am Ende des
Aufrufs von <code>read_to_string</code>, und wir geben immer noch einen <code>Ok</code>-Wert zurück,
der den Benutzernamen in <code>s</code> enthält, wenn sowohl <code>File::open</code> als auch
<code>read_to_string</code> erfolgreich sind, anstatt Fehler zurückzugeben. Die
Funktionalität ist wieder die gleiche wie in Codeblock 9-6 und Codeblock 9-7;
das ist nur eine andere, ergonomischere Schreibweise.</p>
<p>Wenn wir schon von verschiedenen Schreibweisen dieser Funktion sprechen, zeigt
Codeblock 9-9, dass es einen Weg gibt, diese Funktion noch kürzer zu machen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-9: Verwenden von <code>fs::read_to_string</code>,
anstatt die Datei zu öffnen und dann zu lesen</span></p>
<p>Das Einlesen einer Datei in eine Zeichenkette ist eine ziemlich häufig
benötigte Operation, daher bringt Rust die praktische Funktion
<code>fs::read_to_string</code> mit, die die Datei öffnet, einen neuen <code>String</code> erzeugt,
den Inhalt der Datei einliest, den Inhalt in den <code>String</code> einfügt und ihn
zurückgibt. Natürlich gibt uns die Verwendung von <code>fs::read_to_string</code> nicht
die Möglichkeit, die ganze Fehlerbehandlung zu erklären, also haben wir es
zuerst auf dem längeren Weg gemacht.</p>
<h4><a class="header" href="#der--operator-kann-in-funktionen-verwendet-werden-die-result-zurückgeben" id="der--operator-kann-in-funktionen-verwendet-werden-die-result-zurückgeben">Der <code>?</code>-Operator kann in Funktionen verwendet werden, die <code>Result</code> zurückgeben</a></h4>
<p>Der <code>?</code>-Operator kann in Funktionen verwendet werden, die den Rückgabetyp
<code>Result</code> haben, weil er so definiert ist, dass er auf die gleiche Weise
arbeitet wie der <code>match</code>-Ausdruck, den wir in Codeblock 9-6 definiert haben. 
Der Teil von <code>match</code>, der den Rückgabetyp <code>Result</code> erfordert, ist
<code>return Err(e)</code>, daher muss der Rückgabetyp der Funktion <code>Result</code> sein, um mit
<code>return</code> kompatibel zu sein.</p>
<p>Schauen wir uns an, was passiert, wenn wir den <code>?</code>-Operator in der Funktion
<code>main</code> verwenden, die, wie du dich erinnern wirst, den Rückgabetyp <code>()</code> hat:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;)?;
}
</code></pre></pre>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hallo.txt&quot;)?;
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieser Fehler weist darauf hin, dass wir den <code>?</code>-Operator nur in einer Funktion
verwenden dürfen, die <code>Result</code> oder <code>Option</code> oder einen anderen Typ, der
<code>std::ops::Try</code> implementiert, zurückgibt. Wenn du Code in einer Funktion
schreibst, die keinen dieser Typen zurückgibt, und du <code>?</code> verwenden willst,
wenn du andere Funktionen mit dem Rückgabetyp <code>Result&lt;T, E&gt;</code> aufrufst, hast du
zwei Möglichkeiten, dieses Problem zu lösen. Eine Technik besteht darin, den
Rückgabetyp deiner Funktion in <code>Result&lt;T, E&gt;</code> zu ändern, wenn dem nichts
entgegensteht. Die andere Technik besteht darin, <code>match</code> oder eine der Methoden
von <code>Result&lt;T, E&gt;</code> zu verwenden, um das <code>Result&lt;T, E&gt;</code> in geeigneter Weise zu
behandeln.</p>
<p>Die Funktion <code>main</code> ist etwas Besonderes und es gibt Einschränkungen
hinsichtlich ihres Rückgabetyps. Ein gültiger Rückgabetyp für main ist <code>()</code> und
bequemerweise auch <code>Result&lt;T, E&gt;</code>, wie hier zu sehen ist:</p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hallo.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>Der Typ <code>Box&lt;dyn Error&gt;</code> wird als Markmalsobjekt (trait object) bezeichnet,
über das wir im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte
unterschiedlicher Typen erlauben“</a> in Kapitel 17 sprechen
werden. Vorerst kannst du <code>Box&lt;dyn Fehler&gt;</code> als „eine beliebige Fehlerart“
ansehen. Das Verwenden von <code>?</code> in einer <code>main</code>-Funktion mit diesem Rückgabetyp
ist erlaubt.</p>
<p>Nachdem wir nun die Einzelheiten des Aufrufs von <code>panic!</code> und der Rückgabe von
<code>Result</code> besprochen haben, wollen wir zum Thema zurückkehren, wie wir
entscheiden können, was in welchen Fällen angemessen ist.</p>
<h2><a class="header" href="#wann-panic-aufrufen-und-wann-nicht" id="wann-panic-aufrufen-und-wann-nicht">Wann <code>panic!</code> aufrufen und wann nicht?</a></h2>
<p>Wie entscheidest du also, wann du <code>panic!</code> aufrufen und wann <code>Result</code>
zurückgeben sollst? Wenn Code abbricht, gibt es keine Möglichkeit sich vom
Fehler zu erholen. Du könntest <code>panic!</code> in jeder Fehlersituation anrufen,
unabhängig davon, ob es eine Möglichkeit zur Fehlerbehebung gibt oder nicht,
aber dann triffst du die Entscheidung für den Code, der deinen Code aufruft,
dass eine Situation nicht rettbar ist. Wenn du dich dafür entscheidest, einen
<code>Result</code>-Wert zurückzugeben, überlässt du dem aufrufenden Code die
Wahlmöglichkeit, anstatt die Entscheidung für ihn zu treffen. Der aufrufende
Code könnte sich dafür entscheiden, sich vom Fehler auf eine angemessene Weise
zu erholen, oder er könnte sich dafür entscheiden, dass ein <code>Err</code>-Wert in
diesem Fall nicht behebbar ist und <code>panic!</code> aufrufen, und so deinen behebbaren
Fehler in einen nicht behebbaren verwandeln. Daher ist die Rückgabe von
<code>Result</code> eine gute Standardwahl, wenn du eine Funktion definierst, die
fehlschlagen könnte.</p>
<p>In seltenen Situationen ist es besser, Code zu schreiben, der das Programm
abbricht, anstatt ein <code>Result</code> zurückzugeben. Lass uns untersuchen, warum es
bei Beispielen, Code-Prototypen und Tests angebracht ist, das Programm
abzubrechen. Dann werden wir Situationen besprechen, in denen der Compiler
nicht feststellen kann, dass ein Fehler unmöglich ist, du als Mensch aber
schon. Das Kapitel schließt mit einigen allgemeinen Richtlinien zur
Entscheidung, ob in Bibliothekscode ein Programm abgebrochen werden soll.</p>
<h3><a class="header" href="#beispiele-code-prototypen-und-tests" id="beispiele-code-prototypen-und-tests">Beispiele, Code-Prototypen und Tests</a></h3>
<p>Wenn du ein Beispiel schreibst, um ein Konzept zu veranschaulichen, kann ein
robuster Fehlerbehandlungscode das Beispiel unklarer machen. In Beispielen wird
davon ausgegangen, dass der Aufruf einer Methode wie <code>unwrap</code>, die das Programm
abbrechen könnte, als Platzhalter für die Art und Weise gedacht ist, wie deine
Anwendung mit Fehlern umgehen soll, die je nachdem, was der Rest deines Codes
tut, unterschiedlich sein können.</p>
<p>In ähnlicher Weise sind die Methoden <code>unwrap</code> und <code>expect</code> bei Prototypen sehr
praktisch, wenn du noch nicht entscheiden willst, wie mit Fehlern umzugehen
ist. Du hinterlässt klare Markierungen in deinem Code für später, wenn du dein
Programm robuster machst.</p>
<p>Wenn ein Methodenaufruf in einem Test fehlschlägt, würdest du wollen, dass der
gesamte Test fehlschlägt, auch wenn diese Methode nicht die zu testende
Funktionalität ist. Da ein Test mit <code>panic!</code> als fehlgeschlagen markiert wird,
ist der Aufruf von <code>unwrap</code> und <code>expect</code> genau das, was passieren sollte.</p>
<h3><a class="header" href="#fälle-in-denen-du-mehr-informationen-als-der-compiler-hast" id="fälle-in-denen-du-mehr-informationen-als-der-compiler-hast">Fälle, in denen du mehr Informationen als der Compiler hast</a></h3>
<p>Es wäre auch angemessen, <code>unwrap</code> aufzurufen, wenn du eine andere Logik hast,
die sicherstellt, dass <code>Result</code> einen <code>Ok</code>-Wert hat, aber die Logik kann vom
Compiler nicht verstanden werden. Du wirst immer noch ein <code>Result</code> haben,
mit dem du umgehen musst: Welche Operation auch immer du aufrufst, es besteht
immer noch die Möglichkeit, dass sie im Allgemeinen scheitert, auch wenn es in
deiner speziellen Situation logischerweise unmöglich ist. Wenn du durch
manuelle Codeinspektion sicherstellen kannst, dass du niemals eine
<code>Err</code>-Variante haben wirst, ist es vollkommen akzeptabel, <code>unwrap</code> aufzurufen.
Hier ist ein Beispiel:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Wir erstellen eine <code>IpAddr</code>-Instanz, indem wir eine hartkodierte Zeichenkette
parsen. Wir können sehen, dass <code>127.0.0.1</code> eine gültige IP-Adresse ist, sodass
es akzeptabel ist, hier <code>unwrap</code> zu verwenden. Eine hartkodierte, gültige
Zeichenkette ändert jedoch nicht den Rückgabetyp der <code>parse</code>-Methode: Wir
erhalten immer noch einen <code>Result</code>-Wert und der Compiler wird von uns
verlangen, <code>Result</code> so zu behandeln, als ob die <code>Err</code>-Variante möglich wäre,
weil der Compiler nicht klug genug ist, um zu erkennen, dass diese
Zeichenkette stets eine gültige IP-Adresse ist. Wenn die
IP-Adressen-Zeichenkette von einem Benutzer kam, anstatt fest im Programm
kodiert zu sein, und daher möglicherweise fehlschlagen könnte, würden wir
stattdessen definitiv <code>Result</code> auf eine robustere Weise behandeln wollen.</p>
<h3><a class="header" href="#richtlinien-zur-fehlerbehandlung" id="richtlinien-zur-fehlerbehandlung">Richtlinien zur Fehlerbehandlung</a></h3>
<p>Es ist ratsam, dass dein Code abbricht, wenn es möglich ist, dass dein Code in
einem schlechten Zustand enden könnte. In diesem Zusammenhang ist ein
<em>schlechter Zustand</em> (bad state) dann gegeben, wenn eine Annahme, eine
Garantie, ein Vertrag oder eine Invariante gebrochen wurde, z.B. wenn ungültige
Werte, widersprüchliche Werte oder fehlende Werte an deinen Code übergeben
werden – sowie eine oder mehrere der folgenden Punkte zutreffen:</p>
<ul>
<li>Es wird nicht davon ausgegangen, dass ein schlechter Zustand vorkommt kann.</li>
<li>Dein Code muss sich nach diesem Punkt darauf verlassen können, dass er sich
in keinem schlechten Zustand befindet.</li>
<li>Es gibt keine gute Möglichkeit, diese Informationen in den von dir
verwendeten Typen zu kodieren.</li>
</ul>
<p>Wenn jemand deinen Code aufruft und Werte eingibt, die keinen Sinn ergeben, ist
es vielleicht die beste Wahl, <code>panic!</code> anzurufen und die Person, die deine
Bibliothek benutzt, auf den Fehler in ihrem Code hinzuweisen, damit sie ihn
während der Entwicklung beheben kann. In ähnlicher Weise ist <code>panic!</code> oft
angebracht, wenn du externen Code aufrufst, der sich deiner Kontrolle entzieht
und einen ungültigen Zustand zurückgibt, den du nicht beheben kannst.</p>
<p>Wenn jedoch ein Fehler erwartet wird, ist es angemessener, ein <code>Result</code>
zurückzugeben, als <code>panic!</code> aufzurufen. Beispiele hierfür sind ein Parser, dem
fehlerhafte Daten übergeben werden, oder eine HTTP-Anfrage, die einen Status
zurückgibt, der anzeigt, dass du ein Aufruflimit erreicht hast. In diesen
Fällen zeigt der Rückgabetyp <code>Result</code> an, dass ein Fehler eine erwartete
Möglichkeit ist, bei der der aufrufende Code entscheiden muss, wie er damit
umgeht.</p>
<p>Wenn dein Code Operationen mit Werten ausführt, sollte dein Code zuerst
überprüfen, ob die Werte gültig sind, und das Programm abbrechen, wenn die
Werte nicht gültig sind. Dies geschieht hauptsächlich aus Sicherheitsgründen:
Der Versuch, mit ungültigen Daten zu operieren, kann deinen Code Schwachstellen
aussetzen. Dies ist der Hauptgrund dafür, dass die Standardbibliothek <code>panic!</code>
aufruft, wenn du versuchst, einen unzulässigen Speicherzugriff durchzuführen:
Der Versuch, auf Speicher zuzugreifen, der nicht zur aktuellen Datenstruktur
gehört, ist ein häufiges Sicherheitsproblem. Funktionen haben oft <em>Verträge</em>
(contracts): Ihr Verhalten ist nur dann garantiert, wenn die Eingaben bestimmte
Anforderungen erfüllen. Abzubrechen, wenn der Vertrag verletzt wird, ist
sinnvoll, weil eine Vertragsverletzung immer auf einen Fehler auf der
Anruferseite hinweist und es sich nicht um eine Fehlerart handelt, die der
aufgerufende Code explizit behandeln sollte. Tatsächlich gibt es keinen
vernünftigen Weg, wie sich der aufrufende Code vom Fehler erholen kann; die
aufrufenden <em>Programmierer</em> müssen den Code reparieren. Verträge zu einer
Funktion sollten in der API-Dokumentation der Funktion erläutert werden,
insbesondere wenn deren Verletzung zu einem Programmabbruch führt.</p>
<p>Zahlreiche Fehlerprüfungen in deinen Funktionen wären jedoch langatmig und
störend. Glücklicherweise kannst du das Typsystem von Rust (und damit die
Typprüfung durch den Compiler) verwenden, um viele Prüfungen für dich zu
übernehmen. Wenn deine Funktion einen besonderen Typ als Parameter hat, kannst
du mit der Logik deines Codes fortfahren, da du weißt, dass der Compiler
bereits sichergestellt hat, dass du einen gültigen Wert hast. Wenn du zum
Beispiel einen Typ anstatt einer <code>Option</code> hast, erwartet dein Programm <em>etwas</em>
statt <em>nichts</em>. Dein Code muss dann nicht zwei Fälle für die Varianten <code>Some</code>
und <code>None</code> behandeln: Er wird nur einen Fall mit definitiv einem Wert haben.
Code, der versucht, nichts an deine Funktion zu übergeben, lässt sich nicht
einmal kompilieren, sodass deine Funktion diesen Fall zur Laufzeit nicht prüfen
muss. Ein anderes Beispiel ist die Verwendung eines vorzeichenlosen
Ganzzahl-Typs wie <code>u32</code>, der sicherstellt, dass der Parameter niemals negativ
ist.</p>
<h3><a class="header" href="#benutzerdefinierte-typen-für-die-validierung-erstellen" id="benutzerdefinierte-typen-für-die-validierung-erstellen">Benutzerdefinierte Typen für die Validierung erstellen</a></h3>
<p>Gehen wir die Idee, das Rust-Typsystem zu verwenden, um sicherzustellen, dass
wir einen gültigen Wert haben, einen Schritt weiter und schauen uns an, wie wir
einen benutzerdefinierten Typ für die Validierung erstellen können. Erinnere
dich an das Ratespiel in Kapitel 2, bei dem unser Code den Benutzer
aufforderte, eine Zahl zwischen 1 und 100 zu erraten. Wir haben nie überprüft,
ob die Schätzung des Benutzers zwischen diesen Zahlen lag, bevor wir sie mit
unserer Geheimzahl verglichen haben; wir haben nur überprüft, ob die Schätzung
richtig war. In diesem Fall waren die Folgen nicht sehr gravierend: Unsere
Ausgabe von „zu groß“ oder „zu klein“ wäre immer noch richtig. Aber es wäre
eine nützliche Erweiterung, um den Benutzer zu gültigen Rateversuchen zu führen
und ein unterschiedliches Verhalten zu zeigen, wenn ein Benutzer eine Zahl
eingibt, die außerhalb des Bereichs liegt, als wenn ein Benutzer stattdessen
z.B. Buchstaben eingibt.</p>
<p>Eine Möglichkeit, dies zu tun, wäre, die Eingabe als <code>i32</code> statt nur als <code>u32</code>
zu parsen, um potenziell negative Zahlen zuzulassen, und dann eine
Bereichsprüfung der Zahl zu ergänzen, etwa so:</p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Rate eine Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        // --abschneiden--

        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;Die geheime Zahl wird zwischen 1 und 100 liegen.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Der <code>if</code>-Ausdruck prüft, ob unser Wert außerhalb des Bereichs liegt, informiert
den Benutzer über das Problem und ruft <code>continue</code> auf, um die nächste Iteration
der Schleife zu starten und um eine weitere Schätzung zu bitten. Nach dem
<code>if</code>-Ausdruck können wir mit dem Vergleich zwischen <code>guess</code> und der Geheimzahl
fortfahren, wobei wir wissen, dass <code>guess</code> zwischen 1 und 100 liegt.</p>
<p>Dies ist jedoch keine Ideallösung: Wenn es absolut entscheidend wäre, dass das
Programm nur mit Werten zwischen 1 und 100 arbeitet, und wir viele Funktionen
mit dieser Anforderung haben, wäre eine solche Prüfung in jeder Funktion mühsam
(und könnte die Leistung beeinträchtigen).</p>
<p>Stattdessen können wir einen neuen Typ erstellen und die Validierungen in eine
Funktion geben, um eine Instanz des Typs zu erzeugen, anstatt die Validierungen
überall zu wiederholen. Auf diese Weise ist es für die Funktionen sicher, den
neuen Typ in ihren Signaturen zu verwenden und die erhaltenen Werte
vertrauensvoll zu nutzen. Codeblock 9-10 zeigt eine Möglichkeit, einen Typ
<code>Guess</code> zu definieren, der nur dann eine Instanz von <code>Guess</code> erzeugt, wenn die
Funktion <code>new</code> einen Wert zwischen 1 und 100 erhält.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Der Schätzwert muss zwischen 1 und 100 liegen, ist jedoch {}.&quot;,
                   value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-10: Ein Typ <code>Guess</code>, der nur bei Werten
zwischen 1 und 100 fortsetzt</span></p>
<p>Zuerst definieren wir eine Struktur <code>Guess</code>, die ein Feld <code>value</code> hat, das
einen <code>i32</code> enthält. Hier wird die Nummer gespeichert.</p>
<p>Dann implementieren wir die zugehörige Funktion <code>new</code> auf <code>Guess</code>, die
Instanzen von <code>Guess</code> erzeugt. Die Funktion <code>new</code> ist so definiert, dass sie
einen Parameter <code>value</code> vom Typ <code>i32</code> nimmt und eine <code>Guess</code>-Instanz
zurückgibt. Der Code im Funktionsrumpf von <code>new</code> testet den Wert in <code>value</code>, um
sicherzustellen, dass er zwischen 1 und 100 liegt. Wenn <code>value</code> diesen Test
nicht besteht, rufen wir <code>panic!</code> auf, was den Programmierer des aufrufenden
Codes darauf aufmerksam macht, dass er einen Fehler hat, den er beheben muss,
denn ein <code>Guess</code> mit einem Wert außerhalb dieses Bereichs zu erzeugen, würde
den Vertrag verletzen, auf den sich <code>Guess::new</code> verlässt. Die Bedingungen,
unter denen <code>Guess::new</code> das Programm abbricht, sollten in der öffentlich
zugänglichen API-Dokumentation genannt werden; wir werden die
Dokumentationskonventionen, die auf die Möglichkeit eines <code>panic!</code>-Aufrufs
hinweisen, in der API-Dokumentation behandeln, die du in Kapitel 14 erstellst. 
Wenn <code>value</code> den Test besteht, erstellen wir eine neue <code>Guess</code>-Instanz, deren
Feld <code>value</code> den Parameterwert <code>value</code> erhält, und geben die Instanz zurück.</p>
<p>Als nächstes implementieren wir eine Methode namens <code>value</code>, die <code>self</code>
ausleiht, keine anderen Parameter hat und ein <code>i32</code> zurückgibt. Diese
Methodenart wird manchmal als <em>Abfragemethode</em> (getter) bezeichnet, weil ihr
Zweck darin besteht, Daten aus ihren Feldern zurückzugeben. Diese öffentliche
Methode ist notwendig, weil das Feld <code>value</code> der Struktur <code>Guess</code> privat ist.
Es ist wichtig, dass das Feld <code>value</code> privat ist, damit Code, der die Struktur
<code>Guess</code> verwendet, <code>value</code> nicht direkt setzen kann: Code außerhalb des Moduls
<em>muss</em> die Funktion <code>Guess::new</code> verwenden, um eine Instanz von <code>Guess</code> zu
erzeugen, wodurch sichergestellt wird, dass es keine Möglichkeit gibt, dass
<code>Guess</code> einen <code>Wert</code> hat, der nicht durch die Bedingungen in der Funktion
<code>Guess::new</code> überprüft wurde.</p>
<p>Eine Funktion, die einen Parameter hat oder nur Zahlen zwischen 1 und 100
zurückgibt, könnte dann in ihrer Signatur angeben, dass sie ein <code>Guess</code>
anstelle eines <code>i32</code> entgegennimmt oder zurückgibt und bräuchte dann in ihrem
Rumpf keine zusätzlichen Prüfungen durchzuführen.</p>
<h2><a class="header" href="#zusammenfassung-8" id="zusammenfassung-8">Zusammenfassung</a></h2>
<p>Die Fehlerbehandlungsfunktionen von Rust sollen dir helfen, robusteren Code zu
schreiben. Das Makro <code>panic!</code> signalisiert, dass sich dein Programm in einem
Zustand befindet, mit dem es nicht umgehen kann, und ermöglicht es dir, den
Prozess anzuhalten, anstatt zu versuchen, mit ungültigen oder falschen Werten
fortzufahren. Die Aufzählung <code>Result</code> verwendet das Typsystem von Rust, um
anzuzeigen, dass Operationen so fehlschlagen könnten, dass dein Code sich davon
wieder erholen könnte. Du kannst <code>Result</code> verwenden, um dem Code, der deinen
Code aufruft, mitzuteilen, dass er auch mit potentiellem Erfolg und Misserfolg
umgehen muss. Das Verwenden von <code>panic!</code> und <code>Result</code> in den entsprechenden
Situationen wird deinen Code angesichts unvermeidlicher Probleme zuverlässiger
machen.</p>
<p>Nachdem du nun nützliche Möglichkeiten gesehen hast, wie die Standardbibliothek
generische Datentypen mit den Enums <code>Option</code> und <code>Result</code> verwendet, werden wir
darüber sprechen, wie generische Datentypen funktionieren und wie du sie in
deinem Code verwenden kannst.</p>
<h1><a class="header" href="#generische-typen-merkmale-traits-und-lebensdauer" id="generische-typen-merkmale-traits-und-lebensdauer">Generische Typen, Merkmale (traits) und Lebensdauer</a></h1>
<p>Jede Programmiersprache verfügt über Werkzeuge, mit denen die Duplizierung von
Konzepten (duplication of concepts) effektiv gehandhabt werden kann. In Rust
ist ein solches Werkzeug der <em>generische Datentyp</em> (generics). Generische
Datentypen sind abstrakte Stellvertreter für konkrete Typen oder andere
Eigenschaften. Wenn wir Code schreiben, können wir das Verhalten generischer
Datentypen oder ihre Beziehung zu anderen generischen Datentypen ausdrücken,
ohne zu wissen, was an ihrer Stelle beim Kompilieren und Ausführen des Codes
stehen wird.</p>
<p>Ähnlich wie eine Funktion Parameter mit unbekannten Werten entgegennimmt, um
den gleichen Code auf mehreren konkreten Werten auszuführen, können Funktionen
Parameter irgendeines generischen Typs anstelle eines konkreten Typs, wie <code>i32</code>
oder <code>String</code>, haben. Tatsächlich haben wir generische Datentypen bereits in
Kapitel 6 mit <code>Option&lt;T&gt;</code>, in Kapitel 8 mit <code>Vec&lt;T&gt;</code> und <code>HashMap&lt;K, V&gt;</code> und in
Kapitel 9 mit <code>Result&lt;T, E&gt;</code> verwendet. In diesem Kapitel erfährst du, wie du
deine eigenen Typen, Funktionen und Methoden mit generischen Datentypen
definieren kannst!</p>
<p>Zunächst werden wir uns anschauen, wie eine Funktion extrahiert werden kann, um
Code-Duplizierung zu reduzieren. Danach verwenden wir dieselbe Technik, um aus
zwei Funktionen, die sich nur im Datentyp ihrer Parameter unterscheiden, eine
generische Funktion zu machen. Wir werden auch erklären, wie generische Typen
in Struktur- (struct) und Aufzählungsdefinitionen (enum) verwendet werden
können.</p>
<p>Dann wirst du lernen, wie man <em>Merkmale</em> (traits) verwendet, um Verhalten auf
generische Weise zu definieren. Du kannst Merkmale mit generischen Typen
kombinieren, um einen generischen Typ auf solche Typen einzuschränken, die ein
bestimmtes Verhalten aufweisen, im Gegensatz zu einem beliebigen Typ.</p>
<p>Schließlich werden wir die <em>Lebensdauer</em> (lifetimes) besprechen, eine Spielart
generischer Typen, die dem Compiler Informationen darüber gibt, wie
Referenzen zueinander in Beziehung stehen. Die Lebensdauer erlaubt es uns, in
vielen Situationen Werte auszuleihen und gleichzeitig dem Compiler die
Möglichkeit zu geben, die Gültigkeit der Referenzen zu überprüfen.</p>
<h2><a class="header" href="#duplikate-entfernen-durch-extrahieren-einer-funktion" id="duplikate-entfernen-durch-extrahieren-einer-funktion">Duplikate entfernen durch Extrahieren einer Funktion</a></h2>
<p>Bevor wir in die Syntax der generischen Typen eintauchen, wollen wir uns
zunächst ansehen, wie man Duplikate, die keine generischen Typen betreffen,
durch Extrahieren einer Funktion entfernt. Dann werden wir diese Technik
anwenden, um eine generische Funktion zu extrahieren! Auf die gleiche Weise,
wie du doppelten Code erkennst, der zu einer Funktion extrahiert wird, wirst du
auch doppelten Code erkennen, der generische Typen verwenden kann.</p>
<p>Betrachte ein kurzes Programm, das die größte Zahl in einer Liste findet, wie
in Codeblock 10-1 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
<span class="boring">    assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-1: Code zum Finden der größten Zahl in einer
Liste von Zahlen</span></p>
<p>Dieser Code enthält eine Liste von ganzen Zahlen in der Variablen <code>number_list</code>
und weist die erste Zahl der Liste einer Variablen namens <code>largest</code> zu. Dann
iteriert sie über alle Zahlen in der Liste und wenn die aktuelle Zahl größer
ist als die in <code>largest</code> gespeicherte Zahl, ersetzt sie die Zahl in dieser
Variablen. Wenn die aktuelle Zahl jedoch kleiner oder gleich der größten bisher
gefundenen Zahl ist, ändert sich die Variable nicht, und der Code geht zur
nächsten Zahl in der Liste weiter. Nach dem Durchlaufen aller Zahlen in der
Liste sollte <code>largest</code> die größte Zahl enthalten, in diesem Fall 100.</p>
<p>Um die größte Zahl in zwei verschiedenen Zahlenlisten zu finden, können wir den
Code in Codeblock 10-1 duplizieren und dieselbe Logik an zwei verschiedenen
Stellen im Programm verwenden, wie in Codeblock 10-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-2: Code zum Auffinden der größten Zahl in
<em>zwei</em> Zahlenlisten</span></p>
<p>Obwohl dieser Code funktioniert, ist das Duplizieren von Code mühsam und
fehleranfällig. Außerdem müssen wir den Code an mehreren Stellen aktualisieren,
wenn wir ihn ändern wollen.</p>
<p>Um diese Redundanz zu eliminieren, können wir eine Abstraktion schaffen, indem
wir eine Funktion definieren, die auf einer beliebigen Liste ganzer Zahlen
operiert, die ihr als Parameter übergeben wird. Diese Lösung macht unseren Code
klarer und lässt uns das Konzept, die größte Zahl in einer Liste zu finden,
abstrakter ausdrücken.</p>
<p>In Codeblock 10-3 extrahierten wir den Code, der die größte Zahl findet, in
eine Funktion namens <code>largest</code>. Im Unterschied zum Code in Codeblock 10-1, der
die größte Zahl in nur einer bestimmten Liste finden kann, kann dieses Programm
die größte Zahl in zwei verschiedenen Listen finden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;6000);
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-3: Abstrahierter Code, um die größte Zahl in
zwei Listen zu finden</span></p>
<p>Die Funktion <code>largest</code> hat einen Parameter <code>list</code>, der einen beliebigen
Anteilstyp von <code>i32</code>-Werten repräsentiert, die wir an die Funktion übergeben
könnten. Wenn wir die Funktion aufrufen, läuft der Code also auf den
spezifischen Werten, die wir übergeben.</p>
<p>Zusammenfassend hier die Schritte, die wir unternommen haben, um den Code aus
Codeblock 10-2 in Codeblock 10-3 zu überführen:</p>
<ol>
<li>Identifiziere doppelten Code.</li>
<li>Extrahiere den doppelten Code in den Funktionskörper und spezifiziere die
Eingabe- und Rückgabewerte dieses Codes in der Funktionssignatur.</li>
<li>Aktualisiere die beiden Instanzen des doppelten Codes, um stattdessen die
Funktion aufzurufen.</li>
</ol>
<p>Als Nächstes werden wir dieselben Schritte auf generische Datentypen anwenden,
um doppelten Code auf unterschiedliche Weise zu reduzieren. Ähnlich wie der
Funktionsrumpf auf einer abstrakten Liste anstelle spezifischer Werte arbeiten
kann, erlauben es generische Datentypen, auf abstrakten Typen zu arbeiten.</p>
<p>Nehmen wir zum Beispiel an, wir hätten zwei Funktionen: Eine, die das größte
Element in einem Anteilstyp mit <code>i32</code>-Werten findet, und eine, die das größte
Element in einem Anteilstyp mit <code>char</code>-Werten findet. Wie würden wir diese
Duplizierung beseitigen? Lass es uns herausfinden!</p>
<h2><a class="header" href="#generische-datentypen" id="generische-datentypen">Generische Datentypen</a></h2>
<p>Wir können generische Datentypen (generics) verwenden, um Definitionen für
Elemente wie Funktionssignaturen oder Strukturen (structs) zu erstellen, die
wir dann mit vielen verschiedenen konkreten Datentypen verwenden können. Sehen
wir uns zunächst an, wie Funktionen, Strukturen, Aufzählungen und Methoden
mithilfe von generischen Datentypen definiert werden können. Danach werden wir
uns ansehen, wie generische Datentypen die Code-Performanz beeinflussen.</p>
<h3><a class="header" href="#in-funktionsdefinitionen" id="in-funktionsdefinitionen">In Funktionsdefinitionen</a></h3>
<p>Bei der Definition einer Funktion, die generische Datentypen verwendet,
platzieren wir die generischen Datentypen in der Signatur der Funktion, wo wir
normalerweise die Datentypen der Parameter und des Rückgabewerts angeben
würden. Dadurch wird unser Code flexibler und bietet den Aufrufern unserer
Funktion mehr Funktionalität, während gleichzeitig Code-Duplikate verhindert
werden.</p>
<p>Um mit unserer Funktion <code>largest</code> fortzufahren, zeigt Codeblock 10-4 zwei
Funktionen, die beide den größten Wert in einem Anteilstyp finden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;'y');
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-4: Zwei Funktionen, die sich nur in ihren
Namen und den Typen in ihren Signaturen unterscheiden</span></p>
<p>Die Funktion <code>largest_i32</code> ist diejenige, die wir in Codeblock 10-3 extrahiert
haben und die den größten <code>i32</code> in einem Anteilstyp findet. Die Funktion
<code>largest_char</code> findet das größte <code>char</code> in einem Anteilstyp. Die
Funktionsrümpfe haben den gleichen Code, also lass uns die Duplizierung
eliminieren, indem wir einen generischen Typparameter in einer einzigen
Funktion einführen.</p>
<p>Um die Typen in der neuen Funktion, die wir definieren werden, zu
parametrisieren, müssen wir den Typparameter benennen, so wie wir es für die
Wertparameter einer Funktion tun. Du kannst jeden beliebigen Bezeichner als
Typparametername verwenden. Aber wir werden <code>T</code> verwenden, weil die
Parameternamen gemäß Konvention in Rust kurz sind, oft nur ein Buchstabe, und
Rusts Typbezeichnungskonvention verwendet Binnenmajuskel (CamelCase). Als
Abkürzung für „Typ“ ist <code>T</code> die Standardwahl der meisten Rust-Programmierer.</p>
<p>Wenn wir einen Parameter im Funktionsrumpf verwenden, müssen wir den
Parameternamen in der Signatur deklarieren, damit der Compiler weiß, was
dieser Name bedeutet. In ähnlicher Weise müssen wir den Typ-Parameternamen
deklarieren, bevor wir ihn in einer Funktionssignatur verwenden können. Um die
generische Funktion <code>largest</code> zu definieren, platzieren wir die
Typnamen-Deklarationen innerhalb spitzer Klammern <code>&lt;&gt;</code>, zwischen dem
Funktionsnamen und der Parameterliste, so wie hier:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
</code></pre>
<p>Wir lesen diese Definition wie folgt: Die Funktion <code>largest</code> ist generisch über
einen Typ <code>T</code>. Sie hat einen Parameter namens <code>list</code>, der ein Anteilstyp von
Werten des Typs <code>T</code> ist. Die Funktion <code>largest</code> gibt eine Referenz auf einen
Wert des gleichen Typs <code>T</code> zurück.</p>
<p>Codeblock 10-5 zeigt die kombinierte Funktionsdefinition <code>largest</code>, die den
generischen Datentyp in ihrer Signatur verwendet. Der Codeblock zeigt auch, wie
wir die Funktion entweder mit einem Anteilstyp von <code>i32</code>-Werten oder
<code>char</code>-Werten aufrufen können. Beachte, dass sich dieser Code noch nicht
kompilieren lässt, aber wir werden das Problem später in diesem Kapitel
beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-5: Eine Definition der Funktion <code>largest</code>,
die generische Typparameter verwendet, aber noch nicht kompiliert</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Hinweis erwähnt <code>std::cmp::PartialOrd</code>, was ein <em>Merkmal</em> (trait) ist. Wir
werden im nächsten Abschnitt über Merkmale sprechen. Vorerst bedeutet dieser
Fehler, dass der Rumpf von <code>largest</code> nicht für alle möglichen Typen
funktioniert, die <code>T</code> sein könnten. Da wir Werte des Typs <code>T</code> im Rumpf
vergleichen wollen, können wir nur Typen verwenden, deren Werte sortiert werden
können. Um Vergleiche zu ermöglichen, hat die Standardbibliothek das Merkmal
<code>std::cmp::PartialOrd</code>, das du auf Typen implementieren kannst (siehe Anhang C
für weitere Informationen zu diesem Merkmal). Du wirst im Abschnitt <a href="ch10-02-traits.html#merkmale-als-parameter">„Merkmale
als Parameter“</a> lernen, wie man angibt, dass ein
generischer Typ ein bestimmtes Merkmal hat, aber lass uns zunächst andere
Möglichkeiten der Verwendung generischer Typparameter untersuchen.</p>
<h3><a class="header" href="#in-struktur-definitionen" id="in-struktur-definitionen">In Struktur-Definitionen</a></h3>
<p>Wir können auch Strukturen definieren, um einen generischen Typparameter in
einem oder mehreren Feldern mit der <code>&lt;&gt;</code> Syntax zu verwenden. Codeblock 10-6
zeigt, wie man eine Struktur <code>Point&lt;T&gt;</code> definiert, um Koordinatenwerte <code>x</code> und
<code>y</code> eines beliebigen Typs aufzunehmen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-6: Eine Struktur <code>Point&lt;T&gt;</code>, die Werte <code>x</code>
und <code>y</code> vom Typ <code>T</code> enthält</span></p>
<p>Die Syntax zum Verwenden von generischen Datentypen in Strukturdefinitionen
ähnelt der Syntax, die in Funktionsdefinitionen verwendet wird. Zuerst
deklarieren wir den Namen des Typparameters innerhalb spitzer Klammern direkt
nach dem Namen der Struktur. Dann können wir den generischen Typ in der
Strukturdefinition verwenden, wo wir sonst konkrete Datentypen angeben würden.</p>
<p>Beachte, da wir nur einen generischen Typ zur Definition von <code>Point&lt;T&gt;</code>
verwendet haben, besagt diese Definition, dass die Struktur <code>Point&lt;T&gt;</code>
generisch über einen Typ <code>T</code> ist, und die beiden Felder <code>x</code> und <code>y</code> <em>denselben</em>
Typ haben, welcher Typ das auch immer sein mag. Wenn wir eine Instanz von
<code>Point&lt;T&gt;</code> erzeugen, die Werte unterschiedlichen Typs hat, wie in Codeblock
10-7, wird sich unser Code nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-7: Die Felder <code>x</code> und <code>y</code> müssen vom
gleichen Typ sein, da beide den gleichen generischen Datentyp <code>T</code> haben.</span></p>
<p>Wenn wir in diesem Beispiel <code>x</code> den Integer-Wert 5 zuweisen, lassen wir den
Compiler wissen, dass der generische Typ <code>T</code> für diese Instanz von
<code>Point&lt;T&gt;</code> ein Integer sein wird. Wenn wir dann 4.0 für <code>y</code> angeben, das wir so
definiert haben, dass es den gleichen Typ wie <code>x</code> hat, erhalten wir einen
Typfehler wie diesen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Um eine Struktur <code>Point</code> zu definieren, bei der <code>x</code> und <code>y</code> generische, aber
unterschiedliche, Typen haben können, können wir mehrere generische
Typparameter verwenden. Zum Beispiel können wir in Codeblock 10-8 die
Definition von <code>Point</code> so ändern, dass sie über den Typen <code>T</code> und <code>U</code> generisch
ist, wobei <code>x</code> vom Typ <code>T</code> und <code>y</code> vom Typ <code>U</code> ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-8: <code>Point&lt;T, U&gt;</code> ist generisch über zwei
Typen, sodass <code>x</code> und <code>y</code> Werte unterschiedlichen Typs haben können</span></p>
<p>Jetzt sind alle gezeigten Instanzen von <code>Point</code> erlaubt! Du kannst so viele
generische Typparameter in einer Definition verwenden, wie du willst, aber das
Verwenden von mehr als einigen wenigen macht deinen Code schwer lesbar. Wenn du
viele generische Typen in deinem Code benötigst, könnte dies darauf hinweisen,
dass dein Code in kleinere Teile zerlegt werden muss.</p>
<h3><a class="header" href="#in-aufzählungsdefinitionen" id="in-aufzählungsdefinitionen">In Aufzählungsdefinitionen</a></h3>
<p>Wie wir es bei Strukturen gemacht haben, können wir Aufzählungen definieren, um
generische Datentypen in ihren Varianten zu verwenden. Werfen wir noch einmal
einen Blick auf die Aufzählung <code>Option&lt;T&gt;</code>, die die Standardbibliothek bietet
und die wir in Kapitel 6 verwendet haben:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese Definition dürfte für dich jetzt mehr Sinn machen. Wie du sehen kannst,
ist <code>Option&lt;T&gt;</code> eine Aufzählung, die über dem Typ <code>T</code> generisch ist und zwei
Varianten hat: <code>Some</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>None</code>, die
keinen Wert enthält. Durch das Verwenden der Aufzählung <code>Option&lt;T&gt;</code> können wir
das abstrakte Konzept eines optionalen Wertes ausdrücken und da <code>Option&lt;T&gt;</code>
generisch ist, können wir diese Abstraktion unabhängig vom Typ des
optionalen Wertes verwenden.</p>
<p>Aufzählungen können auch mehrere generische Typen verwenden. Die Definition der
Aufzählung <code>Result</code>, die wir in Kapitel 9 verwendet haben, ist ein Beispiel
dafür:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Aufzählung <code>Result</code> ist generisch über zwei Typen <code>T</code> und <code>E</code> und hat zwei
Varianten: <code>Ok</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>Err</code>, die einen Wert
vom Typ <code>E</code> enthält. Diese Definition macht es bequem, die Aufzählung <code>Result</code>
überall dort zu verwenden, wo wir eine Operation haben, die erfolgreich sein
(gibt einen Wert vom Typ <code>T</code> zurück) oder fehlschlagen (gibt einen Fehler vom
Typ <code>E</code> zurück) könnte. Tatsächlich haben wir dies beim Öffnen einer Datei in
Codeblock 9-3 verwendet, wobei für <code>T</code> der Typ <code>std::fs::File</code> verwendet wurde,
wenn die Datei erfolgreich geöffnet wurde, und für <code>E</code> der Typ
<code>std::io::Error</code>, wenn es Probleme beim Öffnen der Datei gab.</p>
<p>Wenn du in deinem Code Situationen mit mehreren Struktur- oder
Aufzählungsdefinitionen erkennst, die sich nur in den Typen der darin
enthaltenen Werte unterscheiden, kannst du doppelten Code vermeiden, indem du
stattdessen generische Typen verwendest.</p>
<h3><a class="header" href="#in-methodendefinitionen" id="in-methodendefinitionen">In Methodendefinitionen</a></h3>
<p>Wir können Methoden auf Strukturen und Aufzählungen implementieren (wie wir es
in Kapitel 5 getan haben) und auch generische Typen in ihren Definitionen
verwenden. Codeblock 10-9 zeigt die Struktur <code>Point&lt;T&gt;</code>, die wir in Codeblock
10-6 definiert haben, mit einer darauf implementierten Methode namens <code>x</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-9: Implementierung einer Methode <code>x</code> auf der
Struktur <code>Point&lt;T&gt;</code>, die eine Referenz auf das Feld <code>x</code> vom Typ <code>T</code>
zurückgibt</span></p>
<p>Hier haben wir eine Methode <code>x</code> auf <code>Point&lt;T&gt;</code> definiert, die eine Referenz auf
den Wert im Feld <code>x</code> zurückgibt.</p>
<p>Beachte, dass wir <code>T</code> direkt nach <code>impl</code> deklarieren müssen, damit wir Methoden
zum Typ <code>Punkt&lt;T&gt;</code> implementieren können. Durch das Deklarieren von <code>T</code> als
generischen Typ hinter <code>impl</code> kann Rust erkennen, dass der Typ in spitzen
Klammern in <code>Point</code> ein generischer und kein konkreter Typ ist.</p>
<p>Wir könnten zum Beispiel Methoden nur für <code>Point&lt;f32&gt;</code>-Instanzen
implementieren, anstatt für <code>Point&lt;T&gt;</code>-Instanzen mit einem generischen Typ. In
Codeblock 10-10 verwenden wir den konkreten Typ <code>f32</code>, d.h. wir deklarieren
keinen Typ hinter <code>impl</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-10: Ein <code>impl</code>-Block, der nur für eine
Struktur mit einem bestimmten konkreten Typ für den generischen Typparameter
<code>T</code> gilt</span></p>
<p>Dieser Code bedeutet, dass der Typ <code>Point&lt;f32&gt;</code> eine Methode namens
<code>distance_from_origin</code> hat und andere Instanzen von <code>Point&lt;T&gt;</code>, bei denen <code>T</code>
nicht vom Typ <code>f32</code> ist, haben diese Methode nicht. Die Methode misst, wie weit
unser Punkt vom Punkt mit den Koordinaten (0,0, 0,0) entfernt ist, und
verwendet mathematische Operationen, die nur für Fließkomma-Typen zur Verfügung
stehen.</p>
<p>Generische Typparameter in einer Strukturdefinition sind nicht immer die
gleichen wie die, die du in den Methodensignaturen für diese Struktur
verwendest. Zum Beispiel definiert Codeblock 10-11 die Methode <code>mixup</code> auf der
Struktur <code>Point&lt;T, U&gt;</code> aus Codeblock 10-8. Die Methode nimmt einen weiteren
<code>Point</code> als Parameter, der andere Typen haben kann als die bei <code>self</code>. Die
Methode erzeugt eine neue <code>Point</code>-Instanz mit dem Wert <code>x</code> aus <code>self</code> (vom Typ
<code>T</code>) und dem Wert <code>y</code> aus dem übergebenen <code>Point</code> (vom Typ <code>W</code>).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hallo&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-11: Eine Methode, die verschiedene
generische Typen aus der Definition ihrer Struktur verwendet</span></p>
<p>In <code>main</code> haben wir einen <code>Point</code> definiert, bei dem <code>x</code> den Typ <code>i32</code> (mit dem
Wert <code>5</code>) und <code>y</code> den Typ <code>f64</code> (mit dem Wert <code>10.4</code>) hat. Die Variable <code>p2</code>
ist eine Struktur <code>Point</code>, bei der <code>x</code> einen Zeichenkettenanteilstyp (mit dem
Wert <code>&quot;Hallo&quot;</code>) und <code>y</code> den Typ <code>char</code> (mit dem Wert <code>c</code>) hat. Wenn wir <code>mixup</code>
auf <code>p1</code> mit dem Argument <code>p2</code> aufrufen, erhalten wir <code>p3</code>, das ein <code>i32</code> für
<code>x</code> haben wird, weil <code>x</code> von <code>p1</code> kam. Die Variable <code>p3</code> wird ein <code>char</code> für
<code>y</code> haben, weil <code>y</code> von <code>p2</code> stammt. Der Makroaufruf <code>println!</code> gibt
<code>p3.x = 5, p3.y = c</code> aus.</p>
<p>Der Zweck dieses Beispiels ist es, eine Situation zu demonstrieren, in der
einige generische Parameter mit <code>impl</code> und einige mit der Methodendefinition
deklariert werden. Hier werden die generischen Parameter <code>T</code> und <code>U</code> nach
<code>impl</code> deklariert, weil sie zur Strukturdefinition gehören. Die generischen
Parameter <code>V</code> und <code>W</code> werden nach <code>fn mixup</code> deklariert, da sie nur für die
Methode relevant sind.</p>
<h3><a class="header" href="#code-performanz-beim-verwenden-generischer-datentypen" id="code-performanz-beim-verwenden-generischer-datentypen">Code-Performanz beim Verwenden generischer Datentypen</a></h3>
<p>Du fragst dich vielleicht, ob beim Verwenden generischer Typparameter
Laufzeitkosten anfallen. Die gute Nachricht ist, dass Rust generische
Typparameter so implementiert, dass dein Code mit generischen Typen nicht
langsamer läuft als mit konkreten Typen.</p>
<p>Rust erreicht dies durch Duplizierung von Code, der zur Kompilierzeit
generische Datentypen verwendet. <em>Codeduplizierung</em> (monomorphization) ist der
Vorgang der Umwandlung von generischem Code in spezifischen Code durch
Ausfüllen der konkreten Typen, die bei der Kompilierung verwendet werden.</p>
<p>Bei diesem Prozess führt der Compiler das Gegenteil der Schritte aus, die
wir beim Erstellen der generischen Funktion in Codeblock 10-5 angewendet haben: 
Der Compiler schaut sich alle Stellen an, an denen generischer Code
aufgerufen wird, und generiert Code für die konkreten Typen, mit denen der
generische Code aufgerufen wird.</p>
<p>Betrachten wir die Funktionsweise anhand eines Beispiels, das die Aufzählung
<code>Option&lt;T&gt;</code> der Standardbibliothek verwendet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Wenn Rust diesen Code kompiliert, führt es eine Codeduplizierung durch. Während
dieses Vorgangs liest der Compiler die Werte ein, die in
<code>Option&lt;T&gt;</code>-Instanzen verwendet wurden, und identifiziert zwei Arten von
<code>Option&lt;T&gt;</code>: Eine verwendet den Typ <code>i32</code> und die andere <code>f64</code>. Daraufhin
erweitert es die generische Definition von <code>Option&lt;T&gt;</code> zu <code>Option_i32</code> und
<code>Option_f64</code> und ersetzt damit die generische Definition durch die spezifische.</p>
<p>Die duplizierte Codeversion sieht wie folgt aus. Die generische <code>Option&lt;T&gt;</code>
wird durch die vom Compiler erstellten spezifischen Definitionen ersetzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Da Rust generischen Code in Code kompiliert, der den Typ in jedem Fall
spezifiziert, zahlen wir keine Laufzeitkosten beim Verwenden von generischen
Datentypen. Wenn der Code läuft, verhält er sich genauso, wie wenn wir jede
Definition von Hand dupliziert hätten. Der Vorgang der Codeduplizierung macht
Rusts generische Datentypen zur Laufzeit äußerst effizient.</p>
<h2><a class="header" href="#merkmale-traits-gemeinsames-verhalten-definieren" id="merkmale-traits-gemeinsames-verhalten-definieren">Merkmale (traits): Gemeinsames Verhalten definieren</a></h2>
<p>Ein <em>Merkmal</em> (trait) teilt dem Rust-Compiler mit, welche Funktionalität ein
bestimmter Typ hat und mit anderen Typen teilen kann. Wir können Merkmale
verwenden, um gemeinsames Verhalten auf abstrakte Weise zu definieren. Wir
können Merkmalsabgrenzungen (trait bounds) verwenden, um anzugeben, dass ein
generischer Typ jeder Typ sein kann, der ein bestimmtes Verhalten aufweist.</p>
<blockquote>
<p>Anmerkung: Merkmale sind einer Funktionalität recht ähnlich, die in anderen
Sprachen oft <em>Schnittstelle</em> (interface) genannt wird, wenn auch mit einigen
Unterschieden.</p>
</blockquote>
<h3><a class="header" href="#ein-merkmal-definieren" id="ein-merkmal-definieren">Ein Merkmal definieren</a></h3>
<p>Das Verhalten eines Typs besteht aus den Methoden, die wir auf diesen Typ
anwenden können. Verschiedene Typen haben das gleiche Verhalten, wenn wir bei
allen die gleichen Methoden aufrufen können. Merkmalsdefinitionen sind eine
Möglichkeit, Methodensignaturen zu gruppieren, um eine Reihe von
Verhaltensweisen zu definieren, die zum Erreichen eines bestimmten Zwecks
erforderlich sind.</p>
<p>Nehmen wir zum Beispiel an, wir haben mehrere Strukturen (structs), die
verschiedene Arten und Mengen von Text enthalten: Eine Struktur <code>NewsArticle</code>,
die eine Nachricht enthält, die sich auf einen bestimmten Ort bezieht, und ein
<code>Tweet</code>, der maximal 280 Zeichen umfassen kann, sowie Metadaten, die angeben,
ob es sich um eine neue Kurznachricht, eine Wiederholung oder eine Antwort auf
eine andere Kurznachricht handelt.</p>
<p>Wir wollen eine Medienaggregator-Bibliothek erstellen, die Zusammenfassungen
von Daten anzeigen kann, die in einer <code>NewsArticle</code>- oder <code>Tweet</code>-Instanz
gespeichert sind. Dazu benötigen wir eine Zusammenfassung für jeden Typ und wir
wollen diese Zusammenfassung anfordern, indem wir eine Methode <code>summarize</code> der
Instanz aufrufen. Codeblock 10-12 zeigt die Definition eines Merkmals
<code>Summary</code>, das dieses Verhalten zum Ausdruck bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-12: Ein Merkmal <code>Summary</code>, dessen Verhalten
aus der Methode <code>summarize</code> besteht</span></p>
<p>Hier deklarieren wir ein Merkmal mit dem Schlüsselwort <code>trait</code> und dann den
Namen des Merkmals, der in diesem Fall <code>Summary</code> lautet. Innerhalb der
geschweiften Klammern deklarieren wir die Methodensignaturen, die das Verhalten
der Typen beschreiben, die dieses Merkmal implementieren, was in diesem Fall
<code>fn summarize(&amp;self) -&gt; String</code> ist.</p>
<p>Nach der Methodensignatur verwenden wir statt einer Implementierung in
geschweiften Klammern ein Semikolon. Jeder Typ, der dieses Merkmal
implementiert, muss sein eigenes benutzerdefiniertes Verhalten für den
Methodenrumpf bereitstellen. Der Compiler wird sicherstellen, dass jeder
Typ, der das Merkmal <code>Summary</code> hat, die Methode <code>summarize</code> mit genau dieser
Signatur hat.</p>
<p>Ein Merkmal kann mehrere Methoden umfassen: Die Methodensignaturen werden
zeilenweise aufgelistet und jede Zeile endet mit einem Semikolon.</p>
<h3><a class="header" href="#ein-merkmal-für-einen-typ-implementieren" id="ein-merkmal-für-einen-typ-implementieren">Ein Merkmal für einen Typ implementieren</a></h3>
<p>Da wir nun das gewünschte Verhalten mithilfe des Merkmals <code>Summary</code> definiert
haben, können wir es für die Typen unseres Medienaggregators implementieren. 
Codeblock 10-13 zeigt eine Implementierung des Merkmals <code>Summary</code> für die
Struktur <code>NewsArticle</code>, die die Überschrift, den Autor und den Ort verwendet,
um den Rückgabewert von <code>summarize</code> zu erzeugen. Für die Struktur <code>Tweet</code>
definieren wir <code>summarize</code> als den Benutzernamen, gefolgt vom gesamten Text der
Kurznachricht, wobei wir davon ausgehen, dass der Inhalt der Kurznachricht
bereits auf 280 Zeichen begrenzt ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-13: Implementierung des Merkmals <code>Summary</code>
für die Typen <code>NewsArticle</code> und <code>Tweet</code></span></p>
<p>Die Implementierung eines Merkmals für einen Typ ist ähnlich zur
Implementierung regulärer Methoden. Der Unterschied besteht darin, dass wir
nach <code>impl</code> den Namen des Merkmals schreiben, das wir implementieren wollen,
dann das Schlüsselwort <code>for</code> gefolgt vom Namen des Typs angeben, für den wir
das Merkmal implementieren wollen. Innerhalb des <code>impl</code>-Blocks geben wir die
Methodensignaturen an, die das Merkmal vorgibt. Anstatt nach jeder Signatur ein
Semikolon zu schreiben, verwenden wir geschweifte Klammern und füllen den
Methodenrumpf mit dem spezifischen Verhalten, das die Methoden des Merkmals für
den jeweiligen Typ haben sollen.</p>
<p>Nachdem wir das Merkmal implementiert haben, können wir die Methoden der
<code>NewsArticle</code>- und <code>Tweet</code>-Instanzen auf die gleiche Weise aufrufen, wie wir
reguläre Methoden aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: horse_ebooks: natürlich, wie du wahrscheinlich schon weißt</code> aus.</p>
<p>Beachte, dass wir in Codeblock 10-13 das Merkmal <code>Summary</code> und die Typen
<code>NewsArticle</code> und <code>Tweet</code> in der gleichen Datei <em>lib.rs</em> definiert haben,
sodass sie alle im gleichen Gültigkeitsbereich liegen. Nehmen wir an, diese
Datei <em>lib.rs</em> ist für eine Kiste (crate), die wir <code>aggregator</code> genannt haben,
und jemand anderes möchte die Funktionalität unserer Kiste nutzen, um das
Merkmal <code>Summary</code> für eine Struktur innerhalb des Gültigkeitsbereichs seiner
Bibliothek zu implementieren. Dann muss er das Merkmal erst in seinen
Gültigkeitsbereich bringen. Er würde dies durch Angeben von
<code>use aggregator::Summary;</code> tun, was es ihm dann ermöglichen würde,<code>Summary</code> für
seinen Typ zu implementieren. Das Merkmal <code>Summary</code> müsste auch ein
öffentliches Merkmal für eine andere Kiste sein, um sie zu implementieren, was
auch der Fall ist, weil wir in Codeblock 10-12 das Schlüsselwort <code>pub</code> vor das
Merkmal <code>trait</code> gestellt haben.</p>
<p>Eine Einschränkung, die bei der Implementierung von Merkmalen zu beachten ist,
ist, dass wir ein Merkmal für einen Typ nur dann implementieren können, wenn
entweder das Merkmal oder der Typ lokal in unserer Kiste vorhanden ist. Zum
Beispiel können wir Standard-Bibliotheksmerkmale wie <code>Display</code> auf einem
benutzerdefinierten Typ wie <code>Tweet</code> als Teil unserer
<code>aggregator</code>-Kistenfunktionalität implementieren, weil der Typ <code>Tweet</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört. Wir können auch <code>Summary</code> auf <code>Vec&lt;T&gt;</code> in
unserer <code>aggregator</code>-Kiste implementieren, weil das Merkmal <code>Summary</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört.</p>
<p>Aber wir können externe Merkmale nicht auf externe Typen anwenden. Zum Beispiel
können wir das Merkmal <code>Display</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
nicht implementieren, weil <code>Display</code> und <code>Vec&lt;T&gt;</code> in der Standardbibliothek
definiert sind und nicht lokal zu unserer <code>aggregator</code>-Kiste gehören. Diese
Beschränkung ist Teil einer Eigenschaft von Programmen namens <em>Kohärenz</em>
(coherence), genauer gesagt der <em>Waisenregel</em> (orphan rule), die so genannt
wird, weil der übergeordnete Typ nicht vorhanden ist. Diese Regel stellt
sicher, dass der Code anderer Personen deinen Code nicht brechen kann und
umgekehrt. Ohne diese Regel könnten zwei Kisten dasselbe Merkmal für denselben
Typ implementieren und Rust wüsste nicht, welche Implementierung es verwenden
sollte.</p>
<h3><a class="header" href="#standard-implementierungen" id="standard-implementierungen">Standard-Implementierungen</a></h3>
<p>Manchmal ist es nützlich, ein Standardverhalten für einige oder alle Methoden
eines Merkmals zu haben, anstatt Implementierungen für alle Methoden für jeden
Typ zu verlangen. Wenn wir dann das Merkmal für einem bestimmten Typ
implementieren, können wir das Standardverhalten jeder Methode beibehalten oder
überschreiben.</p>
<p>Codeblock 10-14 zeigt, wie man eine Standard-Zeichenkette für die Methode
<code>summarize</code> des Merkmals <code>Summary</code> angibt, anstatt nur die Methodensignatur zu
definieren, wie wir es in Codeblock 10-12 getan haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Lies mehr ...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-14: Definition eines Merkmals <code>Summary</code> mit
einer Standard-Implementierung der Methode <code>summarize</code></span></p>
<p>Um eine Standard-Implementierung zu verwenden, um Instanzen von <code>NewsArticle</code>
zusammenzufassen, anstatt eine benutzerdefinierte Implementierung zu
definieren, geben wir einen leeren <code>impl</code>-Block mit <code>impl Summary for NewsArticle {}</code> an.</p>
<p>Auch wenn wir die Methode <code>summarize</code> nicht mehr direkt für <code>NewsArticle</code>
definieren, haben wir eine Standard-Implementierung bereitgestellt und
festgelegt, dass <code>NewsArticle</code> das Merkmal <code>Summary</code> implementiert.
Infolgedessen können wir immer noch die Methode <code>summarize</code> einer
<code>NewsArticle</code>-Instanz aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(&quot;Die Pittsburgh Penguins sind erneut die beste \
                               Eishockeymannschaft in der NHL.&quot;,
        ),
    };

    println!(&quot;Neuer Artikel verfügbar! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>Neuer Artikel verfügbar! (Lies mehr ...)</code> aus.</p>
<p>Das Erstellen einer Standard-Implementierung für <code>summarize</code> erfordert nicht,
dass wir an der Implementierung von <code>Summary</code> für <code>Tweet</code> in Codeblock 10-13
etwas ändern. Der Grund dafür ist, dass die Syntax für das Überschreiben einer
Standard-Implementierung die gleiche ist wie die Syntax für die Implementierung
einer Merkmalsmethode, die keine Standard-Implementierung hat.</p>
<p>Standard-Implementierungen können andere Methoden desselben Merkmals aufrufen,
selbst wenn diese anderen Methoden keine Standard-Implementierung haben. Auf
diese Weise kann ein Merkmal eine Menge nützlicher Funktionalität bereitstellen
und von den Implementierern nur die Angabe eines kleinen Teils verlangen. Zum
Beispiel könnten wir das Merkmal <code>Summary</code> so definieren, dass wir eine Methode
<code>summarize_author</code> haben, deren Implementierung erforderlich ist, und dann eine
Methode <code>summarize</code> definieren, die eine Standard-Implementierung hat und die
Methode <code>summarize_author</code> aufruft:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Um diese Version von <code>Summary</code> zu verwenden, müssen wir <code>summarize_author</code> nur
dann definieren, wenn wir das Merkmal für einen Typ implementieren:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nachdem wir <code>summarize_author</code> definiert haben, können wir <code>summarize</code> auf
Instanzen der <code>Tweet</code>-Struktur aufrufen, und die Standard-Implementierung von
<code>summarize</code> wird die Definition von <code>summarize_author</code> aufrufen, die wir
bereitgestellt haben. Da wir <code>summarize_author</code> implementiert haben, hat uns
das Merkmal <code>Summary</code> das Verhalten der <code>summarize</code>-Methode mitgeliefert, ohne
dass wir weiteren Code schreiben müssen. </p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: (Lies mehr von @horse_ebooks...)</code> aus.</p>
<p>Beachte, dass es nicht möglich ist, die Standardimplementierung von einer
übergeordneten Implementierung derselben Methode aus aufzurufen.</p>
<h3><a class="header" href="#merkmale-als-parameter" id="merkmale-als-parameter">Merkmale als Parameter</a></h3>
<p>Da du jetzt weißt, wie man Merkmale definiert und implementiert, können wir
untersuchen, wie man Merkmale zur Definition von Funktionen verwendet, die
viele verschiedene Typen akzeptieren.</p>
<p>Beispielsweise haben wir in Codeblock 10-13 das Merkmal <code>Summary</code> für die Typen
<code>NewsArticle</code> und <code>Tweet</code> implementiert. Wir können eine Funktion <code>notify</code>
definieren, die die Methode <code>summarize</code> ihres <code>item</code>-Parameters aufruft, der
einen Typ hat, der das Merkmal <code>Summary</code> implementiert. Um dies zu tun, können
wir die Syntax <code>impl Trait</code> verwenden, etwa so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Anstelle eines konkreten Typs für den Parameter <code>item</code> geben wir das
Schlüsselwort <code>impl</code> und den Merkmalsnamen an. Dieser Parameter akzeptiert
jeden Typ, der das angegebene Merkmal implementiert. Im Rumpf von <code>notify</code>
können wir alle Methoden von <code>item</code> aufrufen, die vom Merkmal <code>Summary</code>
herrühren, zum Beispiel <code>summarize</code>. Wir können <code>notify</code> aufrufen und jede
Instanz von <code>NewsArticle</code> und <code>Tweet</code> angeben. Code, der die Funktion mit einem
anderen Typ aufruft, z.B. <code>String</code> oder <code>i32</code>, lässt sich nicht kompilieren, da
diese Typen kein <code>Summary</code> implementieren.</p>
<h4><a class="header" href="#merkmalsabgrenzungs-syntax" id="merkmalsabgrenzungs-syntax">Merkmalsabgrenzungs-Syntax</a></h4>
<p>Die Syntax <code>impl Trait</code> funktioniert für einfache Fälle, ist aber eigentlich
syntaktischer Zucker für eine längere Form, die <em>Merkmalsabgrenzung</em> (trait
bound) genannt wird; sie sieht so aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese längere Form entspricht dem Beispiel im vorigen Abschnitt, ist aber
wortreicher. Wir platzieren Merkmalsabgrenzungen in der Deklaration des
generischen Typparameters nach einem Doppelpunkt und innerhalb spitzer
Klammern.</p>
<p>Die Syntax <code>impl Trait</code> ist bequem und ermöglicht in einfachen Fällen einen
prägnanteren Code. Die Merkmalsabgrenzungs-Syntax kann andererseits mehr
Komplexität ausdrücken. Zum Beispiel können wir zwei Parameter haben, die
<code>Summary</code> implementieren. Das Verwenden der Syntax <code>impl Trait</code> sieht
folgendermaßen aus:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Wenn wir wollten, dass diese Funktion bei <code>item1</code> und <code>item2</code> unterschiedliche
Typen haben kann, wäre das Verwenden von <code>impl Trait</code> dafür geeignet (solange
beide Typen <code>Summary</code> implementieren). Wenn beide Parameter aber den gleichen
Typ haben sollten, dann kann man das nur durch eine Merkmalsabgrenzung
ausdrücken, so wie hier:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>Der als Parametertyp für <code>item1</code> und <code>item2</code> angegebene generische Typ <code>T</code>
schränkt die Funktion so ein, dass der konkrete Typ der als Argument für
<code>item1</code> und <code>item2</code> übergebenen Werte derselbe sein muss.</p>
<h4><a class="header" href="#angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-" id="angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-">Angeben mehrerer Merkmalsabgrenzungen mit der Syntax <code>+</code></a></h4>
<p>Wir können auch mehr als eine Merkmalsabgrenzung angeben. Nehmen wir an, wir
wollen, dass sowohl <code>notify</code> als auch die Methode <code>summarize</code> die
Bildschirmausgabe für <code>item</code> formatieren: Spezifizieren wir in der
<code>notify</code>-Definition, dass <code>item</code> sowohl <code>Display</code> als auch <code>Summary</code>
implementieren muss. Wir können dies mit der Syntax <code>+</code> tun:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p>Die Syntax <code>+</code> ist auch bei Merkmalsabgrenzungen mit generischen Typen gültig:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>Mit den beiden angegebenen Merkmalsabgrenzungen kann der Rumpf von <code>notify</code> die
Methode <code>summarize</code> aufrufen und <code>{}</code> verwenden, um <code>item</code> zu formatieren.</p>
<h4><a class="header" href="#klarere-merkmalsabgrenzungen-mit-where-klauseln" id="klarere-merkmalsabgrenzungen-mit-where-klauseln">Klarere Merkmalsabgrenzungen mit <code>where</code>-Klauseln</a></h4>
<p>Zu viele Merkmalsabgrenzungen zu verwenden, hat seine Schattenseiten. Jeder
generische Datentyp hat seine eigenen Merkmalsabgrenzungen, sodass Funktionen
mit mehreren generischen Typparametern viele Merkmalsabgrenzungsangaben
zwischen Funktionsname und Parameterliste enthalten können, wodurch die
Funktionssignatur schwer lesbar wird. Aus diesem Grund hat Rust für die Angabe
von Merkmalsabgrenzungen eine alternative Syntax in Form einer <code>where</code>-Klausel
nach der Funktionssignatur. Anstatt das hier zu schreiben:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>können wir eine <code>where</code>-Klausel wie folgt verwenden:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Die Signatur dieser Funktion ist übersichtlicher: Der Funktionsname, die
Parameterliste und der Rückgabetyp liegen nahe beieinander, ähnlich wie bei
einer Funktion ohne viele Merkmalsabgrenzungen.</p>
<h3><a class="header" href="#rückgabetypen-die-merkmale-implementieren" id="rückgabetypen-die-merkmale-implementieren">Rückgabetypen, die Merkmale implementieren</a></h3>
<p>Wir können die Syntax <code>impl Trait</code> auch für den Rückgabetyp verwenden, wie hier
gezeigt:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Durch Verwenden von <code>impl Summary</code> für den Rückgabetyp legen wir fest, dass die
Funktion <code>returns_summarizable</code> einen Typ zurückgibt, der das Merkmal <code>Summary</code>
implementiert, ohne den konkreten Typ zu nennen. In diesem Fall gibt
<code>returns_summarizable</code> einen <code>Tweet</code> zurück, aber der Code, der diese Funktion
aufruft, weiß das nicht.</p>
<p>Die Fähigkeit, einen Typ zurückzugeben, der nur durch das Merkmal spezifiziert
ist, das er implementiert, ist besonders nützlich im Zusammenhang mit
Funktionsabschlüssen und Iteratoren, die wir in Kapitel 13 behandeln.
Funktionsabschlüsse und Iteratoren erzeugen Typen, die nur der Compiler
kennt oder deren Spezifikation sehr lang ist. Mit der Syntax <code>impl Trait</code>
kannst du prägnant angeben, dass eine Funktion einen Typ zurückgibt, der das
Merkmal <code>Iterator</code> implementiert, ohne dass du einen sehr langen Typ schreiben
musst.</p>
<p>Du kannst <code>impl Trait</code> jedoch nur verwenden, wenn du einen einzigen Typ
zurückgibst. Beispielsweise würde dieser Code, der entweder einen <code>NewsArticle</code>
oder einen <code>Tweet</code> mit dem Rückgabetyp <code>impl Summary</code> zurückgibt, nicht
funktionieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;Die Pittsburgh Penguins sind erneut die beste \
                 Eishockeymannschaft in der NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Rückgabe entweder eines <code>NewsArticle</code> oder eines <code>Tweet</code> ist aufgrund von
Einschränkungen hinsichtlich der Implementierung der Syntax <code>impl Trait</code> im
Compiler nicht erlaubt. Wie man eine Funktion mit diesem Verhalten schreibt,
wird im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher
Typen erlauben“</a>
in Kapitel 17 behandelt.</p>
<h3><a class="header" href="#korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen" id="korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen">Korrigieren der Funktion <code>largest</code> mit Merkmalsabgrenzungen</a></h3>
<p>Da du nun weißt, wie du das gewünschte Verhalten mit generischer
Typparameterabgrenzung spezifizieren kannst, kehren wir zu Codeblock 10-5
zurück, um die Definition der Funktion <code>largest</code>, die einen generischen
Typparameter verwendet, zu korrigieren! Als wir das letzte Mal versuchten,
den Code auszuführen, erhielten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Im Rumpf von <code>largest</code> wollten wir zwei Werte vom Typ <code>T</code> mit dem Operator
größer als (<code>&gt;</code>) vergleichen. Da dieser Operator als Standardmethode für das
Standardbibliotheks-Merkmal <code>std::cmp::PartialOrd</code> definiert ist, müssen wir
<code>PartialOrd</code> als Merkmalsabgrenzung für <code>T</code> angeben, damit die Funktion
<code>largest</code> auf Anteilstypen beliebiger Typen arbeiten kann, die wir vergleichen
können. Wir brauchen <code>PartialOrd</code> nicht in den Gültigkeitsbereich zu bringen,
weil das automatisch erfolgt. Ändere die Signatur von <code>largest</code> wie folgt:</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;Die größte Zahl ist {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;Das größte Zeichen ist {}&quot;, result);
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir den Code kompilieren, erhalten wir nun andere Fehlermeldungen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Schlüsselzeile bei diesem Fehler ist <code>cannot move out of type [T], a non-copy slice</code>. Mit unseren nicht-generischen Versionen der Funktion <code>largest</code>
versuchten wir nur, die größte <code>i32</code> oder <code>char</code> zu finden. Wie im Abschnitt
<a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel
4 besprochen, können Typen wie <code>i32</code> und <code>char</code>, die eine bekannte Größe haben,
auf dem Stapelspeicher gespeichert werden, sodass sie das Merkmal <code>Copy</code>
implementieren. Aber als wir die Funktion <code>largest</code> generisch gemacht haben,
wurde es möglich, dass der Parameter <code>list</code> Typen enthält, die das Merkmal
<code>Copy</code> nicht implementieren. Folglich wären wir nicht in der Lage, den Wert aus
<code>list[0]</code> in die Variable <code>largest</code> zu verschieben, was zu diesem Fehler führt.</p>
<p>Um diesen Code nur mit den Typen aufzurufen, die das Merkmal <code>Copy</code>
implementieren, können wir <code>Copy</code> zu den Merkmalsabgrenzungen von <code>T</code>
hinzufügen! Codeblock 10-15 zeigt den vollständigen Code einer generischen
Funktion <code>largest</code>, die kompiliert, solange die Typen der Werte im Anteilstyp,
die wir der Funktion übergeben, die Merkmale <code>PartialOrd</code> <em>und</em> <code>Copy</code>
implementieren, wie <code>i32</code> und <code>char</code> es tun.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-15: Eine funktionierende Definition der
Funktion <code>largest</code>, die mit jedem generischen Typ funktioniert, der die
Merkmale <code>PartialOrd</code> und <code>Copy</code> implementiert</span></p>
<p>Wenn wir die Funktion <code>largest</code> nicht auf Typen beschränken wollen, die das
Merkmal <code>Copy</code> implementieren, könnten wir angeben, dass <code>T</code> die
Merkmalsabgrenzung <code>Clone</code> anstelle von <code>Copy</code> verwendet. Dann könnten wir
jeden Wert des Anteilstyps klonen, wenn wir wollen, dass die Funktion <code>largest</code>
die Eigentümerschaft übernimmt. Das Verwenden der Funktion <code>clone</code> bedeutet,
dass wir potenziell mehr Allokationen im Haldenspeicher im Falle von
Typen vornehmen, die Haldenspeicherdaten wie <code>String</code> besitzen. Und
Allokationen im Haldenspeicher können langsam sein, wenn wir mit großen
Datenmengen arbeiten.</p>
<p>Eine andere Möglichkeit, wie wir <code>largest</code> implementieren könnten, besteht
darin, dass die Funktion eine Referenz auf einen <code>T</code>-Wert im Anteilstyp
zurückgibt. Wenn wir den Rückgabetyp in <code>&amp;T</code> anstelle von <code>T</code> ändern und
dadurch den Funktionsrumpf ändern, um eine Referenz zurückzugeben, bräuchten
wir die Merkmalsabgrenzungen <code>Clone</code> oder <code>Copy</code> nicht und könnten Allokationen
im Haldenspeicher vermeiden. Versuche, diese alternativen Lösungen selbst
zu implementieren!</p>
<h3><a class="header" href="#verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden" id="verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden">Verwenden von Merkmalsabgrenzungen zur bedingten Implementierung von Methoden</a></h3>
<p>Durch Verwenden einer Merkmalsabgrenzung mit einem <code>impl</code>-Block, der generische
Typparameter verwendet, können wir Methoden bedingt für Typen implementieren,
die das angegebene Merkmal implementieren. Beispielsweise implementiert der Typ
<code>Pair&lt;T&gt;</code> in Codeblock 10-16 immer die Funktion <code>new</code>. Aber <code>Pair&lt;T&gt;</code>
implementiert die Methode <code>cmp_display</code> nur, wenn ihr innerer Typ <code>T</code> die
Merkmale <code>PartialOrd</code> <em>und</em> <code>Display</code> implementiert, die den Vergleich bzw.
eine Ausgabe ermöglichen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Das größte Element ist x = {}&quot;, self.x);
        } else {
            println!(&quot;Das größte Element ist y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-16: Bedingte Implementierung von Methoden
für einen generischen Typ in Abhängigkeit von Merkmalsabgrenzungen</span></p>
<p>Wir können auch ein Merkmal für beliebige Typen bedingt implementieren, die ein
anderes Merkmal implementieren. Implementierungen eines Merkmals für Typen, die
Merkmalsabgrenzungen erfüllen, werden als <em>Pauschal-Implementierungen</em> (blanket
implementations) bezeichnet und kommen in der Rust-Standardbibliothek ausgiebig
zur Anwendung. Beispielsweise implementiert die Standardbibliothek das Merkmal
<code>ToString</code> für jeden Typ, der das Merkmal <code>Display</code> implementiert. Der
<code>impl</code>-Block in der Standardbibliothek sieht in etwa so aus:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --abschneiden--
}
</code></pre>
<p>Da die Standardbibliothek diese Pauschal-Implementierungen hat, können wir die
<code>to_string</code>-Methode, die durch das Merkmal <code>ToString</code> definiert ist, bei jedem
Typ aufrufen, der das Merkmal <code>Display</code> implementiert. Zum Beispiel können wir
ganze Zahlen in ihre entsprechenden <code>String</code>-Werte umwandeln, weil ganze
Zahlen <code>Display</code> implementieren:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Pauschal-Implementierungen erscheinen in der Dokumentation des Merkmals im
Abschnitt „Implementierer“ (implementors).</p>
<p>Mithilfe von Merkmalen und Merkmalsabgrenzungen können wir Code schreiben, der
generische Typparameter verwendet, um Duplikationen zu reduzieren, aber auch
dem Compiler gegenüber angeben, dass der generische Typ ein bestimmtes
Verhalten haben soll. Der Compiler kann dann die Merkmalsabgrenzungen
verwenden, um zu überprüfen, ob alle konkreten Typen, die von unserem Code
verwendet werden, das richtige Verhalten aufweisen. In dynamisch typisierten
Sprachen würden wir einen Laufzeitfehler erhalten, wenn wir eine Methode bei
einem Typ aufrufen, der die Methode nicht definiert hat. Rust verschiebt diese
Fehler jedoch in die Kompilierzeit und verlangt damit, dass wir die Probleme
beheben, bevor unser Code überhaupt lauffähig ist. Außerdem müssen wir keinen
Code schreiben, der das Verhalten zur Laufzeit überprüft, da wir es bereits zur
Kompilierungszeit überprüft haben. Auf diese Weise wird die Performanz
verbessert, ohne die Flexibilität der generischen Datentypen aufgeben zu
müssen.</p>
<p>Eine weitere generische Funktionalität, die wir bereits verwendet haben, heißt
<em>Lebensdauer</em> (lifetimes). Anstatt sicherzustellen, dass ein Typ das von uns
gewünschte Verhalten hat, stellen wir durch die Lebensdauer sicher, dass
Referenzen so lange gültig sind, wie wir sie brauchen. Schauen wir uns an, wie
Lebensdauern das tun.</p>
<h2><a class="header" href="#referenzen-validieren-mit-lebensdauern" id="referenzen-validieren-mit-lebensdauern">Referenzen validieren mit Lebensdauern</a></h2>
<p>Ein Detail, das wir im Abschnitt <a href="ch04-02-references-and-borrowing.html">„Referenzen und Ausleihen
(borrowing)“</a> in Kapitel 4 nicht erörtert haben, ist,
dass jede Referenz in Rust eine <em>Lebensdauer</em> (lifetime) hat, d.h. einen
Gültigkeitsbereich, in dem diese Referenz gültig ist. In den meisten Fällen
sind Lebensdauern implizit und abgeleitet, ebenso wie in den meisten Fällen
Typen abgeleitet werden. Wir müssen Typen mit Annotationen versehen, wenn
mehrere Typen möglich sind. In ähnlicher Weise müssen wir Lebensdauern
annotieren, wenn die Lebensdauern von Referenzen auf verschiedene Weise
miteinander in Beziehung gesetzt werden könnten. Rust verlangt von uns, die
Beziehungen mit generischen Lebensdauerparametern zu annotieren, um
sicherzustellen, dass die tatsächlich zur Laufzeit verwendeten Referenzen
definitiv gültig sind.</p>
<p>Das Konzept der Lebensdauer unterscheidet sich etwas von Werkzeugen in anderen
Programmiersprachen, was die Lebensdauer wohl zur charakteristischsten
Funktionalität von Rust macht. Auch wenn wir in diesem Kapitel die Lebensdauern
nicht in ihrer Gesamtheit behandeln werden, so werden wir doch allgemeine
Möglichkeiten erörtern, mit denen du dich mit der Syntax der Lebensdauer und
den Konzepten vertraut machen kannst.</p>
<h3><a class="header" href="#verhindern-hängender-referenzen-mit-lebensdauern" id="verhindern-hängender-referenzen-mit-lebensdauern">Verhindern hängender Referenzen mit Lebensdauern</a></h3>
<p>Das Hauptziel der Lebensdauer ist es, hängende Referenzen zu verhindern, die
dazu führen, dass ein Programm auf andere Daten referenziert als die, auf die
es referenzieren soll. Betrachte das Programm in Codeblock 10-17, das einen
äußeren und einen inneren Gültigkeitsbereich hat.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-17: Ein Versuch, eine Referenz zu verwenden,
deren Wert außerhalb des Gültigkeitsbereichs liegt</span></p>
<blockquote>
<p>Hinweis: Die Beispiele in den Codeblöcken 10-17, 10-18 und 10-24 deklarieren
Variablen ohne Initialwert, sodass der Variablenname im äußeren
Gültigkeitsbereich existiert. Auf den ersten Blick mag dies im Widerspruch
dazu stehen, dass Rust keine Nullwerte hat. Wenn wir jedoch versuchen, eine
Variable zu verwenden, bevor wir ihr einen Wert geben, erhalten wir einen
Kompilierfehler, der zeigt, dass Rust tatsächlich keine Nullwerte zulässt.</p>
</blockquote>
<p>Der äußere Gültigkeitsbereich deklariert eine Variable <code>r</code> ohne Initialwert und
der innere Gültigkeitsbereich deklariert eine Variable <code>x</code> mit dem Initialwert
5. Im inneren Gültigkeitsbereich versuchen wir, den Wert von <code>r</code> als Referenz
auf <code>x</code> zu setzen. Dann endet der innere Gültigkeitsbereich und wir versuchen,
den Wert in <code>r</code> auszugeben. Dieser Code lässt sich nicht kompilieren, weil der
Wert, auf den sich <code>r</code> bezieht, den Gültigkeitsbereich verlassen hat, bevor wir
versuchen, ihn zu verwenden. Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Variable <code>x</code> lebt nicht „lange genug“. Der Grund dafür ist, dass <code>x</code> den
Gültigkeitsbereich verlässt, da der innere Gültigkeitsbereich bei Zeile 8
endet. Aber <code>r</code> ist im äußeren Gültigkeitsbereich immer noch gültig; da sein
Gültigkeitsbereich größer ist, sagen wir, dass es „länger lebt“. Wenn Rust
diesen Code funktionieren ließe, würde <code>r</code> auf Speicher verweisen, der
freigegeben wurde, als <code>x</code> den Gültigkeitsbereich verlassen hat, und alles, was
wir mit <code>r</code> tun würden, würde nicht korrekt funktionieren. Wie stellt Rust also
fest, dass dieser Code ungültig ist? Es verwendet einen Ausleihenprüfer (borrow
checker).</p>
<h3><a class="header" href="#der-ausleihenprüfer" id="der-ausleihenprüfer">Der Ausleihenprüfer</a></h3>
<p>Der Rust-Compiler verfügt über einen <em>Ausleihenprüfer</em> (borrow checker), der
Gültigkeitsbereiche vergleicht, um festzustellen, ob alle Ausleihen gültig
sind. Codeblock 10-18 zeigt den gleichen Code wie Codeblock 10-17, jedoch mit
Annotationen, die die Lebensdauer der Variablen angeben.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-18: Annotationen der Lebensdauern von <code>r</code>
und <code>x</code>, genannt <code>'a</code> bzw. <code>'b</code></span></p>
<p>Hier haben wir die Lebensdauer von <code>r</code> mit <code>'a</code> und die Lebensdauer von <code>x</code> mit
<code>'b</code> vermerkt. Wie du sehen kannst, ist der innere <code>'b</code>-Block viel kleiner als
der äußere <code>'a</code>-Lebensdauer-Block. Zur Kompilierzeit vergleicht Rust die Größe
der beiden Lebensdauern und stellt fest, dass <code>r</code> eine Lebensdauer von <code>'a</code>
hat, jedoch auf einen Speicherbereich mit Lebensdauern <code>'b</code> referenziert. Das
Programm wird abgelehnt, weil <code>'b</code> kürzer als <code>'a</code> ist: Der Referenzinhalt lebt
nicht so lange wie die Referenz selbst.</p>
<p>Mit Codeblock 10-19 wird der Code so korrigiert, dass er keine hängende
Referenz hat und fehlerfrei kompiliert werden kann.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-19: Eine gültige Referenz, da die Daten eine
längere Lebensdauer als die Referenz haben</span></p>
<p>Hier hat <code>x</code> die Lebensdauer <code>'b</code>, die in diesem Fall größer ist als <code>'a</code>. Das
bedeutet, dass <code>r</code> auf <code>x</code> referenzieren kann, weil Rust weiß, dass die
Referenz in <code>r</code> immer gültig sein wird, solange <code>x</code> gültig ist.</p>
<p>Da du nun weißt, wo die Lebensdauern von Referenzen sind und wie Rust die
Lebensdauer analysiert, um sicherzustellen, dass Referenzen immer gültig sind,
lass uns die generischen Lebensdauern von Parametern und Rückgabewerten im
Kontext von Funktionen untersuchen.</p>
<h3><a class="header" href="#generische-lebensdauern-in-funktionen" id="generische-lebensdauern-in-funktionen">Generische Lebensdauern in Funktionen</a></h3>
<p>Schreiben wir eine Funktion, die den längeren von zwei
Zeichenkettenanteilstypen zurückgibt. Diese Funktion nimmt zwei
Zeichenkettenanteilstypen entgegen und gibt einen
Zeichenkettenanteilstyp zurück. Nachdem wir die Funktion <code>longest</code>
implementiert haben, sollte der Code in Codeblock 10-20 <code>Die längere Zeichenkette ist abcd</code> ausgeben.</p>
<p><span class="filename">Datei: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}
</code></pre>
<p><span class="caption">Codeblock 10-20: Eine Funktion <code>main</code>, die die Funktion
<code>longest</code> aufruft, um die längere von zwei Zeichenkettenanteilstypen zu
bestimmen</span></p>
<p>Beachte, dass wir wollen, dass die Funktion Zeichenkettenanteilstypen nimmt,
die Referenzen sind, weil wir nicht wollen, dass die Funktion <code>longest</code> die
Eigentümerschaft ihrer Parameter übernimmt. Lies den Abschnitt
<a href="ch04-03-slices.html#zeichenkettenanteilstypen-als-parameter">„Zeichenkettenanteilstypen als Parameter“</a> in
Kapitel 4, um mehr darüber zu erfahren, warum die Parameter, die wir in
Codeblock 10-20 verwenden, die von uns gewünschten sind.</p>
<p>Wenn wir versuchen, die Funktion <code>longest</code>, wie in Codeblock 10-21 gezeigt, zu
implementieren, wird sie sich nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-21: Eine Implementierung der Funktion
<code>longest</code>, die die längere von zwei Zeichenkettenanteilstypen zurückgibt, aber
noch nicht kompiliert</span></p>
<p>Stattdessen erhalten wir folgenden Fehler, der von Lebensdauern spricht:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Aus dem Hilfetext geht hervor, dass der Rückgabetyp einen generischen
Lebensdauer-Parameter benötigt, da Rust nicht sagen kann, ob sich die
zurückgegebene Referenz auf <code>x</code> oder auf <code>y</code> bezieht. Eigentlich wissen wir es
auch nicht, weil der <code>if</code>-Zweig im Funktionsrumpf eine Referenz auf <code>x</code> und der
<code>else</code>-Zweig eine Referenz auf <code>y</code> zurückgibt!</p>
<p>Wenn wir diese Funktion definieren, kennen wir die konkreten Werte nicht, die
an diese Funktion übergeben werden, also wissen wir nicht, ob der <code>if</code>-Zweig
oder der <code>else</code>-Zweig ausgeführt wird. Wir kennen auch nicht die konkreten
Lebensdauern der Referenzen, die weitergegeben werden, sodass wir nicht wie in
den Codeblöcken 10-18 und 10-19 die Gültigkeitsbereiche betrachten können, um
festzustellen, ob die von uns zurückgegebene Referenz immer gültig sein wird.
Der Ausleihenprüfer kann dies auch nicht feststellen, weil er nicht weiß, wie
die Lebensdauer von <code>x</code> und <code>y</code> mit der Lebensdauer des Rückgabewertes
zusammenhängt. Um diesen Fehler zu beheben, geben wir generische
Lebensdauerparameter an, die die Beziehung zwischen den Referenzen definieren,
damit der Ausleihenprüfer seine Analyse durchführen kann.</p>
<h3><a class="header" href="#lebensdauer-annotationssyntax" id="lebensdauer-annotationssyntax">Lebensdauer-Annotationssyntax</a></h3>
<p>Lebensdauer-Annotationen ändern nichts daran, wie lange eine Referenz lebt.
Genauso wie Funktionen jeden Typ entgegennehmen können, wenn die Signatur einen
generischen Typparameter angibt, können Funktionen Referenzen mit beliebiger
Lebensdauer akzeptieren, indem sie einen generischen Lebensdauerparameter
angeben. Lebensdauer-Annotationen beschreiben die Beziehungen der Lebensdauern
mehrerer Referenzen zueinander, ohne die Lebensdauern zu beeinflussen.</p>
<p>Lebensdauer-Annotationen haben eine etwas ungewöhnliche Syntax: Die Namen der
Lebensdauer-Parameter müssen mit einem Apostroph (<code>'</code>) beginnen und sind
normalerweise kleingeschrieben und sehr kurz, wie generische Typen. Die meisten
Menschen verwenden den Namen <code>'a</code>. Wir platzieren
Lebensdauer-Parameter-Annotationen hinter dem <code>&amp;</code> einer Referenz, wobei wir ein
Leerzeichen verwenden, um die Annotation vom Typ der Referenz zu trennen.</p>
<p>Hier sind einige Beispiele: Eine Referenz auf einen <code>i32</code> ohne
Lebensdauer-Parameter, eine Referenz auf einen <code>i32</code>, die einen
Lebensdauer-Parameter namens <code>'a</code> hat, und eine veränderlicher Referenz auf
einen <code>i32</code>, die ebenfalls die Lebensdauer <code>'a</code> hat.</p>
<pre><code class="language-rust ignore">&amp;i32        // eine Referenz
&amp;'a i32     // eine Referenz mit expliziter Lebensdauer
&amp;'a mut i32 // eine veränderliche Referenz mit expliziter Lebensdauer
</code></pre>
<p>Eine Lebensdauer-Annotation an sich hat nicht viel Bedeutung, da die
Annotationen Rust mitteilen sollen, wie sich generische
Lebensdauer-Parameter mehrerer Referenzen zueinander verhalten. Nehmen wir zum
Beispiel an, wir haben eine Funktion mit dem Parameter <code>first</code>, die eine
Referenz auf einen <code>i32</code> mit Lebensdauer <code>'a</code> ist. Die Funktion hat noch einen
weiteren Parameter namens <code>second</code>, der eine weitere Referenz auf einen <code>i32</code>
ist, die ebenfalls die Lebensdauer <code>'a</code> hat. Die Lebensdauer-Annotationen
weisen darauf hin, dass die Referenzen <code>first</code> und <code>second</code> beide so lange
leben müssen wie diese generische Lebensdauer.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-funktionssignaturen" id="lebensdauer-annotationen-in-funktionssignaturen">Lebensdauer-Annotationen in Funktionssignaturen</a></h3>
<p>Lass uns nun Lebensdauer-Annotationen im Kontext der Funktion <code>longest</code>
untersuchen. Wie bei generischen Typparametern müssen wir generische
Lebensdauerparameter innerhalb spitzer Klammern zwischen dem Funktionsnamen und
der Parameterliste deklarieren. Die Beschränkung, die wir mit dieser Signatur
zum Ausdruck bringen wollen, besteht darin, dass alle Referenzen in den
Parametern und dem Rückgabewert die gleiche Lebensdauer haben müssen. Wir
nennen die Lebensdauer <code>'a</code> und fügen sie dann jeder Referenz hinzu, wie in
Codeblock 10-22 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-22: Die Funktionsdefinition <code>longest</code> gibt
an, dass alle Referenzen in der Signatur die gleiche Lebensdauer <code>'a</code> haben
müssen</span></p>
<p>Die Funktionssignatur sagt Rust, dass die Funktion für eine gewisse Lebensdauer
<code>'a</code> zwei Parameter benötigt, die beide den Zeichenkettenanteilstyp haben und
mindestens so lange leben wie die Lebensdauer <code>'a</code>. Die Funktionssignatur sagt
Rust auch, dass der von der Funktion zurückgegebene Zeichenkettenanteilstyp
mindestens so lange leben wird wie die Lebensdauer <code>'a</code>. In der Praxis bedeutet
dies, dass die Lebensdauer der von der Funktion <code>longest</code> zurückgegebenen
Referenz identisch mit der kürzeren der Lebensdauern der entgegengenommenen
Referenzen ist. Diese Bedingung wollen wir durch Rust sicherstellen lassen.
Denke daran, indem wir die Lebensdauerparameter in dieser Funktionssignatur
angeben, ändern wir nicht die Lebensdauer der übergebenen oder zurückgegebenen
Werte. Vielmehr legen wir fest, dass der Ausleihenprüfer alle Werte ablehnen
soll, die sich nicht an diese Bedingung halten. Beachte, dass die Funktion
<code>longest</code> nicht genau wissen muss, wie lange <code>x</code> und <code>y</code> leben werden, nur dass
ein gewisser Gültigkeitsbereich für <code>'a</code> eingesetzt werden kann, der dieser
Signatur genügt.</p>
<p>Wenn Funktionen mit Lebensdauern annotiert werden, gehören die Annotationen zur
Funktionssignatur, nicht zum Funktionsrumpf. Rust kann den Code innerhalb der
Funktion ohne jede Hilfe analysieren. Wenn eine Funktion jedoch Referenzen auf
oder von Code außerhalb dieser Funktion hat, wird es für Rust fast unmöglich,
die Lebensdauer der Parameter oder Rückgabewerte allein herauszufinden. Die
Lebensdauer kann bei jedem Aufruf der Funktion unterschiedlich sein. Aus diesem
Grund müssen wir die Lebensdauern manuell angeben.</p>
<p>Wenn wir der Funktion <code>longest</code> konkrete Referenzen übergeben, ist die konkrete
Lebensdauer, die an die Stelle von <code>'a</code> tritt, der Teil des Gültigkeitsbereichs
von <code>x</code>, der sich mit dem Gültigkeitsbereich von <code>y</code> überschneidet. Mit anderen
Worten bekommt die generische Lebensdauer <code>'a</code> die konkrete Lebensdauer, die
der kürzeren der Lebensdauern von <code>x</code> und <code>y</code> entspricht. Da wir die
zurückgegebene Referenz mit dem gleichen Lebensdauer-Parameter <code>'a</code> annotiert
haben, wird die zurückgegebene Referenz auch für die Dauer der kürzeren
Lebensdauer von <code>x</code> und <code>y</code> gültig sein.</p>
<p>Schauen wir uns an, wie die Lebensdauer-Annotationen die Funktion <code>longest</code>
beschränken, indem wir Referenzen mit unterschiedlichen konkreten Lebensdauern
übergeben. Codeblock 10-23 ist ein einfaches Beispiel.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-23: Verwenden der Funktion <code>longest</code> mit
Referenzen auf Zeichenketten, die unterschiedliche konkrete Lebensdauern
haben</span></p>
<p>In diesem Beispiel ist <code>string1</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig, <code>string2</code> ist bis zum Ende des inneren Gültigkeitsbereichs gültig, und
<code>result</code> referenziert auf etwas, das bis zum Ende des inneren
Gültigkeitsbereichs gültig ist. Führe diesen Code aus und du wirst sehen, dass
der Ausleihenprüfer diesen Code akzeptiert; er kompiliert und gibt <code>Die längere Zeichenkette ist lange Zeichenkette ist lang</code>.</p>
<p>Versuchen wir als nächstes ein Beispiel, das zeigt, dass die Lebensdauer der
Referenz in <code>result</code> die kürzere Lebensdauer der beiden Argumente sein muss. 
Wir verschieben die Deklaration der Variable <code>result</code> oberhalb des inneren
Gültigkeitsbereichs, lassen aber die Zuweisung des Wertes an die Variable
<code>result</code> innerhalb des Gültigkeitsbereichs mit <code>string2</code>. Dann verschieben wir
<code>println!</code>, das <code>result</code> verwendet, unterhalb des inneren Gültigkeitsbereichs.
Der Code in Codeblock 10-24 lässt sich nicht kompilieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-24: Der Versuch, <code>result</code> zu verwenden,
nachdem <code>string2</code> den Gültigkeitsbereich verlassen hat</span></p>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
  |                                                 ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler zeigt, dass <code>string2</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig sein müsste, damit <code>result</code> in der Anweisung <code>println!</code> noch gültig ist. 
Rust weiß das, weil wir die Lebensdauer der Funktionsparameter und
Rückgabewerte mit dem gleichen Lebensdauerparameter <code>'a</code> annotiert haben.</p>
<p>Als Menschen können wir uns diesen Code ansehen und erkennen, dass <code>string1</code>
länger als <code>string2</code> ist und deshalb wird <code>result</code> eine Referenz auf <code>string1</code>
enthalten. Da <code>string1</code> den Gültigkeitsbereich noch nicht verlassen hat, wird
eine Referenz auf <code>string1</code> in der <code>println!</code>-Anweisung noch gültig sein. Der
Compiler kann jedoch nicht sehen, dass die Referenz in diesem Fall gültig
ist. Wir haben Rust gesagt, dass die Lebensdauer der Referenz, die von der
Funktion <code>longest</code> zurückgegeben wird, die gleiche ist wie die kürzere der
Lebensdauern der entgegengenommenen Referenzen. Daher lehnt der Ausleihenprüfer
den Code in Codeblock 10-24 als möglicherweise ungültige Referenz ab.</p>
<p>Versuche, dir weitere Experimente auszudenken, die die Werte und die
Lebensdauern der an die Funktion <code>longest</code> übergebenen Referenzen variieren und
wie die zurückgegebene Referenz verwendet wird. Stelle Hypothesen darüber auf,
ob deine Experimente den Ausleihenprüfer bestehen oder nicht, bevor du
kompilierst; prüfe dann, ob du Recht hast!</p>
<h3><a class="header" href="#denken-in-lebensdauern" id="denken-in-lebensdauern">Denken in Lebensdauern</a></h3>
<p>Die Art und Weise, in der du Lebensdauerparameter angeben musst, hängt davon
ab, was deine Funktion tut. Wenn wir zum Beispiel die Implementierung der
Funktion <code>longest</code> so ändern würden, dass sie immer den ersten Parameter
zurückgibt und nicht den längsten Zeichenkettenanteilstyp, bräuchten wir keine
Lebensdauer für den Parameter <code>y</code> anzugeben. Der folgende Code wird
kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>In diesem Beispiel haben wir einen Lebensdauer-Parameter <code>'a</code> für den Parameter
<code>x</code> und den Rückgabetyp angegeben, aber nicht für den Parameter <code>y</code>, weil die
Lebensdauer von <code>y</code> in keiner Beziehung zur Lebensdauer von <code>x</code> oder dem
Rückgabewert steht.</p>
<p>Wenn eine Funktion eine Referenz zurückgibt, muss der Lebensdauerparameter für
den Rückgabetyp mit dem Lebensdauerparameter für einen der Parameter
übereinstimmen. Wenn sich die zurückgegebene Referenz <em>nicht</em> auf einen der
Parameter bezieht, muss er sich auf einen innerhalb dieser Funktion erzeugten
Wert beziehen, was eine hängende Referenz wäre, da der Wert am Ende der
Funktion den Gültigkeitsbereich verlässt. Betrachte diesen Versuch einer
Implementierung der Funktion <code>longest</code>, die sich nicht kompilieren lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;wirklich lange Zeichenkette&quot;);
    result.as_str()
}
</code></pre></pre>
<p>Auch wenn wir hier einen Lebensdauer-Parameter <code>'a</code> für den Rückgabetyp
angegeben haben, wird diese Implementierung nicht kompilieren, weil die
Lebensdauer des Rückgabewerts überhaupt nicht mit der Lebensdauer der Parameter
zusammenhängt. Hier ist die Fehlermeldung, die wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Das Problem ist, dass <code>result</code> den Gültigkeitsbereich verlässt und am Ende der
Funktion <code>longest</code> aufgeräumt wird. Wir versuchen auch, eine Referenz auf den
Wert in <code>result</code> zurückzugeben. Es gibt keine Möglichkeit, Lebensdauerparameter
so anzugeben, dass die hängende Referenz beseitigt wird, Rust lässt uns also
keine hängende Referenz erstellen. In diesem Fall wäre die beste Lösung, einen
eigenen Datentyp statt einer Referenz zurückzugeben, sodass die aufrufende
Funktion dann für das Aufräumen des Wertes verantwortlich ist.</p>
<p>Letztlich geht es bei der Lebensdauersyntax darum, die Lebensdauern
verschiedener Parameter und Rückgabewerte von Funktionen miteinander zu
verbinden. Sobald sie verbunden sind, verfügt Rust über genügend Informationen,
um speichersichere Operationen zu ermöglichen und Operationen zu unterbinden,
die hängende Zeiger erzeugen oder anderweitig die Speichersicherheit verletzen
würden.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-struktur-definitionen" id="lebensdauer-annotationen-in-struktur-definitionen">Lebensdauer-Annotationen in Struktur-Definitionen</a></h3>
<p>Bisher haben wir nur Strukturen (structs) definiert, die aneigenbare Typen
enthalten. Es ist möglich, dass Strukturen Referenzen enthalten, aber in diesem
Fall müssten wir Lebensdauer-Annotationen zu jeder Referenz in der
Strukturdefinition angeben. Codeblock 10-25 hat eine Struktur namens
<code>ImportantExcerpt</code>, die einen Zeichenkettenanteilstyp enthält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-25: Eine Struktur, die eine Referenz
enthält, sodass ihre Definition eine Lebensdauer-Annotationen benötigt</span></p>
<p>Diese Struktur hat ein Feld <code>part</code>, das einen Zeichenkettenanteilstyp enthält,
der eine Referenz ist. Wie bei generischen Datentypen deklarieren wir den Namen
des generischen Lebensdauerparameters innerhalb spitzer Klammern hinter dem
Strukturnamen, damit wir den Lebensdauerparameter im Rumpf der
Strukturdefinition verwenden können. Diese Annotation bedeutet, dass eine
Instanz von <code>ImportantExcerpt</code> die Referenz, die sie in ihrem Feld <code>part</code>
enthält, nicht überleben kann.</p>
<p>Die Funktion <code>main</code> erzeugt hier eine Instanz der Struktur <code>ImportantExcerpt</code>,
die eine Referenz auf den ersten Satz des <code>String</code> enthält, der der Variablen
<code>novel</code> gehört. Die Daten in <code>novel</code> existieren, bevor die Instanz
<code>ImportantExcerpt</code> erzeugt wird. Darüber hinaus verlässt <code>novel</code> den
Gültigkeitsbereich erst, nachdem <code>ImportantExcerpt</code> den Gültigkeitsbereich
verlassen hat, sodass die Referenz in der <code>ImportantExcerpt</code>-Instanz gültig
ist.</p>
<h3><a class="header" href="#lebensdauer-elision" id="lebensdauer-elision">Lebensdauer-Elision</a></h3>
<p>Du hast gelernt, dass jede Referenz eine Lebensdauer hat und dass du
Lebensdauerparameter für Funktionen oder Strukturen angeben musst, die
Referenzen verwenden. In Kapitel 4 hatten wir jedoch eine Funktion in Codeblock
4-9, die wiederum in Codeblock 10-26 gezeigt wird, die ohne
Lebensdauer-Annotationen kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-26: Eine Funktion, die wir in Codeblock 4-9
definiert haben und die ohne Lebensdauer-Annotationen kompiliert, obwohl
Parameter und Rückgabetyp Referenzen sind</span></p>
<p>Der Grund, warum diese Funktion ohne Lebensdauer-Annotationen kompiliert, ist
historisch bedingt: In frühen Versionen (vor 1.0) von Rust hätte sich dieser
Code nicht kompilieren lassen, da jede Referenz eine explizite Lebensdauer
benötigte. Damals wäre die Funktionssignatur so geschrieben worden:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Nachdem jede Menge Rust-Code geschrieben wurde, stellte das Rust-Team fest,
dass die Rust-Programmierer in bestimmten Situationen immer wieder die gleichen
Lebensdauer-Annotationen angaben. Diese Situationen waren vorhersehbar und
folgten einigen wenigen deterministischen Mustern. Die Entwickler
programmierten diese Muster in den Code des Compilers, sodass der
Ausleihenprüfer in diesen Situationen auf die Lebensdauer schließen konnte und
keine expliziten Annotationen benötigte.</p>
<p>Dieses Stück Rust-Geschichte ist relevant, weil es möglich ist, dass weitere
deterministische Muster auftauchen und dem Compiler hinzugefügt werden. In
Zukunft könnten noch weniger Lebensdauer-Annotationen erforderlich sein.</p>
<p>Die Muster, die in Rusts Referenzanalyse programmiert sind, werden die
<em>Lebensdauer-Elisionsregeln</em> (lifetime elision rules) genannt. Dies sind keine
Regeln, die Programmierer befolgen müssen; es handelt sich um eine Reihe
besonderer Fälle, die der Compiler berücksichtigt, und wenn dein Code zu
einem dieser Fälle passt, brauchst du die Lebensdauer nicht explizit anzugeben.</p>
<p>Die Elisionsregeln bieten keine vollständige Schlussfolgerung. Wenn Rust die
Regeln deterministisch anwendet, aber immer noch Unklarheit darüber besteht,
welche Lebensdauer die Referenzen haben, wird der Compiler nicht erraten,
wie lang die Lebensdauer der verbleibenden Referenzen sein sollte. In diesem
Fall gibt dir der Compiler statt einer Vermutung einen Fehler an, den du
beheben kannst, indem du die Lebensdauer-Annotationen angibst, die festlegen,
wie sich die Referenzen zueinander verhalten.</p>
<p>Die Lebensdauern der Funktions- oder Methodenparameter werden als
<em>Eingangslebensdauern</em> (input lifetimes) bezeichnet, und die Lebensdauern der
Rückgabewerte als <em>Ausgangslebensdauern</em> (output lifetimes) bezeichnet.</p>
<p>Der Compiler verwendet drei Regeln, um herauszufinden, welche Lebensdauer
Referenzen haben, wenn keine expliziten Annotationen vorhanden sind. Die erste
Regel gilt für Eingangslebensdauern und die zweite und dritte Regel gelten für
Ausgangslebensdauern. Wenn der Compiler das Ende der drei Regeln erreicht
und es immer noch Referenzen gibt, für die er keine Lebensdauern ermitteln
kann, bricht der Compiler mit einem Fehler ab. Diese Regeln gelten sowohl
für <code>fn</code>-Definitionen als auch für <code>impl</code>-Blöcke.</p>
<p>Die erste Regel ist, dass jeder Parameter, der eine Referenz ist, seinen
eigenen Lebensdauerparameter erhält. Mit anderen Worten, eine Funktion mit
einem Parameter erhält einen Lebensdauerparameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>;
eine Funktion mit zwei Parametern erhält zwei separate Lebensdauerparameter:
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; und so weiter.</p>
<p>Die zweite Regel lautet: Wenn es genau einen Eingangslebensdauer-Parameter
gibt, wird diese Lebensdauer allen Ausgangslebensdauer-Parametern zugewiesen:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Die dritte Regel lautet: Wenn es mehrere Eingangslebensdauer-Parameter gibt,
aber einer davon <code>&amp;self</code> oder <code>&amp;mut self</code> ist, weil dies eine Methode ist, wird
die Lebensdauer von <code>self</code> allen Ausgangslebensdauer-Parametern zugewiesen.
Diese dritte Regel macht Methoden viel angenehmer zu lesen und zu schreiben,
weil weniger Symbole erforderlich sind.</p>
<p>Tun wir so, als wären wir der Compiler. Wir werden diese Regeln anwenden, um
herauszufinden, wie lang die Lebensdauer der Referenzen in der Signatur der
Funktion <code>first_word</code> in Codeblock 10-26 ist. Die Signatur beginnt ohne
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Dann wendet der Compiler die erste Regel an, die festlegt, dass jeder
Parameter seine eigene Lebensdauer erhält. Wir nennen sie wie üblich <code>'a</code>, also
sieht die Signatur jetzt so aus:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Die zweite Regel trifft zu, weil es genau eine Eingangslebensdauer gibt. Die
zweite Regel legt fest, dass die Lebensdauer des einen Eingabeparameters der
Ausgangslebensdauer zugeordnet wird, sodass die Signatur nun wie folgt
aussieht:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Jetzt haben alle Referenzen in dieser Funktionssignatur eine Lebensdauer und
der Compiler kann seine Analyse fortsetzen, ohne dass der Programmierer die
Lebensdauer in dieser Funktionssignatur annotieren muss.</p>
<p>Schauen wir uns ein anderes Beispiel an, diesmal mit der Funktion <code>longest</code>,
die keine Lebensdauerparameter hatte, als wir in Codeblock 10-21 mit ihr zu
arbeiten begannen:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Wenden wir die erste Regel an: Jeder Parameter erhält seine eigene Lebensdauer.
Diesmal haben wir zwei Parameter anstelle von einem, also haben wir zwei
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Du siehst, dass die zweite Regel nicht gilt, weil es mehr als eine
Eingangslebensdauer gibt. Auch die dritte Regel trifft nicht zu, weil <code>longest</code>
eine Funktion ist, keine Methode, sodass keiner der Parameter <code>self</code> ist.
Nachdem wir alle drei Regeln durchgearbeitet haben, haben wir immer noch nicht
herausgefunden, wie lang die Lebensdauer des Rückgabetyps ist. Aus diesem Grund
haben wir beim Versuch, den Code in Codeblock 10-21 zu kompilieren, einen
Fehler erhalten: Der Compiler arbeitete die Lebensdauer-Elisionsregeln
durch, konnte aber immer noch nicht alle Lebensdauern der Referenzen in der
Signatur ermitteln.</p>
<p>Da die dritte Regel eigentlich nur für Methodensignaturen gilt, werden wir uns
als nächstes die Lebensdauern in diesem Zusammenhang ansehen, um zu sehen,
warum die dritte Regel bedeutet, dass wir die Lebensdauer in Methodensignaturen
nicht sehr oft annotieren müssen.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-methodendefinitionen" id="lebensdauer-annotationen-in-methodendefinitionen">Lebensdauer-Annotationen in Methodendefinitionen</a></h3>
<p>Wenn wir Methoden auf einer Struktur mit Lebensdauer implementieren, verwenden
wir die gleiche Syntax wie die in Codeblock 10-11 gezeigten generischen
Typparameter. Wo wir die Lebensdauerparameter deklarieren und verwenden, hängt
davon ab, ob sie sich auf die Strukturfelder oder auf die Methodenparameter und
Rückgabewerte beziehen.</p>
<p>Lebensdauer-Namen für Struktur-Felder müssen immer nach dem
<code>impl</code>-Schlüsselwort deklariert und dann hinter dem Namen der Struktur verwendet
werden, da diese Lebensdauern Teil des Typs der Struktur sind.</p>
<p>In Methodensignaturen innerhalb des <code>impl</code>-Blocks können Referenzen an die
Lebensdauern der Referenzen in den Feldern der Struktur gebunden sein oder sie
können unabhängig sein. Darüber hinaus sorgen die Lebensdauer-Elisionsregeln
oft dafür, dass Lebensdauer-Annotationen in Methodensignaturen nicht
erforderlich sind. Betrachten wir einige Beispiele mit der Struktur
<code>ImportantExcerpt</code> an, die wir in Codeblock 10-25 definiert haben.</p>
<p>Zuerst werden wir eine Methode namens <code>level</code> verwenden, deren einziger
Parameter eine Referenz auf <code>self</code> ist und deren Rückgabewert ein <code>i32</code> ist,
was keine Referenz ist:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Lebensdauer-Parameter-Deklaration nach <code>impl</code> und ihre Verwendung hinter dem
Typnamen sind erforderlich, aber wir sind nicht verpflichtet, die Lebensdauer der
Referenz auf <code>self</code> wegen der ersten Elisionsregel zu annotieren.</p>
<p>Hier ist ein Beispiel, bei dem die dritte Lebensdauer-Elisionsregel gilt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Es gibt zwei Eingangslebensdauern, sodass Rust die erste
Lebensdauer-Elisionsregel anwendet und sowohl <code>&amp;self</code> als auch <code>announcement</code>
ihre eigene Lebensdauer gibt. Da einer der Parameter <code>&amp;self</code> ist, erhält der
Rückgabetyp die Lebensdauer von <code>&amp;self</code>, und alle Lebensdauern sind
berücksichtigt worden.</p>
<h3><a class="header" href="#statische-lebensdauer" id="statische-lebensdauer">Statische Lebensdauer</a></h3>
<p>Eine besondere Lebensdauer, die wir besprechen müssen, ist <code>'static</code>, was
bedeutet, dass diese Referenz während der gesamten Dauer des Programms leben
kann. Alle Zeichenkettenliterale haben die Lebensdauer <code>'static</code>, die wir wie
folgt annotieren können:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;Ich habe eine statische Lebensdauer.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Der Text dieser Zeichenkette wird direkt in der Binärdatei des Programms
gespeichert, die immer verfügbar ist. Daher ist die Lebensdauer aller
Zeichenkettenliterale <code>'static</code>.</p>
<p>Möglicherweise siehst du Hinweise zur Verwendung der Lebensdauer <code>'static</code> in
Fehlermeldungen. Aber bevor du <code>'static</code> als Lebensdauer für eine Referenz
angibst, denke darüber nach, ob deine Referenz tatsächlich während der gesamten
Lebensdauer deines Programms lebt oder nicht. Du könntest überlegen, ob du
willst, dass sie so lange lebt, selbst wenn sie das könnte. Meistens ergibt
sich das Problem aus dem Versuch, eine hängende Referenz zu erstellen oder eine
Unvereinbarkeit zwischen den verfügbaren Lebensdauern zu beheben. In solchen
Fällen besteht die Lösung darin, diese Probleme zu beheben und nicht darin, die
Lebensdauer als <code>'static</code> festzulegen.</p>
<h2><a class="header" href="#generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen" id="generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen">Generische Typparameter, Merkmalsabgrenzungen und Lebensdauern zusammen</a></h2>
<p>Schauen wir uns kurz die Syntax zu Angabe generischer Typparameter,
Merkmalsabgrenzungen und Lebensdauern in einer Funktion an!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Heute hat jemand Geburtstag!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Bekanntmachung! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>Dies ist die Funktion <code>longest</code> aus Codeblock 10-22, die die längere von zwei
Zeichenkettenanteilstypen zurückgibt. Aber jetzt hat sie einen zusätzlichen
Parameter namens <code>ann</code> vom generischen Typ <code>T</code>, der jeder beliebige Typ sein
kann, der das Merkmal <code>Display</code> implementiert, wie in der <code>where</code>-Klausel
spezifiziert ist. Dieser zusätzliche Parameter wird ausgegeben, bevor die
Funktion die Längen der Zeichenkettenanteilstypen vergleicht, weshalb die
Merkmalsabgrenzung <code>Display</code> notwendig ist. Da die Lebensdauer ein generischer
Typ ist, stehen die Deklarationen des Lebensdauer-Parameters <code>'a</code> und des
generischen Typ-Parameters <code>T</code> in der gleichen Liste innerhalb spitzer Klammern
hinter dem Funktionsnamen.</p>
<h2><a class="header" href="#zusammenfassung-9" id="zusammenfassung-9">Zusammenfassung</a></h2>
<p>Wir haben in diesem Kapitel viel behandelt! Jetzt, da du über generische
Typparameter, Merkmale und Merkmalsabgrenzungen sowie generische
Lebensdauerparameter Bescheid weißt, bist du bereit, Code ohne Wiederholungen
zu schreiben, der in vielen verschiedenen Situationen funktioniert. Merkmale
und Merkmalsabgrenzungen stellen sicher, dass die Typen, auch wenn sie
generisch sind, das Verhalten haben, das der Code benötigt. Du hast gelernt,
wie man Lebensdauer-Annotationen verwendet, um sicherzustellen, dass dieser
flexible Code keine hängenden Referenzen hat. Und all diese Analysen finden zur
Kompilierzeit statt, was die Laufzeitperformanz nicht beeinträchtigt!</p>
<p>Ob du es glaubst oder nicht, es gibt zu den Themen, die wir in diesem Kapitel
besprochen haben, noch viel mehr zu sagen: In Kapitel 17 werden Merkmalsobjekte
erörtert, die eine weitere Möglichkeit zur Verwendung von Merkmalen darstellen.
Es gibt auch komplexere Szenarien mit Lebensdauer-Annotationen, die du nur in
sehr fortgeschrittenen Szenarien benötigst; für diese solltest du die
<a href="https://doc.rust-lang.org/reference/index.html">Rust-Referenz</a> lesen. Aber als Nächstes wirst du lernen, wie man
Tests in Rust schreibt, damit du sicherstellen kannst, dass dein Code so
funktioniert, wie er sollte.</p>
<h1><a class="header" href="#automatisierte-tests-schreiben" id="automatisierte-tests-schreiben">Automatisierte Tests schreiben</a></h1>
<p>In seinem Essay „Der bescheidene Programmierer“ von 1972 sagte Edsger W.
Dijkstra, dass „Programmtests eine sehr effektive Methode sein können, das
Vorhandensein von Fehlern zu zeigen, aber sie sind hoffnungslos unzureichend,
um deren Abwesenheit zu zeigen“. Das bedeutet nicht, dass wir nicht versuchen
sollten, so viel wie möglich zu testen!</p>
<p>Korrektheit unserer Programme ist das Maß, inwieweit unser Code das tut, was
wir beabsichtigen. Bei der Entwicklung von Rust wird der Korrektheit von
Programmen große Bedeutung beigemessen, aber Korrektheit ist komplex und nicht
leicht zu beweisen. Das Typsystem von Rust trägt einen großen Teil dieser Last,
aber das Typsystem kann nicht jede Art von Unrichtigkeit erkennen. Rust
beinhaltet Unterstützung für das Schreiben automatisierter Softwaretests
innerhalb der Sprache.</p>
<p>Nehmen wir beispielsweise an, wir schreiben eine Funktion namens <code>add_two</code>, die
2 zu jeder Zahl addiert, die ihr übergeben wird. Die Signatur dieser Funktion
akzeptiert eine ganze Zahl als Parameter und gibt als Ergebnis eine ganze Zahl
zurück. Wenn wir diese Funktion implementieren und kompilieren, führt Rust die
gesamte Typ- und Ausleihenprüfung durch, die du bisher kennengelernt hast, um
sicherzustellen, dass wir z.B. keinen <code>String</code>-Wert oder eine ungültige
Referenz an diese Funktion übergeben. Aber Rust kann <em>nicht</em> überprüfen, ob
diese Funktion genau das tut, was wir beabsichtigen, nämlich den Parameter plus
2 zurückzugeben und nicht etwa den Parameter plus 10 oder den Parameter minus
50! Hier kommen Tests ins Spiel.</p>
<p>Wir können Tests schreiben, die zum Beispiel sicherstellen, dass der
Rückgabewert <code>5</code> ist, wenn wir <code>3</code> an die Funktion <code>add_two</code> übergeben. Wir
können diese Tests immer dann durchführen, wenn wir Änderungen an unserem Code
vornehmen, um sicherzustellen, dass sich ein bestehendes korrektes Verhalten
nicht geändert hat.</p>
<p>Testen ist eine komplexe Fähigkeit: Obwohl wir nicht jedes Detail darüber, wie
man gute Tests schreibt, in einem Kapitel behandeln können, werden wir die
Mechanismen der Rust-Testmöglichkeiten besprechen. Wir werden über Annotationen
und Makros sprechen, die dir beim Schreiben deiner Tests zur Verfügung stehen,
über das Standardverhalten und die Optionen, die es bei der Ausführung deiner
Tests gibt, und darüber, wie du Tests in Modultests (unit tests) und
Integrationstests organisieren kannst.</p>
<h2><a class="header" href="#tests-schreiben" id="tests-schreiben">Tests schreiben</a></h2>
<p>Tests sind Funktionen in Rust, die überprüfen, ob der zu testende Code in der
erwarteten Weise funktioniert. Der Rumpf von Testfunktionen führt in der Regel
diese drei Aktionen aus:</p>
<ol>
<li>Bereite die benötigten Daten und Zustände vor.</li>
<li>Führe den Code aus, den du testen möchtest.</li>
<li>Stelle sicher, dass die Ergebnisse das sind, was du erwartest.</li>
</ol>
<p>Schauen wir uns die Funktionalität an, die Rust speziell für das Schreiben von
Tests bereitstellt, die diese Aktionen ausführen. Dazu gehören das Attribut
<code>test</code>, einige Makros und das Attribut <code>hould_panic</code>.</p>
<h3><a class="header" href="#anatomie-einer-testfunktion" id="anatomie-einer-testfunktion">Anatomie einer Testfunktion</a></h3>
<p>Im einfachsten Fall ist ein Test in Rust eine Funktion, die mit dem Attribut
<code>test</code> annotiert wird. Attribute sind Metadaten über Teile des Rust-Codes; ein
Beispiel ist das Attribut <code>derive</code>, das wir in Kapitel 5 bei Strukturen
verwendet haben. Um eine Funktion in eine Testfunktion zu verwandeln, füge
<code>#[test]</code> oberhalb der Zeile mit <code>fn</code> ein. Wenn du deine Tests mit dem Befehl
<code>cargo test</code> ausführst, erstellt Rust eine Testausführungs-Binärdatei (test
runner binary), die die mit dem Attribut <code>test</code> annotierten Funktionen ausführt
und darüber berichtet, ob jede Testfunktion erfolgreich war oder nicht.</p>
<p>Wenn wir ein neues Bibliotheksprojekt mit Cargo durchführen, wird für uns
automatisch ein Testmodul mit einer Testfunktion darin generiert. Dieses Modul
hilft dir, mit dem Schreiben deiner Tests zu beginnen, sodass du nicht jedes
Mal, wenn du ein neues Projekt startest, die genaue Struktur und Syntax der
Testfunktionen nachschlagen musst. Du kannst so viele zusätzliche
Testfunktionen und Testmodule hinzufügen, wie du möchtest!</p>
<p>Wir werden einige Aspekte der Funktionsweise von Tests untersuchen, indem wir
mit der für uns generierten Testvorlage experimentieren, ohne tatsächlich Code
zu testen. Dann schreiben wir einige Tests aus der realen Welt, die einen von
uns geschriebenen Code aufrufen und sicherstellen, dass sein Verhalten korrekt
ist.</p>
<p>Lass uns ein neues Bibliotheksprojekt namens <code>adder</code> erstellen:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Der Inhalt der Datei <em>src/lib.rs</em> in deiner Bibliothek <code>adder</code> sollte wie
Codeblock 11-1 aussehen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-1: Das Testmodul und die Funktion, die
automatisch von <code>cargo new</code> generiert werden</span></p>
<p>Ignorieren wir vorerst die beiden oberen Zeilen und konzentrieren uns auf die
Funktion, um zu sehen, wie sie funktioniert. Beachte die Annotation <code>#[test]</code>
oberhalb der Zeile mit <code>fn</code>: Dieses Attribut zeigt an, dass es sich um eine
Testfunktion handelt, sodass die Testausführung weiß, dass es diese Funktion
als einen Test behandeln soll. Wir könnten auch Nicht-Test-Funktionen im Modul
<code>tests</code> haben, um gängige Szenarien aufzusetzen oder gängige Operationen
durchzuführen, daher müssen wir mit dem Attribut <code>#[test]</code> angeben, welche
Funktionen Tests sind.</p>
<p>Der Funktionsrumpf verwendet das Makro <code>assert_eq!</code>, um sicherzustellen, dass 2
+ 2 gleich 4 ist. Diese Prüfung dient als Beispiel für den Aufbau eines
typischen Tests. Lassen wir ihn laufen, um zu sehen, dass dieser Test
erfolgreich ist.</p>
<p>Das Kommando <code>cargo test</code> führt alle Tests in unserem Projekt aus, wie in
Codeblock 11-2 zu sehen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Codeblock 11-2: Ergebnis der Ausführung des automatisch
generierten Tests</span></p>
<p>Cargo hat den Test kompiliert und ausgeführt. Nach den Zeilen <code>Compiling</code>,
<code>Finished</code> und <code>Running</code> folgt die Zeile <code>running 1 test</code>. Die nächste Zeile
zeigt den Namen der generierten Testfunktion <code>it_works</code> und das Ergebnis der
Testausführung: <code>ok</code>. Als nächstes wird die Gesamtzusammenfassung der
Testausführung angegeben. Der Text <code>test result: ok.</code> bedeutet, dass alle Tests
bestanden wurden, und der Teil <code>1 passed; 0 failed</code> gibt die Anzahl der Tests
an, die bestanden oder nicht bestanden wurden.</p>
<p>Da wir keine Tests haben, die wir als ignoriert markiert haben, zeigt die
Zusammenfassung <code>0 ignored</code>. Wir haben zudem die auszuführenden Tests nicht
gefiltert, sodass am Ende der Zusammenfassung <code>0 filtered out</code> steht. Wir
werden das Ignorieren und Herausfiltern von Tests im nächsten Abschnitt,
<a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt werden“</a>,
besprechen.</p>
<p>Die Statistik <code>0 measured</code> ist für Benchmark-Tests, die die Performanz messen.
Benchmark-Tests sind zum Zeitpunkt, als dieser Text verfasst wurde, nur im
nächtlichen (nightly) Rust verfügbar. Siehe <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">„Dokumentation über
Benchmark-Tests“</a>, um mehr zu erfahren.</p>
<p>Der nächste Teil der Testausgabe, der mit <code>Doc-tests adder</code> beginnt, ist für
die Ergebnisse von Dokumentationstests. Wir haben noch keine
Dokumentationstests, aber Rust kann alle Code-Beispiele kompilieren, die in
unserer API-Dokumentation erscheinen. Diese Funktionalität hilft uns dabei,
unsere Dokumentation und unseren Code synchron zu halten! Wie man
Dokumentationstests schreibt, werden wir im Abschnitt
<a href="ch14-02-publishing-to-crates-io.html#dokumentationskommentare-als-tests">„Dokumentationskommentare als Tests“</a> in Kapitel 14 besprechen.
Vorerst ignorieren wir die Ausgabe von <code>Doc-tests</code>.</p>
<p>Lass uns den Namen unseres Tests ändern, um zu sehen, wie sich dadurch die
Testausgabe ändert. Ändere die Funktion <code>it_works</code> auf einen anderen Namen,
z.B. <code>exploration</code>, etwa so:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Dann führe <code>cargo test</code> erneut aus. Die Ausgabe zeigt nun <code>exploration</code>
anstelle von <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Fügen wir einen weiteren Test hinzu, aber dieses Mal machen wir einen Test, der
fehlschlägt! Tests schlagen fehl, wenn etwas die Testfunktion zum Abbrechen
bringt. Jeder Test wird in einem neuen Strang (thread) ausgeführt und wenn der
Hauptstrang (main thread) sieht, dass ein Teststrang (test thread) gestorben
ist, wird der Test als fehlgeschlagen markiert. Über den einfachsten Weg, ein
Programm abzubrechen, sprachen wir in Kapitel 9, und zwar durch den Aufruf des
Makros <code>panic!</code>. Erstelle einen neuen Test <code>another</code>, sodass deine Datei
<em>src/lib.rs</em> wie in Codeblock 11-3 aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Lasse diesen Test fehlschlagen&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-3: Hinzufügen eines zweiten Tests, der
fehlschlägt, weil wir das Makro <code>panic!</code> aufrufen</span></p>
<p>Führe die Tests erneut mit <code>cargo test</code> aus. Die Ausgabe sollte wie in
Codeblock 11-4 aussehen, was zeigt, dass unser Test <code>exploration</code> bestanden und
<code>another</code> fehlgeschlagen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Lasse diesen Test fehlschlagen', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Codeblock 11-4: Testergebnisse, wenn ein Test bestanden
und ein Test nicht bestanden wird</span></p>
<p>Statt <code>ok</code> zeigt die Zeile <code>test tests::another</code> das Ergebnis <code>FAILED</code>.
Zwischen den Einzelergebnissen und der Zusammenfassung erscheinen zwei neue
Abschnitte: Der erste Abschnitt zeigt die detaillierte Ursache für jeden
fehlgeschlagenen Test an. In diesem Fall scheiterte <code>another</code> mit der Meldung
<code>panicked at 'Lasse diesen Test fehlschlagen'</code> in Zeile 10 der Datei
<em>src/lib.rs</em>. Der nächste Abschnitt listet nur die Namen aller fehlgeschlagenen
Tests auf, was nützlich ist, wenn es viele Tests und viele detaillierte
Ausgaben von fehlgeschlagenen Tests gibt. Wir können den Namen eines
fehlgeschlagenen Tests verwenden, um genau diesen Test auszuführen, um ihn
leichter zu debuggen; wir werden im Abschnitt <a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt
werden“</a> mehr über Möglichkeiten zur Ausführung
von Tests sprechen.</p>
<p>Die Zusammenfassungszeile zeigt am Ende an: Insgesamt ist unser Testergebnis
<code>FAILED</code>. Wir hatten einen Test bestanden und einen Test nicht bestanden.</p>
<p>Da du nun gesehen hast, wie die Testergebnisse in verschiedenen Szenarien
aussehen, wollen wir uns einige Makros neben <code>panic!</code> ansehen, die bei Tests
nützlich sind.</p>
<h3><a class="header" href="#ergebnisse-überprüfen-mit-dem-makro-assert" id="ergebnisse-überprüfen-mit-dem-makro-assert">Ergebnisse überprüfen mit dem Makro <code>assert!</code></a></h3>
<p>Das Makro <code>assert!</code>, das von der Standardbibliothek bereitgestellt wird, ist
nützlich, wenn du sicherstellen willst, dass eine Bedingung in einem Test als
wahr (true) bewertet wird. Wir geben dem Makro <code>assert!</code> ein Argument, das
boolesch ausgewertet wird. Wenn der Wert <code>true</code> ist, tut <code>assert!</code> nichts und
der Test ist bestanden. Wenn der Wert <code>false</code> ist, ruft das Makro <code>assert!</code> das
Makro <code>panic!</code> auf, wodurch der Test fehlschlägt. Das Verwenden des Makros
<code>assert!</code> hilft uns zu überprüfen, ob unser Code so funktioniert, wie wir es
beabsichtigen.</p>
<p>In Codeblock 5-15 in Kapitel 5 haben wir eine Struktur <code>Rectangle</code> und eine
Methode <code>can_hold</code> verwendet, die hier in Codeblock 11-5 wiederholt werden.
Lass uns diesen Code in die Datei <em>src/lib.rs</em> packen und einige Tests dafür
mit dem Makro <code>assert!</code> schreiben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-5: Verwenden der Struktur <code>Rectangle</code> und
ihrer Methode <code>can_hold</code> aus Kapitel 5</span></p>
<p>Die Methode <code>can_hold</code> gibt ein Boolean zurück, was bedeutet, dass es ein
perfekter Anwendungsfall für das Makro <code>assert!</code> ist. In Codeblock 11-6
schreiben wir einen Test, der die Methode <code>can_hold</code> überprüft, indem wir eine
<code>Rectangle</code>-Instanz mit einer Breite von 8 und einer Höhe von 7 erstellen und
sicherstellen, dass es eine weitere <code>Rectangle</code>-Instanz mit einer Breite von 5
und einer Höhe von 1 enthalten kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
<span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-6: Ein Test für <code>can_hold</code>, der prüft, ob in
ein größeres Rechteck tatsächlich ein kleineres Rechteck passt</span></p>
<p>Beachte, dass wir eine neue Zeile innerhalb des Moduls <code>tests</code> hinzugefügt
haben: <code>use super::*;</code>. Das Modul <code>tests</code> ist ein reguläres Modul, das den
üblichen Sichtbarkeitsregeln folgt, die wir in Kapitel 7 im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit
Pfaden auf ein Element im Modulbaum
verweisen“</a> behandelt haben.
Da das Modul <code>tests</code> ein inneres Modul ist, müssen wir den Code, der im äußeren
Modul getestet wird, in den Gültigkeitsbereich des inneren Moduls bringen. Wir
verwenden hier einen Stern (glob), sodass alles, was wir im äußeren Modul
definieren, auch in diesem Modul <code>tests</code> zur Verfügung steht.</p>
<p>Wir haben unseren Test <code>larger_can_hold_smaller</code> genannt und wir haben die
beiden <code>Rectangle</code>-Instanzen erzeugt, die wir benötigen. Dann haben wir das
Makro <code>assert!</code> aufgerufen und ihm das Aufrufergebnis von
<code>larger.can_hold(&amp;smaller)</code> übergeben. Dieser Ausdruck soll <code>true</code> zurückgeben,
also sollte unser Test erfolgreich sein. Lass es uns herausfinden!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Es funktioniert! Fügen wir noch einen weiteren Test hinzu, diesmal mit der
Zusicherung, dass ein kleineres Rechteck nicht in ein größeres Rechteck passt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --abschneiden--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Da das korrekte Ergebnis der Funktion <code>can_hold</code> in diesem Fall <code>false</code> ist,
müssen wir dieses Ergebnis negieren, bevor wir es an das Makro <code>assert!</code>
übergeben. Als Ergebnis wird unser Test bestehen, wenn <code>can_hold</code> den
Rückgabewert <code>false</code> hat:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Zwei Tests, die erfolgreich sind! Nun wollen wir sehen, was mit unseren
Testergebnissen passiert, wenn wir einen Fehler in unseren Code einbringen.
Lass uns die Implementierung der Methode <code>can_hold</code> ändern, indem wir das
größer-als-Zeichen durch ein kleiner-als-Zeichen ersetzen, wenn sie die Breiten
vergleicht:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Das Ausführen der Tests ergibt nun Folgendes:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unsere Tests haben den Fehler entdeckt! Da <code>larger.width</code> gleich 8 ist und
<code>smaller.width</code> gleich 5, ergibt der Vergleich der Breiten in <code>can_hold</code> jetzt
<code>false</code>: 8 ist nicht weniger als 5.</p>
<h3><a class="header" href="#prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne" id="prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne">Prüfung auf Gleichheit mit den Makros <code>assert_eq!</code> und <code>assert_ne!</code></a></h3>
<p>Eine übliche Methode zum Testen der Funktionalität besteht darin, das Ergebnis
des zu testenden Codes mit dem Wert zu vergleichen, den du vom Code erwartest,
um sicherzustellen, dass sie gleich sind. Du könntest dies mit dem Makro
<code>assert!</code> tun und ihm einen Ausdruck mit dem Operator <code>==</code> übergeben. Dies ist
jedoch ein so häufiger Testfall, dass die Standardbibliothek zwei Makros zur
Verfügung stellt, um diesen Test bequemer durchzuführen: <code>assert_eq!</code> und
<code>assert_ne!</code>. Diese Makros vergleichen zwei Argumente auf Gleichheit bzw.
Ungleichheit. Sie geben auch die beiden Werte aus, wenn die Zusicherung
fehlschlägt, was es einfacher macht zu erkennen, <em>warum</em> der Test
fehlgeschlagen ist; umgekehrt zeigt das Makro <code>assert!</code> nur an, dass der
Ausdruck <code>==</code> den Wert <code>false</code> ergeben hat, nicht die Werte, die zum falschen
Testergebnis führen.</p>
<p>In Codeblock 11-7 schreiben wir eine Funktion namens <code>add_two</code>, die zu ihrem
Parameter <code>2</code> addiert und das Ergebnis zurückgibt. Dann testen wir diese
Funktion mit dem Makro <code>assert_eq!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-7: Testen der Funktion <code>add_two</code> mit dem
Makro <code>assert_eq!</code></span></p>
<p>Lass uns prüfen, ob sie den Test besteht!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Das erste Argument <code>4</code>, das wir dem Makro <code>assert_eq!</code> übergeben haben, ist
identisch mit dem Ergebnis des Aufrufs <code>add_two(2)</code>. Die Zeile für diesen Test
lautet <code>test tests::it_adds_two ... ok</code>, und der Text <code>ok</code> zeigt an, dass unser
Test bestanden wurde!</p>
<p>Lass uns einen Fehler in unseren Code einbringen, um zu sehen, wie es aussieht,
wenn ein Test, der <code>assert_eq!</code> verwendet, fehlschlägt. Ändern wir die
Implementierung der Funktion <code>add_two</code>, sodass sie stattdessen <code>3</code> addiert:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Führe die Tests erneut aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unser Test hat den Fehler entdeckt! Der Test <code>it_adds_two</code> schlug fehl mit der
Meldung <code>assertion failed: `(left == right)` </code> und dass <code>left</code> den Wert <code>4</code>
und <code>right</code> den Wert <code>5</code> hatte. Diese Nachricht ist nützlich und hilft uns, mit
der Fehlersuche zu beginnen: Sie bedeutet, dass das Argument <code>left</code> von
<code>assert_eq!</code> den Wert <code>4</code> hatte, aber das Argument <code>right</code>, wo wir
<code>add_two(2)</code> hatten, war <code>5</code>.</p>
<p>Beachte, dass in einigen Sprachen und Test-Bibliotheken die Parameter der
Funktionen, die zwei Werte auf Gleichheit prüfen, <code>expected</code> und <code>actual</code>
genannt werden und deren Reihenfolge wichtig ist. In Rust werden sie jedoch
<code>left</code> und <code>right</code> genannt und die Reihenfolge, in der wir den erwarteten Wert
und den vom zu testenden Code produzierten Wert angeben, spielt keine Rolle.
Wir könnten die Zusicherung in diesem Test als <code>assert_eq!(add_two(2), 4)</code>
schreiben, was zur Fehlermeldung <code>assertion failed: `(left == right)` </code>
führen würde und dass <code>left</code> den Wert <code>5</code> und <code>right</code> den Wert <code>4</code> hatte.</p>
<p>Das Makro <code>assert_ne!</code> prüft, ob die beiden Werte, die wir ihm übergeben,
ungleich sind und scheitert, wenn sie gleich sind. Dieses Makro ist am
nützlichsten in Fällen, in denen wir nicht sicher sind, <em>welchen</em> Wert wir
bekommen werden, aber wir wissen, welcher Wert es definitiv <em>nicht</em> sein wird,
wenn unser Code so funktioniert, wie wir es beabsichtigen. Wenn wir zum
Beispiel eine Funktion testen, die ihre Eingabe garantiert in irgendeiner Weise
verändert, aber die Art und Weise, wie die Eingabe verändert wird, vom
Wochentag abhängt, an dem wir unsere Tests ausführen, ist es vielleicht am
besten sicherzustellen, dass die Ausgabe der Funktion nicht gleich der Eingabe
ist.</p>
<p>Unter der Haube verwenden die Makros <code>assert_eq!</code> und <code>assert_ne!</code> die
Operatoren <code>==</code> bzw. <code>!=</code>. Wenn die Zusicherungen fehlschlagen, geben diese
Makros ihre Argumente unter Verwendung der Debug-Formatierung aus, was
bedeutet, dass die zu vergleichenden Werte die Merkmale <code>PartialEq</code> und
<code>Debug</code> implementieren müssen. Alle primitiven Typen und die meisten
Standardbibliothekstypen implementieren diese Merkmale. Für Strukturen und
Aufzählungen, die du definierst, musst du <code>PartialEq</code> implementieren, um
prüfen zu können, dass Werte dieser Typen gleich oder ungleich sind. Du musst
<code>Debug</code> implementieren, um die Werte zu auszugeben, wenn die Zusicherung
fehlschlägt. Da es sich bei beiden Merkmalen um ableitbare Merkmale handelt,
wie in Codeblock 5-12 in Kapitel 5 erwähnt, genügt normalerweise das Ergänzen
der Annotation <code>#[derive(PartialEq, Debug)]</code> bei deiner Struktur- und
Aufzählungsdefinition. Siehe Anhang C <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale
(traits)“</a> für weitere Einzelheiten über diese und andere
ableitbare Merkmale.</p>
<h3><a class="header" href="#benutzerdefinierte-fehlermeldungen-angeben" id="benutzerdefinierte-fehlermeldungen-angeben">Benutzerdefinierte Fehlermeldungen angeben</a></h3>
<p>Du kannst den Makros <code>assert!</code>, <code>assert_eq!</code> und <code>assert_ne!</code> optional auch
eine benutzerdefinierte Nachricht mitgeben, die mit der Fehlermeldungen
ausgegeben wird. Alle Argumente, die nach dem einen erforderlichen Argument für
<code>assert!</code> oder den beiden erforderlichen Argumenten für <code>assert_eq!</code> und
<code>assert_ne!</code> angegeben werden, werden an das Makro <code>format!</code> übergeben (siehe
Kapitel 8, Abschnitt <a href="ch08-02-strings.html#aneinanderh%C3%A4ngen-mit-dem-operator--und-dem-makro-format">„Aneinanderhängen mit dem Operator <code>+</code> und dem Makro
<code>format!</code>“</a>), sodass du
eine Formatierungs-Zeichenkette übergeben kannst, die Platzhalter <code>{}</code> und
Werte enthält, die in diese Platzhalter gehören. Benutzerdefinierte Nachrichten
sind nützlich, um zu dokumentieren, was eine Zusicherung bedeutet; wenn ein
Test fehlschlägt, hast du eine bessere Vorstellung davon, wo das Problem im
Code liegt.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Funktion, die Leute mit Namen
begrüßt, und wir wollen testen, ob der Name, den wir an die Funktion übergeben,
in der Ausgabe auftaucht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hallo {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Die Anforderungen für dieses Programm sind noch nicht abgestimmt worden und wir
sind ziemlich sicher, dass sich der Text <code>Hallo</code> zu Beginn der Begrüßung ändern
wird. Wir haben beschlossen, dass wir den Test nicht aktualisieren wollen, wenn
sich die Anforderungen ändern. Anstatt also zu prüfen, ob der Test exakt dem
von der Funktion <code>greeting</code> zurückgegebenen Wert entspricht, stellen wir
einfach sicher, dass die Ausgabe den Text des Eingabeparameters enthält.</p>
<p>Lass uns einen Fehler in diesen Code einbringen, indem wir <code>greeting</code> so
ändern, dass <code>name</code> nicht enthalten ist, um zu sehen, wie dieses Testversagen
aussieht:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hallo!&quot;)
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Das Ausführen dieses Tests führt zu folgender Ausgabe:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Dieses Ergebnis zeigt nur an, dass die Zusicherung fehlgeschlagen ist und in
welcher Zeile die Zusicherung steht. Eine nützlichere Fehlermeldung würde in
diesem Fall den Wert ausgeben, den wir von der Funktion <code>greeting</code> erhalten
haben. Lass uns die Testfunktion ändern, indem wir ihr eine benutzerdefinierte
Fehlermeldung angeben, die aus einer Formatierungszeichenkette mit einem
Platzhalter besteht, der mit dem tatsächlichen Wert gefüllt ist, den wir von
der Funktion <code>greeting</code> erhalten haben:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hallo!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Begrüßung enthielt nicht den Namen, Wert war `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wenn wir jetzt den Test ausführen, erhalten wir eine aussagekräftigere
Fehlermeldung:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Begrüßung enthielt nicht den Namen, Wert war `Hallo!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir können den Wert, den wir tatsächlich erhalten haben, in der Testausgabe
sehen, was uns helfen wird, das zu debuggen, was passiert ist, anstatt das,
was wir erwartet hatten.</p>
<h3><a class="header" href="#mit-should_panic-auf-programmabbrüche-prüfen" id="mit-should_panic-auf-programmabbrüche-prüfen">Mit <code>should_panic</code> auf Programmabbrüche prüfen</a></h3>
<p>Neben der Prüfung, ob unser Code die von uns erwarteten korrekten Werte
zurückgibt, ist es auch wichtig zu prüfen, ob unser Code Fehlerbedingungen so
behandelt, wie wir es erwarten. Denke zum Beispiel an den Typ <code>Guess</code>, den wir
in Kapitel 9 in Codeblock 9-10 erstellt haben. Anderer Code, der <code>Guess</code>
verwendet, hängt von der Garantie ab, dass <code>Guess</code>-Instanzen nur Werte zwischen
1 und 100 enthalten. Wir können einen Test schreiben, der sicherstellt, dass
der Versuch, eine <code>Guess</code>-Instanz mit einem Wert außerhalb dieses Bereichs zu
erzeugen, zum Programmabbrucht führt.</p>
<p>Wir tun dies, indem wir ein weiteres Attribut <code>should_panic</code> zu unserer
Testfunktion hinzufügen. Dieses Attribut bewirkt, dass ein Test als bestanden
gilt, wenn der Code innerhalb der Funktion abbricht; der Test schlägt fehl,
wenn der Code innerhalb der Funktion nicht abbricht.</p>
<p>Codeblock 11-8 zeigt einen Test, der prüft, ob die Fehlerbedingungen von
<code>Guess::new</code> eintreten, wenn wir dies erwarten.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-8: Testet, dass eine Bedingung zum
Programmabbruch führt</span></p>
<p>Wir setzen das Attribut <code>#[should_panic]</code> hinter das Attribut <code>#[test]</code> und vor
die Testfunktion, auf die sie sich bezieht. Schauen wir uns das Ergebnis an,
wenn dieser Test bestanden ist:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Sieht gut aus! Lass uns nun einen Fehler in unseren Code einbringen, indem wir
die Bedingung entfernen, bei der die Funktion <code>new</code> das Programm abbricht, wenn
der Wert größer als 100 ist:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wenn wir den Test in Codeblock 11-8 ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir erhalten in diesem Fall keine sehr hilfreiche Meldung, aber wenn wir uns
die Testfunktion ansehen, sehen wir, dass sie mit <code>#[should_panic]</code> annotiert
ist. Der Fehler, den wir erhielten, bedeutet, dass der Code in der Testfunktion
keinen Programmabbruch verursacht hat.</p>
<p>Tests, die <code>should_panic</code> verwenden, können ungenau sein, weil sie nur
anzeigen, dass der Code einen Programmabbruch verursacht hat. Ein Test mit
<code>should_panic</code> würde auch dann bestanden werden, wenn der Test aus einem
anderen Grund zum Programmabbrucht führt als dem, den wir erwartet haben. Um
Tests mit <code>should_panic</code> präziser zu machen, können wir beim
<code>should_panic</code>-Attribut einen optionalen Parameter <code>expected</code> ergänzen. Das
Testsystem stellt sicher, dass die Fehlermeldung den angegebenen Text enthält.
Betrachte zum Beispiel den modifizierten Code für <code>Guess</code> in Codeblock 11-9, wo
die Funktion <code>new</code> mit unterschiedlichen Meldungen das Programm abbricht, je
nachdem, ob der Wert zu klein oder zu groß ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;, value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Schätzwert muss kleiner oder gleich 100 sein&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-9: Testet, ob ein Zustand einen
Programmabbruch mit einer bestimmten Abbruchsmeldung auslöst</span></p>
<p>Dieser Test wird bestanden werden, weil der Wert, den wir beim Parameter
<code>expected</code> des <code>should_panic</code>-Attributs angeben, eine Teilzeichenkette der
Nachricht ist, mit der die Funktion <code>Guess::new</code> das Programm abbricht. Wir
hätten die gesamte erwartete Abbruchsnachricht angeben können, in diesem Fall
also <code>Schätzwert muss kleiner oder gleich 100 sein, ist 200</code>. Was du im
Parameter <code>expected</code> für <code>should_panic</code> angibst, hängt davon ab, wie viel von
der Abbruchsnachricht eindeutig oder dynamisch ist und wie präzise dein Test
sein soll. In diesem Fall reicht eine Teilzeichenkette der Abbruchsnachricht
aus, um sicherzustellen, dass der Code in der Testfunktion den Fall <code>else if value &gt; 100</code> ausführt.</p>
<p>Um zu sehen, was passiert, wenn ein Test mit <code>should_panic</code> und einer
<code>expected</code>-Nachricht fehlschlägt, wollen wir wieder einen Fehler in unseren
Code einbringen, indem wir die Zweige <code>if value &lt; 1</code>  und <code>else if value &gt; 100</code>
vertauschen:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;,
                   value);
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wenn wir diesmal den <code>should_panic</code>-Test ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Schätzwert muss größer oder gleich 1 sein, ist 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;Schätzwert muss größer oder gleich 1 sein, ist 200.&quot;`,
 expected substring: `&quot;Schätzwert muss kleiner oder gleich 100 sein&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Die Fehlermeldung zeigt an, dass dieser Test tatsächlich wie erwartet das
Programm abgebrochen hat, aber die Abbruchsmeldung enthielt nicht die erwartete
Zeichenfolge <code>'Schätzwert muss kleiner oder gleich 100 sein'</code>. Die
Abbruchsmeldung, die wir in diesem Fall erhielten, lautete: <code>Schätzwert muss größer oder gleich 1 sein, ist 200.</code> Jetzt können wir anfangen herauszufinden,
wo unser Fehler liegt!</p>
<h3><a class="header" href="#verwenden-von-resultt-e-in-tests" id="verwenden-von-resultt-e-in-tests">Verwenden von <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Bisher haben wir Tests geschrieben, die das Programm abbrechen, wenn sie
fehlschlagen. Wir können auch Tests schreiben, die <code>Result&lt;T, E&gt;</code> verwenden!
Hier ist der Test aus Codeblock 11-1 so umgeschrieben, dass er <code>Result&lt;T, E&gt;</code>
verwendet und <code>Err</code> zurückgibt, anstatt das Programm abzubrechen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;zwei plus zwei ist nicht gleich vier&quot;))
        }
    }
}
</code></pre></pre>
<p>Die Funktion <code>it_works</code> hat jetzt den Rückgabetyp <code>Result&lt;(), String&gt;</code>. Anstatt
das Makro <code>assert_eq!</code> aufzurufen, geben wir im Funktionsrumpf <code>Ok(())</code> zurück,
wenn der Test bestanden ist, und ein <code>Err</code> mit einem <code>String</code> im Inneren, wenn
der Test fehlschlägt.</p>
<p>Wenn du Tests so schreibst, dass sie ein <code>Result&lt;T, E&gt;</code> zurückgeben, kannst du
den Fragezeichen-Operator im Testrumpf verwenden, was eine bequeme Möglichkeit
sein kann, Tests zu schreiben, die fehlschlagen sollten, wenn irgendeine
Operation darin eine <code>Err</code>-Variante zurückgibt.</p>
<p>Du kannst die Annotation <code>#[should_panic]</code> nicht für Tests verwenden, die
<code>Result&lt;T, E&gt;</code> verwenden. Stattdessen solltest du direkt einen <code>Err</code>-Wert
zurückgeben, wenn der Test fehlschlagen soll.</p>
<p>Da du nun verschiedene Möglichkeiten kennst, Tests zu schreiben, lass uns einen
Blick darauf werfen, was passiert, wenn wir unsere Tests ausführen, und die
verschiedenen Optionen untersuchen, die wir mit <code>cargo test</code> verwenden können.</p>
<h2><a class="header" href="#steuern-wie-tests-ausgeführt-werden" id="steuern-wie-tests-ausgeführt-werden">Steuern wie Tests ausgeführt werden</a></h2>
<p>So wie <code>cargo run</code> deinen Code kompiliert und dann die resultierende Binärdatei
ausführt, kompiliert <code>cargo test</code> deinen Code im Testmodus und führt die
resultierende Testbinärdatei aus. Du kannst Befehlszeilenoptionen angeben, um
das Standardverhalten von <code>cargo test</code> zu ändern. Das Standardverhalten der von
<code>cargo test</code> erzeugten Binärdatei besteht beispielsweise darin, alle Tests
parallel auszuführen und die während der Testläufe generierte Ausgabe zu
erfassen, wodurch verhindert wird, dass die Ausgabe angezeigt wird, und das
Lesen der Ausgabe bezüglich der Testergebnisse erleichtert wird.</p>
<p>Einige Kommandozeilen-Optionen betreffen <code>cargo test</code> und einige betreffen die
resultierende Testbinärdatei. Um diese beiden Argumentarten
auseinanderzuhalten, gibst du zuerst die Argumente für <code>cargo test</code>, gefolgt
vom Trennzeichen <code>--</code>, und danach die der Testbinärdatei an. Wenn du <code>cargo test --help</code> ausführst, werden die Optionen angezeigt, die du für <code>cargo test</code>
verwenden kannst, und wenn du <code>cargo test -- --help</code> ausführst, werden die
Optionen angezeigt, die du nach dem Trennzeichen <code>--</code> verwenden kannst.</p>
<h3><a class="header" href="#tests-parallel-oder-nacheinander-ausführen" id="tests-parallel-oder-nacheinander-ausführen">Tests parallel oder nacheinander ausführen</a></h3>
<p>Wenn du mehrere Tests ausführst, werden diese standardmäßig parallel in
Strängen (threads) ausgeführt. Das bedeutet, dass die Tests schneller
abgeschlossen werden, sodass du schneller Rückmeldung darüber erhältst, ob dein
Code funktioniert oder nicht. Da die Tests gleichzeitig ausgeführt werden,
stelle sicher, dass deine Tests nicht voneinander oder von einem gemeinsam
genutzten Zustand abhängen, einschließlich einer gemeinsam genutzten Umgebung,
z.B. dem aktuellen Arbeitsverzeichnis oder Umgebungsvariablen.</p>
<p>Angenommen, jeder deiner Tests führt einen Code aus, der eine Datei auf der
Festplatte mit dem Namen <em>test-output.txt</em> erstellt und einige Daten in diese
Datei schreibt. Dann liest jeder Test Daten aus dieser Datei und stellt fest,
dass die Datei einen bestimmten Wert enthält, der bei jedem Test anders ist. Da
die Tests zur gleichen Zeit laufen, kann es vorkommen, dass ein Test die Datei
überschreibt, während ein anderer Test die Datei schreibt und liest. Der zweite
Test wird dann fehlschlagen, nicht weil der Code falsch ist, sondern weil sich
die Tests bei der parallelen Ausführung gegenseitig beeinflusst haben. Eine
Lösung besteht darin, dafür zu sorgen, dass jeder Test in eine eigene Datei
schreibt; eine andere Lösung besteht darin, die Tests einzeln nacheinander
auszuführen.</p>
<p>Wenn du die Tests nicht parallel ausführen möchtest oder wenn du eine
feingranularere Kontrolle über die Anzahl der verwendeten Stränge haben willst,
kannst du den Schalter <code>--test-threads</code> mit der Anzahl der Stränge, die du
verwenden möchtest, an die Testbinärdatei übergeben. Sieh dir das folgende
Beispiel an:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Wir setzen die Anzahl der Teststränge auf <code>1</code> und weisen das Programm an, keine
Parallelität zu verwenden. Die Ausführung der Tests mit einem Strang dauert
länger als die parallele Ausführung, aber die Tests stören sich nicht
gegenseitig, wenn sie den gleichen Zustand verwenden.</p>
<h3><a class="header" href="#anzeigen-der-funktionsausgabe" id="anzeigen-der-funktionsausgabe">Anzeigen der Funktionsausgabe</a></h3>
<p>Standardmäßig erfasst die Testbibliothek von Rust bei einem bestandenen Test
alles, was in die Standardausgabe ausgegeben wurde. Wenn wir beispielsweise
<code>println!</code> in einem Test aufrufen und der Test erfolgreich ist, sehen wir die
Ausgabe von <code>println!</code> im Terminal nicht; wir sehen nur die Zeile, die den
bestandenen Test anzeigt. Wenn ein Test fehlschlägt, sehen wir das, was in die
Standardausgabe ausgegeben wurde, mit dem Rest der Fehlermeldung.</p>
<p>Als Beispiel hat Codebock 11-10 eine dumme Funktion, die den Wert ihres
Parameters ausgibt und 10 zurückgibt, sowie einen Test, der bestanden wird, und
einen Test, der fehlschlägt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">fn main() {}
</span><span class="boring">
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;Ich habe den Wert {} erhalten.&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
</code></pre></pre>
<p><span class="caption">Codebock 11-10: Tests einer Funktion, die <code>println!</code>
aufruft</span></p>
<p>Wenn wir diese Tests mit <code>cargo test</code> ausführen, werden wir folgende Ausgabe
sehen:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Beachte, dass wir nirgendwo in dieser Ausgabe <code>Ich habe den Wert 4 erhalten.</code>
sehen, was beim erfolgreichen Testlauf ausgegeben wird. Diese Ausgabe wurde
aufgefangen. Die Ausgabe <code>Ich habe den Wert 8 erhalten.</code> des fehlgeschlagenen
Tests erscheint im Abschnitt der Testzusammenfassung, der auch die Ursache des
Testfehlers anzeigt.</p>
<p>Wenn wir auch die ausgegebenen Werte der bestandenen Tests sehen wollen, können
wir Rust mit <code>--show-output</code> anweisen, die Ausgabe erfolgreicher Tests
ebenfalls mit anzuzeigen.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Wenn wir die Tests in Codeblock 11-10 mit dem Schalter <code>--show-output</code> erneut
ausführen, sehen wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
Ich habe den Wert 4 erhalten.

successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<h3><a class="header" href="#ausführen-einer-test-teilmenge-mittels-name" id="ausführen-einer-test-teilmenge-mittels-name">Ausführen einer Test-Teilmenge mittels Name</a></h3>
<p>Manchmal kann die Ausführung einer vollständigen Testsammlung sehr lange
dauern. Wenn du an Code in einem bestimmten Bereich arbeitest, solltest du
vielleicht nur die Tests ausführen, die diesen Code betreffen. Du kannst
wählen, welche Tests ausgeführt werden sollen, indem du <code>cargo test</code> den oder
die Namen der Tests, die du ausführen willst, als Argument übergibst.</p>
<p>Um zu demonstrieren, wie man eine Teilmenge von Tests ausführt, werden wir drei
Tests für unsere Funktion <code>add_two</code> erstellen, wie in Codeblock 11-11 zu sehen
ist, und auswählen, welche wir ausführen wollen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-11: Drei Tests mit drei verschiedenen
Namen</span></p>
<p>Wenn wir die Tests ohne Argumente durchführen, wie vorhin gesehen, werden alle
Tests parallel laufen:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/adder-92948b65e88960b4

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4><a class="header" href="#ausführen-einzelner-tests" id="ausführen-einzelner-tests">Ausführen einzelner Tests</a></h4>
<p>Wir können den Namen einer beliebigen Testfunktion an <code>cargo test</code> übergeben,
um nur diesen Test auszuführen:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Nur der Test mit dem Namen <code>one_hundred</code> lief; die beiden anderen Tests passten
nicht zu diesem Namen. Die Testausgabe lässt uns wissen, dass wir mehrere Tests
hatten, als dieser Befehl ausgeführt wurde, indem am Ende der
Zusammenfassungszeile <code>2 filtered out</code> angezeigt wird.</p>
<p>Wir können die Namen mehrerer Tests nicht auf diese Weise angeben; es wird nur
der erste Wert verwendet, der bei <code>cargo test</code> angegeben wird. Aber es gibt
eine Möglichkeit, mehrere Tests auszuführen.</p>
<h4><a class="header" href="#filtern-um-mehrerer-tests-auszuführen" id="filtern-um-mehrerer-tests-auszuführen">Filtern um mehrerer Tests auszuführen</a></h4>
<p>Wir können einen Teil eines Testnamens angeben und jeder Test, dessen Name zu
diesem Wert passt, wird ausgeführt. Da zum Beispiel zwei der Namen unserer
Tests <code>add</code> enthalten, können wir diese beiden Tests ausführen, indem wir
<code>cargo test add</code> ausführen:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>Dieser Befehl führte alle Tests mit <code>add</code> im Namen aus und filterte den Test
mit dem Namen <code>one_hundred</code> heraus. Beachte auch, dass das Modul, in dem sich
ein Test befindet, Teil des Testnamens wird, sodass wir alle Tests in einem
Modul ausführen können, indem wir nach dem Namen des Moduls filtern.</p>
<h3><a class="header" href="#tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden" id="tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden">Tests ignorieren, die nicht ausdrücklich verlangt werden</a></h3>
<p>Manchmal kann die Ausführung einiger spezifischer Tests sehr zeitaufwendig
sein, sodass du diese bei den meisten <code>cargo test</code>-Aufrufen ausschließen
solltest. Anstatt alle Tests, die du ausführen möchtest, als Argumente
aufzulisten, kannst du die zeitaufwendigen Tests stattdessen mit dem Attribut
<code>ignore</code> annotieren, um sie auszuschließen, wie hier gezeigt: </p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // Code, dessen Ausführung eine Stunde dauert
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Unterhalb <code>#[test]</code> fügen wir die Zeile <code>#[ignore]</code> beim Test ein, den wir
ausschließen wollen. Wenn wir nun unsere Tests ausführen, läuft <code>it_works</code>,
aber <code>expensive_test</code> nicht:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die Funktion <code>expensive_test</code> wird als <code>ignored</code> aufgeführt. Wenn wir nur die
ignorierten Tests ausführen wollen, können wir <code>cargo test -- --ignored</code>
angeben:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Indem du kontrollierst, welche Tests durchgeführt werden, kannst du
sicherstellen, dass dein <code>cargo test</code>-Aufruf schnell zu Ergebnissen führt. Wenn
du an einem Punkt angelangt bist, an dem es sinnvoll ist, die Ergebnisse der
<code>ignored</code>-Tests zu überprüfen, und du Zeit hast, auf die Ergebnisse zu warten,
kannst du stattdessen <code>cargo test -- --ignored</code> ausführen.</p>
<h2><a class="header" href="#testverwaltung" id="testverwaltung">Testverwaltung</a></h2>
<p>Wie zu Beginn des Kapitels erwähnt, ist das Testen eine komplexe Disziplin, und
verschiedene Personen verwenden unterschiedliche Terminologien und
Organisationen. Die Rust-Gemeinschaft teilt Tests in zwei Hauptkategorien ein:
<em>Modultests</em> (unit tests) und <em>Integrationstests</em> (integration tests).
Modultests sind klein und zielgerichteter, testen jeweils ein Modul isoliert
und können private Schnittstellen testen. Integrationstests sind völlig
außerhalb deiner Bibliothek und verwenden deinen Code auf die gleiche Weise wie
jeder andere externe Code, wobei nur die öffentliche Schnittstelle verwendet
wird und möglicherweise mehrere Module pro Test ausgeführt werden.</p>
<p>Es ist wichtig, beide Testarten zu schreiben, um sicherzustellen, dass die
Teile deiner Bibliothek einzeln und zusammen das tun, was du von ihnen
erwartest.</p>
<h3><a class="header" href="#modultests" id="modultests">Modultests</a></h3>
<p>Der Zweck von Modultests besteht darin, jede Code-Einheit isoliert vom Rest des
Codes zu testen, um schnell herauszufinden, welcher Code wie erwartet
funktioniert und welcher nicht. Modultests befinden sich im Verzeichnis <em>src</em>
in den Quellcodedateien, den sie testen. Die Konvention besteht darin, in jeder
Datei ein Modul namens <code>tests</code> zu erstellen, das die Testfunktionen enthält,
und das Modul mit <code>cfg(test)</code> zu annotieren.</p>
<h4><a class="header" href="#das-testmodul-und-cfgtest" id="das-testmodul-und-cfgtest">Das Testmodul und <code>#[cfg(test)]</code></a></h4>
<p>Die Annotation <code>#[cfg(test)]</code> am Testmodul weist Rust an, den Testcode nur dann
zu kompilieren und auszuführen, wenn du <code>cargo test</code> ausführst, nicht aber,
wenn du <code>cargo build</code> ausführst. Dies spart Kompilierzeit, wenn du nur die
Bibliothek erstellen möchtest, und spart Platz im resultierenden, kompilierten
Artefakt, da die Tests nicht enthalten sind. Du wirst feststellen, dass
Integrationstests die Annotation <code>#[cfg(test)]</code> nicht benötigen, weil sie in
einem anderen Verzeichnis liegen. Da Modultests jedoch in den gleichen Dateien
wie der Code sind, wirst du <code>#[cfg(test)]</code> verwenden, um anzugeben, dass sie
nicht im kompilierten Ergebnis enthalten sein sollen.</p>
<p>Erinnere dich daran, dass Cargo diesen Code für uns generiert hat, als wir das
neue Projekt <code>adder</code> im ersten Abschnitt dieses Kapitels erstellt haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Dieser Code ist das automatisch generierte Testmodul. Das Attribut <code>cfg</code> steht
für <em>Konfiguration</em> und teilt Rust mit, dass das folgende Element nur bei einer
bestimmten Konfigurationsoption eingebunden werden soll. In diesem Fall ist die
Konfigurationsoption <code>test</code>, die von Rust beim Kompilieren und Ausführen von
Tests verwendet wird. Durch das Verwenden des Attributs <code>cfg</code> kompiliert Cargo
unseren Testcode nur dann, wenn wir die Tests aktiv mit <code>cargo test</code> ausführen.
Dies schließt alle Hilfsfunktionen ein, die sich innerhalb dieses Moduls
befinden könnten, zusätzlich zu den mit <code>#[test]</code> annotierten Funktionen.</p>
<h4><a class="header" href="#testen-privater-funktionen" id="testen-privater-funktionen">Testen privater Funktionen</a></h4>
<p>In der Testgemeinschaft wird darüber diskutiert, ob private Funktionen direkt
getestet werden sollten oder nicht, und andere Sprachen machen es schwierig
oder gar unmöglich, private Funktionen zu testen. Unabhängig davon, an welcher
Testideologie du festhältst, erlauben dir Rusts Datenschutzregeln, private
Funktionen zu testen. Betrachte den Code in Codeblock 11-12 mit der privaten
Funktion <code>internal_adder</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-12: Testen einer privaten Funktion</span></p>
<p>Beachte, dass die Funktion <code>internal_adder</code> nicht mit <code>pub</code> markiert ist, aber
da Tests nur Rust-Code sind und das Modul <code>tests</code> nur ein weiteres Modul ist,
kannst du <code>internal_adder</code> in den Gültigkeitsbereich eines Tests bringen und
sie aufrufen. Wenn du der Meinung bist, dass private Funktionen nicht getestet
werden sollten, gibt es in Rust nichts, was dich dazu zwingen würde.</p>
<h3><a class="header" href="#integrationstests" id="integrationstests">Integrationstests</a></h3>
<p>In Rust sind Integrationstests völlig außerhalb deiner Bibliothek angesiedelt.
Du verwendest deine Bibliothek auf die gleiche Weise wie jeder andere Code,
d.h. es können nur Funktionen aufgerufen werden, die Teil der öffentlichen
Programmierschnittstelle (API) deiner Bibliothek sind. Ihr Zweck ist es, zu
testen, ob viele Teile deiner Bibliothek korrekt zusammenarbeiten.
Code-Einheiten, die alleine korrekt funktionieren, könnten Probleme nach deren
Integration haben, daher ist auch die Testabdeckung des integrierten Codes
wichtig. Um Integrationstests zu erstellen, benötigst du zunächst ein
Verzeichnis <em>tests</em>.</p>
<h4><a class="header" href="#das-verzeichnis-tests" id="das-verzeichnis-tests">Das Verzeichnis <em>tests</em></a></h4>
<p>Wir erstellen ein Verzeichnis <em>tests</em> auf der obersten Ebene unseres
Projektverzeichnisses, neben <em>src</em>. Cargo weiß, dass es in diesem Verzeichnis
nach Integrationstestdateien suchen soll. Wir können dann in diesem Verzeichnis
so viele Testdateien erstellen, wie wir wollen, und Cargo wird jede dieser
Dateien als eine einzelne Kiste (crate) kompilieren.</p>
<p>Lass uns einen Integrationstest erstellen. Wenn sich der Code in Codeblock
11-12 noch in der Datei <em>src/lib.rs</em> befindet, erstelle ein Verzeichnis
<em>tests</em> und eine neue Datei mit dem Namen <em>tests/integration_test.rs</em> und gib
den Code aus Codeblock 11-13 ein.</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Codeblock 11-13: Integrationstest einer Funktion in der
Kiste <code>adder</code></span></p>
<p>Wir haben am Anfang des Codes <code>use adder;</code> angegeben, was wir bei Modultests
nicht brauchten. Der Grund dafür ist, dass jede Datei im Verzeichnis <code>tests</code>
eine separate Kiste ist, sodass wir unsere Bibliothek in den Gültigkeitsbereich
jeder Testkiste bringen müssen.</p>
<p>Wir brauchen den Code in <em>tests/integration_test.rs</em> nicht mit <code>#[cfg(test)]</code>
zu annotieren. Cargo behandelt das Verzeichnis <code>tests</code> speziell und kompiliert
Dateien in diesem Verzeichnis nur dann, wenn wir <code>cargo test</code> ausführen. Führe
<code>cargo test</code> jetzt aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die drei Abschnitte der Ausgabe umfassen die Modultests, den Integrationstest
und die Dokumentationstests. Der erste Abschnitt für die Modultests ist
derselbe, wie wir ihn gesehen haben: Eine Zeile für jeden Modultest (eine Zeile
mit der Bezeichnung <code>internal</code>, die wir in Codeblock 11-12 hinzugefügt haben)
und dann eine zusammenfassende Zeile für die Modultests.</p>
<p>Der Abschnitt zu den Integrationstests beginnt mit der Zeile <code>Running target/debug/deps/integration_test-82e7799c1bc62298</code> (der Hashwert am Ende
deiner Ausgabe ist anders). Als nächstes kommt eine Zeile für jede Testfunktion
in diesem Integrationstest und eine Zusammenfassung für die Ergebnisse des
Integrationstests, kurz bevor der Abschnitt <code>Doc-tests adder</code> beginnt.</p>
<p>Ähnlich wie das Hinzufügen weiterer Modultestfunktionen zu mehr Ergebniszeilen
im Modultest-Abschnitt führt, führt das Hinzufügen weiterer Testfunktionen in
der Integrationstestdatei zu mehr Ergebniszeilen im Abschnitt zu dieser
Integrationstestdatei. Jede Integrationstestdatei hat ihren eigenen Abschnitt,
wenn wir also weitere Dateien im Verzeichnis <em>tests</em> hinzufügen, wird es mehr
Integrationstest-Abschnitte geben.</p>
<p>Wir können immer noch eine bestimmte Integrationstestfunktion ausführen, indem
wir den Namen der Testfunktion als Argument bei <code>cargo test</code> angeben. Um alle
Tests in einer bestimmten Integrationstestdatei auszuführen, verwenden bei
<code>cargo test</code> das Argument <code>--test</code>, gefolgt vom Namen der Datei:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dieses Kommando führt nur die Tests in der Datei <em>tests/integration_test.rs</em>
aus.</p>
<h4><a class="header" href="#teilmodule-in-integrationstests" id="teilmodule-in-integrationstests">Teilmodule in Integrationstests</a></h4>
<p>Wenn du weitere Integrationstests hinzufügst, möchtest du vielleicht mehr als
eine Datei im Verzeichnis <em>tests</em> erstellen, um sie besser organisieren zu
können; beispielsweise kannst du die Testfunktionen nach der Funktionalität
gruppieren, die sie testen. Wie bereits erwähnt, wird jede Datei im Verzeichnis
<em>tests</em> als eine separate Kiste kompiliert.</p>
<p>Jede Integrationstestdatei wie eine eigene Kiste zu behandeln, ist nützlich, um
separate Bereiche zu erstellen, die eher der Art und Weise entsprechen, wie
Endbenutzer deine Kiste verwenden werden. Das bedeutet jedoch, dass Dateien im
Verzeichnis <em>tests</em> nicht das gleiche Verhalten wie Dateien in <em>src</em> haben, wie
du in Kapitel 7 über die Trennung von Code in Module und Dateien gelernt hast.</p>
<p>Das unterschiedliche Verhalten von Dateien im Verzeichnis <em>tests</em> ist am
deutlichsten, wenn du eine Reihe Hilfsfunktionen hast, die bei mehreren
Integrationstestdateien nützlich wären, und du versuchst, die Schritte im
Abschnitt <a href="ch07-05-separating-modules-into-different-files.html">„Module in verschiedene Dateien
aufteilen“</a> in Kapitel 7 zu befolgen, um sie in
ein gemeinsames Modul zu extrahieren. Wenn wir zum Beispiel <em>tests/common.rs</em>
erstellen und eine Funktion namens <code>setup</code> darin platzieren, können wir <code>setup</code>
etwas Code hinzufügen, den wir von mehreren Testfunktionen in mehreren
Testdateien aufrufen wollen:</p>
<p><span class="filename">Dateiname: tests/common.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // Vorbereitungscode speziell für die Tests deiner Bibliothek
}
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir die Tests erneut ausführen, werden wir für die Datei <em>common.rs</em> einen
neuen Abschnitt in der Testausgabe sehen, obwohl diese Datei keine
Testfunktionen enthält und wir die Funktion <code>setup</code> nicht von irgendwo
aufgerufen haben:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dass in den Testergebnissen <code>common</code> erscheint und dabei <code>running 0 tests</code>
angezeigt wird, ist nicht das, was wir wollten. Wir wollten nur etwas Code mit
den anderen Integrationstestdateien teilen.</p>
<p>Um zu vermeiden, dass <code>common</code> in der Testausgabe erscheint, werden wir statt
<em>tests/common.rs</em> die Datei <em>tests/common/mod.rs</em> erstellen. Dies ist eine
alternative Namenskonvention, die auch Rust versteht. Durch diese Benennung der
Datei wird Rust angewiesen, das Modul <code>common</code> nicht als Integrationstestdatei
zu behandeln. Wenn wir den Funktionscode <code>setup</code> in <em>tests/common/mod.rs</em>
verschieben und die Datei <em>tests/common.rs</em> löschen, erscheint der Abschnitt in
der Testausgabe nicht mehr. Dateien in Unterverzeichnissen des Verzeichnisses
<em>tests</em> werden nicht als separate Kisten kompiliert und erzeugen keine
Abschnitte in der Testausgabe.</p>
<p>Nachdem wir <em>tests/common/mod.rs</em> erstellt haben, können wir es von jeder der
Integrationstestdateien als Modul verwenden. Hier ist ein Beispiel für den
Aufruf der Funktion <code>setup</code> aus dem Test <code>it_adds_two</code> in
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Dateiname: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Beachte, dass die Deklaration <code>mod common;</code> die gleiche ist wie die
Moduldeklaration, die wir in Codeblock 7-21 gezeigt haben. In der Testfunktion
können wir dann die Funktion <code>common::setup()</code> aufrufen.</p>
<h4><a class="header" href="#integrationstests-für-binäre-kisten" id="integrationstests-für-binäre-kisten">Integrationstests für binäre Kisten</a></h4>
<p>Wenn unser Projekt eine binäre Kiste ist, die nur eine Datei <em>src/main.rs</em>
enthält und keine Datei <em>src/lib.rs</em>, können wir keine Integrationstests im
<em>tests</em>-Verzeichnis erstellen und Funktionen, die in der <em>src/main.rs</em>-Datei
definiert sind, mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich bringen.
Nur Bibliothekskisten stellen Funktionen zur Verfügung, die auch von anderen
Kisten verwendet werden können; binäre Kisten sind für den eigenständigen
Betrieb gedacht.</p>
<p>Dies ist einer der Gründe, warum Rust-Projekte, die eine Binärdatei
bereitstellen, eine einfache <em>src/main.rs</em>-Datei haben, die Logik aufruft, die
in der <em>src/lib.rs</em>-Datei lebt. Unter Verwendung dieser Struktur können
Integrationstests die Bibliothekskiste mit <code>use</code> testen, um wichtige
Funktionalität verfügbar zu machen. Wenn die Hauptfunktionalität korrekt ist,
funktionieren auch die kleinen Codestücke in der Datei <em>src/main.rs</em>, und diese
kleinen Codestücke müssen nicht getestet werden.</p>
<h2><a class="header" href="#zusammenfassung-10" id="zusammenfassung-10">Zusammenfassung</a></h2>
<p>Die Testfunktionalitäten von Rust bieten eine Möglichkeit, zu spezifizieren,
wie der Code funktionieren soll, um sicherzustellen, dass er weiterhin so
funktioniert, wie du es erwartest, auch wenn du Änderungen vornimmst. Modultests prüfen
verschiedene Teile einer Bibliothek separat und können private
Implementierungsdetails testen. Integrationstests prüfen, ob viele Teile der
Bibliothek korrekt zusammenarbeiten, und sie verwenden die öffentliche
Programmierschnittstelle (API) der Bibliothek, um den Code auf die gleiche
Weise zu testen, wie externer Code ihn verwenden wird. Auch wenn das Typsystem
und die Eigentümerschaftsregeln von Rust dazu beitragen, einige Fehlerarten zu
verhindern, sind Tests immer noch wichtig, um Logikfehler zu reduzieren, die
damit zu tun haben, wie sich dein Code voraussichtlich verhalten wird.</p>
<p>Lass uns das Wissen, das du in diesem und in den vorhergehenden Kapiteln
gelernt hast, für die Arbeit an einem Projekt einsetzen!</p>
<h1><a class="header" href="#ein-ea-projekt-ein-kommandozeilenprogramm-erstellen" id="ein-ea-projekt-ein-kommandozeilenprogramm-erstellen">Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></h1>
<p>Dieses Kapitel ist eine Zusammenfassung der vielen Fähigkeiten, die du bisher
gelernt hast, und eine Erkundung einiger weiterer
Standard-Bibliotheks-Funktionalitäten. Wir werden ein Kommandozeilenwerkzeug
erstellen, das mit Datei- und Kommandozeilen-Ein- und -Ausgabe interagiert, um
einige der Rust-Konzepte zu üben, die du bereits gelernt hast.</p>
<p>Rusts Geschwindigkeit, Sicherheit, Ausgabe in eine einzelne Binärdatei und
plattformübergreifende Unterstützung machen es zu einer idealen Sprache zum
Erstellen von Kommandozeilenwerkzeugen. Für unser Projekt werden wir daher eine
eigene Version des klassischen Kommandozeilenwerkzeugs <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) erstellen. Im einfachsten
Anwendungsfall durchsucht <code>grep</code> eine angegebene Datei nach einer bestimmten
Zeichenkette. Dazu nimmt <code>grep</code> als Argumente einen Dateinamen und eine
Zeichenkette. Dann liest es die Datei, findet Zeilen in dieser Datei, die das
Zeichenketten-Argument enthalten, und gibt diese Zeilen aus.</p>
<p>Auf dem Weg dorthin werden wir zeigen, wie wir unser Kommandozeilenwerkzeug
dazu bringen können, Funktionalitäten des Terminals zu nutzen, die viele
Kommandozeilenwerkzeuge nutzen. Wir werden den Wert einer Umgebungsvariablen
lesen, die es dem Benutzer ermöglicht, das Verhalten unseres Werkzeugs zu
konfigurieren. Wir werden Fehlermeldungen auch auf der Standardfehlerausgabe
(<code>stderr</code>) statt auf der Standardausgabe (<code>stdout</code>) ausgeben, sodass der
Benutzer z.B. eine erfolgreiche Ausgabe in eine Datei umleiten kann, während er
weiterhin Fehlermeldungen auf dem Bildschirm sieht.</p>
<p>Ein Mitglied der Rust-Gemeinschaft, Andrew Gallant, hat bereits eine voll
ausgestattete, sehr schnelle Version von <code>grep</code>, genannt <code>ripgrep</code>, erstellt.
Im Vergleich dazu wird unsere Version von <code>grep</code> ziemlich einfach sein, aber
dieses Kapitel wird dir einiges an Hintergrundwissen vermitteln, das du
benötigst, um ein reales Projekt wie <code>ripgrep</code> zu verstehen.</p>
<p>Unser <code>grep</code>-Projekt wird eine Reihe von Konzepten kombinieren, die du bisher
gelernt hast:</p>
<ul>
<li>Code organisieren (unter Verwendung dessen, was du über Module in <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Kapitel
7</a> gelernt hast)</li>
<li>Verwenden von Vektoren und Zeichenketten (Kollektionen, <a href="ch08-00-common-collections.html">Kapitel 8</a>)</li>
<li>Fehlerbehandlung (<a href="ch09-00-error-handling.html">Kapitel 9</a>)</li>
<li>Verwenden von Merkmalen (traits) und Lebensdauer (lifetimes) soweit möglich
(<a href="ch10-00-generics.html">Kapitel 10</a>)</li>
<li>Schreiben von Tests (<a href="ch11-00-testing.html">Kapitel 11</a>)</li>
</ul>
<p>Wir werden auch kurz Funktionsabschlüsse (closures), Iteratoren und
Merkmalsobjekte (trait objects) vorstellen, die in den Kapiteln <a href="ch13-00-functional-features.html">13</a> und
<a href="ch17-00-oop.html">17</a> ausführlich behandelt werden.</p>
<h2><a class="header" href="#kommandozeilenargumente-entgegennehmen" id="kommandozeilenargumente-entgegennehmen">Kommandozeilenargumente entgegennehmen</a></h2>
<p>Lass uns ein neues Projekt, wie immer, mit <code>cargo new</code> erstellen. Wir werden
unser Projekt <code>minigrep</code> nennen, um es vom <code>grep</code>-Werkzeug zu unterscheiden,
das du vielleicht schon auf deinem System hast.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Die erste Aufgabe besteht darin, <code>minigrep</code> dazu zu bringen, seine beiden
Kommandozeilenargumente entgegennehmen: Den Dateinamen und eine Zeichenkette,
nach der gesucht werden soll. Das heißt, wir wollen in der Lage sein, unser
Programm mit <code>cargo run</code>, einer zu suchenden Zeichenkette und einem Pfad zu
einer Datei, in der gesucht werden soll, auszuführen:</p>
<pre><code class="language-console">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Im Moment kann das von <code>cargo new</code> generierte Programm die Argumente, die wir
ihm geben, nicht verarbeiten. Einige vorhandene Bibliotheken auf
<a href="https://crates.io/">crates.io</a> können beim Schreiben eines Programms, das
Kommandozeilenargumente akzeptiert, helfen, aber da du dieses Konzept gerade
erst erlernst, sollten wir diese Fähigkeit selbst implementieren.</p>
<h3><a class="header" href="#lesen-der-argumentwerte" id="lesen-der-argumentwerte">Lesen der Argumentwerte</a></h3>
<p>Um <code>minigrep</code> in die Lage zu versetzen, die Werte der Kommandozeilenargumente
zu lesen, die wir ihm übergeben, benötigen wir eine Funktion, die in der
Standardbibliothek von Rust bereitgestellt wird, nämlich <code>std::env::args</code>.
Diese Funktion gibt einen Iterator der Befehlszeilenargumente zurück, die an
<code>minigrep</code> übergeben wurden. Iteratoren werden wir in <a href="ch13-00-functional-features.html">Kapitel 13</a>
ausführlich behandeln. Im Moment brauchst du nur zwei Details über Iteratoren
zu wissen: Iteratoren erzeugen eine Reihe von Werten und wir können die Methode
<code>collect</code> auf einem Iterator aufrufen, um ihn in eine Kollektion, z.B. einen
Vektor, zu verwandeln, der alle Elemente enthält, die der Iterator erzeugt.</p>
<p>Verwende den Code in Codeblock 12-1, um deinem <code>minigrep</code>-Programm zu
ermöglichen, alle ihm übergebenen Befehlszeilenargumente zu lesen und die Werte
dann in einem Vektor zu sammeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-1: Sammeln der Befehlszeilenargumente in
einem Vektor und Ausgeben dieser Werte</span></p>
<p>Zuerst bringen wir das Modul <code>std::env</code> mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich, damit wir seine <code>args</code>-Funktion verwenden können. Beachte,
dass die Funktion <code>std::env::args</code> in zwei Modulebenen verschachtelt ist. Wie
wir in <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#idiomatische-use-pfade-erstellen">Kapitel 7</a> besprochen haben, ist es in Fällen, in
denen die gewünschte Funktion in mehr als einem Modul verschachtelt ist,
üblich, das übergeordnete Modul in den Gültigkeitsbereich zu bringen, anstatt
nur die Funktion. Auf diese Weise können wir leicht andere Funktionen aus
<code>std::env</code> verwenden. Es ist auch weniger mehrdeutig als das Hinzufügen von
<code>use std::env::args</code> und dem anschließenden Aufrufen der Funktion nur mit
<code>args</code>, weil <code>args</code> leicht mit einer Funktion verwechselt werden könnte, die im
aktuellen Modul definiert ist.</p>
<blockquote>
<h3><a class="header" href="#die-args-funktion-und-ungültiger-unicode" id="die-args-funktion-und-ungültiger-unicode">Die <code>args</code>-Funktion und ungültiger Unicode</a></h3>
<p>Beachte, dass <code>std::env::args</code> abstürzt, wenn ein Argument einen ungültigen
Unicode enthält. Wenn dein Programm Argumente mit ungültigem Unicode
akzeptieren muss, verwende stattdessen <code>std::env::args_os</code>. Diese Funktion
gibt einen Iterator zurück, der <code>OsString</code>-Werte anstelle von <code>String</code>-Werten
erzeugt. Wir haben uns hier aus Gründen der Einfachheit für die Verwendung
von <code>std::env::args</code> entschieden, weil <code>OsString</code>-Werte sich je nach
Plattform unterscheiden und die Arbeit mit ihnen komplexer ist als mit
<code>String</code>-Werten.</p>
</blockquote>
<p>In der ersten Zeile von <code>main</code> rufen wir <code>env::args</code> auf und wir verwenden
sofort <code>collect</code>, um den Iterator in einen Vektor zu verwandeln, der alle vom
Iterator erzeugten Werte enthält. Wir können die Funktion <code>collect</code> verwenden,
um viele Arten von Kollektionen zu erstellen, also vermerken wir explizit den
Typ von <code>args</code>, um anzugeben, dass wir einen Vektor mit Zeichenketten wollen.
Obwohl wir in Rust nur sehr selten Typen mit Annotationen versehen müssen, ist
<code>collect</code> eine Funktion, die du häufig mit Annotationen versehen musst, da Rust
nicht in der Lage ist, auf die Art der gewünschten Kollektion zu schließen.</p>
<p>Zum Schluss geben wir den Vektor mit dem Debug-Formatierer <code>:?</code> aus. Versuchen
wir, den Code zuerst ohne Argumente und dann mit zwei Argumenten laufen zu
lassen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<pre><code class="language-console">$ cargo run Nadel Heuhaufen
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep Nadel Heuhaufen`
[&quot;target/debug/minigrep&quot;, &quot;Nadel&quot;, &quot;Heuhaufen&quot;]
</code></pre>
<p>Beachte, dass der erste Wert im Vektor <code>&quot;target/debug/minigrep&quot;</code> ist, was der
Name unserer Binärdatei ist. Dies entspricht dem Verhalten der Argumentliste in
C, sodass Programme bei ihrer Ausführung den Namen verwenden können, unter dem
sie aufgerufen wurden. Es ist oft praktisch, Zugriff auf den Programmnamen zu
haben, falls du ihn in Meldungen ausgeben oder das Verhalten des Programms
ändern möchtest, je nachdem, welcher Befehlszeilen-Alias zum Aufruf des
Programms verwendet wurde. Aber für die Zwecke dieses Kapitels ignorieren wir
ihn und speichern nur die beiden Argumente, die wir brauchen.</p>
<h3><a class="header" href="#speichern-der-argumentwerte-in-variablen" id="speichern-der-argumentwerte-in-variablen">Speichern der Argumentwerte in Variablen</a></h3>
<p>Das Ausgeben der Werte des Argumentvektors veranschaulicht, dass das Programm
auf die als Kommandozeilenargumente angegebenen Werte zugreifen kann. Jetzt
müssen wir die Werte der beiden Argumente in Variablen speichern, damit wir die
Werte im restlichen Programm verwenden können. Das tun wir in Codeblock 12-2.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Suche nach {}&quot;, query);
    println!(&quot;In Datei {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-2: Erstellen von Variablen zur Aufnahme des
Such-Arguments und des Dateiname-Arguments</span></p>
<p>Wie wir gesehen haben, als wir den Vektor ausgegeben haben, nimmt der
Programmname den ersten Wert im Vektor bei <code>args[0]</code> ein, also beginnen wir
beim Index <code>1</code>. Das erste Argument, das <code>minigrep</code> annimmt, ist die
Zeichenkette, nach der wir suchen, also setzen wir eine Referenz auf das erste
Argument in die Variable <code>query</code>. Das zweite Argument wird der Dateiname sein,
also setzen wir eine Referenz auf das zweite Argument in die Variable
<code>filename</code>.</p>
<p>Wir geben vorübergehend die Werte dieser Variablen aus, um zu belegen, dass der
Code so funktioniert, wie wir es beabsichtigen. Lassen wir dieses Programm mit
den Argumenten <code>test</code> und <code>sample.txt</code> noch einmal laufen:</p>
<pre><code class="language-console">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Suche nach test
In Datei sample.txt
</code></pre>
<p>Toll, das Programm funktioniert! Die Werte der Argumente, die wir brauchen,
werden in den richtigen Variablen gespeichert. Später fügen wir eine
Fehlerbehandlung hinzu, um mit bestimmten potentiellen Fehlersituationen
umzugehen, z.B. wenn der Benutzer keine Argumente angibt; für den Moment
ignorieren wir diese Situation und arbeiten stattdessen daran, die
Datei-Lesefunktion hinzuzufügen.</p>
<h2><a class="header" href="#eine-datei-einlesen" id="eine-datei-einlesen">Eine Datei einlesen</a></h2>
<p>Jetzt fügen wir Funktionalität zum Lesen der Datei hinzu, die im
Befehlszeilenargument <code>filename</code> angegeben ist. Zuerst brauchen wir eine
Beispieldatei, um sie zu testen: Die beste Art von Datei, die wir benutzen
können, um sicherzustellen, dass <code>minigrep</code> funktioniert, ist eine Datei mit
einer kleinen Menge Text über mehrere Zeilen mit einigen sich wiederholenden
Wörtern. In Codeblock 12-3 ist ein Gedicht von Emily Dickinson, das gut
funktionieren wird! Erstelle eine Datei namens <em>poem.txt</em> im Hauptverzeichnis
deines Projekts und gib das Gedicht „I’m Nobody! Who are you?“ ein.</p>
<p><span class="filename">Dateiname: poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Codeblock 12-3: Ein Gedicht von Emily Dickinson ist ein
guter Testfall</span></p>
<p>Wenn der Text vorhanden ist, editiere <em>src/main.rs</em> und füge Code zum Lesen der
Datei hinzu, wie in Codeblock 12-4 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, query);
</span>    println!(&quot;In Datei {}&quot;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    println!(&quot;Mit text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-4: Lesen des Inhalts der Datei, die durch
das zweite Argument angegeben wurde</span></p>
<p>Zuerst fügen wir eine weitere <code>use</code>-Anweisung hinzu, um einen relevanten Teil
der Standardbibliothek einzubringen: Wir brauchen <code>std::fs</code>, um Dateien zu
verwenden.</p>
<p>In <code>main</code> haben wir eine neue Anweisung hinzugefügt: <code>fs::read_to_string</code> nimmt
den <code>filename</code>, öffnet diese Datei und gibt ein <code>Result&lt;String&gt;</code> mit dem Inhalt
der Datei zurück.</p>
<p>Nach dieser Anweisung haben wir wieder eine temporäre <code>println!</code>-Anweisung
hinzugefügt, die den Wert von <code>contents</code> ausgibt, nachdem die Datei eingelesen
wurde, sodass wir überprüfen können, ob das Programm soweit funktioniert.</p>
<p>Lassen wir diesen Code mit einer beliebigen Zeichenkette als erstes
Kommandozeilenargument laufen (weil wir den Suchteil noch nicht implementiert
haben) und die Datei <em>poem.txt</em> als zweites Argument:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Großartig! Der Code wurde eingelesen und dann der Inhalt der Datei ausgegeben.
Aber der Code hat ein paar Mängel. Die Funktion <code>main</code> hat mehrere
Verantwortlichkeiten: Im Allgemeinen sind Funktionen klarer und einfacher zu
warten, wenn jede Funktion nur für eine Idee verantwortlich ist. Das andere
Problem ist, dass wir mit Fehlern nicht so gut umgehen, wie wir es könnten. Das
Programm ist noch klein, sodass diese Fehler kein großes Problem darstellen,
aber je größer das Programm wird, desto schwieriger wird es, sie sauber zu
beheben. Es ist eine gute Praxis, schon früh mit dem Umformen (refactor) zu
beginnen, wenn man ein Programm entwickelt, denn es ist viel einfacher,
kleinere Code-Mengen umzuformen. Das werden wir als Nächstes tun.</p>
<h2><a class="header" href="#refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern" id="refaktorierung-um-die-modularität-und-fehlerbehandlung-zu-verbessern">Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></h2>
<p>Um unser Programm zu verbessern, werden wir vier Probleme beheben, die mit der
Struktur des Programms und dem Umgang mit potenziellen Fehlern zu tun haben.</p>
<p>Erstens erfüllt unsere Funktion <code>main</code> jetzt zwei Aufgaben: Sie parst Argumente
und liest Dateien. Für eine so kleine Funktion ist dies kein großes Problem.
Wenn wir jedoch unser Programm innerhalb der Funktion <code>main</code> weiter ausbauen,
wird die Anzahl der einzelnen Aufgaben, die die Funktion <code>main</code> bearbeitet,
zunehmen. In dem Maße, wie eine Funktion an Verantwortung hinzugewinnt, wird es
schwieriger sie zu verstehen, schwieriger sie zu testen und schwieriger sie zu
ändern, ohne dass eines ihrer Teile kaputtgeht. Am besten ist es, die
Funktionalität so aufzuteilen, dass jede Funktion für eine Aufgabe zuständig
ist.</p>
<p>Diese Frage hängt auch mit dem zweiten Problem zusammen: Obwohl <code>query</code> und
<code>filename</code> Konfigurationsvariablen unseres Programms sind, werden Variablen wie
<code>contents</code> verwendet, um die Logik des Programms umzusetzen. Je länger <code>main</code>
wird, desto mehr Variablen müssen wir in den Gültigkeitsbereich bringen; je
mehr Variablen wir im Gültigkeitsbereich haben, desto schwieriger wird es, den
Zweck der einzelnen Variablen im Auge zu behalten. Es ist am besten, die
Konfigurationsvariablen in einer Struktur zu gruppieren, um ihren Zweck zu
verdeutlichen.</p>
<p>Das dritte Problem ist, dass wir <code>expect</code> benutzt haben, um eine Fehlermeldung
auszugeben, wenn das Lesen der Datei fehlschlägt, aber die Fehlermeldung gibt
nur <code>Etwas ging beim Lesen der Datei schief</code> aus. Das Lesen einer Datei kann
auf verschiedene Arten fehlschlagen: Zum Beispiel könnte die Datei fehlen oder
wir haben keine Berechtigung, sie zu öffnen. Im Moment würden wir unabhängig
von der Situation die Fehlermeldung „Etwas ging beim Lesen der Datei schief“
ausgeben, die dem Benutzer keinerlei Informationen geben würde!</p>
<p>Viertens verwenden wir <code>expect</code> erneut, um verschiedene Fehler zu behandeln,
und wenn der Benutzer unser Programm ausführt, ohne genügend Argumente
anzugeben, erhält er einen <code>Index out of bounds</code>-Fehler von Rust, der das
Problem nicht eindeutig erklärt. Am besten wäre es, wenn sich der gesamte
Fehlerbehandlungscode an einer Stelle befände, sodass zukünftige Betreuer nur
eine Stelle im Code konsultieren bräuchten, falls sich die
Fehlerbehandlungslogik ändern sollte. Wenn sich der gesamte
Fehlerbehandlungscode an einer Stelle befindet, wird auch sichergestellt, dass
wir Meldungen ausgeben, die für unsere Endbenutzer aussagekräftig sind.</p>
<p>Lass uns diese vier Probleme angehen, indem wir unser Projekt refaktorieren.</p>
<h3><a class="header" href="#trennen-der-zuständigkeiten-bei-binärprojekten" id="trennen-der-zuständigkeiten-bei-binärprojekten">Trennen der Zuständigkeiten bei Binärprojekten</a></h3>
<p>Das organisatorische Problem der Zuweisung der Verantwortung für mehrere
Aufgaben an die Funktion <code>main</code> ist vielen Binärprojekten gemein.
Infolgedessen hat die Rust-Gemeinschaft ein Verfahren entwickelt, das als
Richtlinie für die Aufteilung der einzelnen Aufgaben eines Binärprogramms
verwendet werden kann, wenn die Funktion <code>main</code> groß wird. Der Prozess umfasst
die folgenden Schritte:</p>
<ul>
<li>Teile dein Programm in eine <em>main.rs</em> und eine <em>lib.rs</em> auf und verschiebe
die Logik deines Programms in die <em>lib.rs</em>.</li>
<li>Solange deine Kommandozeilen-Parselogik klein ist, kann sie in <em>main.rs</em>
bleiben.</li>
<li>Wenn die Kommandozeilen-Parselogik anfängt, kompliziert zu werden, extrahiere
sie aus <em>main.rs</em> und verschiebe sie in <em>lib.rs</em>.</li>
</ul>
<p>Die Verantwortlichkeiten, die nach diesem Prozess in der Funktion <code>main</code>
verbleiben, sollten sich auf Folgendes beschränken:</p>
<ul>
<li>Aufrufen der Kommandozeilen-Parselogik mit den Argumentwerten</li>
<li>Aufbauen weiterer Konfiguration</li>
<li>Aufrufen einer Funktion <code>run</code> in <em>lib.rs</em></li>
<li>Behandeln des Fehlers, wenn <code>run</code> einen Fehler zurückgibt</li>
</ul>
<p>Bei diesem Muster geht es darum, Verantwortlichkeiten zu trennen: <em>main.rs</em>
kümmert sich um die Ausführung des Programms und <em>lib.rs</em> kümmert sich um die
gesamte Logik der anstehenden Aufgabe. Da du die Funktion <code>main</code> nicht direkt
testen kannst, kannst du mit dieser Struktur die gesamte Logik deines Programms
testen, indem du sie in Funktionen in <em>lib.rs</em> verschiebst. Der einzige Code,
der in <em>main.rs</em> verbleibt, wird klein genug sein, um seine Korrektheit durch
Lesen zu überprüfen. Lass uns unser Programm überarbeiten, indem wir diesem
Prozess folgen.</p>
<h4><a class="header" href="#extrahieren-des-argument-parsers" id="extrahieren-des-argument-parsers">Extrahieren des Argument-Parsers</a></h4>
<p>Wir werden die Funktionalität für das Parsen von Argumenten in eine Funktion
extrahieren, die von <code>main</code> aufgerufen wird, um das Verschieben der
Kommandozeilen-Parselogik nach <em>src/lib.rs</em> vorzubereiten. Codeblock 12-5 zeigt
den neuen Anfang von <code>main</code>, der eine neue Funktion <code>parse_config</code> aufruft, die
wir vorerst in <em>src/main.rs</em> definieren werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-5: Extrahieren einer Funktion <code>parse_config</code>
aus <code>main</code></span></p>
<p>Wir sammeln immer noch die Kommandozeilenargumente in einem Vektor, aber
anstatt den Argumentwert am Index 1 der Variablen <code>query</code> und den Argumentwert
am Index 2 der Variablen <code>filename</code> innerhalb der <code>main</code>-Funktion zuzuweisen,
übergeben wir den gesamten Vektor an die Funktion <code>parse_config</code>. Die Funktion
<code>parse_config</code> enthält dann die Logik, die bestimmt, welches Argument in welche
Variable geht und die Werte an <code>main</code> zurückgibt. Wir erstellen immer noch die
Variablen <code>query</code> und <code>filename</code> in <code>main</code>, aber <code>main</code> hat nicht mehr die
Verantwortung zu bestimmen, wie die Kommandozeilenargumente und Variablen
zusammenpassen.</p>
<p>Dieses Überarbeiten mag für unser kleines Programm übertrieben erscheinen, aber
wir führen die Refactoring-Maßnahmen in kleinen, inkrementellen Schritten
durch. Nachdem du diese Änderung vorgenommen hast, führe das Programm erneut
aus, um zu überprüfen, ob das Argumentparsen noch funktioniert. Es ist gut, den
Fortschritt oft zu überprüfen, um die Ursache von Problemen zu erkennen, wenn
sie auftreten.</p>
<h4><a class="header" href="#gruppieren-von-konfigurationswerten" id="gruppieren-von-konfigurationswerten">Gruppieren von Konfigurationswerten</a></h4>
<p>Wir können einen weiteren kleinen Schritt tun, um die Funktion <code>parse_config</code>
weiter zu verbessern. Im Moment geben wir ein Tupel zurück, aber dann zerlegen
wir dieses Tupel sofort wieder in einzelne Teile. Das ist ein Zeichen dafür,
dass wir vielleicht noch nicht die richtige Abstraktion haben.</p>
<p>Ein weiterer Indikator, der zeigt, dass es Raum für Verbesserungen gibt, ist
der <code>config</code>-Teil von <code>parse_config</code>, der impliziert, dass die beiden von uns
zurückgegebenen Werte miteinander in Beziehung stehen und beide Teil eines
Konfigurationswertes sind. Diese Bedeutung vermitteln wir derzeit in der
Struktur der Daten nur durch die Gruppierung der beiden Werte in einem Tupel;
wir könnten die beiden Werte in eine Struktur setzen und jedem der
Strukturfelder einen aussagekräftigen Namen geben. Auf diese Weise wird es
künftigen Betreuern dieses Codes leichter fallen, zu verstehen, wie die
verschiedenen Werte miteinander in Beziehung stehen und was ihr Zweck ist.</p>
<blockquote>
<p>Hinweis: Das Verwenden primitiver Werte, wenn ein komplexer Typ angemessener
wäre, ist ein Anti-Muster, das als <em>primitive Besessenheit</em> (primitive
obsession) bekannt ist.</p>
</blockquote>
<p>Codeblock 12-6 zeigt die Verbesserungen der Funktion <code>parse_config</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span>}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-6: Refactorieren von <code>parse_config</code> zur
Rückgabe einer Instanz einer <code>Config</code>-Struktur</span></p>
<p>Wir haben eine Struktur namens <code>Config</code> hinzugefügt, die so definiert ist, dass
sie Felder mit den Namen <code>query</code> und <code>filename</code> enthält. Die Signatur von
<code>parse_config</code> zeigt nun an, dass sie einen <code>Config</code>-Wert zurückgibt. Im
Rumpf von <code>parse_config</code>, wo wir früher Zeichenkettenanteilstypen (string
slices) zurückgegeben haben, die auf <code>String</code>-Werte in <code>args</code> referenzieren,
definieren wir <code>Config</code> jetzt so, dass es aneigenbare (owned) <code>String</code>-Werte
enthält. Die <code>args</code>-Variable in <code>main</code> ist der Eigentümer der Argumentwerte und
lässt die Funktion <code>parse_config</code> diese nur ausleihen, was bedeutet, dass wir
Rusts Regeln für das Ausleihen verletzen würden, wenn <code>Config</code> versucht, die
Eigentümerschaft für die Werte in <code>args</code> zu nehmen.</p>
<p>Wir könnten die <code>String</code>-Daten auf verschiedene Weise verwalten, aber der
einfachste, wenn auch etwas ineffiziente Weg ist es, die <code>clone</code>-Methode der
Werte aufzurufen. Dadurch wird eine vollständige Kopie der Daten erstellt, die
die <code>Config</code>-Instanz besitzen soll, was mehr Zeit und Speicherplatz in Anspruch
nimmt als das Speichern einer Referenz auf die Zeichenkettendaten. Das Klonen
der Daten macht unseren Code jedoch auch sehr unkompliziert, weil wir die
Lebensdauer der Referenzen nicht verwalten müssen; unter diesen Umständen ist
es ein lohnender Kompromiss, ein wenig Leistung aufzugeben, um Einfachheit zu
bekommen.</p>
<blockquote>
<h3><a class="header" href="#die-kompromisse-beim-verwenden-von-clone" id="die-kompromisse-beim-verwenden-von-clone">Die Kompromisse beim Verwenden von <code>clone</code></a></h3>
<p>Viele Rust-Entwickler neigen dazu, das Verwenden von <code>clone</code> zur Lösung von
Eigentümerschaftsproblemen wegen der Laufzeitkosten zu vermeiden. In <a href="ch13-00-functional-features.html">Kapitel
13</a> erfährst du, wie du in solchen Situationen effizientere Methoden
einsetzen kannst. Aber für den Moment ist es in Ordnung, ein paar
Zeichenketten zu kopieren, um weiter voranzukommen, da du diese Kopien nur
einmal erstellen wirst und dein Dateiname und deine Suchzeichenkette sehr
klein sind. Es ist besser, ein funktionierendes Programm zu haben, das ein
bisschen ineffizient ist, als zu versuchen, den Code beim ersten Durchgang zu
hyperoptimieren. Je mehr Erfahrung du mit Rust sammelst, desto einfacher wird
es, mit der effizientesten Lösung zu beginnen, aber im Moment ist es völlig
akzeptabel, <code>clone</code> aufzurufen.</p>
</blockquote>
<p>Wir haben <code>main</code> aktualisiert, sodass es die Instanz von <code>Config</code>, die von
<code>parse_config</code> zurückgegeben wird, in eine Variable namens <code>config</code> setzt, und
wir haben den Code aktualisiert, der vorher die separaten Variablen <code>query</code> und
<code>filename</code> verwendet hat, sodass er jetzt stattdessen die Felder der
<code>Config</code>-Struktur verwendet.</p>
<p>Nun vermittelt unser Code deutlicher, dass <code>query</code> und <code>filename</code> zueinander
gehören und dass ihr Zweck darin besteht, die Funktionsweise des Programms zu
konfigurieren. Jeder Code, der diese Werte verwendet, weiß, dass er sie in der
<code>config</code>-Instanz in den für ihren Zweck benannten Feldern findet.</p>
<h4><a class="header" href="#erstellen-eines-konstruktors-für-config" id="erstellen-eines-konstruktors-für-config">Erstellen eines Konstruktors für <code>Config</code></a></h4>
<p>Bisher haben wir die Logik, die für das Parsen der Kommandozeilenargumente
verantwortlich ist, aus <code>main</code> extrahiert und in die Funktion <code>parse_config</code>
verschoben. Dies half uns zu erkennen, dass die Werte <code>query</code> und <code>filename</code>
miteinander in Beziehung stehen und diese Beziehung in unserem Code vermittelt
werden sollte. Wir fügten dann eine <code>Config</code>-Struktur hinzu, um das
Zusammengehören von <code>query</code> und <code>filename</code> zu benennen und um die Namen der
Werte als Feldnamen der Struktur von der <code>parse_config</code>-Funktion zurückgeben zu
können.</p>
<p>Da nun der Zweck der <code>parse_config</code>-Funktion darin besteht, eine
<code>Config</code>-Instanz zu erzeugen, können wir <code>parse_config</code> von einer einfachen
Funktion in eine Funktion namens <code>new</code> ändern, die mit der <code>Config</code>-Struktur
assoziiert ist. Durch diese Änderung wird der Code idiomatischer. Wir können
Instanzen von Typen in der Standardbibliothek erstellen, wie bei <code>String</code>,
indem wir <code>String::new</code> aufrufen. In ähnlicher Weise können wir durch Änderen
von <code>parse_config</code> in eine Funktion <code>new</code>, die mit <code>Config</code> assoziiert ist,
Instanzen von <code>Config</code> durch Aufrufen von <code>Config::new</code> erzeugen. Codeblock
12-7 zeigt die Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

<span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">
</span>    // --abschneiden--
}

// --abschneiden--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 12-7: Ändern von <code>parse_config</code> in
<code>Config::new</code></span></p>
<p>Wir haben <code>main</code> aktualisiert, wo wir <code>parse_config</code> aufgerufen haben, um
stattdessen <code>Config::new</code> aufzurufen. Wir haben den Namen von <code>parse_config</code> in
<code>new</code> geändert und ihn innerhalb eines <code>impl</code>-Blocks verschoben, der die
<code>new</code>-Funktion mit <code>Config</code> assoziiert. Versuche, diesen Code erneut zu
kompilieren, um sicherzustellen, dass er funktioniert.</p>
<h3><a class="header" href="#korrigieren-der-fehlerbehandlung" id="korrigieren-der-fehlerbehandlung">Korrigieren der Fehlerbehandlung</a></h3>
<p>Jetzt werden wir daran arbeiten, unsere Fehlerbehandlung zu korrigieren.
Erinnere dich, dass der Versuch, auf die Werte im <code>args</code>-Vektor bei Index 1
oder Index 2 zuzugreifen, das Programm zum Absturz bringt, wenn der Vektor
weniger als drei Elemente enthält. Versuche, das Programm ohne irgendwelche
Argumente laufen zu lassen; es wird so aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Die Zeile <code>index out of bounds: the len is 1 but the index is 1</code> ist eine für
Programmierer bestimmte Fehlermeldung. Sie wird unseren Endbenutzern nicht
helfen zu verstehen, was passiert ist und was sie stattdessen tun sollten. Lass
uns das jetzt korrigieren.</p>
<h4><a class="header" href="#verbessern-der-fehlermeldung" id="verbessern-der-fehlermeldung">Verbessern der Fehlermeldung</a></h4>
<p>In Codeblock 12-8 fügen wir eine Prüfung in der Funktion <code>new</code> hinzu, die
überprüft, ob der Anteilstyp lang genug ist, bevor auf Index 1 und 2
zugegriffen wird. Wenn der Anteilstyp nicht lang genug ist, stürzt das Programm
ab und zeigt eine bessere Fehlermeldung an als die Meldung <code>index out of bounds</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;Nicht genügend Argumente&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, filename }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-8: Hinzufügen einer Prüfung für die Anzahl
der Argumente</span></p>
<p>Dieser Code ähnelt <a href="ch09-03-to-panic-or-not-to-panic.html#benutzerdefinierte-typen-f%C3%BCr-die-validierung-erstellen">der Funktion <code>Guess::new</code>, die wir in Codeblock
9-10</a> geschrieben haben, wo wir <code>panic!</code> aufgerufen haben,
wenn das Argument <code>value</code> außerhalb des gültigen Wertebereichs lag. Anstatt
hier auf einen Wertebereich zu prüfen, prüfen wir, ob die Länge von <code>args</code>
mindestens 3 beträgt und der Rest der Funktion unter der Annahme arbeiten kann,
dass diese Bedingung erfüllt ist. Wenn <code>args</code> weniger als drei Elemente hat,
ist diese Bedingung wahr und wir rufen das Makro <code>panic!</code> auf, um das Programm
sofort zu beenden.</p>
<p>Mit diesen zusätzlichen wenigen Zeilen Code in <code>new</code> lassen wir das Programm
ohne Argumente erneut laufen, um zu sehen, wie der Fehler jetzt aussieht:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'Nicht genügend Argumente', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Diese Ausgabe ist besser: Wir haben jetzt eine vernünftige Fehlermeldung. Wir
haben jedoch auch irrelevante Informationen, die wir unseren Benutzern nicht
geben wollen. Vielleicht ist die Technik, die wir in Codeblock 9-10 verwendet
haben, hier nicht die beste: Das Aufrufen von <code>panic!</code> ist für ein
Programmierproblem besser geeignet als für ein Nutzungsproblem, <a href="ch09-03-to-panic-or-not-to-panic.html#richtlinien-zur-fehlerbehandlung">wie in Kapitel
9 besprochen</a>. Stattdessen können wir die andere Technik
verwenden, über die du in Kapitel 9 gelernt hast – <a href="ch09-02-recoverable-errors-with-result.html">Rückgabe eines
<code>Result</code></a> um entweder Erfolg oder einen Fehler anzuzeigen.</p>
<h4><a class="header" href="#zurückgeben-eines-result-von-new-anstatt-panic-aufzurufen" id="zurückgeben-eines-result-von-new-anstatt-panic-aufzurufen">Zurückgeben eines <code>Result</code> von <code>new</code>, anstatt <code>panic!</code> aufzurufen</a></h4>
<p>Wir können stattdessen einen <code>Result</code>-Wert zurückgeben, der im erfolgreichen
Fall eine <code>Config</code>-Instanz enthält und im Fehlerfall das Problem beschreibt.
Wenn <code>Config::new</code> mit <code>main</code> kommuniziert, können wir den <code>Result</code>-Typ
verwenden, um zu signalisieren, dass ein Problem aufgetreten ist. Dann können
wir <code>main</code> ändern, um eine <code>Err</code>-Variante in einen praktikableren Fehler für
unsere Benutzer umzuwandeln, ohne den umgebenden Text über <code>thread 'main'</code> und
<code>RUST_BACKTRACE</code>, den ein Aufruf von <code>panic!</code> verursacht.</p>
<p>Codeblock 12-9 zeigt die Änderungen, die wir am Rückgabewert von <code>Config::new</code>
und am Funktionsrumpf vornehmen müssen, um ein <code>Result</code> zurückzugeben. Beachte,
dass dies nicht kompiliert werden kann, bis wir auch <code>main</code> aktualisieren, was
wir im nächsten Codeblock tun werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;Nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Codeblock 12-9: Rückgabe eines <code>Result</code> von
<code>Config::new</code></span></p>
<p>Unsere Funktion <code>new</code> liefert jetzt ein <code>Result</code> mit einer <code>Config</code>-Instanz im
Erfolgsfall und ein <code>&amp;'static str</code> im Fehlerfall. Aus dem Abschnitt <a href="ch10-03-lifetime-syntax.html#statische-lebensdauer">„Statische
Lebensdauer“</a> in Kapitel 10 ist zu entnehmen, dass
<code>&amp;'static str</code> der Typ der Zeichenkettenliterale ist, der vorerst unser
Fehlermeldungs-Typ ist.</p>
<p>Wir haben zwei Änderungen im Rumpf der Funktion <code>new</code> vorgenommen: Anstatt
<code>panic!</code> aufzurufen, wenn der Benutzer nicht genug Argumente übergibt, geben
wir jetzt einen <code>Err</code>-Wert zurück, und wir haben den <code>Config</code>-Rückgabewert in
ein <code>Ok</code> verpackt. Diese Änderungen machen die Funktion konform mit ihrer neuen
Typsignatur.</p>
<p>Die Rückgabe eines <code>Err</code>-Wertes aus <code>Config::new</code> erlaubt es der Funktion
<code>main</code>, den von der <code>new</code>-Funktion zurückgegebenen <code>Result</code>-Wert zu verarbeiten
und den Prozess im Fehlerfall sauberer zu beenden.</p>
<h4><a class="header" href="#aufrufen-von-confignew-und-behandeln-von-fehlern" id="aufrufen-von-confignew-und-behandeln-von-fehlern">Aufrufen von <code>Config::new</code> und Behandeln von Fehlern</a></h4>
<p>Um den Fehlerfall zu behandeln und eine benutzerfreundliche Meldung auszugeben,
müssen wir <code>main</code> aktualisieren, um das von <code>Config::new</code> zurückgegebene
<code>Result</code> zu behandeln, wie in Codeblock 12-10 gezeigt. Wir werden auch die
Verantwortung dafür übernehmen, das Kommandozeilenwerkzeug mit einem Fehlercode
ungleich Null wie bei <code>panic!</code> zu beenden und es von Hand zu implementieren.
Ein Exit-Status ungleich Null ist eine Konvention, um dem Prozess, der unser
Programm aufgerufen hat, zu signalisieren, dass das Programm mit einem
Fehlerstatus beendet wurde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-10: Beenden mit einem Fehlercode, wenn das
Erstellen einer neuen <code>Config</code> fehlschlägt</span></p>
<p>In diesem Codeblock haben wir eine Methode verwendet, die wir bisher noch
nicht behandelt haben: <code>unwrap_or_else</code>, die in der Standardbibliothek unter
<code>Result&lt;T, E&gt;</code> definiert ist. Das Verwenden von <code>unwrap_or_else</code> erlaubt es
uns, eine benutzerdefinierte nicht-<code>panic!</code>-Fehlerbehandlung zu definieren.
Wenn das <code>Result</code> ein <code>Ok</code>-Wert ist, verhält sich diese Methode ähnlich wie
<code>unwrap</code>: Sie gibt den inneren Wert von <code>Ok</code> zurück. Wenn der Wert jedoch ein
<code>Err</code>-Wert ist, ruft diese Methode den Code im <em>Funktionsabschluss</em> (closure)
auf, die eine anonyme Funktion ist, die wir definieren und als Argument an
<code>unwrap_or_else</code> übergeben. Auf Funktionsabschlüsse gehen wir ausführlicher in
<a href="ch13-00-functional-features.html">Kapitel 13</a> ein. Im Moment musst du nur wissen, dass <code>unwrap_or_else</code>
den inneren Wert des <code>Err</code>, in diesem Fall die statische Zeichenkette <code>Nicht genügend Argumente</code>, die wir in Codeblock 12-9 hinzugefügt haben, an unseren
Funktionsabschluss im Argument <code>err</code>, das zwischen den senkrechten Strichen
erscheint, weitergibt. Der Code im Funktionsabschluss kann dann den <code>err</code>-Wert
verwenden, wenn sie ausgeführt wird.</p>
<p>Wir haben eine neue Zeile <code>use</code> hinzugefügt, um <code>process</code> aus der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code im
Funktionsabschluss, der im Fehlerfall ausgeführt wird, besteht nur aus zwei
Zeilen: Wir geben den <code>err</code>-Wert aus und rufen dann <code>process::exit</code> auf. Die
Funktion <code>process::exit</code> stoppt das Programm sofort und gibt die Zahl zurück,
die als Exit-Statuscode übergeben wurde. Dies ähnelt der <code>panic!</code>-basierten
Behandlung, die wir in Codeblock 12-8 verwendet haben, aber wir erhalten nicht
mehr die gesamte zusätzliche Ausgabe. Lass es uns versuchen:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Großartig! Diese Ausgabe ist viel benutzerfreundlicher.</p>
<h3><a class="header" href="#extrahieren-von-logik-aus-main" id="extrahieren-von-logik-aus-main">Extrahieren von Logik aus <code>main</code></a></h3>
<p>Da wir mit dem Refaktorieren des Konfigurations-Parsers nun fertig sind, wollen
wir uns der Logik des Programms zuwenden. Wie wir in <a href="ch12-03-improving-error-handling-and-modularity.html#trennen-der-zust%C3%A4ndigkeiten-bei-bin%C3%A4rprojekten">„Trennen der
Zuständigkeiten bei
Binärprojekten“</a> erklärt
haben, werden wir eine Funktion namens <code>run</code> extrahieren, die die gesamte Logik
enthält, die sich derzeit in der Funktion <code>main</code> befindet und nicht mit dem
Aufsetzen der Konfiguration oder dem Behandeln von Fehlern zu tun hat. Wenn wir
fertig sind, wird <code>main</code> prägnant und leicht durch Inspektion zu verifizieren
sein, und wir werden in der Lage sein, Tests für all die andere Logik zu
schreiben.</p>
<p>Codeblock 12-11 zeigt die extrahierte Funktion <code>run</code>. Im Moment machen wir nur
die kleine, inkrementelle Verbesserung durch Extrahieren der Funktion. Wir sind
immer noch dabei, die Funktion in <em>src/main.rs</em> zu definieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Etwas ging beim Lesen der Datei schief&quot;);

    println!(&quot;Mit text:\n{}&quot;, contents);
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-11: Extrahieren einer Funktion <code>run</code>, die
den Rest der Programmlogik enthält</span></p>
<p>Die Funktion <code>run</code> enthält nun die gesamte restliche Logik von <code>main</code>,
beginnend mit dem Lesen der Datei. Die Funktion <code>run</code> nimmt die
<code>Config</code>-Instanz als Argument.</p>
<h4><a class="header" href="#rückgabe-von-fehlern-aus-der-funktion-run" id="rückgabe-von-fehlern-aus-der-funktion-run">Rückgabe von Fehlern aus der Funktion <code>run</code></a></h4>
<p>Wenn die verbleibende Programmlogik in die Funktion <code>run</code> separiert wird,
können wir die Fehlerbehandlung verbessern, wie wir es mit <code>Config::new</code> in
Codeblock 12-9 getan haben. Anstatt das Programm durch den Aufruf von <code>expect</code>
abstürzen zu lassen, gibt die Funktion <code>run</code> ein <code>Result&lt;T, E&gt;</code> zurück, wenn
etwas schief läuft. Auf diese Weise können wir in <code>main</code> die Logik rund um den
Umgang mit Fehlern auf benutzerfreundliche Weise weiter konsolidieren.
Codeblock 12-12 zeigt die Änderungen, die wir an der Signatur und dem Rumpf von
<code>run</code> vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;Mit text:\n{}&quot;, contents);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-12: Ändern der Funktion <code>run</code>, um ein
<code>Result</code> zurückzugeben</p>
<p>Wir haben hier drei wesentliche Änderungen vorgenommen. Erstens haben wir den
Rückgabetyp der Funktion <code>run</code> in <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> geändert. Diese
Funktion gab zuvor den Einheitstyp <code>()</code> zurück und wir behalten diesen als
Rückgabewert im Fall <code>Ok</code> bei.</p>
<p>Für den Fehlertyp haben wir das <em>Merkmalsobjekt</em> (trait object) <code>Box&lt;dyn Error&gt;</code> verwendet (und wir haben <code>std::error::Error</code> mit einer <code>use</code>-Anweisung
am Anfang des Gültigkeitsbereichs eingebunden). Wir werden Merkmalsobjekte in
<a href="ch17-00-oop.html">Kapitel 17</a> behandeln. Für den Moment solltest du nur wissen, dass
<code>Box&lt;dyn Error&gt;</code> bedeutet, dass die Funktion einen Typ zurückgibt, der das
Merkmal <code>Error</code> implementiert, aber wir müssen nicht angeben, welcher bestimmte
Typ der Rückgabewert sein wird. Das gibt uns die Flexibilität, Fehlerwerte
zurückzugeben, die in verschiedenen Fehlerfällen von unterschiedlichem Typ sein
können. Das Schlüsselwort <code>dyn</code> ist die Abkürzung für „dynamisch“.</p>
<p>Zweitens haben wir den Aufruf von <code>expect</code> zugunsten des <code>?</code>-Operators
entfernt, wie wir in <a href="ch09-02-recoverable-errors-with-result.html#abk%C3%BCrzung-zum-weitergeben-von-fehlern-der-operator-">Kapitel 9</a> besprochen haben. Statt
<code>panic!</code> bei einem Fehler aufzurufen gibt <code>?</code> den Fehlerwert aus der aktuellen
Funktion zurück, den der Aufrufer behandeln muss.</p>
<p>Drittens gibt die Funktion <code>run</code> jetzt im Erfolgsfall einen <code>Ok</code>-Wert zurück.
Wir haben den Erfolgstyp der Funktion <code>run</code> mit <code>()</code> in der Signatur
deklariert, was bedeutet, dass wir den Wert des Einheitstyps in den Wert <code>Ok</code>
einpacken müssen. Diese Syntax <code>Ok((())</code> mag zunächst etwas merkwürdig
aussehen, aber wenn wir <code>()</code> so verwenden, ist das der idiomatische Weg, um
anzuzeigen, dass wir <code>run</code> nur wegen seiner Nebenwirkungen aufrufen; es gibt
keinen Wert zurück, den wir brauchen.</p>
<p>Wenn du diesen Code ausführst, wird er kompiliert, aber es wird eine Warnung
angezeigt:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Suche nach the
In Datei poem.txt
Mit text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Rust sagt uns, dass unser Code den <code>Result</code>-Wert ignoriert hat, und der
<code>Result</code>-Wert könnte darauf hinweisen, dass ein Fehler aufgetreten ist. Aber
wir überprüfen nicht, ob ein Fehler aufgetreten ist oder nicht, und der
Compiler erinnert uns daran, dass wir wahrscheinlich gemeint haben, hier etwas
Fehlerbehandlungscode zu haben! Lass uns dieses Problem jetzt beheben.</p>
<h4><a class="header" href="#behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden" id="behandeln-von-fehlern-die-von-run-in-main-zurückgegeben-wurden">Behandeln von Fehlern, die von <code>run</code> in <code>main</code> zurückgegeben wurden</a></h4>
<p>Wir werden nach Fehlern suchen und sie mit einer Technik behandeln, die ähnlich
der Technik ist, die wir mit <code>Config::new</code> in Codeblock 12-10 verwendet haben,
aber mit einem kleinen Unterschied:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --abschneiden--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Suche nach {}&quot;, config.query);
    println!(&quot;In Datei {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Anwendungsfehler: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>Wir benutzen <code>if let</code> statt <code>unwrap_or_else</code>, um zu prüfen, ob <code>run</code> einen
<code>Err</code>-Wert zurückgibt und rufen <code>process::exit(1)</code> auf, wenn dies der Fall ist.
Die Funktion <code>run</code> gibt keinen Wert zurück, den wir mit <code>unwrap</code> auspacken
wollen, auf die gleiche Weise, wie <code>Config::new</code> die <code>Config</code>-Instanz
zurückgibt. Da <code>run</code> im Erfolgsfall <code>()</code> zurückgibt, geht es uns nur darum,
einen Fehler zu entdecken, wir brauchen also nicht <code>unwrap_or_else</code>, um den
ausgepackten Wert zurückzugeben, weil er nur <code>()</code> wäre.</p>
<p>Die Rümpfe von <code>if let</code> und der <code>unwrap_or_else</code>-Funktionen sind in beiden
Fällen gleich: Wir geben den Fehler aus und beenden.</p>
<h3><a class="header" href="#code-in-eine-bibliothekskiste-aufteilen" id="code-in-eine-bibliothekskiste-aufteilen">Code in eine Bibliothekskiste aufteilen</a></h3>
<p>Unser <code>minigrep</code>-Projekt sieht soweit gut aus! Jetzt teilen wir die Datei
<em>src/main.rs</em> auf und fügen etwas Code in die Datei <em>src/lib.rs</em> ein, damit wir
sie testen können und eine Datei <em>src/main.rs</em> mit weniger Verantwortlichkeiten
haben.</p>
<p>Lass uns den ganzen Code, der nicht die Funktion <code>main</code> ist, von <em>src/main.rs</em>
nach <em>src/lib.rs</em> verschieben:</p>
<ul>
<li>Die Definition der Funktion <code>run</code></li>
<li>Die relevanten <code>use</code>-Anweisungen</li>
<li>Die Definition von <code>Config</code></li>
<li>Die Funktionsdefinition <code>Config::new</code></li>
</ul>
<p>Der Inhalt von <em>src/lib.rs</em> sollte die in Codeblock 12-13 gezeigten Signaturen
haben (wir haben die Rümpfe der Funktionen der Kürze halber weggelassen).
Beachte, dass dies nicht kompiliert werden kann, bis wir <em>src/main.rs</em> in
Codeblock 12-14 modifiziert haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --abschneiden--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --abschneiden--
<span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Mit text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Codeblock 12-13: Verschieben von <code>Config</code> und <code>run</code> in
<em>src/lib.rs</em></span></p>
<p>Wir haben das Schlüsselwort <code>pub</code> großzügig verwendet: Bei <code>Config</code>, bei seinen
Feldern und seiner Methode <code>new</code> und bei der Funktion <code>run</code>. Wir haben jetzt
eine Bibliothekskiste, die eine öffentliche API hat, die wir testen können!</p>
<p>Jetzt müssen wir den Code, den wir nach <em>src/lib.rs</em> verschoben haben, in den
Gültigkeitsbereich der Binärkiste in <em>src/main.rs</em> bringen, wie in Codeblock
12-14 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --abschneiden--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Suche nach {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In Datei {}&quot;, config.filename);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --abschneiden--
<span class="boring">        println!(&quot;Anwendungsfehler: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">Codeblock 12-14: Verwenden der
<code>minigrep</code>-Bibliothekskiste in <em>src/main.rs</em></span></p>
<p>Wir fügen eine Zeile <code>use minigrep::Config</code> hinzu, um den Typ <code>Config</code> aus der
Bibliothekskiste in den Gültigkeitsbereich der Binärkiste zu bringen, und wir
stellen der Funktion <code>run</code> unseren Kistennamen voran. Nun sollte die gesamte
Funktionalität verbunden sein und funktionieren. Starte das Programm mit <code>cargo run</code> und stelle sicher, dass alles korrekt funktioniert.</p>
<p>Puh! Das war eine Menge Arbeit, aber wir haben uns für den Erfolg in der
Zukunft gerüstet. Jetzt ist es viel einfacher, mit Fehlern umzugehen, und wir
haben den Code modularer gestaltet. Fast unsere gesamte Arbeit wird von nun an
in <em>src/lib.rs</em> durchgeführt.</p>
<p>Lass uns diese neu gewonnene Modularität nutzen, indem wir etwas tun, was mit
dem alten Code schwierig gewesen wäre, mit dem neuen Code aber einfach ist: Wir
schreiben ein paar Tests!</p>
<h2><a class="header" href="#bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen" id="bibliotheksfunktionalität-mit-testgetriebener-entwicklung-erstellen">Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></h2>
<p>Jetzt, da wir die Logik nach <em>src/lib.rs</em> extrahiert haben und die
Argumentkollektion und Fehlerbehandlung in <em>src/main.rs</em> belassen haben, ist es
viel einfacher, Tests für die Kernfunktionalität unseres Codes zu schreiben.
Wir können Funktionen direkt mit verschiedenen Argumenten aufrufen und
Rückgabewerte überprüfen, ohne unsere Binärdatei von der Kommandozeile aus
aufrufen zu müssen. Fühle dich frei, einige Tests für die Funktionalität in den
Funktionen <code>Config::new</code> und <code>run</code> selbst zu schreiben.</p>
<p>In diesem Abschnitt fügen wir dem <code>minigrep</code>-Programm die Suchlogik hinzu,
indem wir die Methode der testgetriebenen Entwicklung (TDD) verwenden. Diese
Softwareentwicklungstechnik folgt diesen Schritten:</p>
<ol>
<li>Schreibe einen Test, der fehlschlägt, und führe ihn aus, um sicherzustellen,
dass er aus dem von dir erwarteten Grund fehlschlägt.</li>
<li>Schreibe oder modifiziere gerade genug Code, um den neuen Test zu bestehen.</li>
<li>Refaktoriere den Code, den du gerade hinzugefügt oder geändert hast, und
stelle sicher, dass die Tests weiterhin bestanden werden.</li>
<li>Wiederhole ab Schritt 1!</li>
</ol>
<p>Diese Methode ist nur eine von vielen Möglichkeiten, Software zu schreiben,
aber TDD kann auch beim Code-Design helfen. Das Schreiben der Tests vor dem
Schreiben des Codes, der den Test bestehen lässt, trägt dazu bei, während des
gesamten Entwicklungsprozesses eine hohe Testabdeckung aufrechtzuerhalten.</p>
<p>Wir werden die Implementierung der Funktionalität testen, die tatsächlich die
Suche nach der Suchzeichenkette im Dateiinhalt durchführt und eine Liste von
Zeilen erzeugt, die der Suchabfrage entsprechen. Wir werden diese
Funktionalität in einer Funktion namens <code>search</code> hinzufügen.</p>
<h3><a class="header" href="#schreiben-eines-fehlschlagenden-tests" id="schreiben-eines-fehlschlagenden-tests">Schreiben eines fehlschlagenden Tests</a></h3>
<p>Da wir sie nicht mehr benötigen, entfernen wir die <code>println!</code> -Anweisungen aus
<em>src/lib.rs</em> und <em>src/main.rs</em>, die wir zum Überprüfen des Programmverhaltens
verwendet haben. Dann fügen wir in <em>src/lib.rs</em> ein Modul <code>tests</code> mit einer
Testfunktion hinzu, wie wir es in <a href="ch11-01-writing-tests.html#anatomie-einer-testfunktion">Kapitel 11</a> getan haben. Die
Testfunktion spezifiziert das Verhalten, das die Funktion <code>search</code> haben soll:
Sie nimmt eine Suchabfrage und den Text, in dem gesucht werden soll, entgegen
und gibt nur die Zeilen aus dem Text zurück, die die Suchabfrage enthalten.
Codeblock 12-15 zeigt diesen Test, der sich noch nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;dukt&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.&quot;;

        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-15: Erstellen eines fehlschlagenden Tests
für die Funktion <code>search</code>, die wir uns wünschen</span></p>
<p>Dieser Test sucht nach der Zeichenkette <code>&quot;dukt&quot;</code>. Der Text, den wir
durchsuchen, besteht aus drei Zeilen, von denen nur eine <code>&quot;dukt&quot;</code> enthält. Wir
verlangen, dass der von der Funktion <code>search</code> zurückgegebene Wert nur die Zeile
enthält, die wir erwarten.</p>
<p>Wir sind nicht in der Lage, diesen Test auszuführen und zuzusehen, wie er
fehlschlägt, weil der Test noch nicht mal kompiliert: Die Funktion <code>search</code>
existiert noch nicht! Daher fügen wir jetzt gerade genug Code hinzu, um den
Test zum Kompilieren und Ausführen zu bringen, indem wir eine Definition der
Funktion <code>search</code> hinzufügen, die immer einen leeren Vektor zurückgibt, wie in
Codeblock 12-16 gezeigt. Dann sollte der Test kompiliert werden können und
fehlschlagen, weil ein leerer Vektor nicht mit einem Vektor übereinstimmt, der
die Zeile <code>&quot;sicher, schnell, produktiv.&quot;</code> enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-16: Definiere gerade genug von der Funktion
<code>search</code>, damit unser Test kompiliert</span></p>
<p>Beachte, dass wir eine explizite Lebensdauer <code>'a</code> in der Signatur von <code>search</code>
benötigen und diese beim Argument <code>contents</code> und dem Rückgabewert verwenden.
Erinnere dich in <a href="ch10-03-lifetime-syntax.html">Kapitel 10</a> daran, dass die
Lebensdauer-Parameter angeben, welche Argument-Lebensdauer mit der Lebensdauer
des Rückgabewertes verbunden ist. In diesem Fall geben wir an, dass der
zurückgegebene Vektor Zeichenkettenanteilstypen enthalten sollte, die auf
Anteilstypen des Arguments <code>contents</code> (und nicht auf das Argument <code>query</code>)
referenzieren.</p>
<p>Mit anderen Worten sagen wir Rust, dass die von der Funktion <code>search</code>
zurückgegebenen Daten so lange leben, wie die Daten, die im Argument <code>contents</code>
an die Funktion <code>search</code> übergeben werden. Das ist wichtig! Die Daten, auf die
durch einen Anteilstyp <em>referenziert</em> wird, müssen gültig sein, damit die
Referenz gültig ist; wenn der Compiler annimmt, dass wir
Zeichenkettenanteilstypen aus <code>query</code> statt aus <code>contents</code> erstellen, wird er
seine Sicherheitsprüfung falsch durchführen.</p>
<p>Wenn wir die Lebensdauer-Annotationen vergessen und versuchen, diese Funktion
zu kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                                                   ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust kann unmöglich wissen, welches der beiden Argumente wir brauchen, also
müssen wir es ihm sagen. Da <code>contents</code> das Argument ist, das unseren gesamten
Text enthält, und wir diejenigen Teile dieses Textes zurückgeben wollen, die
passen, wissen wir, dass <code>contents</code> das Argument ist, das mit dem Rückgabewert
unter Verwendung der Lebensdauer-Syntax verbunden werden sollte.</p>
<p>Bei anderen Programmiersprachen ist es nicht erforderlich, Argumente zu
verbinden, um Werte in der Signatur zurückzugeben. Obwohl dies seltsam
erscheinen mag, wird es mit der Zeit einfacher werden. Vergleiche dieses
Beispiel mit dem Abschnitt <a href="ch10-03-lifetime-syntax.html">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10.</p>
<p>Lass uns jetzt den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Toll, der Test schlägt fehl, genau wie wir erwartet haben. Bringen wir den Test
zum Bestehen!</p>
<h3><a class="header" href="#code-schreiben-um-den-test-zu-bestehen" id="code-schreiben-um-den-test-zu-bestehen">Code schreiben, um den Test zu bestehen</a></h3>
<p>Derzeit scheitert unser Test, weil wir immer einen leeren Vektor zurückgeben.
Um dies zu korrigieren und <code>search</code> zu implementieren, muss unser Programm die
folgenden Schritte befolgen:</p>
<ul>
<li>Iteriere über jede Zeile des Inhalts.</li>
<li>Prüfe, ob die Zeile unseren Abfragetext enthält.</li>
<li>Wenn ja, füge sie der Liste der Werte hinzu, die wir zurückgeben.</li>
<li>Wenn nicht, tue nichts.</li>
<li>Gib die Liste der passenden Ergebnisse zurück.</li>
</ul>
<p>Lass uns jeden Schritt durcharbeiten, beginnend mit dem Iterieren über die
Zeilen.</p>
<h4><a class="header" href="#iterieren-über-zeilen-mit-der-methode-lines" id="iterieren-über-zeilen-mit-der-methode-lines">Iterieren über Zeilen mit der Methode <code>lines</code></a></h4>
<p>Rust hat eine hilfreiche Methode zum zeilenweisen Iterieren von Zeichenketten,
bequemerweise <code>lines</code> genannt, die wie in Codeblock 12-17 gezeigt funktioniert.
Beachte, dass dies noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // mache etwas mit line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-17: Iteriere über jede Zeile in
<code>contents</code></span></p>
<p>Die Methode <code>lines</code> gibt einen Iterator zurück. Wir werden in <a href="ch13-02-iterators.html">Kapitel
13</a> ausführlich über Iteratoren sprechen, aber erinnere dich
daran, dass du diese Art der Verwendung eines Iterators in <a href="ch03-05-control-flow.html#wiederholen-anhand-einer-kollektion-mit-for">Codeblock
3-5</a> gesehen hast, wo wir eine <code>for</code>-Schleife mit einem Iterator
benutzt haben, um etwas Code für jedes Element in einer Kollektion auszuführen.</p>
<h4><a class="header" href="#durchsuchen-aller-zeilen-nach-dem-abfragetext" id="durchsuchen-aller-zeilen-nach-dem-abfragetext">Durchsuchen aller Zeilen nach dem Abfragetext</a></h4>
<p>Als nächstes prüfen wir, ob die aktuelle Zeile unsere Abfragezeichenkette
enthält. Glücklicherweise haben Zeichenketten eine hilfreiche Methode namens
<code>contains</code>, die dies für uns erledigt! Füge einen Aufruf der <code>contains</code>-Methode
in der Funktion <code>search</code> hinzu, wie in Codeblock 12-18 gezeigt. Beachte, dass
dies noch nicht kompiliert werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // mache etwas mit line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-18: Hinzufügen von Funktionalität, um zu
sehen, ob die Zeile die Zeichenkette in <code>query</code> enthält</span></p>
<h4><a class="header" href="#speichern-passender-zeilen" id="speichern-passender-zeilen">Speichern passender Zeilen</a></h4>
<p>Wir brauchen auch eine Möglichkeit, die Zeilen zu speichern, die unsere
Abfragezeichenkette enthalten. Dafür können wir einen veränderlichen Vektor vor
der <code>for</code>-Schleife erstellen und die <code>push</code>-Methode aufrufen, um eine <code>line</code> im
Vektor zu speichern. Nach der <code>for</code>-Schleife geben wir den Vektor zurück, wie
in Codeblock 12-19 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-19: Speichern der passenden Zeilen, damit
wir sie zurückgeben können</span></p>
<p>Jetzt sollte die Funktion <code>search</code> nur noch die Zeilen zurückgeben, die <code>query</code>
enthalten, und unser Test sollte erfolgreich sein. Lass uns den Test ausführen:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Unser Test war erfolgreich, also wissen wir, dass es funktioniert!</p>
<p>An diesem Punkt könnten wir Möglichkeiten für eine Refaktorierung der
Implementierung der Suchfunktion in Betracht ziehen, während die Tests
weiterlaufen, um die gleiche Funktionalität zu erhalten. Der Code in der
Suchfunktion ist nicht allzu schlecht, aber er macht sich einige nützliche
Funktionen der Iteratoren nicht zunutze. Wir kehren zu diesem Beispiel in
<a href="ch13-02-iterators.html">Kapitel 13</a> zurück, wo wir Iteratoren im Detail untersuchen
und uns ansehen, wie man sie verbessern kann.</p>
<h4><a class="header" href="#verwenden-der-funktion-search-in-der-funktion-run" id="verwenden-der-funktion-search-in-der-funktion-run">Verwenden der Funktion <code>search</code> in der Funktion <code>run</code></a></h4>
<p>Da die Funktion <code>search</code> nun funktioniert und getestet ist, müssen wir <code>search</code>
von unserer Funktion <code>run</code> aus aufrufen. Wir müssen den Wert <code>config.query</code> und
den Wert <code>contents</code>, den <code>run</code> aus der Datei liest, an die Funktion <code>search</code>
übergeben. Dann wird <code>run</code> jede von <code>search</code> zurückgegebene Zeile ausgeben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Wir benutzen immer noch eine <code>for</code>-Schleife, um jede Zeile von <code>search</code>
zurückzugeben und auszugeben.</p>
<p>Jetzt sollte das gesamte Programm funktionieren! Lass es uns ausprobieren,
zunächst mit einem Wort, das genau eine Zeile aus dem Emily-Dickinson-Gedicht
wiedergeben sollte: „frog“</p>
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Versuchen wir nun ein Wort, das zu mehreren Zeilen passt, wie „body“:</p>
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Und schließlich sollten wir sicherstellen, dass wir keine Zeilen bekommen, wenn
wir nach einem Wort suchen, das nirgendwo im Gedicht vorkommt, zum Beispiel
„monomorphization“:</p>
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Ausgezeichnet! Wir haben unsere eigene Miniversion eines klassischen Tools
gebaut und viel darüber gelernt, wie man Anwendungen strukturiert. Wir haben
auch ein wenig über Dateieingabe und -ausgabe, Lebensdauer, Testen und
Kommandozeilen-Parsen gelernt.</p>
<p>Um dieses Projekt abzurunden, werden wir kurz demonstrieren, wie man mit
Umgebungsvariablen arbeitet und wie man Standardfehler ausgibt, beides ist
nützlich, wenn du Kommandozeilenprogramme schreibst.</p>
<h2><a class="header" href="#mit-umgebungsvariablen-arbeiten" id="mit-umgebungsvariablen-arbeiten">Mit Umgebungsvariablen arbeiten</a></h2>
<p>Wir werden <code>minigrep</code> verbessern, indem wir eine zusätzliche Funktionalität
hinzufügen: Eine Option für die Suche unabhängig von der Groß-/Kleinschreibung,
die der Benutzer über eine Umgebungsvariable einschalten kann. Wir könnten
diese Funktion zu einer Kommandozeilenoption machen und verlangen, dass die
Benutzer sie jedes Mal eingeben müssen, wenn sie angewendet werden soll, aber
stattdessen werden wir eine Umgebungsvariable verwenden. Auf diese Weise können
unsere Benutzer die Umgebungsvariable einmal setzen und alle Suchvorgänge in
dieser Terminalsitzung ohne Berücksichtigung der Groß-/Kleinschreibung
durchführen.</p>
<h3><a class="header" href="#schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung" id="schreiben-eines-fehlschlagenden-tests-für-die-suche-unabhängig-von-der-groß-kleinschreibung">Schreiben eines fehlschlagenden Tests für die Suche unabhängig von der Groß-/Kleinschreibung</a></h3>
<p>Wir wollen eine neue Funktion <code>search_case_insensitive</code> hinzufügen, die wir
aufrufen werden, wenn die Umgebungsvariable gesetzt ist. Wir werden die
TDD-Methode weiter verfolgen, sodass der erste Schritt wieder darin besteht,
einen fehlschlagenden Test zu schreiben. Wir werden einen neuen Test für die
neue Funktion <code>search_case_insensitive</code> hinzufügen und unseren alten Test von
<code>one_result</code> in <code>case_sensitive</code> umbenennen, um die Unterschiede zwischen den
beiden Tests zu verdeutlichen, wie in Codeblock 12-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;dukt&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.
PRODUKTION.&quot;;

        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
sicher, schnell, produktiv.
Nimm drei.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-20: Hinzufügen eines neuen fehlschlagenden
Tests für die Funktion <code>search_case_insensitive</code>, die wir gleich hinzufügen
werden</span></p>
<p>Beachte, dass wir auch den Inhalt des alten Tests bearbeitet haben. Wir haben
eine neue Zeile mit dem Text <code>&quot;PRODUKTION.&quot;</code> in Großbuchstaben hinzugefügt,
die nicht mit dem Abfragetext <code>&quot;dukt&quot;</code> übereinstimmen sollte, wenn wir bei der
Suche die Groß-/Kleinschreibung beachten. Wenn wir den alten Test auf diese
Weise ändern, stellen wir sicher, dass wir nicht versehentlich die bereits
implementierte Suchfunktionalität unter Berücksichtigung der
Groß-/Kleinschreibung kaputt machen. Dieser Test sollte jetzt erfolgreich sein
und er sollte es auch bleiben, während wir an der Suche unabhängig von der
Groß-/Kleinschreibung arbeiten.</p>
<p>Der neue Test <code>case_insensitive</code> verwendet <code>&quot;rUsT&quot;</code> als Suchabfrage. In der
Funktion <code>search_case_insensitive</code>, die wir gerade hinzufügen wollen, sollte
der Abfragetext <code>&quot;rUsT&quot;</code> zur Zeile, die <code>&quot;Rust:&quot;</code> mit einem großen R enthält,
passen und zur Zeile <code>&quot;Trust me.&quot;</code>, obwohl beide eine andere Schreibweise haben
als der Abfragetext. Dies ist unser fehlschlagender Test und er wird sich nicht
kompilieren lassen, weil wir die Funktion <code>search_case_insensitive</code> noch nicht
definiert haben. Es steht dir frei, eine Skelett-Implementierung hinzuzufügen,
die immer einen leeren Vektor zurückgibt, ähnlich wie wir es für die Funktion
<code>search</code> in Codeblock 12-16 getan haben, um zu sehen, wie der Test kompilieren
wird und fehlschlägt.</p>
<h3><a class="header" href="#implementieren-der-funktion-search_case_insensitive" id="implementieren-der-funktion-search_case_insensitive">Implementieren der Funktion <code>search_case_insensitive</code></a></h3>
<p>Die Funktion <code>search_case_insensitive</code>, die in Codeblock 12-21 gezeigt wird,
wird fast die gleiche sein wie die Funktion <code>search</code>. Der einzige Unterschied
besteht darin, dass wir <code>query</code> und <code>line</code> in Kleinbuchstaben umwandeln, sodass
sie unabhängig von der Groß-/Kleinschreibung der Eingabe-Argumente sind, wenn
wir prüfen, ob die Zeile die Abfrage enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-21: Definieren der Funktion
<code>search_case_insensitive</code>, um den Abfragetext und die Zeile vor dem Vergleich
in Kleinbuchstaben umzuwandeln</span></p>
<p>Zuerst wandeln wir die Zeichenkette <code>query</code> in Kleinbuchstaben um und speichern
ihn in einer beschatteten Variablen mit dem gleichen Namen. Der Aufruf von
<code>to_lowercase</code> beim Abfragetext ist notwendig, sodass wir unabhängig davon, ob
die Abfrage des Benutzers <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;RUST&quot;</code> oder <code>&quot;rUsT&quot;</code> ist, die
Abfrage so behandeln, als ob sie <code>&quot;rust&quot;</code> wäre, und die Groß-/Kleinschreibung
nicht beachten. Obwohl <code>to_lowercase</code> mit einfachem Unicode umgehen kann, wird
es nicht 100% genau sein. Wenn wir eine echte Anwendung schreiben würden,
würden wir hier etwas mehr Arbeit spendieren wollen, aber in diesem Abschnitt
geht es um Umgebungsvariablen, nicht um Unicode, also belassen wir es hier
dabei.</p>
<p>Beachte, dass <code>query</code> jetzt ein <code>String</code> und nicht mehr ein
Zeichenkettenanteilstyp ist, weil der Aufruf von <code>to_lowercase</code> neue Daten
erzeugt, anstatt auf bestehende Daten zu referenzieren. Nehmen wir als Beispiel
an, der Abfragetext sei <code>&quot;rUsT&quot;</code>, dieser Zeichenkettenanteilstyp enthält kein
kleingeschriebenes <code>u</code> oder <code>t</code>, das wir verwenden könnten, also müssen wir
einen neuen <code>String</code> zuweisen, der <code>&quot;rust&quot;</code> enthält. Wenn wir nun <code>query</code> als
Argument an die <code>contains</code>-Methode übergeben, müssen wir ein <code>&amp;</code>-Zeichen
angeben, weil die Signatur von <code>contains</code> so definiert ist, dass sie einen
Zeichenkettenanteilstyp nimmt.</p>
<p>Als nächstes fügen wir einen Aufruf von <code>to_lowercase</code> für jede <code>line</code> ein,
bevor wir prüfen, ob sie <code>query</code> enthält, um alle Zeichen kleinzuschreiben. Da
wir nun <code>line</code> und <code>query</code> in Kleinbuchstaben umgewandelt haben, werden wir
passende Zeilen finden, egal wie die Groß-/Kleinschreibung der Abfrage ist.</p>
<p>Warten wir ab, ob diese Implementierung die Tests besteht:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running target/debug/deps/minigrep-4672b652f7794785

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Großartig! Sie haben bestanden. Lass uns nun die neue Funktion
<code>search_case_insensitive</code> von der Funktion <code>run</code> aufrufen. Zuerst fügen wir
eine Konfigurationsoption zur <code>Config</code>-Struktur hinzu, um zwischen der Suche
mit und ohne Berücksichtigung der Groß- und Kleinschreibung umzuschalten. Das
Hinzufügen dieses Feldes führt zu Kompilierfehlern, da wir dieses Feld noch
nirgendwo initialisiert haben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Beachte, dass wir das Feld <code>case_sensitive</code> hinzugefügt haben, das ein Boolean
enthält. Als Nächstes benötigen wir die Funktion <code>run</code>, um den Wert des Feldes
<code>case_sensitive</code> auszuwerten, und verwenden diese, um zu entscheiden, ob die
Funktion <code>search</code> oder die Funktion <code>search_case_insensitive</code> aufgerufen werden
soll, wie in Codeblock 12-22 gezeigt. Beachte, dass dies noch nicht kompiliert
werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;Nicht genügend Argumente&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-22: Aufruf von entweder <code>search</code> oder
<code>search_case_insensitive</code> basierend auf dem Wert in
<code>config.case_sensitive</code></span></p>
<p>Schließlich müssen wir nach der Umgebungsvariablen suchen. Die Funktionen zum
Arbeiten mit Umgebungsvariablen befinden sich im Modul <code>env</code> in der
Standardbibliothek, daher wollen wir dieses Modul mit einer Zeile <code>use std::env;</code> am Anfang von <em>src/lib.rs</em> in den Gültigkeitsbereich bringen. Dann
werden wir die Funktion <code>var</code> aus dem Modul <code>env</code> verwenden, um auf eine
Umgebungsvariable namens <code>CASE_INSENSITIVE</code> zu prüfen, wie in Codeblock 12-23
gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;
// --abschneiden--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;Nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;dukt&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">PRODUKTION.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sicher, schnell, produktiv.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sicher, schnell, produktiv.
</span><span class="boring">Nimm drei.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 12-23: Prüfen auf eine Umgebungsvariable namens
<code>CASE_INSENSITIVE</code></span></p>
<p>Hier erstellen wir eine neue Variable <code>case_sensitive</code>. Um ihren Wert zu
setzen, rufen wir die Funktion <code>env::var</code> auf und übergeben ihr den Namen der
Umgebungsvariablen <code>CASE_INSENSITIVE</code>. Die Funktion <code>env::var</code> gibt ein
<code>Result</code> zurück, das die erfolgreiche <code>Ok</code>-Variante ist, die den Wert der
Umgebungsvariablen enthält, wenn die Umgebungsvariable gesetzt ist. Sie gibt
die Variante <code>Err</code> zurück, wenn die Umgebungsvariable nicht gesetzt ist.</p>
<p>Wir benutzen die Methode <code>is_err</code> auf <code>Result</code>, um zu prüfen, ob es sich um
einen Fehler handelt und daher nicht gesetzt ist, was bedeutet, dass die Suche
unter Berücksichtigung der Groß-/Kleinschreibung durchgeführt werden soll. Wenn
die Umgebungsvariable <code>CASE_INSENSITIVE</code> auf irgendetwas gesetzt ist, gibt
<code>is_err</code> den Wert false zurück und das Programm führt eine Suche ohne
Berücksichtigung der Groß-/Kleinschreibung durch. Wir kümmern uns nicht um den
<em>Wert</em> der Umgebungsvariablen, nur darum, ob sie gesetzt ist oder nicht, also
prüfen wir mit <code>is_err</code>, anstatt mit <code>unwrap</code>, <code>expect</code> oder einer der anderen
Methoden, die wir bei <code>Result</code> gesehen haben.</p>
<p>Wir übergeben den Wert in der Variablen <code>case_sensitive</code> an die
<code>Config</code>-Instanz, sodass die Funktion <code>run</code> diesen Wert lesen und entscheiden
kann, ob sie <code>search</code> oder <code>search_case_insensitive</code> aufrufen soll, wie wir es
in Codeblock 12-22 implementiert haben.</p>
<p>Lass es uns versuchen! Zuerst führen wir unser Programm ohne die gesetzte
Umgebungsvariable und mit dem Abfragetext <code>to</code> aus, die zu den Zeilen passen
sollte, die das Wort <code>to</code> in Kleinbuchstaben enthalten:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Sieht so aus, als ob das immer noch funktioniert! Lass uns nun das Programm mit
<code>CASE_INSENSITIVE</code> auf <code>1</code> gesetzt ausführen, aber mit dem gleichen Abfragetext
<code>to</code>.</p>
<p>Wenn du die PowerShell verwendest, sind das Setzen der Umgebungsvariable und
das Ausführen des Programms separate Befehle:</p>
<pre><code class="language-console">PS&gt; $Env:CASE_INSENSITIVE=1; cargo run to poem.txt
</code></pre>
<p>Dadurch bleibt <code>CASE_INSENSITIVE</code> für den Rest deiner Shell-Sitzung bestehen.
Sie kann mit <code>Remove-Item</code> zurückgesetzt werden:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:CASE_INSENSITIVE
</code></pre>
<p>Wir sollten Zeilen erhalten, die „to“ enthalten, die Großbuchstaben haben
könnten:</p>
<pre><code class="language-console">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ausgezeichnet, wir haben auch Zeilen mit „to“! Unser <code>minigrep</code>-Programm kann
jetzt ohne Berücksichtigung von Groß-/Kleinschreibung suchen, gesteuert durch
eine Umgebungsvariable. Jetzt weißt du, wie man Optionen verwaltet, die
entweder mit Kommandozeilenargumenten oder Umgebungsvariablen gesetzt werden.</p>
<p>Einige Programme erlauben Argumente <em>und</em> Umgebungsvariablen für die gleiche
Konfiguration. In diesen Fällen entscheiden die Programme, dass das eine oder
das andere Vorrang hat. Versuche für eine weitere eigene Übung, die Steuerung,
ob die Groß-/Kleinschreibung berücksichtigt werden soll, entweder über ein
Kommandozeilenargument oder eine Umgebungsvariable zu ermöglichen. Entscheide,
ob das Kommandozeilenargument oder die Umgebungsvariable Vorrang haben soll,
wenn das Programm mit widersprüchlichen Optionen ausgeführt wird.</p>
<p>Das Modul <code>std::env</code> enthält viele weitere nützliche Funktionalitäten für den
Umgang mit Umgebungsvariablen: Schaue in seine Dokumentation, um zu sehen, was
verfügbar ist.</p>
<h2><a class="header" href="#fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben" id="fehlermeldungen-in-die-standardfehlerausgabe-anstatt-der-standardausgabe-schreiben">Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></h2>
<p>Im Moment schreiben wir unsere gesamte Ausgabe mit dem Makro <code>println!</code> auf das
Terminal. Die meisten Terminals bieten zwei Arten der Ausgabe:
<em>Standardausgabe</em> (<code>stdout</code>) für allgemeine Informationen und
<em>Standardfehlerausgabe</em> (<code>stderr</code>) für Fehlermeldungen. Diese Unterscheidung
ermöglicht es dem Benutzer, die erfolgreiche Ausgabe eines Programms in eine
Datei zu leiten, aber dennoch Fehlermeldungen auf dem Bildschirm auszugeben.</p>
<p>Das Makro <code>println!</code> ist nur in der Lage, auf die Standardausgabe zu schreiben,
also müssen wir etwas anderes verwenden, um auf die Standardfehlerausgabe zu
schreiben.</p>
<h3><a class="header" href="#prüfen-wo-fehler-ausgegeben-werden" id="prüfen-wo-fehler-ausgegeben-werden">Prüfen, wo Fehler ausgegeben werden</a></h3>
<p>Lass uns zunächst beobachten, wie der von <code>minigrep</code> ausgegebene Inhalt derzeit
in die Standardausgabe geschrieben wird, einschließlich aller Fehlermeldungen,
die wir stattdessen in die Standardfehlerausgabe schreiben wollen. Wir tun
dies, indem wir die Standardausgabe in eine Datei umleiten und dabei auch
absichtlich einen Fehler verursachen. Wir werden die Standardfehlerausgabe
nicht umleiten, sodass alle Inhalte, die an die Standardfehlerausgabe gesendet
werden, weiterhin auf dem Bildschirm angezeigt werden.</p>
<p>Von Kommandozeilenprogrammen wird erwartet, dass sie Fehlermeldungen an die
Standardfehlerausgabe senden, sodass wir Fehlermeldungen auch dann noch auf dem
Bildschirm sehen können, wenn wir die Standardausgabe in eine Datei umleiten.
Unser Programm ist zur Zeit nicht sehr brav: Wir werden gleich sehen, dass es
die ausgegebenen Fehlermeldungen stattdessen in eine Datei speichert!</p>
<p>Der Weg, dieses Verhalten zu demonstrieren, besteht darin, das Programm mit <code>&gt;</code>
und dem Dateinamen <em>output.txt</em> laufen zu lassen, zu dem wir die
Standardausgabe umleiten wollen. Wir werden keine Argumente übergeben, was
einen Fehler verursachen sollte:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>Die Syntax <code>&gt;</code> weist die Shell an, den Inhalt der Standardausgabe anstelle des
Bildschirms in <em>output.txt</em> zu schreiben. Wir haben die erwartete Fehlermeldung
nicht gesehen, die auf den Bildschirm ausgegeben werden sollte, also muss sie
in der Datei gelandet sein. Dies ist der Inhalt von <em>output.txt</em>:</p>
<pre><code class="language-text">Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Ja, unsere Fehlermeldung wird in die Standardausgabe geschrieben. Es ist viel
nützlicher, wenn Fehlermeldungen wie diese auf der Standardfehlerausgabe
ausgegeben werden, sodass nur Daten aus einem erfolgreichen Lauf in der Datei
landen. Das werden wir ändern.</p>
<h3><a class="header" href="#fehler-auf-der-standardfehlerausgabe-ausgeben" id="fehler-auf-der-standardfehlerausgabe-ausgeben">Fehler auf der Standardfehlerausgabe ausgeben</a></h3>
<p>Wir werden den Code in Codeblock 12-24 verwenden, um zu ändern, wie
Fehlermeldungen ausgegeben werden. Aufgrund der Refaktorierung, die wir früher
in diesem Kapitel vorgenommen haben, befindet sich der gesamte Code, der
Fehlermeldungen ausgibt, in einer einzigen Funktion, nämlich der Funktion
<code>main</code>. Die Standardbibliothek stellt das Makro <code>eprintln!</code> zur Verfügung, das
in die Standardfehlerausgabe schreibt. Lass uns also die beiden Stellen, an
denen wir <code>println!</code> aufgerufen haben, um Fehler auszugeben, ändern und
stattdessen <code>eprintln!</code> verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Fehler beim Parsen der Argumente: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Anwendungsfehler: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Codeblock 12-24: Schreiben von Fehlermeldungen auf die
Standardfehlerausgabe anstelle der Standardausgabe durch Verwenden von
<code>eprintln!</code></span></p>
<p>Nachdem wir <code>println!</code> in <code>eprintln!</code> geändert haben, lassen wir das Programm
auf die gleiche Art und Weise erneut laufen, ohne Argumente und mit Umleitung
der Standardausgabe mit <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Fehler beim Parsen der Argumente: Nicht genügend Argumente
</code></pre>
<p>Jetzt sehen wir den Fehler auf dem Bildschirm und <em>output.txt</em> enthält nichts,
was dem Verhalten entspricht, das wir von Kommandozeilenprogrammen erwarten.</p>
<p>Lassen wir das Programm erneut mit Argumenten laufen, die keinen Fehler
verursachen, aber dennoch die Standardausgabe in eine Datei umleiten, etwa so:</p>
<pre><code class="language-console">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>Wir werden keine Ausgabe auf dem Terminal sehen und <em>output.txt</em> wird unsere
Ergebnisse enthalten:</p>
<p><span class="filename">Dateiname: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Dies zeigt, dass wir jetzt die Standardausgabe für die erfolgreiche Ausgabe und
gegebenenfalls die Standardfehlerausgabe für die Fehlerausgabe verwenden.</p>
<h2><a class="header" href="#zusammenfassung-11" id="zusammenfassung-11">Zusammenfassung</a></h2>
<p>Dieses Kapitel rekapituliert einige der wichtigsten Konzepte, die du bisher
gelernt hast, und behandelt das Durchführen gängiger E/A-Operationen in Rust.
Durch das Verwenden von Kommandozeilenargumenten, Dateien, Umgebungsvariablen
und des Makros <code>eprintln!</code> für die Fehlerausgabe bist du jetzt bereit,
Kommandozeilenanwendungen zu schreiben. Wenn du die Konzepte in den
vorhergehenden Kapiteln verwendest, wird dein Code gut organisiert sein, Daten
effektiv in den entsprechenden Datenstrukturen speichern, Fehler gut behandeln
und gut getestet sein.</p>
<p>Als Nächstes werden wir einige Rust-Funktionalitäten untersuchen, die von
funktionalen Sprachen beeinflusst wurden: Funktionsabschlüsse (closures) und
Iteratoren.</p>
<h1><a class="header" href="#funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures" id="funktionale-sprachelemente-iteratoren-und-funktionsabschlüsse-closures">Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></h1>
<p>Das Design von Rust wurde von einer Vielzahl von vorhandenen Programmiersprachen
und Techniken beeinflusst und ein signifikanter Einfluss ist die <em>funktionale
Programmierung</em>. Programmieren im funktionalen Stil beinhaltet oft das
Verwenden von Funktionen als Werte, die in Argumenten übergeben, von anderen
Funktionen zurückgegeben, Variablen zur späteren Ausführung zugewiesen werden
und so weiter.</p>
<p>Gegenstand dieses Kapitels ist es nicht, zu erörtern, was funktionale
Programmierung ist oder nicht, stattdessen werden wir einige Funktionalitäten von
Rust besprechen, die denen vieler anderer Sprachen ähneln und häufig als
funktional bezeichnet werden. </p>
<p>Im Einzelnen wird Folgendes behandelt:</p>
<ul>
<li><em>Funktionsabschlüsse</em>, ein Konstrukt, das einer Funktion ähnelt und in einer
Variable gespeichert werden kann.</li>
<li><em>Iteratoren</em>, eine Möglichkeit, eine Reihe von Elementen abzuarbeiten.</li>
<li>Wie wir diese zwei Möglichkeiten benutzen können, um unser E/A-Projekt in
Kapitel 12 verbessern zu können.</li>
<li>Die Performanz dieser beiden Funktionalitäten (Spoiler-Alarm: Sie sind
schneller, als du vielleicht denken magst!)</li>
</ul>
<p>Andere Rust-Funktionalitäten wie Aufzählungen (enums) und Musterabgleich
(pattern matching), die wir bereits in anderen Kapiteln behandelt haben, sind
ebenfalls vom funktionalen Stil beeinflusst. Das Beherrschen von
Funktionsabschlüssen und Iteratoren ist ein wichtiger Bestandteil beim
Schreiben von idiomatischem, schnellem Rust-Programmcode. Daher wird ihnen
das gesamte Kapitel gewidmet.</p>
<h2><a class="header" href="#funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können" id="funktionsabschlüsse-closures-anonyme-funktionen-die-ihre-umgebung-erfassen-können">Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></h2>
<p>Rusts Funktionsabschlüsse sind anonyme Funktionen, die du in einer Variable
speichern oder anderen Funktionen als Argument übergeben kannst. Du kannst einen 
Funktionsabschluss erstellen und dann in einem anderen Zusammenhang aufrufen
und auswerten. Im Gegensatz zu Funktionen können Funktionsabschlüsse auf Werte 
(values) im Gültigkeitsbereich (scope) in dem sie erstellt wurden zugreifen.
Wir werden im Folgenden zeigen, wie die Funktionalität von Funktionsabschlüssen
die Wiederverwendung von Code erlaubt und sein Verhalten anpassen kann.</p>
<h3><a class="header" href="#mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen" id="mit-funktionsabschlüssen-verhaltensabstraktion-erzeugen">Mit Funktionsabschlüssen Verhaltensabstraktion erzeugen</a></h3>
<p>Lass uns an einem Beispiel einer Situation arbeiten, in der es nützlich ist, einen
Funktionsabschluss zu speichern, um ihn später auszuführen. In dieser Zeit werden
wir über Typinferenz, Merkmale (traits) und die Syntax von Funktionsabschlüssen
sprechen.</p>
<p>Ziehe diese hypothetische Situation in Betracht: Wir arbeiten für ein Start-up 
das eine App entwickelt die benutzerdefinierte Work-out-Trainingspläne generiert.
Das Backend ist in Rust geschrieben und der Algorithmus, der die Trainingspläne
erzeugt, berücksichtigt viele Faktoren: Das Alter des Benutzers, Body Mass Index,
Übungsvoreinstellungen, kürzlich erfolgte Work-outs und eine Zahl, die deren
Intensität festlegt. Der eigentliche Algorithmus ist für unser Beispiel nicht
wichtig. Bemerkenswert ist, dass die Berechnung ein paar Sekunden Zeit benötigt,
um die Wartezeit für den Benutzer zu verkürzen, wollen wir daher den Algorithmus
nur einmal aufrufen, und zwar dann, wenn es notwendig ist.</p>
<p>Den Aufruf des hypothetischen Algorithmus werden wir mit der Funktion
<code>simulated_expensive_calculation</code> die im Codeblock 13-1 gezeigt wird und
<code>rechnet langsam...</code>, ausgibt, zwei Sekunden lang wartet und dann die Nummer
zurückgibt die wir übergeben haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;rechnet langsam...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-1: Eine Funktion die für eine hypothetische
Berechnung steht, die etwa 2 Sekunden Laufzeit benötigt.</span></p>
<p>Als Nächstes folgt die Hauptfunktion <code>main</code>, welche die für unser Beispiel
relevanten Teile beinhalten wird. Diese Funktion stellt den Code dar, den die App
aufrufen wird, wenn ein Benutzer einen Trainingsplan anfordert. Da die
Interaktion mit dem Frontend für die Benutzung von Funktionsabschlüssen nicht
von Bedeutung ist, werden Werte die Eingaben (inputs) repräsentieren fest
einprogrammiert (hardcoded) und Ausgaben (outputs) einfach mit <code>print</code>
ausgegeben.</p>
<p>Das sind die benötigten Eingaben:</p>
<ul>
<li>Eine Intensitätszahl mit der die Benutzer festlegen können ob ein Training
von leichter oder hoher Intensität sein soll.</li>
<li>Eine Zufallszahl, die für Abwechslung im Trainingsplan sorgt.</li>
</ul>
<p>Ausgegeben wird der empfohlene Trainingsplan. Codeblock 13-2 zeigt die
Funktion <code>main</code> die wir benutzen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span><span class="boring">
</span>fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-2: Eine Funktion <code>main</code> mit fest
einprogrammierten Werten, um Eingaben zu simulieren und Zufallszahlen zu
erzeugen</span></p>
<p>Die Variable <code>simulated_user_specified_value</code> wurde als 10 fest einprogrammiert
und die Variable <code>simulated_random_number</code> zur Vereinfachung als 7. In einem
tatsächlichen Programm würden wir die Intensitäts-Zahl vom App-Frontend bekommen
und wir würden die Kiste (crate) <code>rand</code> benutzen um eine Zufallszahl zu
erzeugen, so wie wir es im Ratespiel-Beispiel in Kapitel 2 bereits gemacht
haben. Die Funktion <code>main</code> ruft eine Funktion <code>generate_workout</code> mit
simulierten Eingabewerten auf.</p>
<p>Nun da wir einen Kontext haben, lass uns zum Algorithmus kommen. Die Funktion
<code>generate_workout</code> im Codeblock 13-3 beinhaltet die Anwendungslogik der App
mit der wir in diesem Beispiel am häufigsten zu tun haben werden, die folgenden
Veränderungen werden diese Funktion betreffen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Mach heute {} Liegestütze!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Als nächstes {} Sit-ups!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span><span class="boring">
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-3: Die Anwendungslogik, die Trainingspläne anhand
der Eingaben und durch Aufrufe der Funktion <code>simulated_expensive_calculation</code>
ausgibt</span></p>
<p>Der Code im Codeblock 13-3 ruft die langsame Berechnungsfunktion mehrfach auf.
Der erste <code>if</code>-Block verwendet <code>simulated_expensive_calculation</code> zweifach, das
<code>if</code> im äußeren <code>else</code> verwendet die Berechnung nicht und der Code im zweiten
<code>else</code> einmal.</p>
<p>Das gewünschte Verhalten der Funktion <code>generate_workout</code> ist, als Erstes zu
überprüfen, ob der Benutzer ein Training von niedriger Intensität möchte
(gekennzeichnet durch eine Zahl kleiner 25) oder ein Training von hoher
Intensität (eine Zahl größer oder gleich 25). </p>
<p>Trainingspläne von niedriger Intensität empfehlen eine mittels simulierten 
Algorithmus berechnete Anzahl von Liegestützen und Sit-ups.</p>
<p>Falls der Benutzer ein Training von hoher Intensität anfordert, gibt es eine 
zusätzliche Logik: Ergibt der Wert der ermittelten Zufallszahl 3, wird die App
dem Benutzer eine Trinkpause empfehlen, falls sich eine andere Zahl ergibt,
werden dem Benutzer einige Minuten Lauftraining, berechnet durch den simulierten 
Algorithmus, empfohlen.</p>
<p>Lass uns nun annehmen, dass das Datenforschungsteam einige Änderungen anordnet.
Das Programm funktioniert zwar soweit wie gewünscht, aber
<code>simulated_expensive_calculation</code> wird unnötigerweise mehrfach aufgerufen.
Wir sollen daher den Programmcode umformen und vereinfachen, damit die Funktion
nur noch einmal aufgerufen wird, wenn es notwendig ist.</p>
<h4><a class="header" href="#umformen-refactoring-mit-funktionen" id="umformen-refactoring-mit-funktionen">Umformen (refactoring) mit Funktionen</a></h4>
<p>Wir könnten den Programmcode auf viele Arten umstrukturieren, aber zuerst, werden
wir versuchen den doppelten Aufruf der Funktion <code>simulated_expensive_calculation</code>
in eine Variable zu extrahieren, wie es im Codeblock 13-4 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">   println!(&quot;rechnet langsam...&quot;);
</span><span class="boring">   thread::sleep(Duration::from_secs(2));
</span><span class="boring">   intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result);
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(&quot;Heute, {} Minuten Lauftrainig!&quot;, expensive_result);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-4: Extraktion der Aufrufe von
<code>simulated_expensive_calculation</code> zu einem Ort und Speichern des Ergebnisses in
der Variable <code>expensive_result</code></span></p>
<p>Diese Änderung vereinigt alle Aufrufe von <code>simulated_expensive_calculation</code> und
löst das Problem mit deren unnötigen doppelten Aufruf im ersten <code>if</code>-Block.
Leider rufen wir nun die Funktion auf und warten in jeden Fall auf das Ergebnis,
sogar im inneren <code>if</code>-Block der den Ergebniswert überhaupt nicht verwendet.</p>
<p>Wir wollen den Code an einer Stelle in unserem Programm definieren, aber
ausschließlich dort ausführen, wo wir das Ergebnis tatsächlich brauchen.</p>
<h4><a class="header" href="#umformen-mit-funktionsabschlüssen-um-programmcode-zu-speichern" id="umformen-mit-funktionsabschlüssen-um-programmcode-zu-speichern">Umformen mit Funktionsabschlüssen um Programmcode zu speichern</a></h4>
<p>Anstatt die Funktion <code>simulated_expensive_calculation</code> vor den <code>if</code>-Blöcken
immer aufzurufen, können wir einen <em>Funktionsabschluss</em> definieren und diesen
anstatt des Resultates in einer Variable abspeichern, wie es im 
Codeblock 13-5 gezeigt wird. Eigentlich können wir den gesamten Rumpf von
<code>simulated_expensive_calculation</code> in einen Funktionsabschluss verschieben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-5: Definition eines Funktionsabschlusses 
und dessen Speicherung in der Variable <code>expensive_closure</code></span></p>
<p>Die Definition des Funktionsabschlusses folgt dem <code>=</code> um es der Variable
<code>expensive_closure</code> zuzuweisen. Wir beginnen mit einem Paar vertikaler
Pipes (<code>|</code>), worin wir die Parameter des Funktionsabschlusses spezifizieren.
Diese Syntax wurde ausgewählt, da sie so ähnlich ist wie die Definition von
Funktionsabschlüssen in Ruby und Smalltalk. Dieser Funktionsabschluss hat einen
Parameter <code>num</code>: Sollten mehrere Parameter benötigt werden, würden wir diese mit
Kommata getrennt schreiben wie <code>|param1, param2|</code>.</p>
<p>Hinter den Parameter kommen geschweifte Klammern <code>{}</code> die den Rumpf des
Funktionsabschlusses beinhalten. Diese Klammern sind optional, wenn der Rumpf nur
einen Ausdruck beinhaltet. Zum Schluss benötigen wir nach den geschweiften
Klammern ein Semikolon aufgrund der <code>let</code>-Anweisung. Der Wert, der vom
Funktionsabschluss zurückgegeben wird, ist der Wert der letzten Zeile
im Rumpf des Funktionsabschlusses (<code>num</code>), da diese Zeile nicht mit einem
Semikolon endet, wie auch bei Funktionsrümpfen.</p>
<p>Merke, die <code>let</code>-Anweisung bedeutet, dass <code>expensive_closure</code> die <em>Definition</em>
einer anonymen Funktion beinhaltet und nicht den <em>Wert des Ergebnisses</em> des
Aufrufs der anonymen Funktion. Wir benutzen, zur Erinnerung, einen
Funktionsabschluss, da wir den aufzurufenden Programmcode an einer Stelle
definieren, speichern und ihn später aufrufen wollen. Dieser Programmteil ist nun in
<code>expensive_closure</code> gespeichert.</p>
<p>Da wir nun einen Funktionsabschluss definiert haben, können wir nun den Code im
<code>if</code>-Block so ändern, damit der Funktionsabschluss aufgerufen wird um dessen
Code auszuführen und einen Ergebniswert zu erhalten. Der Aufruf eines
Funktionsabschlusses gleicht dem einer Funktion: Wir geben den Variablennamen
an, der den Funktionsabschluss enthält, gefolgt von den Argumentwerten in
Klammern, die wir verwenden möchten, wie in Codeblock 13-6 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-6: Aufruf der neu definierten
<code>expensive_closure</code></span></p>
<p>Nun wird die langsame Berechnung nur noch an einer Stelle aufgerufen und wir
führen sie nur durch, wenn wir das Ergebnis benötigten.</p>
<p>Wir haben jedoch eines der Probleme von Codeblock 13-3 wieder eingeführt.
Im ersten <code>if</code>-Block rufen wir den Funktionsabschluss mehrfach auf und lassen
somit den Benutzer doppelt solange warten als notwendig. Wir könnten das Problem
beheben, indem wir eine lokale Variable definieren die das Ergebnis des
Funktionsabschluss-Aufrufs hält. Funktionsabschlüsse bieten uns eine andere
Lösung. Wir werden diese Lösung in Kürze erklären, aber lass uns zuerst über die
fehlenden Typzuweisungen in der Definition des Funktionsabschlusses und den
Merkmalen (traits) von Funktionsabschlüssen sprechen.</p>
<h3><a class="header" href="#typinferenz-und-zuweisung-bei-funktionsabschlüssen" id="typinferenz-und-zuweisung-bei-funktionsabschlüssen">Typinferenz und Zuweisung bei Funktionsabschlüssen</a></h3>
<p>Bei Funktionsabschlüssen musst du die Typen der Parameter und Rückgabewerte nicht,
wie bei Funktionen, mit Anmerkungen versehen. Für Funktionen sind Typanmerkungen 
erforderlich, da sie Bestandteil einer expliziten Benutzerschnittstelle sind.
Die starre Festlegung dieser Schnittstelle ist wichtig, damit sichergestellt
ist, dass jeder damit übereinstimmt, welche Arten von Werten von der Funktion
entgegengenommen und zurückgegeben werden. Funktionsabschlüsse werden hingegen nicht
in einer Schnittstelle verwendet, sie werden in einer Variable gespeichert und 
aufgerufen, ohne sie zu benennen und Benutzern unserer Bibliothek (library)
zugänglich zu machen.</p>
<p>Funktionsabschlüsse sind für gewöhnlich kurz und eher in einem begrenzten Kontext
relevant, als in einem beliebigen Szenario. Innerhalb dieses beschränkten
Einsatzbereichs ist der Compiler verlässlich in der Lage, Typen, Parameter und
Rückgabewerte zu inferieren, ähnlich wie er meistens bei Variablen die Typen
herleiten kann.</p>
<p>Den Programmierer die Typen in diesen kurzen, anonymen Funktionen anmerken zu
lassen wäre nur störend und überflüssig, da der Compiler bereits über die
dafür notwendigen Informationen verfügt.</p>
<p>Wir können wie bei Variablen Typanmerkungen angeben, wenn wir die Klarheit
und Aussagekraft über das notwendige Maß hinaus erhöhen möchten.
Das Anmerken der Typen für den in Codeblock 13-5 definierten Funktionsabschluss
würde wie die Definition in Codeblock 13-7 aussehen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span><span class="boring">   
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring"> 
</span><span class="boring">
</span><span class="boring">   if intensity &lt; 25 {
</span><span class="boring">       println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_closure(intensity));
</span><span class="boring">       println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_closure(intensity));
</span><span class="boring">   } else {
</span><span class="boring">       if random_number == 3 {
</span><span class="boring">           println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
</span><span class="boring">       } else {
</span><span class="boring">           println!(
</span><span class="boring">               &quot;Heute, {} Minuten Lauftrainig!&quot;,
</span><span class="boring">               expensive_closure(intensity)
</span><span class="boring">           );
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let simulated_user_specified_value = 10;
</span><span class="boring">  let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">  generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-7: Hinzufügen optionaler Typanmerkungen
der Parameter- und Rückgabewert-Typen im Funktionsabschluss
</span></p>
<p>Die Syntax eines Funktionsabschlusses mit Typanmerkungen sieht der Syntax einer
Funktion sehr ähnlich. Es folgt ein vertikaler Vergleich der Syntax einer
Funktionsdefinition, die 1 zu ihrem Parameter addiert und einem
Funktionsabschluss mit dem gleichen Verhalten. Wir haben einige Abstände hinzugefügt,
um die relevanten Teile besser darzustellen. Dies zeigt wie ähnlich die Syntax
von Funktionen der von Funktionsabschlüssen ist, abgesehen von Pipes und der 
Möglichkeit, einen Teil der Syntax wegzulassen:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>Die erste Zeile zeigt eine Funktionsdefinition und die zweite eine Definition
eines Funktionsabschlusses mit allen Typanmerkungen. Bei der dritten Zeile
werden die Typanmerkungen in der Definition des Funktionsabschlusses weggelassen,
in der vierten Zeile das Gleiche ohne Klammern – da diese optional sind da der
Rumpf des Funktionsabschlusses nur einen Ausdruck beinhaltet. Dies sind alles
gültige Ausdrücke die sich beim Aufruf gleich Verhalten. Für <code>add_one_v3</code> und
<code>add_one_v4</code> wird der Aufruf zum Kompilieren des Codes benötigt, da die Typen
hier abhängig von der Benutzung bestimmt werden.</p>
<p>Bei Funktionsabschlüssen wird für jeden Parameter und für den Rückgabewert ein
konkreter Typ abgeleitet. Codeblock 13-8 zeigt zum Beispiel die Definition eines
kurzen Funktionsabschlusses, der nur den Wert zurückgibt, den er als Parameter
erhält. Dieser Funktionsabschluss ist abgesehen von seinem Zweck als Beispiel zu
dienen nicht weiter nützlich. Beachte, dass wir der Definition keine
Typanmerkungen hinzugefügt haben. Wenn wir nun versuchen, die Funktion zweimal
aufzurufen, einmal mit <code>String</code> und einmal mit <code>u32</code>, erhalten wir eine
Fehlermeldung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-8: Versuchter Aufruf eines Funktionsabschluss
den zwei unterschiedliche Typen zugewiesen wurden</span></p>
<p>Der Compiler gibt diesen Fehler aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `std::string::String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Beim ersten Aufruf von <code>example_closure</code> wird dem Typ von <code>x</code> und dem
Rückgabewert des Funktionsabschlusses der Typ <code>String</code> zugewiesen. Diese Typen
sind dann für den Funktionsabschluss <code>example_closure</code> festgeschrieben und daher
bekommen wir eine Fehlermeldung, wenn wir versuchen einen anderen Typ mit dem
gleichen Funktionsabschluss zu benutzen.</p>
<h3><a class="header" href="#speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits" id="speichern-von-funktionsabschlüssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits">Speichern von Funktionsabschlüssen unter Verwendung generischer Parameter und <code>Fn</code>-Merkmalen (traits)</a></h3>
<p>Lass uns auf unser Trainingsplan-Erstellungsprogramm zurückkommen. Im Codeblock
13-6 hat unser Programm, noch immer häufiger als notwendig, den
Funktionsabschluss <code>expensive_closure</code> aufgerufen. Eine Möglichkeit, dieses
Problem zu beheben, besteht darin, das Ergebnis des Funktionsabschlusses in
einer Variable zu speichern und diese Variable zu benutzen, wann immer wir das
Resultat brauchen. Diese Methode würde allerdings zu ziemlich viel wiederholtem
Code führen.</p>
<p>Glücklicherweise steht uns eine andere Lösung zur Verfügung. Wir können eine
Struktur (struct) anlegen die den Funktionsabschluss und dessen Rückgabewert
hält. Die Struktur wird den Funktionsabschluss nur dann ausführen, wenn
wir ein Ergebnis benötigen, und sie wird unseren Rückgabewert zwischenspeichern
damit der Rest unseres Programmcodes nicht mehr für das Speichern und 
Wiederverwenden verantwortlich ist. Dieses Muster (pattern) ist dir vielleicht
als <em>Memoisation</em> (memoization) oder <em>Lazy Evaluation</em> bekannt.</p>
<p>Um eine Struktur für unseren Funktionsabschluss zu erstellen, müssen wir dessen
Typ spezifizieren, da die Definition einer Struktur den Typ aller ihrer Felder
kennen muss. Jede Instanz eines Funktionsabschlusses besitzt ihren einzigartigen
anonymen Typ, der selbst wenn zwei Funktionsabschlüsse identische Signaturen
haben, immer noch als verschieden betrachtet wird. Um Strukturen, Aufzählungen
(enums) oder Funktionen zu definieren, die Funktionsabschlüsse verwenden,
benutzen wir generische Datentypen (generics) und Merkmalsabgrenzungen (trait bounds),
die wir bereits im Kapitel 10 besprochen haben.</p>
<p>Die <code>Fn</code>-Merkmale werden von der Standardbibliothek (standard library) zur
Verfügung gestellt. Alle Funktionsabschlüsse implementieren mindestens eines der
Merkmale: <code>Fn</code>, <code>FnMut</code> oder <code>FnOnce</code>. Wir werden den Unterschied dieser
Merkmale im Abschnitt <a href="ch13-01-closures.html#mit-funktionsabschl%C3%BCssen-die-umgebung-erfassen">„Mit Funktionsabschlüssen die Umgebung
erfassen“</a> besprechen. 
Für unser Beispiel können wir das <code>Fn</code>-Merkmal benutzen.</p>
<p>Den <code>Fn</code>-Merkmalsabgrenzungen fügen wir Typanmerkungen für die Typen, die mit dem
Funktionsabschluss übereinstimmen müssen, hinzu. In diesem Fall hat unser
Funktionsabschluss einen Parameter vom Typ <code>u32</code> und gibt einen <code>u32</code> zurück,
daher spezifizieren wir die Merkmalsabgrenzung mit <code>Fn(u32) -&gt; u32</code>.</p>
<p>Codeblock 13-9 zeigt die Definition der Struktur <code>Cacher</code>, die einen
Funktionsabschluss und optional einen Rückgabewert hält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-9: Definition einer Struktur <code>Cacher</code>, die
einen Funktionsabschluss in <code>calculation</code> enthält und in <code>value</code> optional ein
Resultat</span></p>
<p>Die Struktur <code>Cacher</code> hat ein Feld <code>calculation</code> vom generischen Datentyp <code>T</code>.
Die Merkmalsabgrenzungen auf <code>T</code> legen das <code>Fn</code>-Merkmal für den
Funktionsabschluss fest. Jeder Funktionsabschluss, den wir im Feld <code>calculation</code>
speichern, muss einen <code>u32</code>-Parameter (spezifiziert innerhalb runder Klammern
hinter <code>Fn</code>) haben und ein <code>u32</code> (festgelegt nach dem <code>-&gt;</code>) zurückgeben.</p>
<blockquote>
<p>Merke: Auch Funktionen können alle drei <code>Fn</code>-Merkmale implementieren.
Falls eine Problemstellung das Erfassen eines Wertes der Umgebung nicht erfordert,
können wir eine Funktion anstatt eines Funktionsabschlusses benutzen, der etwas
benötigt, um für ihn das <code>Fn</code>-Merkmal zu implementieren.</p>
</blockquote>
<p>Das Feld <code>value</code> hat den Typ <code>Option&lt;u32&gt;</code>. Bevor wir den Funktionsabschluss
ausführen, hat <code>value</code> den Wert <code>None</code>. Wenn Programmcode mit einem <code>Cacher</code> nach dem
<em>Ergebnis</em> des Funktionsabschlusses fragt, wird der <code>Cacher</code> zu diesem Zeitpunkt
den Funktionsabschluss ausführen und das Ergebnis in einer <code>Some</code>-Variante im
Feld <code>value</code> speichern. Wenn der Code später wieder nach dem Resultat des
Funktionsabschlusses fragt, wird anstatt der erneuten Ausführung der Berechnung
der <code>Cacher</code> den Wert zurückgeben, der in der <code>Some</code>-Variante enthalten ist.</p>
<p>Im Codeblock 13-10, wird die Logik um das soeben beschriebene Feld <code>value</code>
definiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-10: Die Zwischenspeicherungs-Logik von <code>Cacher</code></span></p>
<p>Wir möchten, dass <code>Cacher</code> die Felder der Struktur verwaltet, anstatt den
aufrufenden Code die Werte unter Umständen direkt ändern zu lassen, sodass diese
Felder privat sind.</p>
<p>Die Funktion <code>Cacher::new</code> nimmt einen generischen Datentyp-Parameter <code>T</code>,
welchen wir so definiert haben, dass er dieselbe Merkmalsabgrenzung wie die
<code>Cacher</code>-Struktur hat. Anschließend gibt <code>Cacher::new</code> eine <code>Cacher</code>-Instanz aus
die den Funktionsabschluss enthält der im <code>calculation</code>-Feld spezifiziert wurde
und den Wert <code>None</code> in seinem <code>value</code>-Feld enthält da wir den Funktionsabschluss
bisher noch nicht ausgeführt haben.</p>
<p>Wenn der aufrufende Code das Auswertungsergebnis des Funktionsabschlusses
benötigt, ruft er die Methode <code>value</code> auf, anstatt direkt den Funktionsabschluss.
Diese Methode überprüft, ob wir bereits einen Rückgabewert in <code>self.value</code>
in einen <code>Some</code> gespeichert haben, falls ja, gibt es den Wert, der in <code>Some</code>
enthalten ist zurück ohne den Funktionsabschluss erneut auszuführen.</p>
<p>Falls <code>self.value</code> ein <code>None</code> ist, ruft der Programmcode den Funktionsabschluss
auf, der in <code>self.calculation</code> gespeichert ist, speichert das Resultat in
<code>self.value</code> für seine zukünftige Verwendung und gibt den Wert zurück.</p>
<p>Codeblock 13-11 zeigt wie wir die <code>Cacher</code>-Struktur in der Funktion
<code>generate_workout</code> vom Codeblock 13-6 verwenden können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;rechnet langsam...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(&quot;Mach heute {} Liegestütze!&quot;, expensive_result.value(intensity));
        println!(&quot;Als nächstes {} Sit-ups!&quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Mach heute eine Pause! Denk daran, ausreichend zu trinken!&quot;);
        } else {
            println!(
                &quot;Heute, {} Minuten Lauftrainig!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let simulated_user_specified_value = 10;
</span><span class="boring">   let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">   generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-11: Die Verwendung von <code>Cacher</code> in der
Funktion <code>generate_workout</code> zur Abstraktion der Zwischenspeicherungs-Logik</span></p>
<p>Anstatt den Funktionsabschluss direkt in einer Variable zu speichern, speichern
wir eine neue Instanz von <code>Cacher</code> die den Funktionsabschluss beinhaltet. An
jeder Stelle, an der wir ein Resultat benötigen, rufen wir dann die Methode
<code>value</code> an der <code>Cacher</code>-Instanz auf. Egal ob wir nun die Methode <code>value</code>
mehrmals aufrufen oder gar nicht wird die aufwendige Berechnung nur einmal 
ausgeführt.</p>
<h3><a class="header" href="#einschränkungen-der-cacher-implementierung" id="einschränkungen-der-cacher-implementierung">Einschränkungen der <code>Cacher</code>-Implementierung</a></h3>
<p>Das Zwischenspeichern von Werten ist allgemein eine nützliche Vorgehensweise,
die wir möglicherweise auch an anderen Programmteilen mit verschieden
Funktionsabschlüssen verwenden möchten. Jedoch gibt es zwei Probleme der aktuellen
Implementierung von <code>Cacher</code>, die eine Wiederverwendung in verschiedenen Kontexten
erschweren würden.</p>
<p>Das erste Problem ist, dass eine <code>Cacher</code>-Instanz davon ausgeht, dass sie immer
den gleichen Wert für den <code>arg</code>-Parameter der Methode <code>value</code> bekommt. Das
bedeutet, dass dieser Test fehlschlagen wird:</p>
<pre><pre class="playground"><code class="language-rust panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   calculation: T,
</span><span class="boring">   value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">   T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">   fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">       Cacher {
</span><span class="boring">           calculation,
</span><span class="boring">           value: None,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">       match self.value {
</span><span class="boring">           Some(v) =&gt; v,
</span><span class="boring">           None =&gt; {
</span><span class="boring">               let v = (self.calculation)(arg);
</span><span class="boring">               self.value = Some(v);
</span><span class="boring">               v
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span>    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}    
</span><span class="boring">}
</span></code></pre></pre>
<p>Dieser Test erzeugt eine neue <code>Cacher</code>-Instanz mit einem Funktionsabschluss, der
den Wert zurückgibt, den er erhalten hat. Wir rufen nun die <code>Cacher</code>-Instanz
mit der Methode <code>value</code> auf, zuerst mit dem <code>arg</code>-Wert 1 und dann mit dem
<code>arg</code>-Wert 2 und erwarten, dass beim zweiten Aufruf 2 zurückgegeben wird.</p>
<p>Führe diesen Test mit der Implementierung von <code>Cacher</code> vom Codeblock 13-9 und
13-10 durch und der Test wird an <code>assert_eq!</code> mit folgender Meldung
fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Das Problem ist, dass die <code>Cacher</code>-Instanz beim ersten Aufruf von <code>c.value</code> mit 1
den Wert <code>Some(1)</code> in <code>self.value</code> gespeichert hat. Egal was wir danach der
<code>value</code>-Methode als Wert  mitgeben, wir werden immer 1 zurückbekommen.</p>
<p>Versuche <code>Cacher</code> so zu verändern, dass es anstatt eines Wertes eine Hash-Tabelle
(hash map) enthält. Die Schlüssel (keys) der Hash-Tabelle werden die <code>arg</code>-Werte
die mitgegeben werden sein und die Werte der Hash-Tabelle werden das Resultat des Aufrufs des
Funktionsabschlusses mit dem jeweiligen Schlüssel sein. Anstatt <code>value</code> direkt
zu betrachten, ob es einen <code>Some</code> oder <code>None</code> enthält, wird die <code>value</code>-Funktion
nach <code>arg</code> in der Hash-Tabelle suchen und den Wert, falls vorhanden, zurückgeben.
Falls der Wert nicht vorhanden ist, wird der <code>Cacher</code> den Funktionsabschluss
aufrufen und den Rückgabewert in der Hash-Tabelle zusammen mit seinem <code>arg</code>-Wert
speichern.</p>
<p>Das zweite Problem mit der derzeitigen Implementierung von <code>Cacher</code> ist, dass
sie nur Funktionsabschlüsse annimmt die einen Parameter vom Typ <code>u32</code> haben und 
ein <code>u32</code> zurückgeben. Möglicherweise möchten wir zum Beispiel Ergebnisse von
Funktionsabschlüssen zwischenspeichern die einen Zeichenketten-Anteilstyp (string
slice) nehmen und <code>usize</code>-Werte zurückgeben. Um dieses Problem zu beheben,
versuche generische Datentypen zu verwenden, um die <code>Cacher</code>-Funktionalität
flexibler zu machen.</p>
<h3><a class="header" href="#mit-funktionsabschlüssen-die-umgebung-erfassen" id="mit-funktionsabschlüssen-die-umgebung-erfassen">Mit Funktionsabschlüssen die Umgebung erfassen</a></h3>
<p>Im Trainingsplan-Erstellungs-Beispiel haben wir Funktionsabschlüsse nur als
anonyme Inline-Funktionen verwendet, Funktionsabschlüsse verfügen jedoch über
eine Fähigkeit die Funktionen nicht haben: Sie können ihre Umgebung erfassen und
auf Variablen die im selben Gültigkeitsbereich definiert wurden zugreifen.</p>
<p>Codeblock 13-12 beinhaltet ein Beispiel eines Funktionsabschlusses der in einer
Variable <code>equal_to_x</code> gespeichert ist und eine Variable <code>x</code> aus ihrer Umgebung
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Codeblock 13-12: Beispiel eines Funktionsabschlusses, der
sich auf eine Variable im umgebenden Gültigkeitsbereich bezieht.</span></p>
<p>Auch wenn <code>x</code> hier keiner der Parameter von <code>equal_to_x</code> ist, darf der
Funktionsabschluss <code>equal_to_x</code> die Variable <code>x</code> benutzen, die im gleichen
Gültigkeitsbereich definiert wurde wie <code>equal_to_x</code>.</p>
<p>Mit Funktionen können wir dasselbe nicht machen. Wenn wir es wie im folgenden
Beispiel versuchen wird der Programmcode nicht kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir bekommen eine Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead
</code></pre>
<p>Der Compiler erinnert uns sogar daran, dass dies nur mit Funktionsabschlüssen
funktioniert!</p>
<p>Wenn ein Funktionsabschluss einen Wert aus seiner Umgebung erfasst, benutzt er
Speicher, um die Werte im Funktionsabschluss-Rumpf für die Benutzung zu halten.
Diesen zusätzlichen Aufwand der Speichernutzung wollen wir, wenn wir
Code ausführen möchten der seine Umgebung nicht erfasst, nicht verursachen. Da
Funktionen ihre Umgebung niemals erfassen können, kann das Definieren und
Ausführen von Funktionen auch nie diesen Speichernutzungsmehraufwand
verursachen.</p>
<p>Es gibt drei Möglichkeiten wie Funktionsabschlüsse ihre Umgebung erfassen
können, den drei Möglichkeiten entsprechend wie Funktionen ein Parameter
erhalten können: Eigentümerschaft übernehmen (taking ownership), veränderliches
Ausleihen (borrowing mutably) und unveränderliches Ausleihen (borrowing immutably).
Diese sind wie folgt, in den drei <code>Fn</code>-Merkmalen codiert:</p>
<ul>
<li><code>FnOnce</code> verbraucht die Variablen, die vom umgebenden Gültigkeitsbereich
erfasst werden, dieser Bereich wird als Funktionsabschluss-Umgebung
(closure’s <em>enviroment</em>) bezeichnet. Um die erfassten Variablen verbrauchen
zu können, muss der Funktionsabschluss die Eigentümerschaft dieser Variablen
übernehmen und sie bei dessen Definition, in den Funktionsabschluss verschieben
(move). Der Namensteil <code>Once</code> repräsentiert die Tatsache, dass der
Funktionsabschluss nur einmal die Eigentümerschaft der gleichen Variablen
übernehmen kann, daher kann er nur einmal aufgerufen werden.</li>
<li><code>FnMut</code> kann die Funktionsabschluss-Umgebung verändern, da es Werte
veränderlich ausleiht.</li>
<li><code>Fn</code> leiht Werte des umgebenden Gültigkeitsbereiches unveränderlich aus.</li>
</ul>
<p>Wenn du einen Funktionsabschluss erstellst, schließt Rust, welches Merkmal
verwendet werden soll, aus der Verwendungsweise der vom Funktionsabschluss 
erfassten Variablen. Alle Funktionsabschlüsse implementieren <code>FnOnce</code>, da sie
mindestens einmal aufgerufen werden können. Funktionsabschlüsse, die erfasste
Variablen nicht verschieben, implementieren zusätzlich <code>FnMut</code> und
Funktionsabschlüsse, die keinen veränderlichen Zugriff auf die erfassten Werte
benötigen, implementieren des weiteren <code>Fn</code>. Im Codeblock 13-12, leiht der
Funktionsabschluss <code>equal_to_x</code> den Parameter <code>x</code> unveränderlich (dadurch hat
<code>equal_to_x</code> das <code>Fn</code>-Merkmal), da der Funktionsabschluss-Rumpf den
Variablenwert <code>x</code> nur liest.</p>
<p>Falls du erzwingen möchtest, dass ein Funktionsabschluss die Eigentümerschaft
der aus dem umgebenden Gültigkeitsbereich verwendeten Werte übernimmt, kannst du
vor der Parameterliste das Schlüsselwort <code>move</code> verwenden. Diese Technik ist vor
allem dann nützlich, wenn ein Funktionsabschluss an einen neuen Strang (thread) 
übergeben wird, um die Daten so zu verschieben, dass sie dem neuen Strang
gehören.</p>
<p>Weitere Beispiele für <code>move</code> bei Funktionsabschlüssen folgen in Kapitel 16, wenn
wir über Parallelität sprechen. Einstweilen ist hier der Programmcode von
Codeblock 13-12 mit dem Schlüsselwort <code>move</code>, das der Funktionsabschlussdefinition
hinzugefügt wurde und Vektoren statt Ganzzahlen (integers) verwendet, da
Ganzzahlen kopiert und nicht verschoben werden. Beachte, dass dieser Programmcode
noch nicht kompiliert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Wir erhalten folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!(&quot;kann x hier nicht verwenden: {:?}&quot;, x);
  |                                                   ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.

</code></pre>
<p>Der Wert <code>x</code> wurde bei der Funktionsabschlussdefinition in diesen hineinbewegt,
da wir das Schlüsselwort <code>move</code> angegeben haben. Der Funktionsabschluss hat
dadurch die Eigentümerschaft von <code>x</code> und <code>main</code> kann daher <code>x</code> nicht mehr 
im <code>println!</code>-Statement benutzen. Durch Entfernen von <code>println!</code> wird dieser
Fehler behoben.</p>
<p>Wenn du eine <code>Fn</code>-Merkmalsabgrenzung spezifizierst, reicht es zumeist wenn du
mit <code>Fn</code> beginnst. Der Compiler wird dir mitteilen, wenn es notwendig ist
<code>FnMut</code> oder <code>FnOnce</code> anzugeben, basierend auf dem was im
Funktionsabschluss-Rumpf passiert. </p>
<p>Um Situationen zu veranschaulichen, die die Nützlichkeit von
Umgebung erfassenden Funktionsabschlüssen als Funktionsparameter demonstrieren,
fahren wir mit unserem nächsten Thema fort: Iteratoren.</p>
<h2><a class="header" href="#eine-reihe-von-elementen-verarbeiten-mit-iteratoren" id="eine-reihe-von-elementen-verarbeiten-mit-iteratoren">Eine Reihe von Elementen verarbeiten mit Iteratoren</a></h2>
<p>Iteratoren ermöglichen dir, nacheinander eine Aufgabe für eine Folge von
Elementen auszuführen. Der Iterator ist für die Logik verantwortlich, die
Elemente zu durchlaufen und zu bestimmen, wann eine Sequenz beendet ist.
Durch die Verwendung von Iteratoren ist es nicht notwendig, diese Logik selbst
neu zu implementieren.</p>
<p>Die Iteratoren in Rust sind <em>faul</em> (lazy), das bedeutet, dass sie erst durch
Methodenaufrufe verbraucht werden müssen, um einen Effekt zu haben. Der Programmcode in
Codeblock 13-13 erstellt beispielsweise einen Iterator über die Elemente im
Vektor <code>v1</code> indem die in <code>Vec&lt;T&gt;</code> definierte Methode <code>iter</code> aufgerufen wird.
Dieser Programmcode macht nichts Sinnvolles.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-13: Einen Iterator erstellen</span></p>
<p>Ein Iterator kann nach Erstellung auf verschiedene Weise verwendet werden. In
Codeblock 3-5 in Kapitel 3 haben wir Iteratoren mit <code>for</code>-Schleifen verwendet,
um Programmcode für jedes Element auszuführen, wenngleich wir dadurch nur den
Aufruf von <code>iter</code> schöngefärbt haben.</p>
<p>In Codeblock 13-14 wird die Erstellung des Iterators von dessen Verwendung in
der <code>for</code>-Schleife getrennt. Der Iterator wird in der Variable <code>v1_iter</code>
gespeichert und es findet noch keine Iteration statt. Erst wenn die
<code>for</code>-Schleife mit dem Iterator in <code>v1_iter</code> aufgerufen wird, wird jedes
Element von <code>v1_iter</code> in einer Iteration der Schleife verwendet, die den
jeweiligen Wert ausgibt.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Erhielt: {}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-14: Verwendung eines Iterators in einer
<code>for</code>-Schleife</span></p>
<p>In Sprachen, deren Standardbibliotheken Iteratoren nicht bereitstellen, würde
man diese Funktionalität bereitstellen, indem man eine Variable bei Index 0
startet und diese zum Indizieren im Vektor verwendet und den Wert der 
Indexvariable bei jedem Schleifendurchlauf erhöht bis die Gesamtzahl der
Elemente im Vektor erreicht ist.</p>
<p>Iteratoren übernehmen derartige Logik für dich und reduzieren dadurch sich
wiederholenden Code, der zusätzliche Fehlerquellen beinhalten kann. Iteratoren
geben dir mehr Flexibilität bei der Verwendung derselben Logik für viele
verschiedene Arten von Sequenzen, nicht nur für Datenstrukturen, die du wie
Vektoren indizieren kannst. Lass uns herausfinden, wie Iteratoren das
bewerkstelligen.</p>
<h3><a class="header" href="#das-merkmal-trait-iterator-und-die-methode-next" id="das-merkmal-trait-iterator-und-die-methode-next">Das Merkmal (trait) <code>Iterator</code> und die Methode <code>next</code></a></h3>
<p>Alle Iteratoren implementieren ein Merkmal namens <code>Iterator</code> das in der
Standardbibliothek definiert ist. Die Definition dieses Merkmals sieht wie folgt
aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Methoden mit Standardimplementierung wurden elidiert
}
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass in der Definition eine neue Syntax verwendet wird: <code>type Item</code> und
<code>Self::Item</code> die einen <em>zugeordneten Typ</em> (associated type) mit diesem Merkmal 
definieren. Wir werden zugeordnete Typen im Kapitel 19 besprechen. Im Moment
musst du nur wissen, dass dieser Programmcode bedeutet, dass die Implementierung
des <code>Iterator</code>-Merkmals erfordert, dass du auch einen <code>Item</code>-Typ definierst und
dieser <code>Item</code>-Typ im Rückgabetyp der <code>next</code>-Methode benutzt wird. Mit anderen
Worten wird der <code>Item</code>-Typ der vom Iterator zurückgegebene Typ sein.</p>
<p>Für das <code>Iterator</code>-Merkmal muss man bei der Implementierung nur eine Methode
definieren: Die <code>next</code>-Methode, die jeweils ein Element des Iterators verpackt
in <code>Some</code> zurückgibt und nach Beendigung der Iteration <code>None</code> zurückgibt.</p>
<p>Wir können für Iteratoren die <code>next</code>-Methode direkt aufrufen. Codeblock 13-15
zeigt, welche Werte bei wiederholten Aufrufen von <code>next</code> auf einen aus einem
Vektor erstellten Iterator zurückgegeben werden:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-15: Iterator mit der <code>next</code>-Methode aufrufen</span></p>
<p>Beachte, dass wir <code>v1_iter</code> veränderlich (mutable) machen mussten: Beim Aufrufen
der <code>next</code>-Methode auf einen Iterator wird dessen interner Status geändert, der
verwendet wird, um festzustellen, wo sich der Iterator in der Sequenz befindet.
Mit anderen Worten <em>verbraucht</em> dieser Programmcode den Iterator. Jeder Aufruf
von <code>next</code> isst ein Element des Iterators auf. Als wir die <code>for</code>-Schleife
benutzten, mussten wir <code>v1_iter</code> nicht veränderlich machen, da dies schon hinter
den Kulissen geschah, als die Schleife die Eigentümerschaft (ownership) von
<code>v1_iter</code> übernahm.</p>
<p>Merke auch, dass die Werte, die wir von den Aufrufen von <code>next</code> erhalten,
unveränderliche Referenzen (immutable references) auf die Werte im Vektor sind.
Die <code>iter</code>-Methode erzeugt einen Iterator über unveränderliche Referenzen. Wenn
wir einen Iterator erzeugen möchten der die Eigentümerschaft von <code>v1</code> übernimmt
und angeeignete Werte (owned values) zurückgibt, können wir die
<code>into_iter</code>-Methode anstelle von <code>iter</code> benutzen, und wenn wir über veränderliche
Referenzen iterieren möchten, können wir <code>iter_mut</code> statt <code>iter</code> aufrufen.</p>
<h3><a class="header" href="#methoden-die-den-iterator-verbrauchen" id="methoden-die-den-iterator-verbrauchen">Methoden die den Iterator verbrauchen</a></h3>
<p>Das <code>Iterator</code>-Merkmal verfügt über eine Vielzahl von Methoden, die in der
Standardbibliothek bereitgestellt werden. Du kannst dich über diese Methoden
informieren, indem du in der Standardbibliothek-API-Dokumentation (standard
library API documentation) nach dem <code>Iterator</code>-Merkmal suchst. Einige dieser
Methoden rufen in ihrer Definition die <code>next</code>-Methode auf, daher musst du die
<code>next</code>-Methode bei der Implementierung des <code>Iterator</code>-Merkmals einbauen.</p>
<p>Methoden die <code>next</code> aufrufen werden als <em>konsumierende Adapter</em> (consuming
adaptors) bezeichnet, da deren Aufruf den Iterator verbraucht. Ein Beispiel ist
die Methode <code>sum</code>, sie übernimmt die Eigentümerschaft des Iterators und
durchläuft die Elemente durch wiederholtes Aufrufen von <code>next</code>, wodurch der
Iterator verbraucht wird. Jedes Element wird während der Iteration zu einer
Summe hinzugefügt, die zurückgegeben wird, sobald die Iteration abgeschlossen
ist. Codeblock 13-16 enthält einen Test, der die <code>sum</code>-Methode veranschaulicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-16: Aufruf der <code>sum</code>-Methode um den Wert der
Summe aller Elemente zu erhalten</span></p>
<p>Man kann <code>v1_iter</code> nach dem Aufruf von <code>sum</code> nicht verwenden, da <code>sum</code> die
Eigentümerschaft des Iterators übernimmt, auf dem sie aufgerufen wird.</p>
<h3><a class="header" href="#methoden-die-andere-iteratoren-erzeugen" id="methoden-die-andere-iteratoren-erzeugen">Methoden die andere Iteratoren erzeugen</a></h3>
<p>Andere Methoden die im <code>Iterator</code>-Merkmal definiert sind werden als
<em>Iteratoradapter</em> (iterator adaptors) bezeichnet, sie ermöglichen dir Iteratoren
in andere Arten von Iteratoren zu ändern. Man kann mehrere Aufrufe von
Iteratoradaptern verketten und dadurch komplexe Handlungen auf lesbare Art
ausführen. Da alle Iteratoren jedoch faul sind, ist es notwendig, eine der
konsumierenden Adapter-Methoden aufzurufen, um Ergebnisse zu erhalten.</p>
<p>Codeblock 13-17 zeigt ein Beispiel von einen Aufruf der <code>map</code>-Methode, die einen
Funktionsabschluss auf jedes Element anwendet, um einen neuen Iterator zu
erstellen. Dieser Funktionsabschluss inkrementiert den Wert jedes Elementes des
Vektors um 1. Dieser Programmcode erzeugt jedoch eine Warnung:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-17: Aufruf des Iteratoradapters <code>map</code> um
einen neuen Iterator zu erzeugen</span></p>
<p>Wir erhalten folgende Warnung:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Der Programmcode in Codeblock 13-17 hat keine Wirkung, der Funktionsabschluss
wird nie aufgerufen. Die Warnung erinnert uns daran, dass Iteratoradapter faul
sind und dass wir den Iterator verwenden müssen, um etwas zu bewirken.</p>
<p>Um das zu beheben, werden wir die <code>collect</code>-Methode verwenden, die wir im Kapitel
12 mit <code>env::args</code> im Codeblock 12-1 benutzt haben. Diese Methode konsumiert den
Iterator und sammelt die Ergebniswerte in einen Kollektionsdatentyp (collection
data type).</p>
<p>In Codeblock 13-18 sammeln wir die Resultate der Iterationen über den Iterator,
der vom Aufruf der <code>map</code>-Methode zurückgegeben wird, in einem Vektor. Dieser
Vektor wird dann alle Elemente vom Originalvektor erhöht um 1 beinhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-18: Aufruf der <code>map</code>-Methode um einen
Iterator zu erzeugen und anschließend der <code>collect</code>-Methode um den
Iterator zu verbrauchen und einen Vektor zu erzeugen</span></p>
<p>Da <code>map</code> einen Funktionsabschluss als Parameter annimmt, können wir eine
beliebige Operation spezifizieren, die wir auf jedes Element anwenden wollen.
Dies ist ein gutes Beispiel dafür, wie man mit Funktionsabschlüssen ein
Verhalten anpassen kann, während das vom <code>Iterator</code>-Merkmal bereitgestellte 
Iterationsverhalten wiederverwendet wird.</p>
<h3><a class="header" href="#verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen" id="verwendung-von-funktionsabschlüssen-die-ihre-umgebung-erfassen">Verwendung von Funktionsabschlüssen die ihre Umgebung erfassen</a></h3>
<p>Nun, da wir uns ein wenig mit Iteratoren befasst haben, werden wir anhand
des <code>filter</code>-Iteratoradapters eine häufige Verwendung von Funktionsabschlüssen
die ihre Umgebung erfassen zeigen. Die <code>filter</code>-Methode eines Iterators nimmt
einen Funktionsabschluss als Argument, der für jedes Element des Iterators
einen booleschen Wert zurückgibt. Wenn der Funktionsabschluss <code>true</code>
zurückgibt, wird der Wert in den von <code>filter</code> erzeugten Iterator aufgenommen,
wird <code>false</code> zurückgegeben, ist der Wert im resultierenden Iterator nicht
enthalten.</p>
<p>Im Codeblock 13-19 benutzen wir <code>filter</code> mit einem Funktionsabschluss, der die
Variable <code>shoe_size</code> aus seiner Umgebung erfasst, um über eine Kollektion von
<code>shoe</code>-Strukturinstanzen zu iterieren. Er wird nur Schuhe (shoes) einer
bestimmten Größe zurückgeben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-19: Die <code>filter</code>-Methode mit einen
Funktionsabschluss benutzen der <code>shoe_size</code> erfasst</span></p>
<p>Die <code>shoes_in_my_size</code>-Funktion übernimmt die Eigentümerschaft über einen Vektor
aus Schuhen mit der Schuhgröße als Parameter und gibt einen Vektor zurück, der
nur Schuhe einer bestimmten Größe enthält.</p>
<p>Im Funktionsrumpf von <code>shoes_in_my_size</code> rufen wir <code>into_iter</code> auf, um einen
Iterator zu erzeugen, der die Eigentümerschaft vom Vektor übernimmt. Im Anschluss
rufen wir den <code>filter</code>-Adapter auf, um einen neuen Iterator zu erzeugen, der nur
Elemente enthält, für die der Funktionsabschluss <code>true</code> zurückgibt.</p>
<p>Der Funktionsabschluss erfasst den <code>shoe_size</code>-Parameter aus seiner Umgebung und
vergleicht dessen Wert mit der jeweiligen Schuhgröße und behält nur Schuhe der
gewählten Größe. Zuletzt sammelt der Aufruf der <code>collect</code>-Methode die
zurückgegeben Werte des angeschlossenen Adapters in den Vektor, der von der
Funktion zurückgegeben wird.</p>
<p>Der Test zeigt, wenn wir <code>shoes_in_my_size</code> aufrufen, bekommen wir nur Schuhe
der spezifizierten Größe zurück.</p>
<h3><a class="header" href="#mit-dem-iterator-merkmal-eigene-iteratoren-erstellen" id="mit-dem-iterator-merkmal-eigene-iteratoren-erstellen">Mit dem <code>Iterator</code>-Merkmal eigene Iteratoren erstellen</a></h3>
<p>Wir haben bereits gezeigt, wie man mit <code>iter</code>, <code>into_iter</code> und <code>iter_mut</code> einen
Iterator zu einem Vektor erstellen kann. Du kannst Iteratoren
auch aus anderen Kollektion-Typen der Standardbibliothek wie zum Beispiel einer 
Hashtabelle (hash map) herstellen. Du kannst auch beliebige Iteratoren
durch Implementierung des <code>Iterator</code>-Merkmals auf eigene Typen erstellen. 
Wie bereits erwähnt ist die einzige Methode, für die du eine Definition angeben
musst, die <code>next</code>-Methode. Sobald man das getan hat, kann man alle anderen
Methoden verwenden, die die Standardimplementierung des <code>Iterator</code>-Merkmals
bereitstellt.</p>
<p>Erstellen wir nun einen Iterator zur Demonstration, der immer nur von 1 bis 5 zählt.
Zunächst erstellen wir eine Struktur, die einige Werte enthält, anschließend
machen wir aus dieser Struktur einen Iterator, indem wir das <code>Iterator</code>-Merkmal
implementieren und die Werte in dieser Implementierung benutzen.</p>
<p>Codeblock 13-20 enthält die Definition einer <code>Counter</code>-Struktur und eine
zugehörige <code>new</code>-Funktion zur Erstellung von Instanzen von <code>Counter</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-20: Definition einer <code>Counter</code>-Struktur und einer
Funktion <code>new</code> die Instanzen von <code>Counter</code> mit einem Startwert 0 für <code>count</code> erstellt</span></p>
<p>Die <code>Counter</code>-Struktur beinhaltet ein Feld <code>count</code>, dieses Feld hält einen
<code>u32</code>-Wert der den aktuellen Status der Iteration von 1 bis 5 wiedergibt. Das
Feld <code>count</code> ist privat, da wir möchten, das die Implementierung von <code>Counter</code>
den Wert verwaltet. Die <code>new</code>-Funktion erzwingt, dass neue Instanzen stets mit
einem Wert 0 im <code>count</code>-Feld beginnen.</p>
<p>Als Nächstes werden wir das <code>Iterator</code>-Merkmal für unseren <code>Counter</code>-Typ
implementieren, indem wir den Rumpf der <code>next</code>-Methode so definieren, das er
beinhaltet was wir geschehen lassen möchten, wenn der Iterator benutzt wird.
Siehe Codeblock 12-21:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">   count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">   fn new() -&gt; Counter {
</span><span class="boring">       Counter { count: 0 }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-21: Implementierung des <code>Iterator</code>-Merkmals für
die <code>Counter</code>-Struktur</span></p>
<p>Wir setzen den zugehörigen Typ unseres Iterators auf <code>u32</code>, was bedeutet, dass 
der Iterator <code>u32</code>-Werte zurückgibt. Nochmals, kümmere dich derzeit nicht um 
zugehörige Typen, wir werden sie in Kapitel 19 behandeln.</p>
<p>Wir möchten, dass unser Iterator 1 zum aktuellen Wert hinzufügt, daher haben wir 
<code>count</code> mit 0 initialisiert. Damit er zuerst 1 zurückgibt, wenn der Wert von
<code>count</code> kleiner als 5 ist, erhöht <code>next</code> <code>count</code> und gibt den aktuellen Wert
zurück, der in <code>Some</code> eingeschlossen ist. Wenn <code>count</code> gleich 5 ist, stoppt
unser Iterator das Inkrementieren und gibt immer <code>None</code> zurück.</p>
<h4><a class="header" href="#verwendung-der-next-methode-unseres-counter-iterators" id="verwendung-der-next-methode-unseres-counter-iterators">Verwendung der <code>next</code>-Methode unseres <code>Counter</code>-Iterators</a></h4>
<p>Sobald wir das <code>Iterator</code>-Merkmal implementiert haben, verfügen wir über einen
Iterator! Codeblock 13-22 zeigt mittels Test, dass wir die
<code>Iterator</code>-Funktionalität unserer <code>Counter</code>-Funktion benutzen können, indem wir
die <code>next</code>-Methode direkt auf ihn verwenden, so wie wir es mit dem von einem
Vektor erzeugten Iterator im Codeblock 13-15 gemacht haben.</p>
<p><span class="filename">Codeblock: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-22: Testen der Funktionalität der
Implementierung der <code>next</code>-Methode</span></p>
<p>Dieser Test erstellt eine neue Instanz von <code>Counter</code> in der <code>counter</code>-Variable
und ruft dann wiederholt <code>next</code> auf, um zu überprüfen, ob wir das Verhalten
entsprechend implementiert haben und der Iterator die Werte von 1 bis 5
zurückgibt.</p>
<h4><a class="header" href="#verwendung-anderer-iterator-merkmalsmethoden" id="verwendung-anderer-iterator-merkmalsmethoden">Verwendung anderer <code>Iterator</code>-Merkmalsmethoden</a></h4>
<p>Da wir das <code>Iterator</code>-Merkmal durch implementieren der <code>next</code>-Methode
eingerichtet haben, können wir nun beliebige Methoden der
Standardimplementierung des <code>Iterator</code>-Merkmals benutzen, da sie alle die
Funktionalität der <code>next</code>-Methode verwenden.</p>
<p>Wenn wir beispielsweise die Werte übernehmen  und sie mit den Werten
einer anderen <code>Counter</code>-Instanz koppeln wollen und nach dem Überspringen des
ersten Wertes der anderen Instanz jedes Zahlenpaar miteinander multiplizieren
dabei allerdings nur die Werte behalten, die durch 3 teilbar sind, und diese dann
summieren möchten, können wir das wie im Codeblock 13-23 beschrieben erreichen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn calling_next_directly() {
</span><span class="boring">        let mut counter = Counter::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(counter.next(), Some(1));
</span><span class="boring">        assert_eq!(counter.next(), Some(2));
</span><span class="boring">        assert_eq!(counter.next(), Some(3));
</span><span class="boring">        assert_eq!(counter.next(), Some(4));
</span><span class="boring">        assert_eq!(counter.next(), Some(5));
</span><span class="boring">        assert_eq!(counter.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-23: Benutzung einer Auswahl von <code>Iterator</code>-Merkmal
Methoden auf unseren <code>Counter</code>-Iterator</span></p>
<p>Beachte, dass <code>zip</code> nur vier Paare erzeugt. Das theoretische fünfte Paar <code>(5, None)</code> wird nicht erzeugt da <code>zip</code> <code>None</code> zurückgibt wenn einer seiner
Eingabeiteratoren <code>None</code> zurückgibt.</p>
<p>Alle diese Methodenaufrufe sind möglich, da wir angegeben haben wie die
<code>next</code>-Methode in <code>Counter</code> funktioniert und die Standardbibliothek für andere
Methoden, die <code>next</code> aufrufen, Standardimplementierungen bereitstellt.</p>
<h2><a class="header" href="#unser-ea-projekt-verbessern" id="unser-ea-projekt-verbessern">Unser E/A-Projekt verbessern</a></h2>
<p>Mit diesem Wissen über Iteratoren können wir unser E/A-Projekt in Kapitel 12
verbessern. Wir werden Bereiche im Code klarer und prägnanter gestalten. Lass
uns herausfinden wie Iteratoren unsere Implementierung der
Funktion <code>Config::new</code> und der Funktion <code>search</code> optimieren können.</p>
<h3><a class="header" href="#ein-clone-durch-verwendung-eines-iterators-entfernen" id="ein-clone-durch-verwendung-eines-iterators-entfernen">Ein <code>clone</code> durch Verwendung eines Iterators entfernen</a></h3>
<p>Im Codeblock 12-6 haben wir Programmcode hinzugefügt, der einen Anteilstyp
(slice) von <code>Zeichenketten</code>-Werten (String values) nimmt, und erzeugten eine
<code>Config</code>-Struktur indem wir den Anteilstyp indexierten und die Werte klonten
und der <code>Config</code>-Struktur die Eigentümerschaft dieser Werte gaben. Im Codeblock
13-24 haben wir die Implementierung der Funktion <code>Config::new</code> so reproduziert 
wie sie im Codeblock 12-23 aussah:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;nicht genügend Argumente&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-24: Reproduktion der <code>Config::new</code>-Funktion
vom Codeblock 12-23</span></p>
<p>Zu diesem Zeitpunkt sagten wir, dass man sich keine Gedanken wegen der
ineffizienten <code>clone</code>-Aufrufe machen soll, da sie zu einem späteren Zeitpunkt
entfernt werden. Jetzt ist es an der Zeit, dass wir uns darum kümmern!</p>
<p>Wir haben <code>clone</code> benutzt, da wir einen Anteilstyp mit <code>String</code>-Elementen im
Parameter <code>args</code> haben. Um die Eigentümerschaft einer <code>Config</code>-Instanz
zurückzugeben, mussten wir die Werte aus den Feldern <code>query</code> und <code>filename</code> von
<code>Config</code> klonen, damit die <code>Config</code>-Instanz ihre Werte besitzen kann.</p>
<p>Mithilfe unserer neuen Kenntnisse über Iteratoren können wir die
<code>new</code>-Funktion so ändern, dass sie die Eigentümerschaft eines Iterators als
Argument nimmt anstatt sich einen Anteilstyp auszuleihen. Wir werden die
<code>Iterator</code>-Funktionalität benutzen und nicht mehr den Programmcode der die Länge
des Anteilstyps überprüft und an bestimmte Stellen indiziert. Dadurch wird deutlich,
was die <code>Config::new</code>-Funktion bewirkt, da der Iterator auf Werte zugreift.</p>
<p>Sobald <code>Config::new</code> die Eigentümerschaft des Iterators hat und keine
ausgeliehenen Indexierungsoperationen mehr verwendet, können wir die
<code>Zeichenketten</code>-Werte vom <code>Iterator</code> in <code>Config</code> verschieben anstatt <code>clone</code>
aufzurufen und eine neue Zuweisung vorzunehmen.</p>
<h4><a class="header" href="#direktes-verwenden-des-zurückgegebenen-iterators" id="direktes-verwenden-des-zurückgegebenen-iterators">Direktes Verwenden des zurückgegebenen Iterators</a></h4>
<p>Öffne die Datei <em>src/main.rs</em> deines E/A-Projekts, sie sollte so aussehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem beim Parsen der Argumente: {}&quot;, err);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!(&quot;Anwendungsfehler: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}
</code></pre>
<p>Wir werden den Anfang der Funktion <code>main</code> von Codeblock 12-24 in den 
Programmcode im Codeblock 13-25 ändern. Dieser Code wird erst kompilieren,
wenn wir auch <code>Config::new</code> abgeändert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem beim Parsen der Argumente: {}&quot;, err);
        process::exit(1);
    });

    // --abschneiden--
<span class="boring">  
</span><span class="boring">
</span><span class="boring">   if let Err(e) = minigrep::run(config) {
</span><span class="boring">       eprintln!(&quot;Anwendungsfehler: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">       process::exit(1);
</span><span class="boring">   }
</span>}
</code></pre>
<p><span class="caption">Codeblock 13-25: Übergabe des Rückgabewerts von 
<code>env::args</code> an <code>Config::new</code></span></p>
<p>Die <code>env::arg</code>-Funktion gibt einen Iterator zurück! Anstatt die Werte des Iterators
in einem Vektor zu sammeln und dann einen Anteilstyp an <code>Config::new</code> zu
übergeben, geben wir nun die Eigentümerschaft des Iterators, der von <code>env::args</code>
zurückgegeben wird, direkt an <code>Config::new</code>.</p>
<p>Als Nächstes müssen wir die Definition von <code>Config::new</code> aktualisieren. Ändere
in der Datei <em>src/lib.rs</em> deines E/A-Projekts die Signatur von <code>Config::new</code> um,
damit sie so wie im Codeblock 13-26 aussieht. Dies wird noch immer nicht
kompilieren, da der Funktionsrumpf aktualisiert werden muss.</p>
<p><span class="filename">Dateiname src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub filename: String,
</span><span class="boring">   pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">     
</span><span class="boring">       if args.len() &lt; 3 {
</span><span class="boring">           return Err(&quot;nicht genügend Argumente&quot;);
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       let query = args[1].clone();
</span><span class="boring">       let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">       let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">       Ok(Config {
</span><span class="boring">           query,
</span><span class="boring">           filename,
</span><span class="boring">           case_sensitive,
</span><span class="boring">       })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.case_sensitive {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{}&quot;, line);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.contains(query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-26: Aktualisieren der Funktion<code>Config::new</code>
damit sie einen Iterator annimmt</span></p>
<p>Laut Dokumentation der Standardbibliothek für die Funktion <code>env::args</code> ist der
Typ des zurückgegebenen Iterators <code>std::env::Args</code>. Wir haben die Signatur
der Funktion <code>Config::New</code> aktualisiert, damit der Parameter <code>args</code> den Typ
<code>std::env::Args</code> statt <code>&amp;[String]</code> hat. Da wir die Eigentümerschaft von <code>args</code>
übernehmen und <code>args</code> beim Iterieren verändern werden, können wir das
Schlüsselwort <code>mut</code> in die Spezifikation des Parameter <code>args</code> eintragen, um ihn
veränderlich (mutable) zu machen.</p>
<h4><a class="header" href="#verwenden-von-iterator-merkmalen-anstelle-von-indizierung" id="verwenden-von-iterator-merkmalen-anstelle-von-indizierung">Verwenden von <code>Iterator</code>-Merkmalen anstelle von Indizierung</a></h4>
<p>Als Nächstes werden wir den Rumpf von <code>Config::new</code> in Ordnung bringen. In der
Standardbibliotheksdokumentation wird auch beschrieben, dass <code>std::env::Args</code>
das <code>Iterator</code>-Merkmal implementiert, daher wissen wir, dass wir die Methode
<code>next</code> darauf anwenden können! Codeblock 13-27 aktualisiert den Programmcode aus
Codeblock 12-23, damit <code>next</code> verwendet wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub filename: String,
</span><span class="boring">   pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Keine Abfragezeichenkette erhalten&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Keinen Dateinamen erhalten&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.case_sensitive {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{}&quot;, line);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.contains(query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 13-27: Ändern des Rumpfes von <code>Config::new</code> um
Iterator-Methoden zu verwenden</span></p>
<p>Beachte, dass der erste Wert des Rückgabewerts von <code>env::args</code> der Name des
Programms ist, wir wollen das ignorieren und rufen daher gleich <code>next</code> auf um
zum nächsten Wert zu gelangen und den ersten Rückgabewert zu überspringen. Als
Nächstes rufen wir <code>next</code> auf, um den Wert zu erhalten, den wir in das Feld <code>query</code>
von <code>Config</code> einfügen möchten. Falls <code>next</code> ein <code>Some</code> zurückgibt, benutzen wir
<code>match</code>, um den Wert zu extrahieren, wenn es jedoch <code>None</code> zurückgibt,
bedeutet dies, das nicht genügend Argumente eingegeben wurden und wir kehren
vorzeitig mit einem <code>Err</code> zurück. Dasselbe machen wir für den Wert <code>filename</code>.</p>
<h3><a class="header" href="#programmcode-mit-iteratorenadapter-klarer-gestalten" id="programmcode-mit-iteratorenadapter-klarer-gestalten">Programmcode mit Iteratorenadapter klarer gestalten</a></h3>
<p>Wir können die Vorteile der Iteratoren auch in der Funktion <code>search</code> unseres
E/A-Projekts nutzen, die hier im Codeblock 13-28 wiedergegeben, ist wie im
Codeblock 12-19:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">   pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">       if args.len() &lt; 3 {
</span><span class="boring">           return Err(&quot;nicht genügend Argumente&quot;);
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">       let query = args[1].clone();
</span><span class="boring">       let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">       Ok(Config { query, filename })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn one_result() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-28: Implementierung der Funktion <code>search</code>
aus Codeblock 12-19</span></p>
<p>Wir können diesen Programmcode durch die Verwendung von Iteratoradaptern
prägnanter gestalten und vermeiden, einen veränderlichen Vektor <code>results</code> für
die Zwischenergebnisse zu haben. Bevorzugt wird im funktionalen Programmierstil
die Menge der veränderlichen Werte reduziert, um den Code übersichtlicher zu
machen. Das Entfernen des veränderlich-Status kann uns eventuell zukünftige
Verbesserungen ermöglichen, um die Suche parallel auszuführen, da wir uns nicht
um die Verwaltung des simultanen Zugriffs auf den Ergebnisvektor kümmern müssen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">   pub query: String,
</span><span class="boring">   pub filename: String,
</span><span class="boring">   pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">   pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">       args.next();
</span><span class="boring">
</span><span class="boring">       let query = match args.next() {
</span><span class="boring">           Some(arg) =&gt; arg,
</span><span class="boring">           None =&gt; return Err(&quot;Keine Abfragezeichenkette erhalten&quot;),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       let filename = match args.next() {
</span><span class="boring">           Some(arg) =&gt; arg,
</span><span class="boring">           None =&gt; return Err(&quot;Keinen Dateinamen erhalten&quot;),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">       Ok(Config {
</span><span class="boring">           query,
</span><span class="boring">           filename,
</span><span class="boring">           case_sensitive,
</span><span class="boring">       })
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">   let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">   let results = if config.case_sensitive {
</span><span class="boring">       search(&amp;config.query, &amp;contents)
</span><span class="boring">   } else {
</span><span class="boring">       search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   for line in results {
</span><span class="boring">       println!(&quot;{}&quot;, line);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">   query: &amp;str,
</span><span class="boring">   contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">   let query = query.to_lowercase();
</span><span class="boring">   let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">   for line in contents.lines() {
</span><span class="boring">       if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">           results.push(line);
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_sensitive() {
</span><span class="boring">       let query = &quot;duct&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[test]
</span><span class="boring">   fn case_insensitive() {
</span><span class="boring">       let query = &quot;rUsT&quot;;
</span><span class="boring">       let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">           search_case_insensitive(query, contents)
</span><span class="boring">       );
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 13-29: Verwendung von Iteratoradapter-Methoden
bei der Implementierung der Funktion <code>search</code></span></p>
<p>Denke daran, der Zweck der Funktion <code>search</code> besteht darin, alle Zeilen in
<code>contents</code> zurückzugeben, die die <code>query</code> enthalten. So ähnlich wie im Beispiel
<code>filter</code> im Codeblock 13-19 verwendet dieser Programmcode den <code>filter</code>-Adapter,
um nur die Zeilen beizubehalten, für die <code>line.contains(query)</code> den Wert <code>true</code> zurückgibt.
Wir sammeln dann die passenden Zeilen mit <code>collect</code> in einen anderen Vektor.
Viel einfacher! Nimm die gleiche Änderung vor, um Iteratormethoden auch in der
Funktion <code>search_case_insensitive</code> zu nutzen.</p>
<p>Die nächste logische Frage wäre, welchen Stil du in deinem eigenen Programmcode
wählen solltest und warum. Die ursprüngliche Implementierung im Codeblock 13-28
oder die Version die Iteratoren verwendet im Codeblock 13-29. Die meisten
Rust-Programmierer bevorzugen den Iterator-Stil. Zunächst ist es zwar
schwieriger, den Überblick zu behalten, aber sobald du ein Gefühl für die
verschiedenen Iteratoradapter und deren Funktionsweise hast, können Iteratoren 
einfacher zu verstehen sein. Statt mit verschiedensten Schleifen herumzuspielen
und Vektoren zu erstellen, konzentriert sich der Programmcode auf das höhere
Ziel der Schleife. Dadurch wird ein Teil des gewöhnlichen Programmcodes
abstrahiert und die einzigartigen Konzepte, z.B. die Filterbedingung die
jedes Element bestehen muss um durch den Iterator zu kommen, werden leichter
erkennbar.</p>
<p>Aber sind beide Implementierungen wirklich gleichwertig? Die intuitive Annahme
könnte sein, dass die weniger abstrakte Schleife schneller ist. Lass uns über
Performanz sprechen.</p>
<h2><a class="header" href="#performanzvergleich-schleifen-vs-iteratoren" id="performanzvergleich-schleifen-vs-iteratoren">Performanzvergleich: Schleifen vs. Iteratoren</a></h2>
<p>Um festzustellen, ob man besser Schleifen oder Iteratoren verwendet, solltest du
wissen, welche Version unserer Funktion <code>search</code> schneller ist, die Version mit einer
expliziten <code>for</code>-Schleife oder die mit Iteratoren.</p>
<p>Wir haben einen Benchmark durchführt, der den gesamten Inhalt von <em>The
Adventures of Sherlock Holmes</em> von Sir Arthur Conan Doyle in eine <code>Zeichenkette</code>
(String) lädt und nach dem Wort <em>the</em> im Inhalt sucht. Hier sind die
Ergebnisse des Benchmarks für die Version von <code>search</code> mit <code>for</code>-Schleife und
der Version die Iteratoren verwendet:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Die Version mit Iteratoren war ein wenig schneller! Wir werden den Programmcode
des Benchmarks hier nicht erläutern, da es nicht darum geht, nachzuweisen, dass
die beiden Versionen gleichwertig sind, sondern einen allgemeinen Eindruck davon
zu bekommen, wie diese beiden Versionen im Bezug auf Performanz verglichen
werden.</p>
<p>Für einen umfassenderen Benchmark würde man verschiedene Texte
unterschiedlicher Größe als <code>contents</code>, verschiedene Wörter und Wörter
unterschiedlicher Länge als <code>query</code> verwenden und verschiedene Arten anderer
Variationen verwenden. Der Punkt ist folgender: Obwohl Iteratoren eine
hochrangige Abstraktion sind, werden sie ungefähr auf denselben Programmcode
kompiliert, als hättest du diesen selbst auf niedriger Ebene geschrieben.
Iteratoren sind eine von Rusts <em>Zero-Cost Abstraktionen</em>, damit ist gemeint,
dass die Verwendung keinen zusätzlichen Laufzeitaufwand verursacht. Dies
entspricht der Definition von <em>Zero-Overhead</em> in C++ von Bjarne Stroustrup in
&quot;Foundations of C++&quot; (2012):</p>
<blockquote>
<p>Im Allgemeinen folgen C++-Implementierungen dem Zero-Overhead-Prinzip: Was
du nicht verwendest, bezahlst du nicht. Und darüber hinaus: Was du verwendest,
hättest du von Hand nicht besser programmieren können. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
</blockquote>
<p>Als anderes Beispiel wird der folgende Programmcode eines Audiodecoders
übernommen. Der Decodierungsalgorithmus verwendet die mathematische Operation
der linearen Vorhersage (linear prediction), um zukünftige Werte aufgrund einer
linearen Funktion der vergangenen Abtastwerte zu schätzen. Der Programmcode
verwendet eine Iteratorkette, die drei Variablen im Gültigkeitsbereich
berechnet, einen Anteilstyp <code>buffer</code>, ein Array mit 12 <code>coefficients</code> und einen 
Wert um den die Daten die nach <code>glp_shift</code> verschoben werden sollen. Wir haben
die Variablen in diesem Beispiel deklariert, diesen jedoch keine Werte
zugewiesen, obwohl dieser Programmcode aus seinem Kontext gerissen keine große
Bedeutung hat, ist er dennoch ein gutes Beispiel dafür, wie Rust abstrakte Ideen
im Programmcode auf Code niedriger Ebene übersetzt.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>Um den Wert von <code>prediction</code> zu berechnen, durchläuft dieser Code jeden der 12
Werte in <code>coefficients</code> und verwendet die Methode <code>zip</code>, um die Werte der
Koeffizienten mit den vorherigen 12 Werten in <code>buffer</code> zu paaren. Anschließend
multiplizieren wir die Werte jedes Paars miteinander, summieren alle
Ergebnisse und verschieben die Bits in der Summe um den Wert von <code>glp_shift</code> nach
rechts.</p>
<p>Bei Berechnungen in Anwendungen wie Audiodecodern wird die Performanz häufig
priorisiert. Hier erstellen wir einen Iterator mit zwei Adaptern und verbrauchen
dann den Wert. Zu welchen Assemblercode würde dieser Rustprogrammcode
kompiliert werden? Er würde auf denselben Programmcode kompiliert werden, als
hättest du das Programm selbst in Assemblersprache geschrieben. Es gibt keine
Schleife, die der Iteration über die Werte von <code>coefficients</code> entsprechen würde.
Rust weiß, dass es 12 Iterationen gibt und „rollt“ daher die Schleife ab.
<em>Abrollen</em> (unrolling) ist eine Optimierung, die den Mehraufwand (overhead) der
Steuerung der Schleife beseitigt und stattdessen sich wiederholenden
Programmcode für jede Iteration der Schleife generiert.</p>
<p>Alle Koeffizienten werden in Registern gespeichert, das bedeutet, dass der
Zugriff auf die Werte sehr schnell ist. Es gibt keine Begrenzungsprüfungen (bounds
checks) für den Zugriff auf Arrays zur Laufzeit. Durch diese Optimierungen, die
Rust anwenden kann, ist der resultierende Programmcode äußerst effizient. Nun,
da du das weißt, kannst du, ohne Angst zu haben, Funktionsabschlüsse und
Iteratoren verwenden! Sie lassen den Code abstrakter erscheinen, verursachen
aber keine Performanzeinbußen zur Laufzeit.</p>
<h2><a class="header" href="#zusammenfassung-12" id="zusammenfassung-12">Zusammenfassung</a></h2>
<p>Funktionsabschlüsse und Iteratoren sind Rust-Funktionalitäten, die von Ideen der
funktionalen Programmierung inspiriert sind. Sie tragen zu Rusts Fähigkeit bei,
abstrakte Ideen bei guter Performanz zu ermöglichen. Die Implementierungen von
Iteratoren und Funktionsabschlüssen sind so, dass die Performanz der Laufzeit
nicht beeinträchtigt wird. Dies ist ein Teil von Rusts Ziel,
Zero-Cost-Abstraktionen zu ermöglichen.</p>
<p>Nachdem wir die Ausdruckskraft unseres E/A-Projekts verbessert haben, wollen
wir uns nun einige weitere Funktionalitäten von <code>cargo</code> ansehen, die uns helfen
werden, das Projekt mit der Welt zu teilen.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>(eigene Übersetzung) </p>
</div>
<h1><a class="header" href="#mehr-über-cargo-und-cratesio" id="mehr-über-cargo-und-cratesio">Mehr über Cargo und Crates.io</a></h1>
<p>Bisher haben wir nur die grundlegendsten Funktionalitäten von Cargo für das
Bauen (build), zum Ausführen und für das Testen unseres Programmcodes
verwendet, aber es kann noch vieles mehr. In diesem Kapitel werden einige der
fortgeschrittenen Funktionalitäten erläutern, um zu zeigen, wie man Folgendes
tun kann:</p>
<ul>
<li>Anpassen deines Bauvorgangs mit Freigabeprofilen (release profiles)</li>
<li>Veröffentlichen von Programmbibliotheken auf <a href="https://crates.io/">crates.io</a></li>
<li>Organisieren von großen Projekten mit Arbeitsbereichen (workspaces)</li>
<li>Installieren von Binärdateien (binaries) von <a href="https://crates.io/">crates.io</a></li>
<li>Cargo erweitern mit benutzerdefinierten Befehlen</li>
</ul>
<p>Cargo kann noch einiges mehr als wir in diesem Kapitel behandeln, eine vollständige
Erklärung aller Funktionen findest du in <a href="https://doc.rust-lang.org/cargo/">seiner Dokumentation</a>.</p>
<h2><a class="header" href="#bauvorgang-anpassen-mit-freigabeprofilen-release-profiles" id="bauvorgang-anpassen-mit-freigabeprofilen-release-profiles">Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></h2>
<p>In Rust sind <em>Freigabeprofile</em> vordefinierte, anpassbare Profile mit
unterschiedlichen Konfigurationen, durch die ein Programmierer mehr Kontrolle
über verschiedene Optionen zum Kompilieren von Programmcode hat. Jedes Profil
wird von den anderen unabhängig konfiguriert.</p>
<p>Cargo hat zwei Hauptprofile: Das Profil <code>dev</code>, das von Cargo verwendet wird, wenn
du <code>cargo build</code> ausführst, und das Profil <code>release</code>, das Cargo verwendet, wenn
<code>cargo build --release</code> ausgeführt wird. <code>dev</code> ist mit guten
Standardeinstellungen für die Entwicklung (development) definiert und <code>release</code>
hat gute Standardeinstellungen für Releasebuilds. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Profilnamen die dir möglicherweise aus der Ausgabe beim Bauvorgang bekannt sind:</p>
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>Die Angaben <code>dev</code> und <code>release</code> zeigen an, dass der Compiler
unterschiedliche Profile verwendet.</p>
<p>Cargo hat Standardeinstellungen für jedes der Profile, die verwendet werden,
wenn es keine Abschnitte <code>[profile.*]</code> in der Datei <em>Cargo.toml</em> des Projekts
gibt. Durch Hinzufügen eines Abschnitts <code>[profile.*]</code> für Profile, die du
anpassen möchtest, kannst du Teile der Standardeinstellungen überschreiben.
Hier sind zum Beispiel die Standardwerte für die Einstellung <code>opt-level</code> der
Profile <code>dev</code> und <code>release</code>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Die Einstellung <code>opt-level</code> steuert die Anzahl der Optimierungen, die Rust auf
den Programmcode anwendet, in einem Bereich 0 bis 3. Das Anwenden zusätzlicher
Optimierungen verlängert die Kompilierungszeit. Wenn man in der Entwicklung
häufig den Programmcode kompiliert, wünscht man zumeist, dass das Kompilieren
schneller ist, auch wenn dadurch der resultierende Programmcode langsamer
ausgeführt wird. Aus diesem Grund ist die Standardeinstellung <code>opt-level</code> für
<code>dev</code> <code>0</code>. Wenn du bereit bist, deinen Programmcode zu veröffentlichen, ist es
besser, wenn das Kompilieren mehr Zeit benötigt, man wird nur einmal im
Releasemodus kompilieren, aber das Programm oft ausführen, daher tauscht der
Releasemodus eine längere Kompilierungszeit gegen Programmcode, der schneller
ausgeführt wird. Aus diesem Grund ist das standardmäßige <code>opt-level</code> für das 
Profil <code>release</code> <code>3</code>.</p>
<p>Du kannst jede Standardeinstellung überschreiben, indem du dafür in <em>Cargo.toml</em>
einen anderen Wert hinzufügst. Wenn wir zum Beispiel die Optimierungsstufe 1 im
Entwicklungsprofil verwenden möchten, können wir diese beiden Zeilen in die
Datei <em>Cargo.toml</em> unseres Projekts hinzufügen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Dieser Code überschreibt die Standardeinstellung von <code>0</code>. Wenn wir nun <code>cargo build</code> ausführen, verwendet Cargo die Standardeinstellung für das Profil <code>dev</code>
sowie unsere Anpassung <code>1</code> für <code>opt-level</code>. Cargo wird mehr Optimierungen
vornehmen als mit Standardeinstellungen, aber weniger als bei einem
Releasebuild.</p>
<p>Eine vollständige Liste der Konfigurationsoptionen und Standardeinstellungen für
jedes Profil findest du in <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargos
Dokumentation</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><strong>Release</strong>: Veröffentlichung, <strong>Build</strong>: Kompilierter Quelltext</p>
</div>
<h2><a class="header" href="#kisten-crate-auf-cratesio-veröffentlichen" id="kisten-crate-auf-cratesio-veröffentlichen">Kisten (crate) auf crates.io veröffentlichen</a></h2>
<p>Wir haben Pakete von <a href="https://crates.io/">crates.io</a> als
Abhängigkeiten (dependencies) unseres Projekts verwendet. Du kannst deinen
Programmcode jedoch auch für andere Personen freigeben, indem du eigene Pakete
veröffentlichst. Die Registrierung von Kisten auf <a href="https://crates.io/">crates.io</a>
verteilt den Quellcode deiner Pakete, daher wird primär Open Source Programmcode
gehostet.</p>
<p>Rust und Cargo verfügen über Funktionalitäten, die es Benutzern erleichtern, ihr 
veröffentlichtes Paket zu verwenden und zu finden. Wir werden nun über einige
dieser Funktionalitäten sprechen und dann erklären, wie ein Paket veröffentlicht
wird.</p>
<h3><a class="header" href="#sinnvolle-dokumentationskommentare-erstellen" id="sinnvolle-dokumentationskommentare-erstellen">Sinnvolle Dokumentationskommentare erstellen</a></h3>
<p>Die genaue Dokumentation deiner Pakete hilft anderen Benutzern zu verstehen,
wie diese zu verwenden sind, daher lohnt es sich, Zeit in das Schreiben von
Dokumentationen zu investieren. In Kapitel 3 haben wir besprochen, wie man
Rust-Code mit zwei Schrägstrichen <code>//</code> kommentiert. Rust hat auch eine eigene
Art von Kommentar für die Dokumentation, die passenderweise als 
<em>Dokumentationskommentar</em> bezeichnet wird und HTML-Dokumentation generiert.
Der HTML-Code zeigt den Inhalt von Dokumentationskommentaren für öffentliche
API-Elemente an, die für Programmierer bestimmt sind, die wissen möchten,
wie deine Kiste <em>benutzt</em> wird, und nicht, wie deine Kiste <em>implementiert</em>
ist.</p>
<p>Dokumentationskommentare verwenden drei Schrägstriche <code>///</code> anstelle von zwei
und unterstützen Markdown-Notation zum Formatieren des Textes. Platziere
Dokumentationskommentare nur vor dem zu dokumentierenden Element. 
Codeblock 14-1 zeigt Dokumentationskommentare für eine Funktion <code>add_one</code> in
einer Kiste mit dem Namen <code> my_crate</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given 
///
/// # Examples 
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

</code></pre>
<p><span class="caption">Codeblock 14-1: Ein Dokumentationskommentar für eine Funktion</span> </p>
<p>Hier geben wir eine Beschreibung der Funktionsweise der Funktion <code>add_one</code> an,
beginnen einen Abschnitt mit der Überschrift <code>Examples</code> gefolgt vom
Programmcode, der die Verwendung der Funktion <code>add_one</code> demonstriert. Wir können
die HTML-Dokumentation aus diesem Dokumentationskommentar generieren, indem wir
<code>cargo doc</code> ausführen. Dieser Befehl führt das mit Rust verbreitete Werkzeug
<code>rustdoc</code> aus und legt die generierte HTML-Dokumentation im Verzeichnis
<em>target/doc</em> ab.</p>
<p>Wenn du <code>cargo doc --open</code> ausführst, wird der HTML-Code für die Dokumentation
deiner aktuellen Kiste (und auch die Dokumentation aller Abhängigkeiten
(dependencies) deiner Kiste) erstellt und das Ergebnis in einem Webbrowser
geöffnet. Wenn du zur Funktion <code>add_one</code> navigierst, wirst du sehen wie der Text
in den Dokumentationskommentaren gerendert wird. Siehe Abbildung 14-1:</p>
<img alt="Gerenderte HTML-Dokumentation für die Funktion `add_one` von `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Abbildung 14-1: HTML-Dokumentation für die Funktion
<code>add_one</code></span></p>
<h4><a class="header" href="#häufig-verwendete-abschnitte" id="häufig-verwendete-abschnitte">Häufig verwendete Abschnitte</a></h4>
<p>Wir haben die Markdown-Überschrift <code># Examples</code> in Codeblock 14-1 verwendet um
einen Abschnitt im HTML-Code mit dem Titel <code>Examples</code> zu erstellen. Hier sind
einige andere Abschnitte, die Autoren von Kisten häufig in ihrer Dokumentation
verwenden:</p>
<ul>
<li><strong>Panics</strong>: Die Szenarien, in denen die dokumentierte Funktion <code>panic</code>
aufruft. Anwender der Funktion, die nicht möchten, dass ihre Programme
<code>panic</code> aufrufen, sollten sicherstellen, dass sie die Funktion in solchen
Situationen nicht aufrufen.</li>
<li><strong>Errors</strong>: Wenn die Funktion einen Typ <code>Result</code> zurückgibt, der die Arten von
Fehlern die auftreten können beschreibt und unter welchen Bedingungen diese
Fehler auftreten können, dies kann für Aufrufende hilfreich sein, um
Programmcode zu schreiben der die verschiedenen Arten von Fehlern auf
unterschiedliche Art behandelt.</li>
<li><strong>Safety</strong>: Wenn die Funktion aufzurufen unsicher (<code>unsafe</code>) ist (wir
behandeln die Unsicherheit im Kapitel 19), sollte ein Abschnitt existieren,
in dem erläutert wird, warum die Funktion unsicher ist, und die Invarianten
behandelt werden die die Funktion vom Aufrufenden erwartet.</li>
</ul>
<p>Die meisten Dokumentationskommentare benötigen nicht alle Abschnitte, aber dies
ist eine gute Checkliste um dich an die Aspekte deines Programmcodes erinnern,
die für andere Personen die ihn aufrufen interessant sein werden.</p>
<h4><a class="header" href="#dokumentationskommentare-als-tests" id="dokumentationskommentare-als-tests">Dokumentationskommentare als Tests</a></h4>
<p>Das Hinzufügen von Beispiel-Codeblöcken in deinen Dokumentationskommentaren kann
dabei hilfreich sein, die Verwendung deiner Programmbibliothek darzustellen.
Dies hat einen zusätzlichen Bonus: Das Ausführen von <code>cargo test</code> führt die
Codeblöcke in deiner Dokumentation als Test aus! Nichts ist besser als eine
Dokumentation mit Beispielen, aber nichts ist schlimmer als eine Dokumentation
mit Beispielen die nicht funktionieren, da sich der Code seit dem Schreiben der
Dokumentation geändert hat. Wenn wir <code>cargo test</code> für die Dokumentation der
Funktion <code>add_one</code> aus Codeblock 14-1 aufrufen, sehen wir folgenden Abschnitt in
den Testergebnissen:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Wenn wir nun entweder die Funktion oder das Beispiel so ändern, dass <code>assert_eq!</code>
im Beispiel <code>panic</code> aufruft und erneut <code>cargo test</code> aufrufen, werden wir
bemerken, das <code>cargo test</code> feststellt, dass das Beispiel und der Code nicht
synchron miteinander sind!</p>
<h4><a class="header" href="#enthaltene-elemente-kommentieren" id="enthaltene-elemente-kommentieren">Enthaltene Elemente kommentieren</a></h4>
<p>Ein anderer Stil des Dokumentationskommentars <code>//!</code> fügt dem Element, das die
Kommentare enthält, Dokumentation hinzu, anstatt den Elementen die auf die
Kommentare folgen Dokumentation hinzuzufügen. Wir verwenden diese
Dokumentationskommentare üblicherweise in der Wurzeldatei (laut Konvention
<em>src/lib.rs</em>) oder in einem Modul, um die Kiste oder das Modul als Ganzes zu
dokumentieren.</p>
<p>Wenn wir beispielsweise eine Dokumentation hinzufügen möchten, die den Zweck
der <code>my_crate</code>-Kiste beschreibt, die die Funktion <code>add_one</code> enthält, können wir
am Anfang der Datei <em>src/lib.rs</em> Dokumentationskommentare hinzufügen die mit
<code>//!</code> beginnen. Siehe Codeblock 14-2: </p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">   x + 1
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 14-2: Dokumentation für die gesamte
<code>my_crate</code>-Kiste</span></p>
<p>Beachte, dass nach der letzten Zeile, die mit <code>//!</code> beginnt, kein Programmcode
mehr vorhanden ist. Da wir die Kommentare mit <code>//!</code> anstatt <code>///</code> begonnen
haben, dokumentieren wir das Element, das diesen Kommentar enthält und nicht ein 
Element, das diesem Kommentar folgt. In diesem Fall ist das Element, das diesen
Kommentar enthält, die Datei <em>src/lib.rs</em>, dabei handelt es sich um das
Wurzelverzeichnis der Kiste. Diese Kommentare beschreiben die gesamte Kiste.</p>
<p>Wenn wir <code>cargo doc --open</code> ausführen, werden diese Kommentare auf der
Startseite der Dokumentation für <code>my_crate</code> angezeigt, oberhalb der Liste der
veröffentlichten Elemente in der Kiste. Siehe Abbildung 14-2:</p>
<img alt="Gerenderte HTML-Dokumentation mit einem Kommentar für die gesamte Kiste" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Abbildung 14-2: Gerenderte Dokumentation für <code>my_crate</code>,
einschließlich des Kommentars, der die Kiste als Ganzes beschreibt</span></p>
<p>Dokumentationskommentare innerhalb von Elementen sind besonders nützlich, um
Kisten und Module zu beschreiben. Erkläre anhand dieser Informationen den
allgemeinen Zweck des Containers, damit seine Benutzer die Aufteilung der Kiste
besser verstehen können.</p>
<h3><a class="header" href="#mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren" id="mit-pub-use-eine-benutzerfreundliche-öffentliche-api-exportieren">Mit <code>pub use</code> eine benutzerfreundliche öffentliche API exportieren</a></h3>
<p>In Kapitel 7 wurde erläutert, wie wir unseren Programmcode mithilfe des
Schlüsselworts <code>mod</code> in Module organisieren, Elemente mit dem Schlüsselwort 
<code>pub</code> veröffentlichen und Elemente mit dem Schlüsselwort <code>use</code> in einen
Gültigkeitsbereich (scope) bringen. Die Struktur, die für dich während der
Entwicklung einer Kiste sinnvoll ist, ist für ihre Benutzer jedoch möglicherweise
nicht sehr benutzerfreundlich. Vielleicht möchtest du Strukturen in einer 
Hierarchie mit mehreren Ebenen organisieren, aber Personen, die einen Typ
verwenden möchten, den du tief in der Hierarchie definiert hast, haben
möglicherweise Probleme, herauszufinden, ob dieser Typ vorhanden ist. Sie könnten
sich auch darüber ärgern, dass sie <code>use</code> <code> my_crate::some_module::another_module::UsefulType;</code>
eingeben müssen anstatt <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Die Struktur deiner öffentlichen API spielt beim Veröffentlichen einer Kiste eine
wichtige Rolle. Personen, die deine Kiste verwenden, sind mit der Struktur weniger
vertraut als du und haben vielleicht Schwierigkeiten, die Teile zu finden,
die sie verwenden möchten, wenn deine Kiste eine große Modulhierarchie aufweist.</p>
<p>Die gute Nachricht ist, dass du die interne Organisation nicht neu anordnen
musst, wenn sie für andere aus einer anderen Bibliothek <em>nicht</em> geeignet ist.
Stattdessen kannst du Elemente erneut exportieren, um mit <code>pub use</code> eine
veränderte öffentliche Struktur von deiner privaten Struktur zu erstellen.
Beim Re-Exportieren wird ein öffentliches Element an einem Speicherort genommen 
und an einem anderen Speicherort öffentlich gemacht, als ob es stattdessen am
anderen Speicherort definiert worden wäre.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Bibliothek mit dem Namen <code>art</code>
erstellt, um künstlerische Konzepte zu modellieren. In dieser Bibliothek sind
zwei Module enthalten: Ein Modul <code>kinds</code> mit zwei Aufzählungen (enums) namens
<code>PrimaryColor</code> und <code>SecondaryColor</code> und ein Modul <code>utils</code> das eine Funktion
namens <code>mix</code> beinhaltet. Siehe Codeblock 14-3:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">       SecondaryColor::Orange
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 14-3: Eine Bibliothek <code>art</code> mit Elementen die in
Modulen <code>kinds</code> und <code>utils</code> organisiert sind</span></p>
<p>Abbildung 14-3 zeigt wie die Startseite der Dokumentation für diese Kiste
generiert von <code>cargo doc</code> aussehen würde.</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Abbildung 14-3: Startseite der Dokumentation für <code>art</code>
die Module <code>kinds</code> und <code>utils</code> auflistet</span></p>
<p>Beachte, dass die Typen <code>PrimaryColor</code>, <code>SecondaryColor</code> und die Funktion <code>mix</code>
nicht auf der Startseite angeführt sind. Wir müssen auf <code>kinds</code> und <code>utils</code>
klicken um sie zu sehen.</p>
<p>Eine Kiste, die von dieser Bibliothek abhängt, würde <code>use</code>-Anweisungen
benötigen, die die Elemente aus <code>art</code> in den Gültigkeitsbereich bringen und die
derzeit definierte Modulstruktur angeben. Codeblock 14-4 zeigt ein Beispiel für
eine Kiste, in der die Elemente <code>PrimaryColor</code> und <code>mix</code> aus der <code>art</code>-Kiste
verwendet werden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Codeblock 14-4: Eine Kiste, die die Gegenstände der 
<code>art</code>-Kiste mit ihrer internen Struktur exportiert</span></p>
<p>Der Autor des Programmcodes in Codeblock 14-4, der die Kiste <code>art</code> verwendet,
musste herausfinden, dass sich <code>PrimaryColor</code> im Modul <code>art</code> und <code>mix</code> im Modul
<code>utils</code> befindet. Die Modulstruktur der <code>art</code>-Kiste ist für Entwickler, die an
der <code>art</code>-Kiste arbeiten, relevanter als für Entwickler die die <code>art</code>-Kiste
verwenden. Die interne Struktur, die Teile der Kiste in das Modul <code>art</code> und das
Modul <code>utils</code> unterteilt, enthält keine nützlichen Informationen für jemanden,
der die <code>art</code>-Kiste benutzen möchte, sondern sorgt für Verwirrung, da Entwickler
herausfinden müssen wo sie suchen müssen und die Struktur ist unpraktisch, da
Entwickler die Modulnamen in den <code>use</code>-Anweisungen angeben müssen.</p>
<p>Um die interne Organisation aus der öffentlichen API zu entfernen, können wir den
Programmcode der <code>art</code>-Kiste ändern, um <code>pub use</code>-Anweisungen hinzuzufügen, um
die Elemente der obersten Ebene erneut zu exportieren, wie in Codeblock 14-5
gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
   // --snip--
<span class="boring">   /// The primary colors according to the RYB color model.
</span><span class="boring">   pub enum PrimaryColor {
</span><span class="boring">       Red,
</span><span class="boring">       Yellow,
</span><span class="boring">       Blue,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   /// The secondary colors according to the RYB color model.
</span><span class="boring">   pub enum SecondaryColor {
</span><span class="boring">       Orange,
</span><span class="boring">       Green,
</span><span class="boring">       Purple,
</span><span class="boring">   }
</span>}

pub mod utils {
    // --snip--
<span class="boring">   use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">   /// Combines two primary colors in equal amounts to create
</span><span class="boring">   /// a secondary color.
</span><span class="boring">   pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">       SecondaryColor::Orange
</span><span class="boring">   }
</span>}
</code></pre>
<p><span class="caption">Codeblock 14-5: Hinzufügen von <code>pub use</code>-Anmerkungen um
Elemente erneut zu exportieren</span></p>
<p>Die Dokumentation der API, die von <code>cargo doc</code> generiert wurde, wird nun
aufgelistet und die erneut exportierten Links werden auf der Startseite, wie in
Abbildung 14-4 ersichtlich, angezeigt, so sind die Typen <code>PrimaryColor</code> und
<code>SecondaryColor</code> leichter zu finden.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Abbildung 14-4: Die Startseite der Dokumentation von
<code>art</code> mit den aufgelisteten erneuten Exporten</span></p>
<p>Die Benutzer der <code>art</code>-Kiste können weiterhin die interne Struktur aus Codeblock
14-3 sehen und verwenden, wie es in Codeblock 14-4 gezeigt wurde, oder sie
können die benutzerfreundliche Struktur in Codeblock 14-5 verwenden, wie es im
Codeblock 14-6 gezeigt wurde:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">   let red = PrimaryColor::Red;
</span><span class="boring">   let yellow = PrimaryColor::Yellow;
</span><span class="boring">   mix(red, yellow);
</span>}
</code></pre>
<p><span class="caption">Codeblock 14-6: Ein Programm, das die erneut exportierten
Elemente der <code>art</code>-Kiste verwendet</span></p>
<p>In Fällen, in denen es viele verschachtelte Module gibt, kann das erneute 
Exportieren der Typen auf der obersten Ebene mit <code>pub use</code> die Erfahrung der
Benutzer der Kiste signifikant verbessern.</p>
<p>Das Erstellen einer sinnvollen öffentlichen API-Struktur ist eher eine Kunst als
eine Wissenschaft, und du kannst iterieren, um die API zu finden, die für
Benutzer am besten geeignet ist. Wenn man <code>pub use</code> wählt, erhält man
Flexibilität bei der internen Strukturierung einer Kiste und entkoppelt diese
interne Struktur von dem, was man ihren Benutzern präsentiert. Sieh dir 
einige der Programmcodes von Kisten an die du installiert hast, um festzustellen,
ob sie intern strukturiert sind und ob sich ihre interne Struktur von der
öffentlichen API unterscheidet.</p>
<h3><a class="header" href="#einrichten-eines-kontos-auf-cratesio" id="einrichten-eines-kontos-auf-cratesio">Einrichten eines Kontos auf Crates.io</a></h3>
<p>Bevor man eine Kiste veröffentlichen kann, muss man ein Konto auf 
<a href="https://crates.io/">crates.io</a> erstellen um ein API-Token zu
erhalten. Besuche dazu die Homepage auf <a href="https://crates.io/">crates.io</a>
und melde dich über ein GitHub-Konto an. (Derzeit ist ein GitHub-Konto eine
Voraussetzung, aber die Seite wird möglicherweise in Zukunft andere Wege einen
Account zu erstellen ermöglichen.) Sobald du angemeldet bist, gehe zu
Kontoeinstellungen (account settings) auf 
<a href="https://crates.io/me/">https://crates.io/me/</a> und erhalte deinen 
API-Schlüssel. Rufe anschließend das Kommando <code>cargo login</code> mit deinem
API-Schlüssel auf:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<h3><a class="header" href="#metadaten-zu-einer-neuen-kiste-hinzufügen" id="metadaten-zu-einer-neuen-kiste-hinzufügen">Metadaten zu einer neuen Kiste hinzufügen</a></h3>
<p>Angenommen, du hast ein Konto und eine Kiste, die du veröffentlichen möchtest.
Vor dem Veröffentlichen musst du deiner Kiste einige Metadaten hinzufügen,
indem du sie im Abschnitt <code>[package]</code> der Datei <em>Cargo.toml</em> der Kiste
hinzufügst.</p>
<p>Deine Kiste benötigt einen eindeutigen Namen. Während du vor Ort an einer Kiste
arbeitest, kannst du eine Kiste beliebig benennen. Allerdings werden Kistennamen
auf <a href="https://crates.io/">crates.io</a> nach Verfügbarkeit vergeben.
Sobald ein Kistenname vergeben ist, kann niemand mehr eine Kiste mit
diesem Namen veröffentlichen. Suche vor dem Versuch, eine Kiste zu veröffentlichen,
nach dem Namen, den du auf der Webseite verwenden möchtest. Wenn
der Name von einer anderen Kiste verwendet wurde, wirst du einen anderen Namen
suchen müssen und das Feld <code>name</code> in der Datei <em>Cargo.toml</em> im Abschnitt
<code>[package]</code> bearbeiten, um den neuen Namen für die Veröffentlichung zu
verwenden:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Selbst wenn du einen eindeutigen Namen gewählt hast, wird beim Ausführen von
<code>cargo publish</code> zum Veröffentlichen der Kiste an dieser Stelle eine Warnung und 
anschließend ein Fehler angezeigt:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Der Grund dafür ist, dass einige wichtige Informationen fehlen: Eine
Beschreibung und eine Lizenz sind erforderlich, damit die Benutzer wissen, was
deine Kiste tut und unter welchen Bedingungen man sie verwenden kann. Um diesen
Fehler zu beheben, muss man diese Informationen in die Datei <em>Cargo.toml</em>
aufnehmen.</p>
<p>Füge eine Beschreibung hinzu, die nur ein oder zwei Sätze umfasst, da sie
zusammen mit deiner Kiste in den Suchergebnissen angezeigt wird. Für das Feld
<code>license</code> musst du einen <em>Lizenzkennungswert</em> (licence identifier value) angeben.
In <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a>
sind die Bezeichner aufgeführt, die Sie für diesen Wert verwenden können. Um
beispielsweise anzugeben, dass du deine Kiste mit der MIT-Lizenz lizenziert
hast, füge die <code>MIT</code>-Identifikation hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Wenn man eine Lizenz verwenden möchte, die nicht in SPDX angezeigt wird, muss man
den Text dieser Lizenz in eine Datei einfügen, die Datei in das Projekt aufnehmen
und dann <code>license-file</code> verwenden um den Namen dieser Lizenz zu spezifizieren 
anstelle der Verwendung des <code>license</code>-Schlüssels.</p>
<p>Die Anleitung, welche Lizenz für dein Projekt geeignet ist, geht über den Rahmen
dieses Buches hinaus. Viele Leute in der Rust Community lizenzieren ihre Projekte
genauso wie Rust mit einer Doppellizenz von <code>MIT OR Apache-2.0</code>. Diese Übung
zeigt, dass man durch <code>OR</code> auch mehrere Lizenzkennungen getrennt angeben kann,
um mehrere Lizenzen für ein Projekt zu haben.</p>
<p>Mit einem eindeutigen Namen, der Version, den Angaben des Autors, die beim
Erstellen der Kiste mit <code>cargo new</code> hinzugefügt wurden, deiner Beschreibung und
einer hinzugefügten Lizenz könnte die Datei <em>Cargo.toml</em> für ein Projekt,
das zur Veröffentlichung bereit ist, folgendermaßen aussehen:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargos documentation</a> beschreibt andere 
Metadaten, die du angeben kannst, um sicherzustellen, dass andere deine Kiste
leichter entdecken und verwenden können.</p>
<h3><a class="header" href="#veröffentlichung-auf-cratesio" id="veröffentlichung-auf-cratesio">Veröffentlichung auf Crates.io</a></h3>
<p>Nachdem man ein Konto erstellt, den API-Token gespeichert, einen Namen für seine
Kiste ausgewählt und die erforderlichen Metadaten angegeben hat, kann man
sie veröffentlichen! Durch das Veröffentlichen einer Kiste wird eine bestimmte
Version auf <a href="https://crates.io/">crates.io</a> hochgeladen, damit andere sie
verwenden können.</p>
<p>Sei vorsichtig, wenn du eine Kiste veröffentlichst, da eine
Veröffentlichung <em>permanent</em> ist. Die Version kann niemals überschrieben und
der Programmcode nicht gelöscht werden. Ein Hauptziel von <a href="https://crates.io/">crates.io</a>
ist es, als permanentes Archiv von Code zu fungieren, sodass alle Projekte
die erstellt werden und von Kisten aus <a href="https://crates.io/">crates.io</a> abhängen
weiter funktionieren werden. Das Zulassen von Versionslöschungen würde das
Erreichen dieses Ziels unmöglich machen. Die Anzahl der Kistenversionen, die man
veröffentlichen kann, ist jedoch unbegrenzt.</p>
<p>Rufe <code>cargo publish</code> erneut auf. Diesmal sollte es funktionieren:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Herzlichen Glückwunsch! Du hast deinen Programmcode nun für die Rust-Community
freigegeben. Jeder kann deine Kiste einfach als Abhängigkeit für sein Projekt
hinzufügen.</p>
<h3><a class="header" href="#veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste" id="veröffentlichen-einer-neuen-version-einer-vorhandenen-kiste">Veröffentlichen einer neuen Version einer vorhandenen Kiste</a></h3>
<p>Wenn du Änderungen an deiner Kiste vorgenommen hast und bereit bist, eine neue
Version zu veröffentlichen, ändere den in der <em>Cargo.toml</em>-Datei
angegebenen Versionswert und veröffentliche ihn erneut. Verwende die
<a href="https://semver.org/lang/de/">Regeln für die semantische Versionierung</a>, um auf den von dir 
vorgenommenen Änderungen basierend welche neue Versionsnummer geeignet ist.
Führe dann <code>cargo publish</code> aus, um die neue Version hochzuladen.</p>
<h3><a class="header" href="#mit-cargo-yank-versionen-von-cratesio-entfernen" id="mit-cargo-yank-versionen-von-cratesio-entfernen">Mit <code>cargo yank</code> Versionen von Crates.io entfernen</a></h3>
<p>Obwohl man frühere Versionen einer Kiste nicht entfernen kann, kann man
verhindern, dass zukünftige Projekte sie als neue Abhängigkeit hinzufügen. Dies
ist nützlich, wenn eine Kistenversion aus dem einen oder anderen Grund defekt
ist. In solchen Situationen unterstützt Cargo das <em>herausziehen</em> (yanking)
einer Kistenversion.</p>
<p>Durch das Herausziehen einer Version wird verhindert, dass neue Projekte von
dieser Version abhängen, während alle vorhandenen Projekte, die davon abhängen,
weiterhin heruntergeladen werden können. Im Wesentlichen bedeutet Herausziehen
(yank), dass alle Projekte mit einem <em>Cargo.lock</em> nicht kaputt gehen und zukünftige
generierte <em>Cargo.lock</em>-Dateien nicht die herausgezogene Version verwenden.</p>
<p>Um eine Version einer Kiste herauszuziehen, rufe <code>cargo yank</code> auf und
spezifiziere welche Version du herausziehen möchtest:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<p>Durch Hinzufügen von <code>--undo</code>, kann man das Herausziehen rückgängig machen und
Projekten wieder erlauben von der Version abzuhängen:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>Das Herausziehen löscht <em>keinen</em> Programmcode. Beispielsweise ist die
Herausziehen-Funktion nicht zum Löschen versehentlich hochgeladener Geheimnisse
gedacht. Falls das passieren sollte musst du diese Geheimnisse sofort zurücksetzen.</p>
<h2><a class="header" href="#cargo-arbeitsbereiche" id="cargo-arbeitsbereiche">Cargo-Arbeitsbereiche</a></h2>
<p>In Kapitel 12 haben wir ein Paket erstellt, das eine binäre Kiste und eine
Bibliothekskiste enthält. Während dein Projekt entwickelt wird, wirst du
möglicherweise feststellen, dass die Bibliothekskiste immer größer wird und du
dein Paket weiter in mehrere Bibliothekskisten aufteilen möchtest. In dieser
Situation bietet Cargo eine Funktion namens <em>Arbeitsbereiche</em> (workspaces), mit
denen mehrere verwandte Pakete verwaltet werden können, die gemeinsam entwickelt
werden.</p>
<h3><a class="header" href="#einen-arbeitsbereich-erstellen" id="einen-arbeitsbereich-erstellen">Einen Arbeitsbereich erstellen</a></h3>
<p>Ein <em>Arbeitsbereich</em> ist eine Reihe von Paketen, die dieselbe Datei
<em>Cargo.lock</em> sowie dasselbe Ausgabeverzeichnis
(output directory) verwenden. Lass uns mithilfe eines Arbeitsbereiches ein
Projekt erstellen. Wir verwenden einfachen Programmcode, damit wir uns an die
Struktur des Arbeitsbereiches konzentrieren können. Es gibt verschiedene
Möglichkeiten, einen Arbeitsbereich zu strukturieren. Wir werden einen einen
üblichen Weg zeigen. Wir haben einen Arbeitsbereich mit einer Binärdatei und
zwei Bibliotheken. Die Binärdatei stellt die Hauptfunktion bereit und hängt von
den beiden Bibliotheken ab. Eine Bibliothek stellt die Funktion <code>add_one</code> und
die andere <code>add-two</code> zur Verfügung. Diese drei Kisten werden Teil desselben
Arbeitsbereichs sein. Zunächst erstellen wir ein neues Verzeichnis für den
Arbeitsbereich:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Als Nächstes erstellen wir im Verzeichnis <em>add</em> die Datei <em>Cargo.toml</em>, mit der
der gesamte Arbeitsbereich konfiguriert wird. Diese Datei enthält weder einen
Abschnitt <code>[package]</code> noch die Metadaten, die wir in den anderen
<em>Cargo.toml</em>-Dateien gesehen haben. Stattdessen beginnt sie mit einem Abschnitt
<code>[workspace]</code>, in dem wir Mitglieder zum Arbeitsbereich hinzufügen können, indem
wir den Pfad zum Paket mit unserer Binärkiste angeben. In diesem Fall lautet
dieser Pfad <em>adder</em>:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Als nächstes erstellen wir die Binärkiste <code>adder</code>, indem wir <code>cargo new</code> im
Verzeichnis <em>add</em> ausführen:</p>
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>An dieser Stelle können wir den Arbeitsbereich erstellen, indem wir <code>cargo build</code>
ausführen. Die Dateien in deinem <em>add</em>-Verzeichnis sollten folgendermaßen
aussehen: </p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Das Arbeitsbereich verfügt auf der obersten Ebene über ein <em>Zielverzeichnis</em> 
(target), in das die kompilierten Artefakte abgelegt werden sollen. Das Paket
<code>adder</code> hat kein eigenes <em>Zielverzeichnis</em>. Selbst wenn wir <code>cargo build</code> aus
dem Verzeichnis <em>adder</em> heraus ausführen würden, landen die kompilierten
Artefakte noch immer in <em>add/target</em> und nicht in <em>add/adder/target</em>. Cargo
strukturiert das <em>Zielverzeichnis</em> in einem derartigen Arbeitsverzeichnis, da
die Kisten voneinander abhängig sein sollen. Wenn jede Kiste ihr eigenes
<em>Zielverzeichnis</em> hätte, müssten für jede Kiste die anderen Kisten im
Arbeitsbereich neu kompiliert werden, damit die Artefakte ein eigenes
<em>Zielverzeichnis</em> haben könnten. Durch die gemeinsame Nutzung eines
Verzeichnisses können die Kisten unnötig wiederholte Erstellung vermeiden.</p>
<h3><a class="header" href="#erstellen-des-zweiten-pakets-im-arbeitsbereich" id="erstellen-des-zweiten-pakets-im-arbeitsbereich">Erstellen des zweiten Pakets im Arbeitsbereich</a></h3>
<p>Als Nächstes erstellen wir ein weiteres, dem Arbeitsbereich zugehöriges Paket
und nennen es <code>add_one</code>. Ändere die auf der obersten Ebene befindliche Datei
<em>Cargo.toml</em> um den <em>add-one</em>-Pfad in der Mitgliederliste anzugeben:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>Dann erzeuge eine neue Bibliothekskiste namens <code>add-one</code>:</p>
<pre><code class="language-console">$ cargo new add-one --lib
     Created library `add-one` package
</code></pre>
<p>Dein <em>add</em>-Verzeichnis sollte nun so aussehen:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Lass uns in der Datei <em>add_one/src/lib.rs</em>, eine Funktion <code>add_one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>Nun, da wir ein zusätzliches Paket im Arbeitsbereich haben, können wir das
<code>adder</code>-Paket von unserem <code>add-one</code>-Paket, das unsere Bibliothek enthält,
abhängig machen. Zuerst müssen wir <em>adder/Cargo.toml</em> einen Pfad zur
Abhängigkeit von <code>add-one</code> hinzufügen.</p>
<p><span class="filename">Dateiname: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Cargo geht nicht davon aus, dass Kisten in einem Arbeitsbereich voneinander
abhängen, daher müssen wir die Abhängigkeit explizit angeben.</p>
<p>Als nächstes verwenden wir die Funktion <code>add_one</code> aus der <code>add_one</code>-Kiste der
<code>adder</code>-Kiste. Öffne die Datei <em>adder/src/main.rs</em> und füge oben eine Zeile <code>use</code>
hinzu, um die neue Bibliothekskiste <code>add-one</code> in den Gültigkeitsbereich (scope)
zu bringen. Ändere dann die Funktion <code>main</code>, um die Funktion <code>add_one</code>
aufzurufen, siehe Codeblock 14-7.</p>
<p><span class="filename">Dateiname: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {} plus one is {}!&quot;,
        num,
        add_one::add_one(num)
    );
}
</code></pre>
<p><span class="caption">Codeblock 14-7: Die <code>add-one</code>-Bibliothekskiste aus der 
<code>adder</code>-Kiste verwenden</span></p>
<p>Erstellen wir den Arbeitsbereich, indem wir <code>cargo build</code> im obersten
Verzeichnis <em>add</em> ausführen!</p>
<pre><code class="language-console">$ cargo build
  Compiling add-one v0.1.0 (file:///projects/add/add-one)
  Compiling adder v0.1.0 (file:///projects/add/adder)
   Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Um die Binärkiste aus dem Verzeichnis <em>add</em> auszuführen, können wir mithilfe des
Arguments <code>-p</code> und des Paketnamens mit <code>cargo run</code> angeben, welches Paket im
Arbeitsbereich ausgeführt werden soll:</p>
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Dadurch wird der Programmcode in <em>adder/src/mein.rs</em> ausgeführt, der von der
Kiste <code>add-one</code> abhängt.</p>
<h4><a class="header" href="#abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich" id="abhängigkeiten-zu-externen-paketen-in-einem-arbeitsbereich">Abhängigkeiten zu externen Paketen in einem Arbeitsbereich</a></h4>
<p>Beachte, dass der Arbeitsbereich nur eine <em>Cargo.lock</em>-Datei auf der obersten
Ebene des Arbeitsbereichs enthält, anstatt einer in jeder Kiste. Dies stellt
sicher, dass alle Kisten dieselbe Version aller Abhängigkeiten verwenden. Wenn
wir das Paket <code>rand</code> zu den Dateien <em>adder/Cargo.toml</em> und <em>add-one/Cargo.toml</em>
hinzufügen, löst Cargo beide dieser Versionen zu einer auf und fügt diese in der
<em>Cargo.lock</em>-Datei hinzu. Wenn alle Kisten im Arbeitsbereich dieselben
Abhängigkeiten verwenden, sind die Kisten im Arbeitsbereich immer miteinander
kompatibel. Lass uns die <code>rand</code>-Kiste in der Datei <em>add-one/Cargo.toml</em> 
zum Abschnitt <code>[dependencies]</code> hinzufügen, um die Kiste <code>rand</code> in der <code>add-one</code>-Kiste
verwenden zu können:</p>
<p><span class="filename">Dateiname: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>Wir können nun <code>use rand;</code> zur Datei <em>add-one/src/lib.rs</em> hinzufügen, und wenn
du den gesamten Arbeitsbereich durch Ausführen von <code>cargo build</code> im Verzeichnis
<em>add</em> erstellst, wird die <code>rand</code>-Kiste eingefügt und kompiliert:</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.6
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Die <em>Cargo.lock</em>-Datei der obersten Ebene enthält nun Informationen über die
Abhängigkeit von <code>add-one</code> von <code>rand</code>. Obwohl <code>rand</code> irgendwo im Arbeitsbereich
verwendet wird, können wir es nicht in anderen Kisten im Arbeitsbereich
verwenden, es sei denn, wir fügen <code>rand</code> zu ihren <em>Cargo.toml</em>-Dateien hinzu.
Wenn wir beispielsweise <code>use rand;</code> zur Datei <em>adder/src/main.rs</em> für das Paket
<code>adder</code> hinzufügen, wird folgende Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
</code></pre>
<p>Um dies zu beheben, bearbeiten wir die Datei <em>Cargo.toml</em> für das Paket <code>adder</code>
und geben an, dass <code>rand</code> auch eine Abhängigkeit davon ist. Durch das Erstellen
des Pakets <code>adder</code> wird <code>rand</code> zur Liste der Abhängigkeiten für <code>adder</code> in
<em>Cargo.lock</em> hinzugefügt, es werden jedoch keine zusätzlichen Kopien von <code>rand</code>
heruntergeladen. Cargo hat sichergestellt, dass jede Kiste in jedem Paket im
Arbeitsbereich, die das <code>rand</code>-Paket verwendet, dieselbe Version benutzt.
Verwenden der gleichen Version von <code>rand</code> im gesamten Arbeitsbereich spart
Platz, da wir nicht mehrere Kopien haben und sicherstellen, dass die Kisten im
Arbeitsbereich miteinander kompatibel sind.</p>
<h4><a class="header" href="#hinzufügen-eines-tests-zu-einem-arbeitsbereich" id="hinzufügen-eines-tests-zu-einem-arbeitsbereich">Hinzufügen eines Tests zu einem Arbeitsbereich</a></h4>
<p>Füge für eine weitere Verbesserung innerhalb der <code>add_one</code>-Kiste einen Test der
Funktion <code>add_one::add_one</code> hinzu:</p>
<p><span class="filename">Dateiname: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Führen wir nun <code>cargo test</code> in der obersten Ebene im Verzeichnis <em>add</em> aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Der erste Abschnitt der Ausgabe zeigt, dass der Test <code>it_works</code> in der
<code>add-one</code>-Kiste bestanden wurde. Der nächste Abschnitt zeigt, dass in der Kiste
<code>adder</code> keine Tests gefunden wurden, und der letzte Abschnitt zeigt, dass in der
Kiste <code>add_one</code> keine Dokumentationstests gefunden wurden. Wenn du in einem auf
diese Weise strukturierten Arbeitsbereich <code>cargo test</code> ausführst, werden die
Tests für alle Kisten im Arbeitsbereich ausgeführt.</p>
<p>Wir können auch Tests für eine bestimmte Kiste in einem Arbeitsbereich aus dem
Verzeichnis der obersten Ebene ausführen, indem wir die Option <code>-p</code> verwenden und
den Namen der Kiste angeben, die wir testen möchten:</p>
<pre><code class="language-console">$ cargo test -p add-one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die Ausgabe zeigt, dass <code>cargo test</code> nur die Tests für die Kiste <code>add-one</code> aber
nicht die <code>adder</code>-Tests ausgeführt hat.</p>
<p>Wenn du die Kisten im Arbeitsbereich unter <a href="https://crates.io/">crates.io</a>
veröffentlichst, muss jede Kiste im Arbeitsbereich separat veröffentlicht
werden. Der Befehl <code>cargo publish</code> hat kein Flag <code>--all</code> oder <code>-p</code>, daher musst
du in das Verzeichnis jeder Kiste wechseln und <code>cargo publish</code> auf jeder Kiste
im Arbeitsbereich ausführen, um die Kisten zu veröffentlichen.</p>
<p>Als zusätzliche Übung, füge ähnlich der Kiste <code>add-one</code> diesem Arbeitsbereich
eine <code>add-two</code>-Kiste hinzu!</p>
<p>Wenn dein Projekt wächst, solltest du einen Arbeitsbereich verwenden, es ist
einfacher kleinere, einzelne Komponenten zu verstehen, als ein großes
Programmcode-Objekt. Darüber hinaus kann die Verwaltung von Kisten in einem
Arbeitsbereich die Koordination zwischen ihnen erleichtern, wenn sie häufig zur
gleichen Zeit verändert werden.</p>
<h2><a class="header" href="#kommandozeilenwerkzeuge-von-cratesio-installieren-mit-cargo-install" id="kommandozeilenwerkzeuge-von-cratesio-installieren-mit-cargo-install">Kommandozeilenwerkzeuge von crates.io installieren mit <code>cargo install</code></a></h2>
<p>Mit dem Befehl <code>cargo install</code> kannst du Binärkisten installieren und verwenden.
Dies soll keine Systempakete ersetzen, sondern soll Rust-Entwicklern eine
bequeme Möglichkeit bieten, Tools zu installieren, die andere auf
<a href="https://crates.io/">crates.io</a> veröffentlicht haben. Beachte,
dass du nur binäre Pakete installieren kannst, das heißt in der Kiste muss eine
Datei <em>src/main.rs</em> oder eine andere als binär spezifizierte Datei vorhanden
sein, und nicht nur eine Bibliothek, die alleine nicht ausführbar ist sondern zur 
Aufnahme in andere Programme geeignet ist. Für gewöhnlich enthalten Kisten eine
<em>README</em>-Datei mit Informationen darüber ob die Datei ausführbar ist, eine
Bibliothek enthält oder beides.</p>
<p>Alle mit <code>cargo install</code> installierten Binärdateien werden im Verzeichnis <em>bin</em> 
des Wurzelverzeichnisses der Installation gespeichert. Wenn du die Installation
mit <em>rustup.rs</em> durchgeführt und keine benutzerdefinierte Konfiguration
hast, lautet dieses Verzeichnis <em>$HOME/.cargo/bin</em>. Stelle sicher, dass sich
dieses Verzeichnis in deinem <code>$PATH</code> befindet, damit du Programme ausführen
kannst, die du mit <code>cargo install</code> installiert hast.</p>
<p>In Kapitel 12 haben wir beispielsweise erwähnt, dass es eine
Rust-Implementierung namens <code>ripgrep</code> des Werkzeugs <code>grep</code> zum Durchsuchen von
Dateien gibt. Wenn wir <code>ripgrep</code> installieren möchten, können wir Folgendes
ausführen:</p>
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<p>Die vorletzte Zeile der Ausgabe zeigt den Speicherort und den Namen der
installierten Binärdatei, der im Fall von <code>ripgrep</code> <code>rg</code> ist. Solange sich das
Installationsverzeichnis in deinem <code>$PATH</code> befindet, kannst du <code>rg --help</code>
ausführen und damit beginnen ein schnelleres, in Rust programmiertes
Werkzeug zum Durchsuchen von Dateien verwenden!</p>
<h2><a class="header" href="#cargo-um-benutzerdefinierte-befehle-erweitern" id="cargo-um-benutzerdefinierte-befehle-erweitern">Cargo um benutzerdefinierte Befehle erweitern</a></h2>
<p>Cargo ist so konzipiert, dass man es mit neuen Unterbefehlen erweitern kann,
ohne Cargo ändern zu müssen. Wenn  in deinem <code>$PATH</code> eine Binärdatei
<code>cargo-something</code> benannt wird, kannst du sie wie einen Unterbefehl von Cargo
ausführen, indem du <code>cargo something</code> ausführst. Benutzerdefinierte Befehle wie
dieser werden auch aufgelistet, wenn du <code>cargo --list</code> ausführst. Die
Möglichkeit, mithilfe von <code>cargo install</code> Erweiterungen zu installieren und
diese dann wie die integrierten Werkzeuge von Cargo auszuführen, ist ein
äußerst praktischer Vorteil des Cargo-Designs!</p>
<h2><a class="header" href="#zusammenfassung-13" id="zusammenfassung-13">Zusammenfassung</a></h2>
<p>Das veröffentlichen von Programmcode mit Cargo und <a href="https://crates.io/">crates.io</a>
ist Teil dessen, was das Rust-Ökosystem für viele verschiedene Aufgaben nützlich
macht. Die Standardbibliothek von Rust ist klein und stabil, aber Kisten können
einfach geteilt, verwendet und auf einer von der Sprache unterschiedlichen
Zeitlinie verbessert werden. Scheue dich nicht, Programmcode von 
<a href="https://crates.io/">crates.io</a>, der für dich nützlich ist, zu
veröffentlichen. Es ist wahrscheinlich, dass er auch für andere nützlich sein
wird!</p>
<h1><a class="header" href="#intelligente-zeiger" id="intelligente-zeiger">Intelligente Zeiger</a></h1>
<p>Im Allgemeinen ist ein <em>Zeiger</em> ein Konzept für eine Variable die eine
Speicheradresse enthält. Diese Adresse bezieht sich, oder „zeigt“, auf andere
Daten. Die häufigste Art von Zeigern in Rust ist eine Referenz, die wir bereits
in Kapitel 4 kennengelernt haben. Referenzen werden durch das Symbol <code>&amp;</code>
gekennzeichnet und leihen (borrow) den Wert auf den sie zeigen aus. Sie haben,
außer dem Verweisen auf Daten, keine besonderen Funktionalitäten. Im Übrigen
erzeugen sie keinen Mehraufwand (overhead) und sind die am häufigsten
verwendete Art von Zeigern.</p>
<p><em>Intelligente Zeiger</em> (smart pointers) sind hingegen Datenstrukturen, die nicht
ausschließlich wie ein Zeiger wirken, sondern auch über zusätzliche Metadaten
und Funktionalitäten verfügen. Das Konzept der intelligenten Zeiger gilt nicht
nur für Rust, sie stammen aus C++ und sind auch in anderen Sprachen vorhanden.
In Rust bieten die unterschiedlichen, in der Standardbibliothek definierten
intelligenten Zeiger, Funktionalitäten die über die durch Referenzen
bereitgestellten Möglichkeiten hinausgehen. Ein Beispiel, das wir in diesem
Kapitel untersuchen werden, ist der intelligente Zeiger-Typ <em>Referenzzählung</em>
(reference counting). Mit diesem Zeiger kann man mehrere Eigentümer (owner)
von Daten haben, indem man die Anzahl der Eigentümer verfolgt und die Daten
bereinigt sobald keine Eigentümer mehr vorhanden sind.</p>
<p>Da Rust das Konzept der Eigentümerschaft (ownership) und Ausleihen
(borrowing) verwendet, besteht ein zusätzlicher Unterschied zwischen Referenzen
und intelligenten Zeigern darin, dass Referenzen Zeiger sind, die Daten nur
ausleihen. Im Gegensatz dazu <em>besitzen</em> intelligente Zeiger in vielen Fällen die
Eigentümerschaft von Daten, auf die sie zeigen.</p>
<p>Wir sind in diesem Buch bereits auf einige intelligente Zeiger gestoßen, z.B.
<code>String</code> und <code>Vec&lt;T&gt;</code> in Kapitel 8, obwohl wir sie damals noch nicht als
intelligente Zeiger bezeichnet haben. Diese beiden Typen zählen zu den
intelligenten Zeigern, da sie einen gewissen Speicher besitzen und es dir
ermöglichen, diesen zu manipulieren. Sie verfügen auch über Metadaten (z.B.
ihre Kapazität) und zusätzliche Fähigkeiten oder Garantien (z.B. mit <code>String</code>,
der sicherstellt, dass seine Daten immer gültiges UTF-8 enthalten).</p>
<p>Intelligente Zeiger werden normalerweise mithilfe von Strukturen implementiert.
Das Merkmal, das einen intelligenten Zeiger von einer gewöhnlichen Struktur
(struct) unterscheidet, ist, dass intelligente Zeiger die Merkmale <code>Deref</code> und
<code>Drop</code> implementieren. Das Merkmal <code>Deref</code> ermöglicht es einer Instanz der
Struktur für intelligente Zeiger, sich wie eine Referenz zu verhalten, sodass du
Programmcode schreiben kannst, der entweder mit Referenzen oder intelligenten
Zeigern funktioniert. Mit dem Merkmal <code>Drop</code> kannst du den Programmcode
anpassen, der ausgeführt wird, wenn eine Instanz des intelligenten Zeigers den
Gültigkeitsbereich (scope) verlässt. In diesem Kapitel werden wir beide Merkmale
besprechen und zeigen, warum sie für intelligente Zeiger wichtig sind.</p>
<p>Da das Muster des intelligenten Zeigers ein allgemeines Entwurfsmuster ist, das
in Rust häufig verwendet wird, werden in diesem Kapitel nicht alle vorhandenen
intelligenten Zeiger behandelt. Viele Bibliotheken haben ihre eigenen
intelligenten Zeiger, und du kannst sogar deine eigenen schreiben. Wir werden
die am häufigsten verwendeten intelligenten Zeiger der Standardbibliothek
behandeln:</p>
<ul>
<li><code>Box&lt;T&gt;</code> zum Zuweisen von Werten auf dem Heap</li>
<li><code>Rc&lt;T&gt;</code>, ein Typ der Referenzen zählt und dadurch mehrfache Eigentümerschaft
ermöglicht</li>
<li><code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code>, Zugriff über <code>RefCell&lt;T&gt;</code>, ein Typ, der das
Einhalten der Ausleihregel zur Laufzeit (runtime) statt zur Kompilierungszeit
erzwingt.</li>
</ul>
<p>Darüber hinaus wird das <em>innere Veränderlichkeitsmuster</em> (interior mutability pattern)
behandelt, bei dem ein unveränderlicher Typ eine API zum Verändern eines inneren
Werts verfügbar macht. Wir werden auch <em>Referenzzyklen</em> besprechen, wie diese
Speicherverlust verursachen können und wie das verhindert werden kann.</p>
<p>Lass uns in die Materie eintauchen!</p>
<h2><a class="header" href="#mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen" id="mit-boxt-auf-daten-im-haldenspeicher-heap-zeigen">Mit <code>Box&lt;T&gt;</code> auf Daten im Haldenspeicher (heap) zeigen</a></h2>
<p>Der einfachste intelligente Zeiger ist <em>Box</em>, deren Typ <code>Box&lt;T&gt;</code> lautet. In
Boxen kann man Daten statt auf dem Stapelspeicher im Haldenspeicher
speichern. Was auf dem Stapelspeicher verbleibt, ist der Zeiger auf die Daten im
Haldenspeicher. In Kapitel 4 findest du Informationen zum Unterschied
zwischen dem Stapelspeicher und dem Haldenspeicher.</p>
<p>Boxen haben keinen Performanz-Overhead, außer dass die Daten auf
den Haldenspeicher anstatt auf dem Stapelspeicher gespeichert werden, aber
sie haben auch nicht viele zusätzliche Funktionalitäten. Sie werden am
häufigsten in folgenden Situationen verwendet:</p>
<ul>
<li>Wenn man einen Typ hat, dessen Größe zum Zeitpunkt der Kompilierung nicht
bekannt ist, und man einen Wert dieses Typs in einem Kontext verwenden
möchte, für den eine genaue Größe erforderlich ist.</li>
<li>Wenn man über eine große Datenmenge verfügt und die Eigentümerschaft
(ownership) übertragen möchte und sicherstellen will, dass die Daten dabei
nicht kopiert werden.</li>
<li>Wenn man einen Wert besitzen möchte und sich nur darum kümmert, dass es sich
um einen Typ handelt, der ein bestimmtes Merkmal implementiert, anstatt den
Typ zu spezifizieren.</li>
</ul>
<p>Wir werden die erste Situation im Abschnitt <a href="ch15-01-box.html#erm%C3%B6glichen-rekursiver-typen-mit-boxen">„Ermöglichen rekursiver Typen mit
Boxen“</a> zeigen. Im zweiten Fall kann
die Übertragung der Eigentümerschaft einer großen Datenmenge lange dauern, da
die Daten auf dem Stapelspeicher kopiert werden. Um die Performanz in dieser
Situation zu verbessern, können wir die große Datenmenge auf dem Haldenspeicher
in einer Box speichern. Dann wird nur die kleine Menge von Zeigerdaten auf dem
Stapelspeicher kopiert, während die Daten, auf die verwiesen wird, im
Haldenspeicher an einer Stelle verbleiben. Der dritte Fall ist als
<em>Merkmalsobjekt</em> (trait object) bekannt, und Kapitel 17 widmet einen ganzen
Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen
erlauben“</a> diesem Thema. Was du hier lernst, wirst du im Kapitel
17 erneut anwenden!</p>
<h3><a class="header" href="#boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern" id="boxt-verwenden-um-daten-im-haldenspeicher-zu-speichern"><code>Box&lt;T&gt; verwenden um Daten im Haldenspeicher zu speichern</code></a></h3>
<p>Bevor wir diesen Anwendungsfall für <code>Box&lt;T&gt;</code> behandeln, werden wir die Syntax
und die Interaktion mit Werten behandeln, die in einer <code>Box&lt;T&gt;</code> gespeichert
sind.</p>
<p>Codeblock 15.1 zeigt, wie man mit einer Box einen <code>i32</code>-Wert auf dem
Haldenspeicher speichert:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-1: Speichern eines <code>i32</code>-Wertes in einer Box
im Haldenspeicher</span></p>
<p>Wir definieren die Variable <code>b</code> so, dass sie den den Wert einer <code>Box</code> hat die
auf den Wert <code>5</code> zeigt, der auf dem Haldenspeicher alloziert ist.
Dieses Programm gibt <code>b = 5</code> aus, in diesem Fall können wir auf die Daten in der
Box zugreifen, ähnlich als würden sich die Daten im Stapelspeicher befinden.
Genau wie bei Werten mit Eigentümerschaft wird auch eine Box freigegeben
wenn sie den Gültigkeitsbereich verlässt, wie dies bei <code>b</code> am Ende von <code>main</code>
der Fall ist. Die Freigabe erfolgt für die Box (gespeichert im Stapelspeicher)
und die Daten, auf die sie verweist (gespeichert im Haldenspeicher).</p>
<p>Es ist nicht sehr nützlich, einen einzelnen Wert im Haldenspeicher zu
speichern, daher verwendet man Boxen selten alleine. Meistens ist es besser,
Werte wie eine <code>i32</code> auf dem Stapelspeicher zu haben, wo sie standardmäßig
gespeichert werden. Sehen wir uns einen Fall an, in dem Boxen es uns
ermöglichen, Typen zu definieren, die wir nicht hätten, wenn es keine Boxen
gäbe.</p>
<h3><a class="header" href="#ermöglichen-rekursiver-typen-mit-boxen" id="ermöglichen-rekursiver-typen-mit-boxen">Ermöglichen rekursiver Typen mit Boxen</a></h3>
<p>Zum Zeitpunkt der Kompilierung muss Rust wissen, wie viel Speicherplatz ein Typ einnimmt.
Ein Typ, dessen Größe zum Zeitpunkt des Kompilierung nicht bekannt sein kann,
ist ein <em>rekursiver Typ</em>, bei dem ein Wert einen anderen Wert desselben Typs als
Teil von sich selbst haben kann. Da diese Verschachtelung von Werten theoretisch
unendlich oft fortgesetzt werden kann, weiß Rust nicht, wie viel Speicherplatz
der Wert eines rekursiven Typs benötigt. Boxen haben jedoch eine bekannte
Größe. Wenn man also eine Box in eine rekursive Typdefinition einfügt, kann man
rekursive Typen verwenden.</p>
<p>Lass uns die <em>Cons-Liste</em>, einen Datentyp, der in funktionalen
Programmiersprachen üblich ist, als Beispiel für einen rekursiven Typ
untersuchen. Der von uns definierte cons-Listentyp ist abgesehen von der
Rekursion unkompliziert. Daher sind die Konzepte in diesem Beispiel immer dann
nützlich, wenn man in komplexeren Situationen mit rekursiven Typen arbeitet.</p>
<h4><a class="header" href="#weitere-informationen-zur-cons-liste" id="weitere-informationen-zur-cons-liste">Weitere Informationen zur Cons-Liste</a></h4>
<p>Eine <em>Cons-Liste</em> ist eine Datenstruktur, die aus der Programmiersprache Lisp
und ihren Dialekten stammt. In Lisp erstellt die Konstruktionsfunktion <code>cons</code>
(Kurzform von „construct function“) aus ihren beiden Argumenten, die
normalerweise aus einem einzelnen Wert und einem anderen Paar bestehen, ein
neues Paar. Diese Paare die wiederum Paare enthalten, bilden eine Liste.</p>
<p>Das Konzept der Cons-Liste hat seinen Weg in den allgemeineren Jargon für
funktionale Programmierung gefunden: „to cons <em>x</em> onto <em>y</em>“ bedeutet informell,
eine neue Containerinstanz zu erstellen, indem das Element <em>x</em> an den Anfang dieses
neuen Containers gestellt wird gefolgt vom Container <em>y</em>.</p>
<p>Jedes Element in einer Cons-Liste enthält zwei Elemente: Den Wert des aktuellen
Elements und das nächste Element. Das letzte Element in der Liste enthält nur
ein Element namens <code>Nil</code> ohne ein nächstes Element. Eine Cons-Liste wird durch
rekursives Aufrufen der Funktion <code>cons</code> erstellt. Der kanonische Name für den
Basisfall der Rekursion lautet <code>Nil</code>. Beachte, dass dies nicht mit dem Konzept
„null“ oder „nil“ in Kapitel 6 identisch ist, das einen fehlenden oder
ungültigen Wert darstellt.</p>
<p>Obwohl funktionale Programmiersprachen häufig Cons-Listen verwenden, ist sie in
Rust keine häufig vorkommende Datenstruktur. Wenn man in Rust eine Liste von
Elementen hat, ist <code>Vec&lt;T&gt;</code> die bessere Wahl. Andere, komplexere rekursive
Datentypen sind in verschiedenen Situationen nützlich. Wenn wir jedoch mit der
Cons-Liste beginnen, können wir untersuchen, wie Boxen es uns ermöglichen, ohne
grosse Ablenkung einen rekursiven Datentyp zu definieren.</p>
<p>Codeblock 15-2 enthält eine Aufzählungsdefinition (enum) für eine Cons-Liste. Beachte,
dass dieser Code nicht kompiliert werden kann, da der Typ <code>List</code> keine bekannte
Grösse hat, was wir zeigen werden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-2: Der erste Versuch eine Aufzählung zu
definieren, um eine Datenstruktur der Cons-Liste von <code>i32</code>-Werten darzustellen</span></p>
<blockquote>
<p>Hinweis: Für dieses Beispiel implementieren wir eine Cons-Liste, die nur
<code>i32</code>-Werte enthält. Wir hätten sie mit generischen Typen implementieren
können wie wir es in Kapitel 10 besprochen haben, um eine Cons-Liste zu
erstellen, in der Werte eines beliebigen Typs gespeichert werden können.</p>
</blockquote>
<p>Verwendung des Typs <code>List</code> um die Liste <code>1, 2, 3</code> zu speichern.
Siehe Codeblock 15-3:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">enum List {
</span><span class="boring">   Cons(i32, List),
</span><span class="boring">   Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-3: Verwendung der <code>List</code>-Aufzählung um die 
Liste <code>1, 2, 3</code> zu speichern</span></p>
<p>Der erste <code>Cons</code>-Wert enthält <code>1</code> und einen anderen <code>List</code>-Wert. Dieser
<code>List</code>-Wert ist ein weiterer <code>Cons</code>-Wert, der <code>2</code> und einen anderen <code>List</code>-Wert
enthält. Dieser <code>List</code>-Wert ist ein weiterer <code>Cons</code>, der <code>3</code> enthält und ein
<code>List</code>, der schliesslich <code>Nil</code> ist, die nicht rekursive Variante, die das Ende
der Liste signalisiert.</p>
<p>Wenn wir versuchen den Programmcode in Codeblock 15-3 zu kompilieren,
erhalten wir den Fehler der in Codeblock 15-4 gezeigt wird:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">Codeblock 15-4: Der Fehler den wir erhalten wenn wir
versuchen eine rekursive Aufzählung zu definieren</span></p>
<p>Der Fehler zeigt, dass dieser Typ „unendlich groß“ ist. Der Grund dafür ist,
dass wir <code>List</code> mit einer rekursiven Variante definiert haben, sie enthält
direkt einen anderen Wert von sich selbst, daher kann Rust nicht herausfinden,
wie viel Speicherplatz zum Speichern eines Listenwerts erforderlich ist. Lass
uns kurz zusammenfassen, warum wir diesen Fehler bekommen. Schauen wir uns
zunächst an, wie Rust entscheidet, wie viel Speicherplatz zum Speichern des
Werts eines nicht rekursiven Typs benötigt wird.</p>
<h4><a class="header" href="#die-größe-eines-nicht-rekursiven-typs-berechnen" id="die-größe-eines-nicht-rekursiven-typs-berechnen">Die Größe eines nicht-rekursiven Typs berechnen</a></h4>
<p>Erinnere dich an die in Codeblock 6-2 definierte <code>Message</code>-Aufzählung, als wir
die Definition von Aufzählungen in Kapitel 6 besprochen haben:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Um zu bestimmen, wie viel Speicherplatz für einen <code>Message</code>-Wert zugewiesen
werden soll, durchläuft Rust jede der Varianten, um festzustellen, welche
Variante den meisten Speicherplatz benötigt. Rust sieht, dass <code>Message::Quit</code>
keinen Speicherplatz benötigt, und <code>Message::Move</code> genügend Speicherplatz braucht
um zwei <code>i32</code>-Werte zu speichern, und so weiter. Da nur eine Variante verwendet
wird, ist der größte Speicherplatz, den ein <code>Message</code>-Wert benötigt, gleich
den, der zum Speichern der größten Variante benötigt wird.</p>
<p>Vergleiche das mit dem, was passiert wenn Rust zu bestimmen versucht, wie viel
Speicherplatz ein rekursiver Typ wie die Aufzählung <code>List</code> in Codeblock 15-2
benötigt. Der Compiler betrachtet zunächst die Variante <code>Cons</code>, die einen Typ
<code>i32</code> und einen Wert vom Typ <code>List</code> enthält. Daher benötigt <code>Cons</code> einen
Speicherplatz, der der Größe eines <code>i32</code> plus der Größe einer <code>List</code>
entspricht. Um herauszufinden, wie viel Speicher der Typ <code>List</code> benötigt,
betrachtet der Compiler die Varianten, beginnend mit der Variante <code>Cons</code>. Die
Variante <code>Cons</code> enthält einen Typ <code>i32</code> und einen Wert vom Typ <code>List</code>. Dieser
Vorgang wird wie in Abbildung 15-1 dargestellt, unendlich fortgesetzt.</p>
<img alt="Eine unendliche Cons-Liste" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 15-1: Ein unendlicher <code>List</code>-Typ der aus unendlichen 
<code>Cons</code>-Varianten besteht</span></p>
<h4><a class="header" href="#verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten" id="verwenden-von-boxt-um-einen-rekursiven-typ-mit-einer-bekannten-größe-zu-erhalten">Verwenden von <code>Box&lt;T&gt;</code>, um einen rekursiven Typ mit einer bekannten Größe zu erhalten</a></h4>
<p>Rust kann nicht herausfinden, wie viel Speicherplatz für rekursiv definierte
Typen reserviert werden muss. Daher gibt der Compiler den Fehler in Codeblock
15-4 aus. Der Fehler enthält jedoch diesen hilfreichen Hinweis:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<p>In diesem Hinweis bedeutet „indirection“ (Dereferenzierung), dass anstelle eines
direkten Speicherns des Wertes die Datenstruktur geändert wird, um den Wert
indirekt zu speichern, indem stattdessen ein Zeiger zum Wert gespeichert wird.</p>
<p>Da eine <code>Box&lt;T&gt;</code> ein Zeiger ist, weiß Rust immer, wie viel Platz eine <code>Box&lt;T&gt;</code>
benötigt: Die Größe eines Zeigers ändert sich nicht basierend auf der
Datenmenge, auf die er zeigt. Dies bedeutet, dass wir anstelle eines anderen
<code>List</code>-Wertes direkt eine <code>Box&lt;T&gt;</code> in die <code>Cons</code>-Variante einfügen können. Die
<code>Box&lt;T&gt;</code> zeigt auf den nächsten <code>List</code>-Wert, der sich auf dem Haldenspeicher
befindet und nicht in der <code>Cons</code>-Variante. Konzeptionell haben wir immer noch
eine Liste, die mit Listen erstellt wurde, die andere Listen enthalten. Diese
Implementierung ähnelt nun eher dem Platzieren der Elemente nebeneinander als
ineinander.</p>
<p>Wir können die Definition der Liste <code>List</code> in Codeblock 15-2 und die Verwendung
von <code>List</code> in Codeblock 15-3 in den Programmcode von Codeblock 15-5 ändern, der
kompilieren wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-5: Definition von <code>List</code> die <code>Box&lt;T&gt;</code> benutzt
um eine bekannte Größe zu haben</span></p>
<p>Die <code>Cons</code>-Variante benötigt die Größe eines <code>i32</code> plus Platz zum Speichern der
Zeigerdaten der Box. Die <code>Nil</code>-Variante speichert keine Werte und benötigt daher
weniger Speicher als die <code>Cons</code>-Variante. Wir wissen nun, dass jeder <code>List</code>-Wert 
die Größe eines <code>i32</code> plus die Größe der Zeigerdaten einer Box annimmt. Durch
Verwenden einer Box haben wir die unendliche, rekursive Kette unterbrochen,
sodass der Compiler die Größe ermitteln kann, die zum Speichern eines
Listenwerts erforderlich ist. Abbildung 15-2 zeigt, wie die Variante <code>Cons</code>
jetzt aussieht.</p>
<img alt="Eine endliche Cons-Liste" src="img/trpl15-02.svg" class="center" style="width: 30%;" />
<p><span class="caption">Abbildung 15-2: Ein <code>List</code>-Typ der keine unendliche Größe 
hat da <code>Cons</code> eine <code>Box</code> enthält</span></p>
<p>Boxen bieten nur die Dereferenzierung und Zuordnung am Haldenspeicher, haben
aber sonst keine speziellen Funktionalitäten, wie wir sie bei anderen
intelligenten Zeigertypen sehen werden. Sie haben aber auch keinen
Performanz-Overhead, der mit diesen zusätzlichen Funktionalitäten verbunden
ist. Daher können sie in Fällen wie der Cons-Liste nützlich sein, in denen die
Dereferenzierung die einzige Funktionalität ist, die wir benötigen. Weitere
Anwendungsfälle für Boxen werden wir uns in Kapitel 17 ansehen.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> ist ein intelligenter Zeiger, da er das Merkmal <code>Deref</code>
implementiert, mit dem <code>Box&lt;T&gt;</code> Werte wie Referenzen behandelt werden können.
Wenn ein <code>Box&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt, werden die Daten am
Haldenspeicher, auf die die Box zeigt, aufgrund der Implementierung des
<code>Drop</code>-Merkmals ebenfalls bereinigt. Lass uns diese beiden Merkmale genauer
untersuchen. Diese beiden Merkmale sind für die Funktionalität der anderen
intelligenten Zeigertypen, die wir im restlichen Kapitel erläutern, noch wichtiger.</p>
<h2><a class="header" href="#intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref" id="intelligente-zeiger-wie-normale-referenzen-behandeln-mit-dem-merkmal-trait-deref">Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) <code>Deref</code></a></h2>
<p>Durch die Implementierung des Merkmals <code>Deref</code> kann man das Verhalten des
<em>Dereferenzierungsoperators</em> (dereference operator) <code>*</code> (im Gegensatz zum Multiplikations- oder
Stern-Operator (glob operator)) anpassen. Indem du <code>Deref</code> so implementierst, dass ein
intelligenter Zeiger wie eine reguläre Referenz behandelt werden kann, kannst du
Programmcode schreiben, der mit Referenzen arbeitet, und diesen Programmcode
auch mit intelligenten Zeigern verwenden.</p>
<p>Schauen wir uns zunächst an, wie der Dereferenzierungsoperator mit regulären
Referenzen arbeitet. Dann werden wir versuchen, einen benutzerdefinierten Typ zu
definieren, der sich wie <code>Box&lt;T&gt;</code> verhält, und herausfinden, warum der
Dereferenzierungsoperator nicht wie eine Referenz für unseren neu definierten
Typ funktioniert. Wir werden untersuchen, wie die Implementierung des Merkmals
<code>Deref</code> es intelligenten Zeigern ermöglicht, auf ähnliche Weise wie Referenzen
zu funktionieren, dann sehen wir uns an wie wir mit Rusts <em>automatischer
Umwandlung</em> (deref coercion) mit Referenzen oder
intelligenten Zeigern arbeiten können.</p>
<blockquote>
<p>Hinweis: Es gibt einen großen Unterschied zwischen dem Typ <code>MyBox&lt;T&gt;</code>, den wir
gerade erstellen, und dem echten Typ <code>Box&lt;T&gt;</code>: Unsere Version speichert ihre
Daten nicht auf dem Haldenspeicher (heap). In diesem Beispiel konzentrieren wir uns auf
<code>Deref</code>, daher ist es weniger wichtig, wo die Daten tatsächlich gespeichert sind
als das zeigerähnliche Verhalten.</p>
</blockquote>
<h3><a class="header" href="#dem-zeiger-zum-wert-folgen-mit-dem-dereferenzierungsoperator" id="dem-zeiger-zum-wert-folgen-mit-dem-dereferenzierungsoperator">Dem Zeiger zum Wert folgen mit dem Dereferenzierungsoperator</a></h3>
<p>Eine reguläre Referenz ist eine Art Zeiger, und eine Möglichkeit, sich einen
Zeiger vorzustellen, ein Pfeil der auf einen Wert zeigt der an einer anderen
Stelle gespeichert ist. In Codeblock 15-6 erstellen wir eine Referenz auf einen
<code>i32</code>-Wert und verwenden dann den Dereferenzierungsoperator, um der Referenz zu
den Daten zu folgen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-6: Einen Dereferenzierungsoperator verwenden
um einer Referenz auf einen <code>i32</code>-Wert zu folgen </span></p>
<p>Die Variable <code>x</code> enthält den <code>i32</code>-Wert <code>5</code>. Wir setzen <code>y</code> gleich einer
Referenz auf <code>x</code>. Wir können sicherstellen, das <code>x</code>
gleich <code>5</code> ist. Wenn wir jedoch eine Aussage über den Wert <code>y</code> machen möchten,
auf den er zeigt, müssen wir <code>*y</code> verwenden, um der Referenz auf den Wert zu
folgen, auf den sie zeigt (daher <em>Dereferenzierung</em>). Sobald wir <code>y</code>
dereferenzieren, haben wir Zugriff auf den Zahlenwert auf den <code>y</code> zeigt und 
können ihn mit <code>5</code> vergleichen.</p>
<p>Wenn wir stattdessen versuchen würden, <code>assert_eq!(5, y);</code> zu schreiben, würden
wir diesen Fehler beim Kompilieren erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Das Vergleichen einer Zahl mit einer Referenz auf eine Zahl ist nicht zulässig,
da es sich um verschiedene Typen handelt. Wir müssen den Dereferenzierungsoperator
verwenden um der Referenz auf den Wert zu folgen, auf den sie zeigt.</p>
<h3><a class="header" href="#boxt-wie-eine-referenz-verwenden" id="boxt-wie-eine-referenz-verwenden"><code>Box&lt;T&gt;</code> wie eine Referenz verwenden</a></h3>
<p>Wir können den Programmcode in Codeblock 15-6 neu schreiben, um anstelle einer
Referenz <code>Box&lt;T&gt;</code> zu verwenden. Wie Codeblock 15-7 zeigt, funktioniert der
Dereferenzierungsoperator:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>Der einzige Unterschied zwischen Codeblock 15-7 und 15-6 besteht darin, dass wir 
hier <code>y</code> als Instanz eines Feldes festlegen, das auf einen kopierten Wert von <code>x</code>
zeigt, und nicht als Referenz, die auf den Wert <code>x</code> zeigt. In der letzten
Zusicherung (assertion) können wir den Dereferenzierungsoperator verwenden um dem Zeiger
der Box auf die gleiche Weise zu folgen, wie wir es getan haben, als <code>y</code> eine
Referenz war. Als Nächstes werden wir ergründen, was das Besondere an <code>Box&lt;T&gt;</code>
ist, das es uns ermöglicht, den Dereferenzierungsoperator zu verwenden, indem
wir unseren eigenen Box-Typ definieren.</p>
<h3><a class="header" href="#einen-eigenen-intelligenten-zeiger-definieren" id="einen-eigenen-intelligenten-zeiger-definieren">Einen eigenen intelligenten Zeiger definieren</a></h3>
<p>Erstellen wir einen intelligenten Zeiger, der dem von der Standardbibliothek
bereitgestellten Typ <code>Box&lt;T&gt;</code> ähnelt, um zu erfahren, wie sich intelligente
Zeiger standardmäßig anders als Referenzen verhalten. Anschließend sehen wir
uns an, wie man die Möglichkeit zur Verwendung des Dereferenzierungsoperators
hinzufügen können.</p>
<p>Der Typ <code>Box&lt;T&gt;</code> wird letztendlich als Tupel-Struktur (tuple struct) mit einem
Element definiert, sodass Codeblock 15-8 einen Typ <code>MyBox&lt;T&gt;</code> auf die gleiche
Weise definiert. Wir werden auch eine <code>new</code>-Funktion definieren, die mit der in
der <code>Box&lt;T&gt;</code> definierten übereinstimmt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-8: Einen <code>MyBox&lt;T&gt;</code>-Typ definieren</span></p>
<p>Wir definieren eine Struktur mit dem Namen <code>MyBox</code> und deklarieren einen
generischen Parameter <code>T</code>, da unser Typ Werte eines beliebigen Typs enthalten
soll. Der Typ <code>MyBox</code> ist eine Tupelstruktur mit einem Element vom Typ <code>T</code>. Die
Funktion <code>MyBox::new</code> verwendet einen Parameter vom Typ <code>T</code> und gibt eine 
<code>MyBox</code>-Instanz zurück, die den übergebenen Wert enthält.</p>
<p>Versuchen wir, die <code>main</code>-Funktion in Codeblock 15-7 zu Codeblock 15-8
hinzuzufügen und sie so zu ändern, dass der von uns definierte Typ <code>MyBox&lt;T&gt;</code>
anstelle von <code>Box&lt;T&gt;</code> verwendet wird. Der Programmcode in Codeblock 15-9 wird
nicht kompilieren, da Rust nicht weiß, wie er <code>MyBox</code> dereferenzieren kann.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring"> }
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-9: Versuch, <code>MyBox&lt;T&gt;</code> auf die gleiche Weise
wie <code>Box&lt;T&gt;</code> und Referenzen zu benutzen</span></p>
<p>Hier ist der Kompilierfehler den wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Unser Typ <code>MyBox&lt;T&gt;</code> kann nicht dereferenziert werden, da wir diese
Fähigkeit für unseren Typ nicht implementiert haben. Um eine
Dereferenzierung mit dem Operator <code>*</code> zu ermöglichen, implementieren wir das
Merkmal <code>Deref</code>.</p>
<h3><a class="header" href="#einen-typ-wie-eine-referenz-behandeln-durch-implementierens-des-deref-merkmals" id="einen-typ-wie-eine-referenz-behandeln-durch-implementierens-des-deref-merkmals">Einen Typ wie eine Referenz behandeln durch Implementierens des <code>Deref</code>-Merkmals</a></h3>
<p>Wie in Kapitel 10 besprochen, müssen wir zur Implementierung eines Merkmals
Implementierungen für die erforderlichen Methoden des Merkmals bereitstellen.
Das von der Standardbibliothek bereitgestellte Merkmal <code>Deref</code> erfordert die
Implementierung einer Methode namens <code>deref</code>, die <code>self</code> ausleiht (borrow) und
eine Referenz auf die beinhalteten Daten zurückgibt. Codeblock 15-10 enthält
eine Implementierung von <code>Deref</code>, um die Definition von <code>MyBox</code> zu ergänzen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-10: <code>Deref</code> auf <code>MyBox&lt;T&gt;</code> implementieren</span></p>
<p>Die Syntax <code>type Target = T;</code> definiert einen assoziierten Typ, den das Merkmal
<code>Deref</code> verwenden soll. Assoziierte Typen sind eine andere Art, einen
generischen Parameter zu deklarieren, aber darüber musst du dir vorerst noch
keine Gedanken machen, in Kapitel 19 werden wir sie ausführlicher behandeln.</p>
<p>Wir füllen den Rumpf der <code>deref</code>-Methode mit <code>&amp;self.0</code>, und <code>deref</code> gibt
eine Referenz auf den Wert zurück, auf den wir mit dem <code>*</code>-Operator zugreifen
möchten. Die <code>main</code>-Funktion in Codeblock 15-9, die <code>*</code> für den Wert <code>MyBox&lt;T&gt;</code>
aufruft, kompiliert nun und die Zusicherungen werden bestanden!</p>
<p>Ohne das Merkmal <code>Deref</code> kann der Compiler nur <code>&amp;</code>-Referenzen dereferenzieren.
Die <code>deref</code>-Methode gibt dem Compiler die Möglichkeit, einen Wert eines
beliebigen Typs zu verwenden, der <code>Deref</code> implementiert, und die <code>deref</code>-Methode
aufzurufen, um eine <code>&amp;</code>-Referenz zu erhalten, die er dereferenzieren kann.</p>
<p>Als wir in Codeblock 15-9 <code>*y</code> eingegeben haben, hat Rust hinter den Kulissen
tatsächlich diesen Programmcode ausgeführt:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust ersetzt den Operator <code>*</code> durch einen Aufruf der <code>deref</code>-Methode und dann
durch eine einfache Dereferenzierung, sodass wir nicht darüber nachdenken
müssen, ob wir die <code>deref</code>-Methode aufrufen müssen oder nicht. Mit dieser
Rust-Funktionalität können wir Code schreiben, der unabhängig davon, ob wir eine reguläre
Referenz oder einen Typ haben der <code>Deref</code> implementiert, identisch funktioniert.</p>
<p>Der Grund, warum die <code>deref</code>-Methode eine Referenz auf einen Wert zurückgibt und
die einfache Dereferenzierung außerhalb der Klammern in <code>*(y.deref())</code>
weiterhin erforderlich ist, ist die Eigentümerschaft (ownership). Wenn die
<code>deref</code>-Methode den Wert direkt anstelle einer Referenz auf den Wert zurückgibt,
wird der Wert aus <code>self</code> herausverschoben. Meistens wenn wir den
Dereferenzierungsoperator verwenden, wollen wir, so wie auch in diesem Fall,
nicht die Eigentümerschaft des inneren Wertes von <code>MyBox&lt;T&gt;</code> übernehmen.</p>
<p>Beachte, dass der <code>*</code>-Operator durch einen Aufruf der <code>deref</code>-Methode und dann
nur einmal durch einen Aufruf des <code>*</code>-Operators ersetzt wird, jedes Mal, wenn
wir ein <code>*</code> in unserem Programmcode verwenden. Da die Ersetzung des 
<code>*</code>-Operator nicht unendlich rekursiv ist, erhalten wir Daten vom Typ
<code>i32</code>, die mit der <code>5</code> in <code>assert_eq!</code> in Codeblock 15-9 übereinstimmen.</p>
<h3><a class="header" href="#implizite-automatische-umwandlung-mit-funktionen-und-methoden" id="implizite-automatische-umwandlung-mit-funktionen-und-methoden">Implizite automatische Umwandlung mit Funktionen und Methoden</a></h3>
<p><em>Automatische Umwandlung</em> (deref coercion) ist eine bequeme Funktionalität die Rust bei Argumenten für
Funktionen und Methoden ausführt. Die automatische Umwandlung funktioniert nur bei Typen,
die das Merkmal <code>Deref</code> implementieren. Die automatische Umwandlung wandelt einen solchen
Typ in eine Referenz auf einen anderen Typ um. Zum Beispiel kann die automatische
Umwandlung <code>&amp;String</code> in <code>&amp;str</code> konvertieren, da <code>String</code> das Merkmal <code>Deref</code>
implementiert, sodass <code>str</code> zurückgegeben wird. Die automatische Umwandlung erfolgt
automatisch, wenn wir eine Referenz auf den Wert eines bestimmten Typs als Argument an
eine Funktion oder Methode übergeben, die nicht dem Parametertyp in der Funktion
oder Methodendefinition übereinstimmt. Eine Folge von Aufrufen der
<code>deref</code>-Methode konvertiert den von uns angegebenen Typ in den Typ, den der
Parameter benötigt.</p>
<p>Rust wurde um die automatische Umwandlung erweitert, damit Programmierer, die Funktions- und
Methodenaufrufe schreiben, nicht so viele explizite Referenzierungen und Dereferenzierungen
mit <code>&amp;</code> und <code>*</code> angeben müssen. Mit der Funktionalität der automatischen Umwandlung
können wir auch mehr Programmcode schreiben, der sowohl für Referenzen als auch
für intelligente Zeiger geeignet ist.</p>
<p>Um die automatische Umwandlung in Aktion zu sehen, verwenden wir den in Codeblock 15-8
definierten Typ <code>MyBox&lt;T&gt;</code> sowie die Implementierung von <code>Deref</code>, die wir in
Codeblock 15-10 hinzugefügt haben. Codeblock 15-11 zeigt die Definition einer
Funktion mit einen Zeichenketten-Anteilstyp (string slice) Parameter:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hallo {}!&quot;, name);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-11: Eine <code>hello</code>-Funktion mit dem Parameter
<code>name</code> vom Typ <code>&amp;str</code></span></p>
<p>Wir können die Funktion <code>hello</code> mit einem Zeichenketten-Anteilstyp als Argument
aufrufen, wie zum Beispiel <code>hello(&quot;Rust&quot;);</code>. Die automatischer Umwandlung ermöglicht es,
<code>hello</code> mit einer Referenz auf einen Wert vom Typ <code>MyBox&lt;String&gt;</code> aufzurufen,
wie es in Codeblock 15-12 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hallo {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-12: <code>hello</code> mit einer Referenz auf einen
<code>MyBox&lt;String&gt;</code>-Wert, der aufgrund automatischer Umwandlung funktioniert</span></p>
<p>Hier rufen wir die Funktion <code>hello</code> mit dem Argument <code>&amp;m</code> auf, das auf einen
<code>MyBox&lt;String&gt;</code>-Wert verweist. Da wir in Codeblock 15-10 das Merkmal <code>Deref</code> für
<code>MyBox&lt;T&gt;</code> implementiert haben, kann Rust <code>&amp;MyBox&lt;String&gt;</code> durch Aufrufen von
<code>deref</code> in <code>&amp;String</code> verwandeln. Die Standardbibliothek bietet eine
Implementierung von <code>Deref</code> auf <code>String</code>, die einen Zeichenketten-Anteilstyp
zurückgibt. Dies kann man in der API-Dokumentation für <code>Deref</code> nachlesen. Rust
ruft erneut <code>deref</code> auf, um <code>&amp;String</code> in <code>&amp;str</code> umzuwandeln, was der Definition
der Funktion <code>hello</code> entspricht.</p>
<p>Wenn Rust keine automatische Umwandlung implementiert hätte, müssten wir den
Programmcode in Codeblock 15-13 anstelle des Programmcodes in 15-12 schreiben,
um <code>hello</code> mit einem Wert vom Typ <code>&amp;MyBox&lt;String&gt;</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hallo {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-13: Programmcode den wir schreiben
müssten wenn Rust keine automatische Umwandlung hätte</span></p>
<p>Das <code>(*m)</code> dereferenziert <code>Mybox&lt;String&gt;</code> in einen <code>String</code>. Dann nehmen die <code>&amp;</code>
und <code>[..]</code> einen Anteilstyp des <code>String</code>, der gleich der gesamten Zeichenkette ist, um der
Signatur von <code>hello</code> zu entsprechen. Der Programmcode ohne automatische Umwandlung ist
mit allen Symbolen schwerer zu lesen, zu schreiben und zu verstehen. Durch
die automatische Umwandlung kann Rust diese Konvertierung automatisch für uns abwickeln.</p>
<p>Wenn das Merkmal <code>Deref</code> für die beteiligten Typen definiert ist, analysiert
Rust die Typen und verwendet <code>Deref::deref</code> so oft wie nötig, um eine Referenz
zu erhalten, die dem Typ des Parameters entspricht. Die Häufigkeit, mit der
<code>Deref::deref</code> eingefügt werden muss, wird zur Kompilierzeit aufgelöst,
sodass kein Nachteil zur Laufzeit bei der Nutzung der automatischen Umwandlung
entsteht!</p>
<h3><a class="header" href="#wie-die-automatische-umwandlung-mit-veränderlichkeit-umgeht" id="wie-die-automatische-umwandlung-mit-veränderlichkeit-umgeht">Wie die automatische Umwandlung mit Veränderlichkeit umgeht</a></h3>
<p>Ähnlich wie du das Merkmal <code>Deref</code> verwendest, um den <code>*</code>-Operator bei
unveränderlichen Referenzen zu überschreiben, kannst du das Merkmal <code>DerefMut</code>
verwenden, um den <code>*</code>-Operator bei veränderlichen Referenzen zu überschreiben.</p>
<p>Rust wendet die automatische Umwandlung an, wenn Typen und Merkmalsimplementierungen in
folgenden drei Fällen gefunden werden:</p>
<ul>
<li>Von <code>&amp;T</code> zu <code>&amp;U</code>, wenn <code>T:Deref&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;mutU</code>, wenn <code>T:DerefMut&lt;Target=U&gt;</code></li>
<li>Von <code>&amp;mutT</code> zu <code>&amp;U</code>, wenn <code>T:Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Die ersten beiden Fälle sind bis auf die Veränderlichkeit gleich. Der erste Fall
besagt, dass wenn man einen <code>&amp;T</code> hat und <code>T</code> <code>Deref</code> für einen Typ <code>U</code> 
implementiert hat, man transparent einen <code>&amp;U</code> erhalten kann. Der zweite Fall
besagt, dass die gleiche automatische Umwandlung bei veränderlichen Referenzen
erfolgt.</p>
<p>Der dritte Fall ist schwieriger: Rust wird auch eine veränderliche Referenz in
eine unveränderliche umwandeln. Das Gegenteil ist jedoch <em>nicht</em> möglich:
Unveränderliche Referenzen werden niemals zu veränderlichen gemacht. Wenn man
eine veränderliche Referenz hat, muss diese veränderliche Referenz aufgrund der
Ausleihregeln (borrowing rules) die einzige Referenz auf diese Daten sein
(anderenfalls würde das Programm nicht kompilieren). Das Konvertieren einer
veränderlichen Referenz in eine unveränderliche verstößt niemals gegen die
Ausleihregeln. Das Konvertieren einer unveränderlichen Referenz in eine
veränderliche Referenz, würde erfordern, dass die ursprüngliche unveränderliche
Referenz die einzige unveränderliche Referenz auf diese Daten ist, aber die
Ausleihregeln garantieren dies nicht.
Daher kann Rust nicht davon ausgehen, dass die Konvertierung einer
unveränderlichen Referenz in eine veränderbare Referenz möglich ist.</p>
<h2><a class="header" href="#programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop" id="programmcode-beim-aufräumen-ausführen-mit-dem-merkmal-trait-drop">Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) <code>Drop</code></a></h2>
<p>Das zweite wichtige Merkmal für intelligente Zeiger ist <code>Drop</code>, mit dem man
anpassen kann, was passiert, wenn ein Wert den Gültigkeitsbereich verlässt. Man
kann eine Implementierung für das Merkmal (trait) <code>Drop</code> für jeden Typ bereitstellen,
und der angegebene Programmcode kann zum Freigeben von Ressourcen wie Dateien
oder Netzwerkverbindungen verwendet werden. Wir führen <code>Drop</code> im Kontext von
intelligenten Zeigern ein, da die Funktionalität des Merkmals <code>Drop</code> fast immer
bei der Implementierung eines intelligenten Zeigers verwendet wird.
Wenn beispielsweise eine <code>Box&lt;T&gt;</code> gelöscht wird, wird der Speicherplatz auf dem
Haldenspeicher freigegeben, auf den die Box zeigt.</p>
<p>In einigen Programmiersprachen muss der Programmierer bei jeder Verwendung einer
Instanz eines intelligenten Zeigers Programmcode aufrufen, um Speicher oder
Ressourcen freizugeben. Wenn sie es vergessen, kann das System überlastet werden
und abstürzen. In Rust kann man festlegen, dass ein bestimmter Programmcode
ausgeführt wird, wenn ein Wert seinen Gültigkeitsbereich verlässt, und der
Compiler fügt diesen Programmcode automatisch ein. Infolgedessen muss man nicht
vorsichtig sein, wenn man Bereinigungscode überall in einem Programm platziert,
mit dem eine Instanz eines bestimmten Typs fertig ist, man wird dennoch keine
Ressourcen verlieren!</p>
<p>Der Programmcode der ausgeführt wird, wenn ein Wert den Gültigkeitsbereich
verlässt, wird durch Implementieren des Merkmals <code>Drop</code> angegeben. Für das
Merkmal <code>Drop</code> muss man eine Methode <code>drop</code> implementieren, die eine 
veränderliche Referenz auf <code>self</code> enthält. Um zu sehen, wann Rust <code>drop</code>
aufruft, implementieren wir <code>drop</code> zunächst mit <code>println!</code>-Anweisungen.</p>
<p>Codeblock 15-14 zeigt eine Struktur (struct) <code>CustomSmartPointer</code>, deren einzige 
benutzerdefinierte Funktionalität darin besteht, dass <code>Lösche CustomSmartPointer!</code> ausgegeben wird, wenn die Instanz den Gültigkeitsbereich
verlässt. Dieses Beispiel zeigt, wann Rust die <code>drop</code>-Funktion ausführt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Lösche CustomSmartPointer und Daten `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;meine Sache&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;andere Sachen&quot;),
    };
    println!(&quot;CustomSmartPointers erzeugt.&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-14: Eine Struktur <code>CustomSmartPointer</code> die
das <code>Drop</code>-Merkmal implementiert wo wir unseren Programmcode für das
Aufräumen platzieren würden</span></p>
<p>Das Merkmal <code>Drop</code> ist im Präludium (prelude) enthalten, daher müssen wir es nicht in den
Gültigkeitsbereich bringen. Wir implementieren das Merkmal <code>Drop</code> in
<code>CustomSmartPointer</code> und stellen eine Implementierung für die Methode <code>drop</code>
bereit, die <code>println!</code> aufruft. Im Hauptteil der <code>drop</code>-Funktion kannst du jede
Logik platzieren, die du ausführen möchtest, wenn eine Instanz deines Typs
ihren Gültigkeitsbereich verlässt. Wir geben hier einen Text aus, um zu zeigen,
wann Rust <code>drop</code> aufruft.</p>
<p>In <code>main</code> erstellen wir zwei Instanzen von <code>CustomSmartPointer</code> und geben dann 
<code>CustomSmartPointers erzeugt</code> aus. Am Ende von <code>main</code> werden unsere Instanzen
von <code>CustomSmartPointer</code> nicht mehr gültig sein, und Rust ruft den Programmcode
auf, den wir in der <code>drop</code>-Methode angegeben haben, und gibt unsere endgültige
Nachricht aus. Beachte, dass wir die <code>drop</code>-Methode nicht explizit aufrufen
mussten.</p>
<p>Wenn wir das Programm ausführen, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers erzeugt.
Lösche CustomSmartPointer und Daten `andere Sachen`!
Lösche CustomSmartPointer und Daten `meine Sache`!
</code></pre>
<p>Rust hat für uns automatisch <code>drop</code> und den von uns angegebenen Programmcode 
aufgerufen, sobald unsere Instanzen den Gültigkeitsbereich verlassen haben. 
Variablen werden in umgekehrter Reihenfolge ihrer Erstellung gelöscht, daher
wurde <code>d</code> vor <code>c</code> gelöscht. Dieses Beispiel gibt dir eine visuelle Anleitung zur
Funktionsweise der <code>drop</code>-Methode. Normalerweise gibst du den Bereinigungscode
an, den dein Typ ausführen muss, anstatt einen Text auszugeben.</p>
<h3><a class="header" href="#einen-wert-mit-stdmemdrop-frühzeitig-löschen" id="einen-wert-mit-stdmemdrop-frühzeitig-löschen">Einen Wert mit <code>std::mem::drop</code> frühzeitig löschen</a></h3>
<p>Unglücklicherweise ist es nicht einfach, die automatische <code>drop</code>-Funktionalität
zu deaktivieren. Für gewöhnlich ist es auch nicht erforderlich; der wesentliche
Punkt des <code>Drop</code>-Merkmals ist, dass es automatisch erledigt wird. Gelegentlich
möchte man jedoch möglicherweise einen Wert frühzeitig bereinigen. Ein Beispiel
ist die Verwendung intelligenter Zeiger, die Sperren verwalten: Möglicherweise
möchtest du die <code>drop</code>-Methode dazu zwingen, die Sperre freizugegeben,
damit anderer Programmcode im selben Gültigkeitsbereich die Sperre erhalten kann. Mit
Rust kann man die <code>drop</code>-Methode des <code>Drop</code>-Merkmals nicht manuell aufrufen.
Stattdessen muss man die von der Standardbibliothek bereitgestellte Funktion
<code>std::mem::drop</code> aufrufen, wenn man das Löschen eines Werts vor dem Ende seines
Gültigkeitsbereich erzwingen möchte.</p>
<p>Wenn wir versuchen die <code>drop</code>-Methode des <code>Drop</code>-Merkmals manuell aufzurufen,
indem wir die <code>main</code>-Funktion aus Codeblock 15-14 ändern, wie im Codeblock 15-15,
gezeigt, erhalten wir folgenden Fehler beim Kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Lösche CustomSmartPointer und Daten `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;Daten&quot;),
    };
    println!(&quot;CustomSmartPointer erzeugt.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer vor dem Ende von main gelöscht.&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-15: Der Versuch, die <code>drop</code>-Methode 
des <code>Drop</code>-Merkmals manuell aufzurufen, um frühzeitig zu bereinigen</span></p>
<p>Wenn wir versuchen, diesen Programmcode zu kompilieren, wird folgende
Fehlermeldung ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Fehlermeldung besagt, dass wir <code>drop</code> nicht explizit aufrufen dürfen. Die
Fehlermeldung verwendet den Begriff <em>Destruktor</em> (destructor), der der allgemeine
Programmierbegriff für eine Funktion ist, die eine Instanz bereinigt. Ein
<em>Destruktor</em> ist analog zu einem <em>Konstruktor</em> (constructor), der eine Instanz
erstellt. Die <code>drop</code>-Funktion in Rust ist ein bestimmter <em>Destruktor</em>.</p>
<p>Rust lässt uns <code>drop</code> nicht explizit aufrufen, da Rust immer noch automatisch
für den Wert am Ende von <code>main</code> <code>drop</code> aufruft. Dies wäre ein <em>double
free</em>-Fehler, da Rust versuchen würde, den gleichen Wert zweimal aufzuräumen.</p>
<p>Die <code>std::mem::drop</code>-Funktion unterscheidet sich von der Methode <code>drop</code> im
Merkmal <code>Drop</code>. Wir rufen sie auf, indem wir den Wert, dessen vorzeitige Löschung
wir erzwingen möchten, der Funktion als Argument mitgeben. Die Funktion befindet
sich im Präludium, daher können wir <code>main</code> in Codeblock 15-15 ändern, um die
<code>drop</code>-Funktion wie in Codeblock 15-16 gezeigt aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Lösche CustomSmartPointer und Daten `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;Daten&quot;),
    };
    println!(&quot;CustomSmartPointer erzeugt.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer vor dem Ende von main gelöscht.&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-16: <code>std::mem::drop</code> aufrufen um einen Wert
explizit zu löschen bevor er den Gültigkeitsbereich verlässt</span></p>
<p>Wenn wir den Programmcode aufrufen, wird folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer erzeugt.
Lösche CustomSmartPointer und Daten `Daten`!
CustomSmartPointer vor dem Ende von main gelöscht.
</code></pre>
<p>Der Text <code>Lösche CustomSmartPointer und Daten `Daten`!</code> wird zwischen 
<code>CustomSmartPointer erzeugt</code> und <code>CustomSmartPointer vor dem Ende von main gelöscht.</code>
ausgegeben und zeigt, dass der <code>drop</code>-Methodencode aufgerufen wird um <code>c</code> an
diesem Punkt zu löschen.</p>
<p>Du kannst den Programmcode, der in einer Implementierung des <code>Drop</code>-Merkmals
angegeben ist, auf viele Arten verwenden, um die Bereinigung bequem und sicher
zu gestalten, du kannst ihn beispielsweise dazu verwnden, um deinen eigenen
Speicher-Allokator (memory allocator) zu erstellen! Mit dem Merkmal <code>Drop</code> und dem 
Eigentümerschaftssystem von Rust musst du nicht daran denken den Programmcode zu
bereinigen, da Rust dies automatisch tut.</p>
<p>Man muss sich auch keine Sorgen über Probleme machen, die sich aus der
versehentlichen Bereinigung noch verwendeter Werte ergeben: Das Eigentümerschaftssystem,
das sicherstellt, das Referenzen immer gültig sind, stellt auch sicher, dass
<code>drop</code> nur einmal aufgerufen wird, wenn der Wert nicht mehr verwendet wird.</p>
<p>Nachdem wir nun <code>Box&lt;T&gt;</code> und einige der Merkmale von intelligenten Zeigern
untersucht haben, schauen wir uns einige andere intelligente Zeiger an, die in
der Standardbibliothek definiert sind.</p>
<h2><a class="header" href="#der-referenzzählende-intelligente-zeiger-rct" id="der-referenzzählende-intelligente-zeiger-rct">Der referenzzählende intelligente Zeiger <code>Rc&lt;T&gt;</code></a></h2>
<p>In den meisten Fällen ist die Eigentümerschaft klar, man weiß genau, welche
Variable einen bestimmten Wert besitzt. Es gibt jedoch Fälle, in denen ein
einzelner Wert mehrere Eigentümer haben kann. In Diagrammdatenstrukturen 
(graph data structures) können beispielsweise mehrere Kanten auf denselben Knoten
verweisen, und dieser Knoten gehört konzeptionell allen Kanten, die darauf
verweisen. Ein Knoten sollte nur bereinigt werden, wenn keine Kanten darauf zeigen.</p>
<p>Um Mehrfacheigentum zu ermöglichen, hat Rust einen Typ namens <code>Rc&lt;T&gt;</code>, was eine
Kurzform für <em>Referenzzählung</em> (reference counting) ist. Der Typ <code>Rc&lt;T&gt;</code>
beobachtet die Anzahl der Referenzen auf einen Wert, der bestimmt, ob ein Wert
noch verwendet wird oder nicht. Wenn auf einen Wert keine Referenz vorhanden
ist, kann der Wert bereinigt werden, ohne dass Referenzen ungültig werden.</p>
<p>Stell dir <code>Rc&lt;T&gt;</code> als einen Fernseher im Wohnzimmer vor. Wenn eine Person zum
Fernsehen hereinkommt, schaltet sie ein. Andere können in das Zimmer kommen und
fernsehen. Wenn die letzte Person den Raum verlässt, schaltet sie den Fernseher
aus, da er nicht mehr verwendet wird. Wenn jemand den Fernseher ausschaltet,
während andere noch fernsehen möchten, wird es Aufruhr bei den übrigen
Zuschauern geben!</p>
<p>Wir verwenden den Typ <code>Rc&lt;T&gt;</code>, wenn wir Daten auf dem Haldenspeicher allokieren
möchten, damit mehrere Teile unseres Programms diese lesen können,
und wir können zum Zeitpunkt der Kompilierung nicht bestimmen, welcher Teil
zuletzt fertig sein würde. Wenn wir wüssten, welcher Teil zuletzt fertig sein
würde, könnten wir diesen Teil einfach zum Eigentümer der Daten machen, und die
Eigentumsregeln, die zur Kompilierzeit durchgesetzt werden, würden wirksam.</p>
<p>Beachte, dass <code>Rc&lt;T&gt;</code> nur in einsträngigen (single-threaded) Szenarien verwendet
werden kann. Wenn wir in Kapitel 16 auf Nebenläufigkeit (concurrency) eingehen,
werden wir uns mit der Referenzzählung in mehrsträngigen (multi-threaded)
Programmen befassen.</p>
<h3><a class="header" href="#rct-zur-gemeinsamen-nutzung-von-daten-verwenden" id="rct-zur-gemeinsamen-nutzung-von-daten-verwenden"><code>Rc&lt;T&gt;</code> zur gemeinsamen Nutzung von Daten verwenden</a></h3>
<p>Kehren wir zu unserem Beispiel für die Cons-Liste in Codeblock 15-5 zurück.
Denke daran, dass wir es mit <code>Box&lt;T&gt;</code> definiert haben. Dieses Mal erstellen
wir zwei Listen, die beide gemeinsam eine dritte Liste besitzen. Konzeptionell
sieht dies ähnlich aus wie in Abbildung 15-3:</p>
<p><img alt="Zwei Listen die sich die Eigentümerschaft einer dritten Liste teilen" 
src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Abbildung 15-3: Zwei Listen <code>b</code> und <code>c</code> teilen sich 
die Eigentümerschaft über eine dritte Liste <code>a</code></span></p>
<p>Wir erstellen eine Liste <code>a</code>, die 5 und dann 10 enthält. Dann erstellen wir zwei
weitere Listen: <code>b</code>, die mit 3 beginnt, und <code>c</code>, die mit 4 beginnt. Sowohl
<code>b</code> als auch <code>c</code> werden dann mit mit der ersten Liste <code>a</code> fortfahren, die 5 und
10 enthält. Mit anderen Worten, beide Listen teilen sich die erste Liste mit 5
und 10.</p>
<p>Der Versuch, dieses Szenario mithilfe unserer Definition von <code>List</code> mit <code>Box&lt;T&gt;</code>
zu implementieren, funktioniert nicht, wie in Codeblock 15-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-17: Dies zeigt, dass wir mit <code>Box&lt;T&gt;</code> keine
zwei Listen haben dürfen, die versuchen, die Eigentümerschaft einer dritten Liste zu
teilen</span></p>
<p>Beim Versuch den Programmcode zu kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die <code>Cons</code>-Varianten besitzen die Daten, die sie enthalten. Wenn wir also die
<code>b</code>-Liste erstellen, wird <code>a</code> in <code>b</code> verschoben und <code>b</code> besitzt <code>a</code>. Wenn wir
dann beim Erstellen von <code>c</code> versuchen erneut <code>a</code> zu verwenden, ist dies nicht
zulässig, da <code>a</code> verschoben wurde.</p>
<p>Wir könnten die Definition von <code>Cons</code> ändern, um stattdessen Referenzen zu
erhalten, aber dann müssten wir Lebensdauerparameter (lifetime parameters)
angeben. Durch die Angabe von Lebensdauerparametern würden wir angeben, dass
jedes Element in der Liste mindestens so lange wie die gesamte Liste lebt. Mit
dem Ausleihenprüfer (borrow checker) können wir beispielsweise <code>let a = Cons(10, &amp;Nil);</code> nicht kompilieren, da der temporäre <code>Nil</code>-Wert aufgeräumt
wird, bevor <code>a</code> darauf referenzieren kann.</p>
<p>Stattdessen ändern wir unsere Definition von <code>List</code> so, dass <code>Rc&lt;T&gt;</code> anstelle
von <code>Box&lt;T&gt;</code> verwendet wird, wie in Codeblock 15-18 gezeigt. Jede
<code>Cons</code>-Variante enthält nun einen Wert und ein <code>Rc&lt;T&gt;</code>, das auf eine <code>List</code>
zeigt. Wenn wir <code>b</code> erstellen, klonen wir, anstatt <code>a</code> zu übernehmen, die
<code>Rc&lt;List&gt;</code>, die <code>a</code> enthält, und erhöhen die Anzahl der Referenzen von eins auf
zwei und lassen <code>a</code> und <code>b</code> die Eigentümerschaft (ownership) an den Daten dieser <code>Rc&lt;List&gt;</code>
teilen. Wir werden auch <code>a</code> klonen, wenn wir <code>c</code> erstellen, wodurch die Anzahl
der Referenzen von zwei auf drei erhöht wird. Jedes Mal, wenn wir <code>Rc::clone</code>
aufrufen, erhöht sich die Anzahl der Referenzen auf die Daten in der
<code>Rc&lt;Liste&gt;</code>, und die Daten werden erst dann bereinigt, wenn keine Referenzen
darauf vorhanden sind.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-18: Eine Definition von <code>List</code> die <code>Rc&lt;T&gt;</code>
verwendet</span></p>
<p>Wir müssen eine <code>use</code>-Anweisung hinzufügen, um <code>Rc&lt;T&gt;</code> in den
Gültigkeitsbereich (scope) zu bringen, da sie nicht im Präludium (prelude) ist.
In <code>main</code> erstellen wir die Liste mit 5 und 10 und speichern sie in einem neuen
<code>Rc&lt;List&gt;</code> in <code>a</code>. Wenn wir dann <code>b</code> und <code>c</code> erstellen, rufen wir die Funktion
<code>Rc::clone</code> auf und übergeben eine Referenz auf <code>Rc&lt;List&gt;</code> in <code>a</code> als Argument.</p>
<p>Wir hätten <code>a.clone()</code> anstelle von <code>Rc::clone(&amp;a)</code> aufrufen können, aber Rusts
Konvention lautet in diesem Fall <code>Rc::clone</code>. Die Implementierung von <code>Rc::clone</code>
erstellt keine tiefe Kopie aller Daten, wie es bei den meisten Implementierungen
von <code>clone</code> der Fall ist. Der Aufruf von <code>Rc::clone</code> erhöht nur den
Referenzzähler, was nicht viel Zeit in benötigt. Tiefe Kopien von Daten
können viel Zeit in Anspruch nehmen. Durch die Verwendung von <code>Rc::Clone</code> für
die Referenzzählung können wir visuell zwischen den Arten von Klonen mit tiefer
Kopie und Klonen, die den Referenzzähler erhöhen, unterscheiden. Bei
der Suche nach Performanzproblemen im Code müssen wir nur die Klone mit tiefer
Kopie berücksichtigen und können die Aufrufe von <code>Rc::clone</code> ignorieren.</p>
<h3><a class="header" href="#rct-zu-klonen-erhöht-den-referenzzähler" id="rct-zu-klonen-erhöht-den-referenzzähler"><code>Rc&lt;T&gt;</code> zu klonen erhöht den Referenzzähler</a></h3>
<p>Lass uns unser Arbeitsbeispiel in Codeblock 15-18 ändern, damit sich die
Referenzanzahl ändert, wenn wir Referenzen auf <code>Rc&lt;List&gt;</code> in <code>a</code> erstellen
und löschen.</p>
<p>In Codeblock 15-19 ändern wir <code>main</code>, damit es einen inneren Gültigkeitsbereich um die
Liste <code>c</code> hat, so können wir sehen, wie sich der Referenzzähler ändert, wenn <code>c</code>
den Gültigkeitsbereich verlässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;Zähler nach der Erstellung von a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;Zähler nach der Erstellung von b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;Zähler nach der Erstellung von c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;Zahler nachdem c den Gültigkeitsbereich verlässt = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-19: Den Referenzzähler ausgeben</span></p>
<p>An jeden Punkt im Programm, an dem sich der Referenzzähler ändert, geben wir
den Referenzzähler aus, den wir durch Aufrufen der Funktion <code>Rc::strong_count</code>
erhalten können. Diese Funktion heißt <code>strong_count</code> und nicht <code>count</code>, da der
Typ <code>Rc&lt;T&gt;</code> auch eine Funktion <code>weak_count</code> hat. Wir werden im Abschnitt
<a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">„Verhindern von Referenzzyklen: <code>Rc&lt;T&gt;</code> in <code>Weak&lt;T&gt;</code>
verwandeln“</a> sehen wofür <code>weak_count</code> verwendet wird.</p>
<p>Dieser Programmcode gibt folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
Zähler nach der Erstellung von a = 1
Zähler nach der Erstellung von b = 2
Zähler nach der Erstellung von c = 3
Zahler nachdem c den Gültigkeitsbereich verlässt = 2
</code></pre>
<p>Wir sehen, dass <code>Rc&lt;List&gt;</code> in <code>a</code> einen anfänglichen Referenzzähler
von 1 hat. Jedes Mal wenn wir <code>clone</code> aufrufen, steigt die Anzahl um 1. Wenn <code>c</code>
den Gültigkeitsbereich verlässt, sinkt die Anzahl um 1. Wir müssen keine
Funktion aufrufen, um den Referenzzähler wie erforderlich zu verringern,
während wir <code>Rc::clone</code> aufrufen müssen, um den Referenzzähler zu erhöhen: Die
Implementierung des Merkmals (trait) <code>Drop</code> verringert den Referenzzähler
automatisch, wenn ein <code>Rc&lt;T&gt;</code>-Wert den Gültigkeitsbereich verlässt.</p>
<p>Was wir in diesem Beispiel nicht sehen können, ist, dass wenn <code>b</code> und dann <code>a</code>
am Ende von <code>main</code> den Gültigkeitsbereich verlassen, der Zähler 0 ist und
<code>Rc&lt;List&gt;</code> an diesem Punkt vollständig bereinigt wird. Durch die Verwendung von
<code>Rc&lt;T&gt;</code> kann ein einzelner Wert mehrere Eigentümer haben und der Zähler stellt
sicher, dass der Wert gültig bleibt, solange ein Eigentümer vorhanden ist.</p>
<p>Über unveränderliche (immutable) Referenzen kann man mit <code>Rc&lt;T&gt;</code> Daten zwischen
mehreren Teilen eines Programms zum Lesen austauschen. Wenn man mit <code>Rc&lt;T&gt;</code>
auch mehrere veränderliche (mutable) Referenzen haben könnte, verstößt man
möglicherweise gegen eine der in Kapitel 4 beschriebenen Ausleihregeln: Mehrere
veränderlich ausgeliehene Referenzen an derselben Stelle können zu
Daten-Wettlaufsituationen (data races) und Inkonsistenzen führen. Es ist jedoch
sehr nützlich, Daten verändern zu können! Im nächsten Abschnitt werden wir das
innere Veränderlichkeitsmuster und den Typ <code>RefCell&lt;T&gt;</code> erläutern, den man in
Verbindung mit <code>Rc&lt;T&gt;</code> verwenden kann, um mit dieser
Unveränderlichkeitsbeschränkung zu arbeiten.</p>
<h2><a class="header" href="#refcellt-und-das-innere-veränderlichkeitsmuster" id="refcellt-und-das-innere-veränderlichkeitsmuster"><code>RefCell&lt;T&gt;</code> und das innere Veränderlichkeitsmuster</a></h2>
<p><em>Innere Veränderlichkeit</em> (interior mutability) ist ein Entwurfsmuster in Rust,
mit dem man Daten auch dann verändern kann, wenn unveränderliche Referenzen auf
diese Daten vorhanden sind. Normalerweise ist diese Aktion nach den
Ausleihregeln nicht zulässig. Um Daten zu verändern, verwendet das Muster
„unsicheren“ Programmcode (<code>unsafe</code> code) innerhalb einer Datenstruktur, um Rusts
übliche Regeln, die Veränderlichkeit und Ausleihen betreffen, zu verändern. Wir
haben unsicheren Code noch nicht behandelt. Wir werden in Kapitel 19 darauf
eingehen. Wir können Typen verwenden, die das innere Veränderlichkeitsmuster
verwenden, wenn wir sicherstellen können, dass die Ausleihregeln zur Laufzeit
eingehalten werden, obwohl der Compiler dies nicht garantieren kann. Der
betreffende unsichere Programmcode wird dann in eine sichere API
eingeschlossen und der äußere Typ ist immer noch unveränderlich.</p>
<p>Lass uns dieses Konzept untersuchen, indem wir uns den Typ <code>RefCell&lt;T&gt;</code> ansehen,
der dem inneren Veränderlichkeitsmuster folgt.</p>
<h3><a class="header" href="#mit-refcellt-ausleihregeln-zur-laufzeit-durchsetzen" id="mit-refcellt-ausleihregeln-zur-laufzeit-durchsetzen">Mit <code>RefCell&lt;T&gt;</code> Ausleihregeln zur Laufzeit durchsetzen</a></h3>
<p>Im Gegensatz zu <code>Rc&lt;T&gt;</code> repräsentiert der Typ <code>RefCell&lt;T&gt;</code> die
einzige Eigentümerschaft (ownership) für die darin enthaltenen Daten. Was unterscheidet
<code>RefCell&lt;T&gt;</code> von einem Typ wie <code>Box&lt;T&gt;</code>? Erinnere dich an die Ausleihregeln die
wir im Kapitel 4 gelernt haben:</p>
<ul>
<li>Zu jeder Zeit kann man <em>entweder</em> eine veränderliche Referenz oder eine
beliebige Anzahl unveränderlicher Referenzen haben (nicht aber beides).</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Mit Referenzen und <code>Box&lt;T&gt;</code> werden die Invarianten der Ausleihregeln beim
Kompilieren erzwungen. Mit <code>RefCell&lt;T&gt;</code> werden diese Invarianten <em>zur Laufzeit</em>
erzwungen. Wenn man mit Referenzen gegen diese Regeln verstößt wird beim
Kompilieren ein Fehler angezeigt. Wenn man mit <code>RefCell&lt;T&gt;</code> gegen diese Regeln
verstößt, wird das Programm mit <code>panic</code> beendet.</p>
<p>Die Überprüfung der Ausleihregeln zur Kompilierzeit hat den Vorteil, dass
Fehler früher im Entwicklungsprozess erkannt werden und die Laufzeitperformanz
nicht beeinträchtigt wird, da die gesamte Analyse im Voraus abgeschlossen
wurde. Aus diesen Gründen ist es in den meisten Fällen die beste Wahl, die
Ausleihregeln zur Kompilierzeit zu überprüfen. Aus diesem Grund ist dies die
Standardeinstellung von Rust.</p>
<p>Der Vorteil der Überprüfung der Ausleihregeln zur Laufzeit besteht darin, dass
bestimmte speichersichere Szenarien zulässig sind, während sie durch die
Überprüfung zur Kompilierzeit nicht zulässig sind. Die statische Analyse
ist wie der Rust-Compiler von Natur aus konservativ. Einige Eigenschaften des
Programmcodes lassen sich durch Analyse des Programmcodes nicht erkennen: Das
bekannteste Beispiel ist das Halteproblem, das den Rahmen dieses Buches sprengt,
aber ein interessantes Thema zum Nachforschen darstellt.</p>
<p>Da eine Analyse nicht möglich ist, lehnt der Rust-Compiler möglicherweise ein
ein korrektes Programm ab, wenn er nicht sicher sein kann, dass der Programmcode
den Eigentümerschaftsregeln entspricht. Auf diese Art ist Rust konservativ. Wenn
es ein falsches Programm akzeptiert, können Benutzer den Garantien von Rust
nicht vertrauen. Wenn Rust jedoch ein ein korrektes Programm ablehnt, wird der
Programmierer belästigt, obwohl nichts negatives passieren kann. Der Typ
<code>RefCell&lt;T&gt;</code> ist nützlich, wenn man sicher ist, dass der Programmcode den
Ausleihregeln entspricht, der Compiler dies jedoch nicht verstehen und
garantieren kann.</p>
<p>Ähnlich wie <code>Rc&lt;T&gt;</code> ist <code>RefCell&lt;T&gt;</code> nur für die Verwendung in einsträngigen
(single-threaded) Szenarien vorgesehen und gibt einen Fehler beim Kompilieren
aus, wenn man versucht, es in einem mehrsträngigen (multi-threaded) Kontext zu
verwenden. Wir werden in Kapitel 16 darüber sprechen, wie man die Funktionalität 
von <code>RefCell&lt;T&gt;</code> in einem mehrsträngigen Programm erhält.</p>
<p>Eine Zusammenfassung der Gründe für die Wahl von <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> oder
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> erlaubt mehrere Eigentümer derselben Daten. Mit <code>Box&lt;T&gt;</code> und
<code>RefCell&lt;T&gt;</code> haben Daten nur einen Eigentümer.</li>
<li><code>Box&lt;T&gt;</code> ermöglicht unveränderliches oder veränderliches Ausleihen, das zur
Kompilierzeit überprüft wird. <code>Rc&lt;T&gt;</code> erlaubt nur unveränderliches
Ausleihen, das zur Kompilierzeit geprüft wird und <code>RefCell&lt;T&gt;</code>
erlaubt unveränderliches oder veränderliches Ausleihen, das zur Laufzeit
überprüft wird.</li>
<li>Da <code>RefCell&lt;T&gt;</code> zur Laufzeit überprüfbares veränderliches Ausleihen zulässt,
kann man den Wert innerhalb von <code>RefCell&lt;T&gt;</code> auch dann ändern, wenn
<code>RefCell&lt;T&gt;</code> unveränderlich ist.</li>
</ul>
<p>Das Ändern des Werts innerhalb eines unveränderlichen Werts ist das <em>innere
Veränderlichkeitsmuster</em>. Schauen wir uns eine Situation an, in der innere
Veränderlichkeit nützlich ist, und untersuchen, wie dies möglich ist.</p>
<h3><a class="header" href="#innere-veränderlichkeit-das-veränderliche-ausleihen-eines-unveränderlichen-wertes" id="innere-veränderlichkeit-das-veränderliche-ausleihen-eines-unveränderlichen-wertes">Innere Veränderlichkeit: Das veränderliche Ausleihen eines unveränderlichen Wertes</a></h3>
<p>Eine Konsequenz der Ausleihregeln ist, dass man einen unveränderlichen Wert
nicht veränderlich ausleihen kann. Dieser Programmcode wird beispielsweise nicht
kompilieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn main() {
let x = 5;
let y = &amp;mut x;
}
</code></pre></pre>
<p>Wenn man versucht, diesen Programmcode zu kompilieren, wird die folgende
Fehlermeldung angezeigt:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Es gibt jedoch Situationen, in denen es nützlich wäre, wenn ein Wert in
seinen Methoden selbst veränderlich ist, aber für einen anderen Programmode 
unveränderlich erscheint. Programmcode außerhalb der Methoden des Werts kann
diesen nicht verändern. Die Verwendung von <code>RefCell&lt;T&gt;</code> ist eine Möglichkeit,
die Fähigkeit zur inneren Veränderlichkeit zu erhalten, allerdings
umgeht <code>RefCell&lt;T&gt;</code> die Ausleihregeln nicht vollständig: Der Ausleihenprüfer (borrow checker) im
Compiler ermöglicht diese innere Veränderlichkeit, und die Ausleihregeln werden
stattdessen zur Laufzeit überprüft. Wenn man gegen die Regeln verstößt wird
<code>panic</code> anstelle eines Fehlers beim Kompilieren ausgelöst.</p>
<p>Lass uns ein praktisches Beispiel durcharbeiten, in dem wir <code>RefCell&lt;T&gt;</code>
verwenden können, um einen unveränderlichen Wert zu ändern und herauszufinden,
warum dies nützlich ist.</p>
<h4><a class="header" href="#ein-anwendungsfall-für-die-innere-veränderlichkeit-mock-objekte-mock-objects" id="ein-anwendungsfall-für-die-innere-veränderlichkeit-mock-objekte-mock-objects">Ein Anwendungsfall für die innere Veränderlichkeit: Mock-Objekte (Mock Objects)</a></h4>
<p>Ein <em>Testdoppel</em> (test double) ist das allgemeine Programmierkonzept für einen 
Typ, der beim Testen anstelle eines anderen Typs verwendet wird. <em>Mock-Objekte</em> 
sind bestimmte Arten von Testdoppeln, die aufzeichnen, was während eines Tests
passiert, damit man bestätigen kann, dass die richtigen Aktionen ausgeführt
wurden.</p>
<p>Rust verfügt nicht im gleichen Sinne wie andere Programmiersprachen über
Objekte und in die Standardbibliothek integrierte Mock-Objekt-Funktionen. Man
kann jedoch definitiv eine Struktur erstellen, die denselben Zwecken dient wie
ein Mock-Objekt.</p>
<p>Hier ist das Szenario, das wir testen werden: Wir erstellen eine Bibliothek, die
einen Wert anhand eines Maximalwerts verfolgt und Nachrichten basierend darauf
sendet, wie nahe der Maximalwert am aktuellen Wert liegt. Diese Bibliothek kann
verwendet werden, um das Kontingent eines Benutzers für die Anzahl der
API-Aufrufe zu verfolgen, die er beispielsweise ausführen darf.</p>
<p>Unsere Bibliothek bietet nur die Funktionalität, zu verfolgen, wie nahe ein Wert
am Maximum liegt und wie die Nachrichten zu welchen Zeiten sein sollten.
Von Anwendungen, die unsere Bibliothek verwenden wird erwartet, dass sie den
Mechanismus zum Senden der Nachrichten bereitstellen: Die Anwendung könnte eine
Nachricht in der Anwendung anlegen, eine E-Mail senden, eine Textnachricht
senden oder etwas anderes. Die Bibliothek muss dieses Detail nicht kennen.
Alles, was es braucht, ist etwas, das ein von uns bereitgestelltes Merkmal
(trait) namens <code>Messenger</code> implementiert. Codeblock 15-20 zeigt den
Bibliothekscode:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-20: Eine Bibliothek um zu verfolgen, wie nahe
ein Wert an einem Maximalwert liegt, und um zu warnen, wenn der Wert über
bestimmten Schwellwerten liegt</span></p>
<p>Ein wichtiger Teil dieses Programmcodes ist, dass das Merkmal <code>Messenger</code> eine
Methode namens <code>send</code> hat, die eine unveränderliche Referenz auf <code>self</code> und den
Text der Nachricht enthält. Dies ist die Schnittstelle, die unser Mock-Objekt
haben muss. Der andere wichtige Teil ist, dass wir das Verhalten der Methode
<code>set_value</code> auf dem <code>LimitTracker</code> testen möchten. Wir können ändern, was wir
für den Parameter <code>value</code> übergeben, aber <code>set_value</code> auf dem <code>LimitTracker</code>
testen möchten. Wir können ändern, was wir für den Parameter <code>value</code> übergeben,
aber <code>set_value</code> gibt nichts zurück, worüber wir Aussagen machen können. Wir
möchten sagen können, dass, wenn wir einen <code>LimitTracker</code> mit etwas das das
Merkmal <code>Messenger</code> implementiert erstellen und einen bestimmten Wert für <code>max</code>,
wenn wir unterschiedliche Zahlen für <code>value</code> übergeben, der Messenger angewiesen
wird entsprechende Nachrichten zu senden.</p>
<p>Wir benötigen ein Mock-Objekt, das anstelle einer E-Mail oder einer
Textnachricht beim Aufrufen von <code>send</code> nur die Nachrichten verfolgt, die
gesendet werden sollen. Wir können eine neue Instanz des Mock-Objekts estellen,
einen <code>LimitTracker</code> erstellen, der das Mock-Objekt verwendet, die
<code>set_value</code>-Methode für <code>LimitTracker</code> aufrufen und dann überprüfen, ob das
Mock-Objekt die erwarteten Nachrichten enthält. Codeblock 15-21 zeigt den
Versuch, ein Mock-Objekt zu implementieren, um genau das zu tun, aber der
Ausleihenprüfer erlaubt dies nicht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-21: Der Versuch einen <code>MockMessenger</code> zu
implementieren, der vom Ausleihenprüfer nicht erlaubt wird</span></p>
<p>Dieser Testcode definiert eine Struktur <code>MockMessenger</code> mit einem
<code>sent_messages</code>-Feld mit einem <code>Vec</code> von <code>String</code>-Werten, um Nachrichten zu
verfolgen, die gesendet werden sollen. Wir definieren auch eine zugehörige
Funktion <code>new</code>, um das Erstellen neuer <code>MockMessenger</code>-Werte zu vereinfachen,
die mit einer leeren Liste von Nachrichten beginnen. Wir implementieren dann das
Merkmal <code>Messenger</code> für <code>MockMessenger</code> damit wir einem <code>LimitTracker</code> einen
<code>MockMessenger</code> übergeben können. Bei der Definition der Methode <code>send</code> nehmen wir
die übergebene Nachricht als Parameter und speichern sie in der Liste
<code>MockMessenger</code> von <code>sent_messages</code>.</p>
<p>Im Test testen wir, was passiert, wenn dem <code>LimitTracker</code> gesagt wird, er solle
<code>value</code> auf etwas setzen, das mehr als 75 Prozent des <code>max</code>-Wertes beträgt.
Zuerst erstellen wir einen neuen <code>MockMessenger</code>, der mit einer leeren
Nachrichtenliste beginnt. Dann erstellen wir einen neuen <code>LimitTracker</code> und
geben ihm eine Referenz auf den neuen <code>MockMessenger</code> und einen <code>max</code>-Wert von
100. Wir rufen die Methode <code>set_value</code> auf <code>LimitTracker</code> mit dem Wert 80 auf,
was mehr als 75 Prozent von 100 ist. Dann stellen wir sicher, dass die
Nachrichtenliste, die der <code>MockMessenger</code> verwaltet, nun eine einzige Nachricht
enthalten sollte.</p>
<p>Es gibt jedoch ein Problem mit diesem Test, wie hier gezeigt:</p>
<pre><code class="language-text">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
57 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- help: consider changing this to be a mutable reference: `&amp;mut self`
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wir können den <code>MockMessenger</code> nicht ändern, um die Nachrichten zu verfolgen, da
die <code>send</code>-Methode eine unveränderliche Referenz auf <code>self</code> verwendet. Wir
können auch nicht den Vorschlag aus dem Fehlertext übernehmen, stattdessen 
<code>&amp;mut self</code> zu verwenden, da die Signatur von <code>send</code>nicht mit der Signatur in 
der Merkmalsdefinition von <code>Messenger</code> übereinstimmt (probiere es gerne aus und
schau dir die Fehlermeldung an, die dabei ausgegeben wird).</p>
<p>Dies ist eine Situation, in der innere Veränderlichkeit helfen kann! Wir
speichern die <code>send_messages</code> in einer <code>RefCell&lt;T&gt;</code> und dann kann die
<code>send</code>-Nachricht <code>sent_messages</code> ändern, um Nachrichten zu speichern, die wir
gesehen haben. Codeblock 15-22 zeigt, wie das aussieht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --abschneiden--

<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span>        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-22: <code>RefCell&lt;T&gt;</code> verwenden, um einen inneren
Wert zu verändern, während der äußere Wert als unveränderlich betrachtet wird</span></p>
<p>Das Feld <code>sent_messages</code> ist jetzt vom Typ <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> anstelle von
<code>Vec&lt;String&gt;</code>. In der Funktion <code>new</code> erstellen wir eine neue 
<code>RefCell&lt;Vec&lt;Sting&gt;&gt;</code>-Instanz um den leeren Vektor.</p>
<p>Für die Implementierung der <code>send</code>-Methode ist der erste Parameter immer noch
eine unveränderliche Ausleihe von <code>self</code>, die der Merkmalsdefinition entspricht.
Wir rufen <code>borrow_mut</code> auf der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> auf,
um eine veränderliche Referenz auf den Wert in der <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> zu
erhalten, der der Vektor ist. Dann können <code>push</code> auf der veränderlichen
Referenz zum Vektor aufrufen, um die während des Tests gesendeten Nachrichten zu
verfolgen.</p>
<p>Die letzte Änderung, die wir vornehmen müssen, betrifft die Behauptung: Um zu
sehen, wie viele Elemente sich im inneren Vektor befinden, rufen wir in der
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> <code>borrow</code> auf, um eine unveränderliche Referenz auf den
Vektor zu erhalten.</p>
<p>Nachdem du nun gesehen hast, wie du <code>RefCell&lt;T&gt;</code> verwendest, wollen wir uns mit
der Funktionsweise befassen.</p>
<h4><a class="header" href="#mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten" id="mit-refcellt-den-Überblick-über-die-ausleihen-zur-laufzeit-behalten">Mit <code>RefCell&lt;T&gt;</code> den Überblick über die Ausleihen zur Laufzeit behalten</a></h4>
<p>Beim Erstellen unveränderlicher und veränderlicher Referenzen verwenden wir die
Syntax <code>&amp;</code> bzw. <code>&amp;mut</code>. Bei <code>RefCell&lt;T&gt;</code> verwenden wir die Methoden <code>borrow</code> und
<code>borrow_mut</code>, die Teil der sicheren API sind, die zu <code>RefCell&lt;T&gt;</code> gehört. Die
Methode <code>borrow</code> gibt den intelligenten Zeigertyp <code>Ref&lt;T&gt;</code> zurück und
<code>borrow_mut</code> den intelligenten Zeigertyp <code>RefMut&lt;T&gt;</code>. Beide Typen
implementieren <code>Deref</code>, sodass wir sie wie reguläre Referenzen behandeln
können.</p>
<p>Der <code>RefCell&lt;T&gt;</code> verfolgt, wie viele intelligente Zeiger <code>Ref&lt;T&gt;</code> und <code>RefMut&lt;T&gt;</code>
derzeit aktiv sind. Jedes Mal, wenn wir <code>borrow</code> aufrufen, erhöht <code>RefCell&lt;T&gt;</code>
die Anzahl der aktiven unveränderlichen Ausleihen. Wenn ein <code>Ref&lt;T&gt;</code>-Wert
außerhalb des Gültigkeitsbereichs (scope) liegt, sinkt die Anzahl der unveränderlichen
Ausleihen um eins. Genau wie bei den Ausleihregeln zur Kompilierzeit können
wir mit <code>RefCell&lt;T&gt;</code> zu jedem Zeitpunkt viele unveränderliche Ausleihen oder eine
veränderliche Ausleihe haben.</p>
<p>Wenn wir versuchen, diese Regeln zu verletzen, erhalten wir keinen
Kompilierfehler wie bei Referenzen, sondern die Implementierung von
<code>RefCell&lt;T&gt;</code> wird zur Laufzeit abstürzen. Codeblock 15-23 zeigt eine
Modifikation der Implementierung von <code>send</code> in Codeblock 15-22. Wir versuchen
absichtlich, zwei veränderliche Ausleihen zu erstellen, die für denselben
Bereich aktiv sind, um zu veranschaulichen, dass <code>RefCell&lt;T&gt;</code> uns daran
hindert, dies zur Laufzeit zu tun.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Fehler: Du hast dein Kontingent überschritten!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Dringliche Warnung: Du hast über 90% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warnung: Du hast über 50% deines Kontingents verbraucht!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 15-23: Wir erstellen zwei veränderliche Referenzen im
selben Gültigkeitsbereich, um zu sehen, dass <code>RefCell&lt;T&gt;</code> abstürzt</span></p>
<p>Wir erstellen eine Variable <code>one_borrow</code> für den intelligenten Zeiger 
<code>RefMut&lt;T&gt;</code>, der von <code>borrow_mut</code> zurückgegeben wird. Dann erstellen wir auf die
gleiche Weise eine weitere veränderlichen Ausleihe in der Variable <code>two_borrow</code>.
Dadurch werden zwei veränderbare Referenzen im selben Bereich erstellt, was
nicht zulässig ist. Wenn wir die Tests für unsere Bibliothek ausführen, wird der
Programmcode in Codeblock 15-23 fehlerfrei kompiliert, aber der Test schlägt
fehl: </p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Beachte, dass der Programmcode mit der Meldung <code>already borrowed: BorrowMutError</code> abstürzt. Auf diese Weise behandelt <code>RefCell&lt;T&gt;</code> zur
Laufzeit Verstöße gegen die Ausleihregel.</p>
<p>Das Abfangen von Ausleihfehlern zur Laufzeit anstelle der Kompilierzeit
bedeutet, dass man später im Entwicklungsprozess einen Fehler im Programmcode
finden und möglicherweise erst, wenn das Programm für die Produktion
bereitgestellt wurde. Außerdem würde dieser Programmcode eine kleine
Beeinträchtigung der Laufzeitperformanz verursachen, da die Ausleihen zur Laufzeit
und nicht zur Kompilierzeit nachverfolgt werden. Die Verwendung von
<code>RefCell&lt;T&gt;</code> ermöglicht es jedoch, ein Mock-Objekt zu schreiben, das sich selbst
ändern kann, um die Nachrichten zu verfolgen, die es gesehen hat, während man es
in einem Kontext verwendet, in dem nur unveränderliche Werte zulässig sind. Man
kann <code>RefCell&lt;T&gt;</code> trotz seiner Kompromisse verwenden, um mehr Funktionen zu
erhalten, als reguläre Referenzen bieten.</p>
<h3><a class="header" href="#mehrere-eigentümer-veränderlicher-daten-durch-kombinieren-von-rct-und-refcellt" id="mehrere-eigentümer-veränderlicher-daten-durch-kombinieren-von-rct-und-refcellt">Mehrere Eigentümer veränderlicher Daten durch Kombinieren von <code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code></a></h3>
<p>Eine übliche Methode zur Verwendung von <code>RefCell&lt;T&gt;</code> ist die Kombination mit
<code>Rc&lt;T&gt;</code>. Erinnere dich, dass man mit <code>Rc&lt;T&gt;</code> mehrere Eigentümer einiger Daten
haben können, aber nur unveränderlichen Zugriff auf diese Daten erhalten. Wenn
man eine <code>Rc&lt;T&gt;</code> hat, das eine <code>RefCell&lt;T&gt;</code> enthält, kann man einen Wert
erhalten, der mehrere Eigentümer hat <em>und</em> veränderlich ist!</p>
<p>Erinnern wir uns beispielsweise an das Beispiel für die Cons-Liste in Codeblock
15-18, in dem wir <code>Rc&lt;T&gt;</code> verwendet haben, um mehrere Listen die gemeinsame
Nutzung einer anderen Liste ermöglichen. Da <code>Rc&lt;T&gt;</code> nur unveränderliche Werte
enthält, können wir keinen der Werte in der Liste ändern, sobald wir sie
erstellt haben. Fügen wir <code>RefCell&lt;T&gt;</code> hinzu, um die Werte in den Listen ändern
zu können. Codeblock 15-24 zeigt, dass wir durch Verwendung einer <code>RefCell&lt;T&gt;</code>
in der Cons-Definition den in allen Listen gespeicherten Wert ändern können:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-24: Verwendung von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> um <code>List</code>
zu erstellen, die wir verändern können</span></p>
<p>Wir erstellen einen Wert, der eine Instanz von <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> ist, und
speichern ihn dann in einer Variable mit dem Namen <code>value</code>, damit wir später
direkt darauf zugreifen können. Dann erstellen wir eine Liste in <code>a</code> mit einer
<code>Cons</code>-Variante, die <code>value</code> enthält. Wir müssen <code>value</code> klonen, damit sowohl 
<code>a</code> als auch <code>value</code> Eigentümerschaft am inneren Wert <code>5</code> haben, anstatt das
Eigentum von <code>value</code> auf <code>a</code> zu übertragen oder <code>a</code> von <code>value</code> auszuleihen.</p>
<p>Wir wickeln die Liste <code>a</code> in ein <code>Rc&lt;T&gt;</code> ein. Wenn wir also die Listen <code>b</code> und
<code>c</code> erstellen, können beide auf <code>a</code> verweisen, was wir in Codeblock 15-18 getan
haben.</p>
<p>Nachdem wir die Listen <code>a</code>, <code>b</code> und <code>c</code> erstellt haben, addieren wir 10 zum Wert
in <code>value</code>. Dazu rufen wir <code>borrow_mut</code> für <code>value</code> auf, wobei die in Kapitel 5
beschriebene automatische Dereferenzierung verwendet wird 
(siehe Abschnitt <a href="ch05-03-method-syntax.html#wo-ist-der-operator--">„Wo ist der Operator <code>-&gt;</code>?“</a>), um den
<code>Rc&lt;T&gt;</code> auf den inneren <code>RefCell&lt;T&gt;</code>-Wert zu dereferenzieren. Die
<code>borrow_mut</code>-Methode gibt einen intelligenten Zeiger <code>RefMut&lt;T&gt;</code> zurück, und wir
verwenden den Dereferenzierungsoperator darauf und ändern den inneren Wert.</p>
<p>Wenn wir <code>a</code>, <code>b</code> und <code>c</code> ausgeben, können wir sehen, dass sie alle den
veränderten Wert 15 anstelle von 5 haben:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Diese Technik ist ziemlich sauber! Durch die Verwendung von <code>RefCell&lt;T&gt;</code> haben
wir einen nach außen unveränderlichen <code>List</code>-Wert. Wir können jedoch die
Methoden für <code>RefCell&lt;T&gt;</code> verwenden, die den Zugriff auf die innere
Veränderlichkeit ermöglichen, damit wir unsere Daten bei Bedarf ändern können.
Die Laufzeitprüfungen der Ausleihregeln schützen uns vor
Daten-Wettlaufsituationen (data races), und manchmal lohnt es sich, ein wenig
Geschwindigkeit für diese Flexibilität in unseren Datenstrukturen
einzutauschen.</p>
<p>Die Standardbibliothek verfügt über andere Typen, die eine innere
Veränderlichkeit bieten, z.B. <code>Cell&lt;T&gt;</code>, die ähnlich ist, mit der Ausnahme, dass
der Wert nicht auf den inneren Wert referenziert, sondern in die <code>Cell&lt;T&gt;</code> und aus
diese herauskopiert wird. Es gibt auch <code>Mutex&lt;T&gt;</code>, das eine innere
Veränderlichkeit bietet, die sicher über Stränge (threads) hinweg verwendet
werden kann. Wir werden die Verwendung in Kapitel 16 erläutern. Weitere
Informationen zu den Unterschieden zwischen diesen Typen findest du in den
Standardbibliotheksdokumenten.</p>
<h2><a class="header" href="#referenzzyklen-können-zu-einem-speicherleck-führen" id="referenzzyklen-können-zu-einem-speicherleck-führen">Referenzzyklen können zu einem Speicherleck führen</a></h2>
<p>Die Speichersicherheitsgarantien von Rust machen es schwierig, aber nicht
unmöglich, versehentlich Speicher zu erstellen, der niemals bereinigt wird
(bekannt als <em>Speicherleck</em> (memory leak)). Das vollständige Verhindern von
Speicherlecks ist keine der Garantien von Rust, ebenso wie das Nichtzulassen von
Daten-Wettlaufsituationen (data races) zur Kompilierzeit. Dies bedeutet, dass
Speicherlecks in Rust speichersicher sind. Wir können sehen, dass Rust
Speicherlecks mithilfe von <code>Rc&lt;T&gt;</code> und <code>RefCell&lt;T&gt;</code> zulässt: Es ist möglich,
Referenzen zu erstellen, bei denen Elemente in einem Zyklus aufeinander
referenzieren. Dies führt zu Speicherlecks, da der Referenzzähler jedes Elements im
Zyklus niemals 0 erreicht und die Werte niemals gelöscht werden.</p>
<h3><a class="header" href="#einen-referenzzyklus-erstellen" id="einen-referenzzyklus-erstellen">Einen Referenzzyklus erstellen</a></h3>
<p>Schauen wir uns an, wie ein Referenzzyklus stattfinden kann und wie er verhindert
werden kann, beginnend mit der Definition der Aufzählung <code>List</code> und einer
Methode <code>tail</code> in Codeblock 15-25:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Codeblock 15-25: Definition einer Cons-Liste die ein
<code>RefCell&lt;T&gt;</code> hält, damit man ändern kann, worauf eine <code>Cons</code>-Variante
referenziert</span></p>
<p>Wir verwenden eine andere Variante der <code>List</code>-Definition aus Codeblock 15-5 Das
zweite Element in der <code>Cons</code>-Variante ist jetzt <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>. Dies
bedeutet, dass wir anstelle der Möglichkeit, den <code>i32</code>-Wert wie in Codeblock
15-24 zu ändern, den <code>List</code>-Wert einer <code>Cons</code>-Variante ändern auf den sie zeigt.
Wir fügen eine <code>tail</code>-Methode hinzu, damit wir bequem auf das zweite Element
zugreifen können, wenn wir eine <code>Cons</code>-Variante haben.</p>
<p>In Codeblock 15-26 fügen wir eine Funktion <code>main</code> hinzu, die die Definitionen in
Codeblock 15-25 verwendet. Dieser Code erstellt eine Liste in <code>a</code> und eine Liste
in <code>b</code>, die auf die Liste in <code>a</code> verweist. Anschließend wird die Liste in <code>a</code> so
geändert, dass sie auf <code>b</code> zeigt, wodurch ein Referenzzyklus erstellt wird. Es
gibt <code>println!</code>-Anweisungen auf dem Weg, um zu zeigen, wie hoch der
Referenzzähler an verschiedenen Punkten in diesem Prozess sind.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a anfängliche Rc-Zählung = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a nächstes Element = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a Rc-Zählung nach Erstellen von b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b anfängliche Rc-Zählung = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b nächstes Element = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b Rc-Zählung nach Änderung von a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a Rc-Zählung nach Änderung von a = {}&quot;, Rc::strong_count(&amp;a));

    // Kommentiere die nächste Zeile aus, um zu sehen, dass wir einen Zyklus haben;
    // es wird den Stapelspeicher überlaufen lassen
    // println!(&quot;a nächstes Element = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-26: Erstellen eines Referenzzyklus aus zwei
aufeinanderzeigenden Listenwerten</span></p>
<p>Wir erstellen eine <code>Rc&lt;List&gt;</code>-Instanz, die einen <code>List</code>-Wert in der Variablen <code>a</code>
mit einer initialen Liste <code>5, Nil</code> enthält. Wir erstellen dann eine
<code>Rc&lt;List&gt;</code>-Instanz, die einen anderen <code>List</code>-Wert in der Variablen <code>b</code> enthält,
die den Wert 10 enthält und auf die Liste in <code>a</code> zeigt.</p>
<p>Wir modifizieren <code>a</code> so, dass es auf <code>b</code> anstatt auf <code>Nil</code> zeigt, wodurch ein
Zyklus erstellt wird. Wir tun dies, indem wir die <code>tail</code>-Methode verwenden, um
eine Referenz auf <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code> zu erhalten, die wir in die
Variable <code>link</code> einfügen. Dann verwenden wir die <code>borrow_mut</code>-Methode für
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, um den Wert von <code>Rc&lt;List&gt;</code>, der einen <code>Nil</code>-Wert enthält,
in <code>Rc&lt;List&gt;</code> in <code>b</code> zu ändern.</p>
<p>Wenn wir diesen Programmcode ausführen und das letzte <code>println!</code>
auskommentieren, erhalten wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a anfängliche Rc-Zählung = 1
a nächstes Element = Some(RefCell { value: Nil })
a Rc-Zählung nach erstellen von b = 2
b anfängliche Rc-Zählung = 1
b nächstes Element = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b Rc-Zählung nach Änderung von a = 2
a Rc-Zählung nach Änderung von a = 2     
</code></pre>
<p>Der Referenzzähler der <code>Rc&lt;List&gt;</code>-Instanzen in <code>a</code> und <code>b</code> beträgt 2, nachdem
wir die Liste in <code>a</code> so geändert haben, dass sie auf <code>b</code> zeigt. Am Ende von
<code>main</code> versucht Rust, zuerst <code>b</code> zu löschen, wodurch der Zähler der
<code>Rc&lt;List&gt;</code>-Instanz in <code>b</code> um 1 verringert wird.</p>
<p>Da <code>a</code> jedoch immer noch auf die <code>Rc&lt;List&gt;</code> verweist, die sich in <code>b</code> befand,
hat <code>Rc&lt;List&gt;</code> einen Zählerwert von 1 anstelle von 0, sodass der Speicher, den
<code>Rc&lt;List&gt;</code> auf dem Haldenspeicher (heap) hat, nicht aufgeräumt wird. Der
Speicher wird bei einem Zählerwert von 1 einfach bestehen bleiben, für immer.
Zur Veranschaulichung dieses Referenzzyklus haben wir in Abbildung 15-4 ein
Diagramm erstellt.</p>
<img alt="Referenzzyklus von Listen" src="img/trpl15-04.svg" class="center" style="width: 30%;" />
<p><span class="caption">Abbildung 15-4: Ein Referenzzyklus der Listen <code>a</code> und <code>b</code>,
die aufeinander zeigen</span></p>
<p>Wenn man das letzte <code>println!</code> auskommentiert und das Programm ausführt,
versucht Rust, diesen Zyklus mit <code>a</code> auszugeben, wobei <code>b</code> auf <code>a</code> zeigt, und so
weiter, bis der Stapelspeicher (stack) überläuft.</p>
<p>In diesem Fall endet das Programm direkt nach dem Erstellen des Referenzzyklus.
Die Folgen dieses Zyklus sind nicht sehr schlimm. Wenn jedoch ein komplexeres
Programm viel Speicher in einem Zyklus allokierte und diesen lange Zeit
behielte, würde das Programm mehr Speicher als erforderlich verbrauchen und
das System möglicherweise überlasten, sodass ihm der verfügbare Speicher
ausgeht.</p>
<p>Das Erstellen von Referenzzyklen ist nicht einfach, aber auch nicht unmöglich.
Wenn man <code>RefCell&lt;T&gt;</code>-Werte hat, die <code>Rc&lt;T&gt;</code>-Werte oder ähnliche verschachtelte
Typkombinationen mit innerer Veränderlichkeit und Referenzzählung enthalten,
muss man sicherstellen, dass man keine Zyklen erstellt. Man kann sich nicht
darauf verlassen, dass Rust sie feststellen kann. Das Erstellen eines
Referenzzyklus wäre ein logischer Fehler in deinem Programm, den du mithilfe
automatisierter Tests, Codeüberprüfungen und anderer Methoden zur
Softwareentwicklung minimieren solltest.</p>
<p>Eine andere Lösung zur Vermeidung von Referenzzyklen besteht darin, deine
Datenstrukturen so zu reorganisieren, dass einige Referenzen die
Eigentümerschaft (ownership) erhalten und andere nicht. Infolgedessen können
Zyklen bestehen, die aus Beziehungen mit und ohne Eigentümerschaft bestehen,
und nur die Beziehungen mit Eigentümerschaft beeinflussen, ob ein
Wert gelöscht wird oder nicht. In Codeblock 15-25 möchten wir immer, dass
<code>Cons</code>-Varianten ihre Liste besitzen, sodass eine Neuorganisation der
Datenstruktur nicht möglich ist. Schauen wir uns ein Beispiel an, in dem
Diagramme aus übergeordneten und untergeordneten Knoten verwendet werden, um
festzustellen, wann Beziehungen ohne Eigentümerschaft ein geeigneter Weg sind,
um Referenzzyklen zu verhindern.</p>
<h3><a class="header" href="#verhindern-von-referenzzyklen-umwandeln-von-rct-in-weakt" id="verhindern-von-referenzzyklen-umwandeln-von-rct-in-weakt">Verhindern von Referenzzyklen: Umwandeln von <code>Rc&lt;T&gt;</code> in <code>Weak&lt;T&gt;</code></a></h3>
<p>Bisher haben wir gezeigt, dass das Aufrufen von <code>Rc::clone</code> den <code>strong_count</code>
einer <code>Rc&lt;T&gt;</code>-Instanz erhöht und eine <code>Rc&lt;T&gt;</code>-Instanz nur dann aufgeräumt wird,
wenn ihr <code>strong_count</code> 0 ist. Man kann auch eine <em>schwache Referenz</em> (weak
reference) auf den Wert innerhalb einer <code>Rc&lt;T&gt;</code>-Instanz erstellen, indem man
<code>Rc::downgrade</code> aufruft und eine Referenz auf den <code>Rc&lt;T&gt;</code> übergibt. Wenn man
<code>Rc::downgrade</code> aufruft, erhält man einen intelligenten Zeiger vom Typ
<code>Weak&lt;T&gt;</code>. Anstatt den <code>strong_count</code> in der <code>Rc&lt;T&gt;</code>-Instanz um 1 zu erhöhen,
erhöht der Aufruf von <code>Rc::downgrade</code> den <code>weak_count</code> um 1. Der Typ <code>Rc&lt;T&gt;</code>
verwendet <code>weak_count</code>, um den Überblick zu behalten wie viele
<code>Weak&lt;T&gt;</code>-Referenzen existieren, ähnlich wie bei <code>strong_count</code>. Der
Unterschied besteht darin, dass <code>weak_count</code> nicht 0 sein muss, damit die
<code>Rc&lt;T&gt;</code>-Instanz aufgeräumt wird.</p>
<p>Mit starken Referenzen kann man die Eigentümerschaft einer <code>Rc&lt;T&gt;</code>-Instanz
teilen, schwache Referenzen drücken hingegen keine Eigentümerschafts-Beziehung
aus. Sie verursachen keinen Referenzzyklus, da jeder Zyklus mit schwachen
Referenzen unterbrochen wird, sobald die starke Referenzanzahl der beteiligten
Werte 0 beträgt.</p>
<p>Da der Wert, auf den <code>Weak&lt;T&gt;</code> referenziert, möglicherweise aufgeräumt wurde, musst
du sicherstellen, dass der Wert noch vorhanden ist, um etwas mit dem Wert zu
tun, auf dem ein <code>Weak&lt;T&gt;</code> zeigt. Ruft man dazu die Methode <code>upgrade</code> für eine
<code>Weak&lt;T&gt;</code>-Instanz auf, die eine <code>Option&lt;Rc&lt;T&gt;&gt;</code>zurückgibt, erhält man ein <code>Some</code>
als Ergebnis, wenn der Wert <code>Rc&lt;T&gt;</code> noch nicht aufgeräumt wurde, und das Ergebnis
<code>None</code>, wenn der <code>Rc&lt;T&gt;</code>-Wert gelöscht wurde. Da <code>upgrade</code> eine
<code>Option&lt;Rc&lt;T&gt;&gt;</code> zurückgibt, stellt Rust sicher, dass der Fall <code>Some</code> und der
Fall <code>None</code> behandelt werden und es keine ungültigen Zeiger gibt.</p>
<p>Anstatt eine Liste zu verwenden, deren Elemente nur das nächste Element kennen,
erstellen wir eine Baumstruktur, deren Elemente die Kind-Elemente <em>und</em> die
Eltern-Elemente kennen.</p>
<h4><a class="header" href="#erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten" id="erstellen-einer-baumdatenstruktur-ein-knoten-mit-kind-knoten">Erstellen einer Baumdatenstruktur: Ein Knoten mit Kind-Knoten</a></h4>
<p>Zunächst erstellen wir eine Baumstruktur mit Knoten (nodes), die ihre
Kind-Knoten kennen. Wir erstellen eine Struktur mit dem
Namen <code>Node</code>, die ihren eigenen <code>i32</code>-Wert sowie Referenzen auf die
Kind-<code>Node</code>-Werte enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Wir möchten, dass ein <code>Node</code> seine Kind-Elemente besitzt, und wir möchten diese
Eigentümerschaft mit Variablen teilen, damit wir direkt auf jeden <code>Node</code> in
der Baumstruktur zugreifen können. Zu diesem Zweck definieren wir die
<code>Vec&lt;T&gt;</code>-Elemente als Werte vom Typ <code>Rc&lt;Node&gt;</code>. Wir möchten auch ändern, welche
Knoten Kind-Knoten eines anderen Knotens sind, sodass wir einen <code>RefCell&lt;T&gt;</code> in
<code>children</code> um den <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> haben.</p>
<p>Als Nächstes verwenden wir unsere Strukturdefinition und erstellen eine
<code>Node</code>-Instanz mit dem Namen <code>leaf</code> und dem Wert 3 und ohne Kind-Elemente,
sowie eine weitere Instanz mit dem Namen <code>branch</code> und dem Wert 5 und <code>leaf</code> als
Kind-Element, wie in Codeblock 15-27 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-27: Erstellen eines <code>leaf</code>-Knotens ohne
Kind-Element und eines <code>branch</code>-Knotens mit <code>leaf</code> als Kind-Element</span></p>
<p>Wir klonen den <code>Rc&lt;Node&gt;</code> in <code>leaf</code> und speichern ihn in <code>branch</code>, was bedeutet,
dass der <code>Node</code> in <code>leaf</code> jetzt zwei Eigentümer hat: <code>leaf</code> und <code>branch</code>. Wir
können über <code>branch.children</code> von <code>branch</code> zu <code>leaf</code> gelangen, aber es gibt
keine Möglichkeit, von <code>leaf</code> zu <code>branch</code> zu gelangen. Der Grund dafür ist, dass
<code>leaf</code> keine Referenz zu <code>branch</code> hat und daher nicht weiß, dass diese in
Beziehung stehen. Wir möchten, dass <code>leaf</code> weiß, dass <code>branch</code> ein
übergeordnetes Element ist. Das machen wir als Nächstes.</p>
<h4><a class="header" href="#hinzufügen-einer-referenz-vom-kind--zum-eltern-element" id="hinzufügen-einer-referenz-vom-kind--zum-eltern-element">Hinzufügen einer Referenz vom Kind- zum Eltern-Element</a></h4>
<p>Um dem Kind-Knoten seinen Eltern-Knoten bewusst zu
machen, müssen wir unserer Strukturdefinition <code>Node</code> ein <code>parent</code>-Feld
hinzufügen. Das Problem besteht darin, zu entscheiden, welcher Typ <code>parent</code> sein
soll. Wir wissen, dass es keinen <code>Rc&lt;T&gt;</code> enthalten kann, da dies einen
Referenzzyklus erzeugen würde, bei dem <code>leaf.parent</code> auf <code>branch</code> und
<code>branch.children</code> auf <code>leaf</code> zeigt, was dazu führen würde das die 
<code>strong_count</code>-Werte niemals 0 sein würden.</p>
<p>Wenn man die Beziehungen auf andere Weise betrachtet, sollte ein Eltern-Knoten
die Eigentümerschaft seiner Kind-Knoten besitzen: Wenn ein Eltern-Knoten
aufgeräumt wird, sollten auch seine Kind-Knoten aufgeräumt werden. Ein
Kind-Knoten sollte jedoch keine Eigentümerschaft seines Eltern-Elementes haben:
Wenn wir einen Kind-Knoten aufräumen, sollte das Eltern-Element weiterhin
existieren. Dies ist ein Fall für schwache Referenzen!</p>
<p>Anstelle von <code>Rc&lt;T&gt;</code> wird <code>parent</code> den Typ <code>Weak&lt;T&gt;</code> verwenden, im Speziellen
einen <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Nun sieht unsere <code>Node</code>-Strukturdefinition
folgendermaßen aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<p>Ein Knoten kann auf seinen Eltern-Knoten referenzieren, besitzt ihn jedoch
nicht. In Codeblock 15-28 aktualisieren wir <code>main</code>, um diese neue Definition
zu verwenden, damit der <code>leaf</code>-Knoten auf seinen Eltern-Knoten <code>branch</code>
referenzieren kann:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-28: Ein <code>leaf</code>-Knoten mit einer schwachen
Referenz auf seinen Eltern-Knoten <code>branch</code></span></p>
<p>Das Erstellen des <code>leaf</code>-Knotens ähnelt dem Erstellen des <code>leaf</code>-Knotens in
Codeblock 15-27 mit Ausnahme des Feldes <code>parent</code>: <code>leaf</code> beginnt ohne
Eltern-Knoten, daher erstellen wir eine neue leere
<code>Weak&lt;Node&gt;</code>-Referenz-Instanz.</p>
<p>Wenn wir zu diesem Zeitpunkt versuchen, mit der Methode <code>upgrade</code> eine
Referenz auf das Eltern-Element von <code>leaf</code> zu bekommen, erhalten wir den
Wert <code>None</code>. Wir sehen dies in der Ausgabe der ersten <code>println!</code>-Anweisung:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Wenn wir den <code>branch</code>-Knoten erstellen, hat er auch eine neue <code>Weak&lt;Node&gt;</code>-Referenz
im Feld <code>parent</code>, da <code>branch</code> keinen Eltern-Knoten hat. Wir haben
noch immer <code>leaf</code> als Kind-Element von <code>branch</code>. Sobald
wir die <code>Node</code>-Instanz in <code>branch</code> haben, können wir <code>leaf</code> ändern, um ihm eine
<code>Weak&lt;Node&gt;</code>-Referenz auf sein Eltern-Element zu geben. Wir verwenden
die <code>bor_mut</code>-Methode für <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> im <code>parent</code>-Feld von <code>leaf</code> und
verwenden dann die Funktion <code>Rc::downgrade</code>, um eine <code>Weak&lt;Node&gt;</code>-Referenz auf
<code>branch</code> aus dem <code>Rc&lt;Node&gt;</code> in <code>branch</code> zu erzeugen.</p>
<p>Wenn wir das Eltern-Element von <code>leaf</code> erneut ausgeben, erhalten wir
diesmal eine <code>Some</code>-Variante mit <code>branch</code>: Jetzt kann <code>leaf</code> auf das
Eltern-Element zugreifen! Wenn wir <code>leaf</code> ausgeben, vermeiden wir auch
den Zyklus, der schließlich zu einem Stapelspeicherüberlauf führte, wie wir ihn
in Codeblock 15-26 hatten. Die <code>Weak&lt;Node&gt;</code>-Referenzen werden als <code>(Weak)</code>
ausgegeben:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Das Fehlen einer unendlichen Ausgabe bedeutet, dass dieser Programmcode keinen
Referenzzyklus erzeugt hat. Wir können dies auch anhand der Werte erkennen, die
wir durch den Aufruf von <code>Rc::strong_count</code> und <code>Rc::weak_count</code> erhalten.</p>
<h4><a class="header" href="#visualisieren-von-Änderungen-an-strong_count-und-weak_count" id="visualisieren-von-Änderungen-an-strong_count-und-weak_count">Visualisieren von Änderungen an <code>strong_count</code> und <code>weak_count</code></a></h4>
<p>Schauen wir uns an, wie sich die Werte für <code>strong_count</code> und <code>weak_count</code> der
<code>Rc&lt;Node&gt;</code>-Instanzen ändern, indem ein neuer innerer Gültigkeitsbereich (scope)
erstellt und die Erstellung von <code>branch</code> in diesen Bereich verschoben wird. Auf
diese Weise können wir sehen, was passiert, wenn <code>branch</code> erstellt und dann
aufgeräumt wird, wenn es den Gültigkeitsbereich verlässt. Die Änderungen
sind in Codeblock 15-29 aufgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Codeblock 15-29: Erstellen von <code>branch</code> in einem inneren
Gültigkeitsbereich und Prüfen der starken und schwachen Referenzzähler</span></p>
<p>Nachdem <code>leaf</code> erstellt wurde, hat <code>Rc&lt;Node&gt;</code> einen <code>strong_count</code> von 1 und
einen <code>weak_count</code> von 0. Im inneren Gültigkeitsbereich erstellen wir <code>branch</code> und ordnen
ihm <code>leaf</code> zu. Zum Zeitpunkt des Ausgebens der Zähler, hat der <code>Rc&lt;Node&gt;</code> in
<code>branch</code> einen <code>strong_count</code> von 1 und einen <code>weak_count</code> von 1 (da <code>leaf.parent</code>
mit einen <code>Weak&lt;Node&gt;</code> auf <code>branch</code> zeigt). Wenn wir den Zähler in <code>leaf</code>
ausgeben, werden wir sehen, dass er einen <code>strong_count</code> von 2 hat, da <code>branch</code>
jetzt einen Klon des <code>Rc&lt;Node&gt;</code> von <code>leaf</code> in <code>branch.children</code> gespeichert hat,
aber immer noch einen <code>weak_count</code>von 0 hat.</p>
<p>Wenn der innere Gültigkeitsbereich endet, verlässt <code>branch</code> den
Gültigkeitsbereich und der <code>strong_count</code> von <code>Rc&lt;Node&gt;</code> sinkt auf 0, sodass
sein <code>Node</code> aufgeräumt wird. Der <code>weak_count</code> von 1 aus <code>leaf_parent</code> hat keinen
Einfluss darauf, ob <code>Node</code> aufgeräumt wird oder nicht, sodass wir kein
Speicherleck bekommen!</p>
<p>Wenn wir nach dem Ende des Gültigkeitsbereichs versuchen, auf das Eltern-Element von
<code>leaf</code> zuzugreifen, erhalten wir erneut <code>None</code>. Am Ende des Programms hat der
<code>Rc&lt;Node&gt;</code> in <code>branch</code> einen <code>strong_count</code> von 1 und einen <code>weak_count</code> von 0, da
die Variable <code>branch</code> jetzt wieder die einzige Referenz auf <code>Rc&lt;Node&gt;</code> ist.</p>
<p>Die gesamte Logik, die die Zähler und das Aufräumen des Wertes verwaltet, ist
in <code>Rc&lt;T&gt;</code> und <code>Weak&lt;T&gt;</code> und deren Implementierung des Merkmals (trait) <code>Drop</code>
integriert. Wenn man angibt, dass die Beziehung von einem Kind- zu seinem
Eltern-Element eine <code>Weak&lt;T&gt;</code>-Referenz in der Definition von <code>Node</code> sein soll,
können Eltern-Knoten auf Kind-Knoten referenzieren und umgekehrt, ohne einen
Referenzzyklus oder Speicherlecks zu erzeugen.</p>
<h2><a class="header" href="#zusammenfassung-14" id="zusammenfassung-14">Zusammenfassung</a></h2>
<p>In diesem Kapitel wurde beschrieben, wie man mithilfe intelligenter Zeiger
andere Garantien und Kompromisse eingehen kann als es standardmäßig mit gewöhnlichen
Referenzen in Rust möglich ist. Der Typ <code>Box&lt;T&gt;</code> hat eine bekannte Größe und
zeigt auf Daten die auf dem Haldenspeicher allokiert sind. Der Typ <code>Rc&lt;T&gt;</code>
verfolgt die Anzahl der Referenzen von Daten auf dem Haldenspeicher, sodass
Daten mehrere Eigentümer haben können. Der Typ <code>RefCell&lt;T&gt;</code> mit
seiner inneren Veränderlichkeit stellt uns einen Typ zur Verfügung, den wir
verwenden können, wenn wir einen unveränderlichen Typ benötigen, aber einen
inneren Wert dieses Typs ändern müssen. Außerdem werden die Ausleihregeln zur
Laufzeit anstatt zur Kompilierzeit durchgesetzt.</p>
<p>Ebenfalls diskutiert wurden die Merkmale <code>Deref</code> und <code>Drop</code>, die einen Großteil
der Funktionalität von intelligenten Zeigern ermöglichen. Wir haben
Referenzzyklen untersucht, die zu Speicherlecks führen können, und wie diese
mithilfe von <code>Weak&lt;T&gt;</code> verhindert werden können.</p>
<p>Wenn dieses Kapitel dein Interesse geweckt hat und du deinen eigenen
intelligenten Zeiger implementieren möchtest, lies <a href="https://doc.rust-lang.org/nomicon/index.html">„The
Rustonomicon“</a>, um weitere nützliche Informationen zu erhalten.</p>
<p>Als Nächstes werden wir über Nebenläufigkeit (concurrency) in Rust sprechen.
Wir werden sogar einige neue intelligente Zeiger kennenlernen.</p>
<h1><a class="header" href="#furchtlose-nebenläufigkeit" id="furchtlose-nebenläufigkeit">Furchtlose Nebenläufigkeit</a></h1>
<p>Der sichere und effiziente Umgang mit nebenläufiger Programmierung ist ein
weiteres wichtiges Ziel von Rust. Die <em>nebenläufige Programmierung</em> (concurrent
programming), bei der verschiedene Teile eines Programms unabhängig voneinander
ausgeführt werden, und die <em>parallele Programmierung</em> (parallel programming),
bei der verschiedene Teile eines Programms gleichzeitig ausgeführt werden,
werden immer wichtiger, da immer mehr Computer die Vorteile mehrerer
Prozessoren nutzen. In der Vergangenheit war die Programmierung in diesen
Bereichen schwierig und fehleranfällig: Rust hofft, das ändern zu können.</p>
<p>Ursprünglich dachte das Rust-Team, dass das Gewährleisten von
Speichersicherheit (memory safety) und das Verhindern von
Nebenläufigkeitsproblemen (concurrency problems) zwei separate
Herausforderungen seien, die mit unterschiedlichen Methoden gelöst werden
müssten. Im Laufe der Zeit entdeckte das Team, dass Eigentümerschaft
(ownership) und Typsysteme ein leistungsstarkes Instrumentarium zur Bewältigung
von Speichersicherheits- <em>und</em> Nebenläufigkeitsproblemen sind! Durch das Nutzen
der Eigentümerschaft und Typprüfung werden viele Nebenläufigkeitsfehler zu
Kompilierzeitfehlern in Rust anstatt Laufzeitfehlern. Anstatt dass du viel Zeit
damit verbringen musst, die genauen Umstände zu reproduzieren, unter denen ein
Laufzeit-Nebenläufigkeitsfehler auftritt, wird der fehlerhafte Code nicht
kompilieren und einen Fehler anzeigen, der das Problem erklärt. Dadurch kannst
du deinen Code reparieren, während du daran arbeitest, und nicht möglicherweise
erst, nachdem er in Produktion ausgeliefert wurde. Wir haben diesem Aspekt von
Rust den Spitznamen <em>furchtlose Nebenläufigkeit</em> (fearless concurrency)
gegeben. Die furchtlose Nebenläufigkeit ermöglicht es dir, Code zu schreiben,
der frei von subtilen Fehlern ist und leicht zu refaktorieren ist, ohne neue
Fehler zu erzeugen.</p>
<blockquote>
<p>Anmerkung: Der Einfachheit halber werden wir viele der Probleme als
<em>nebenläufig</em> bezeichnen, anstatt präziser zu sein, indem wir <em>nebenläufig
und/oder gleichzeitig</em> sagen. Wenn es in diesem Buch um Nebenläufigkeit
und/oder Gleichzeitigkeit ginge, wären wir präziser. Bitte ersetze dieses
Kapitel gedanklich durch <em>nebenläufig und/oder gleichzeitig</em>, wenn wir
<em>nebenläufig</em> verwenden.</p>
</blockquote>
<p>Viele Sprachen sind dogmatisch, was die Lösungen betrifft, die sie zur
Behandlung von Nebenläufigkeitsproblemen anbieten. Beispielsweise verfügt
Erlang über elegante Funktionen für die nachrichtenübermittelnde
Nebenläufigkeit (message-passing concurrency), hat aber nur obskure
Möglichkeiten, einen gemeinsamen Status mit mehreren Strängen (threads) zu
teilen. Die Unterstützung nur einer Teilmenge möglicher Lösungen ist eine
vernünftige Strategie für Hochsprachen, da eine Hochsprache Vorteile
verspricht, wenn sie eine gewisse Kontrolle aufgibt, um Abstraktionen zu
erhalten. Es wird jedoch erwartet, dass Sprachen auf niedrigeren Ebenen in
jeder Situation die Lösung mit der besten Performanz bieten und weniger
Abstraktionen der Hardware haben. Daher bietet Rust eine Vielzahl von
Werkzeugen zur Modellierung von Problemen in der Art und Weise, die für deine
Situation und deine Anforderungen geeignet ist.</p>
<p>Hier sind die Themen, die wir in diesem Kapitel behandeln werden:</p>
<ul>
<li>Wie man Stränge erstellt, um mehrere Code-Stücke gleichzeitig auszuführen.</li>
<li><em>Nachrichtenübermittelnde</em> Nebenläufigkeit, bei der Kanäle Nachrichten
zwischen Strängen senden.</li>
<li>Nebenläufigkeit mit <em>gemeinsamem Zustand</em> (shared-state), bei der mehrere
Stränge Zugriff auf bestimmte Daten haben.</li>
<li>Die Merkmale (traits) <code>Sync</code> und <code>Send</code>, die Rusts Nebenläufigkeitsgarantien
sowohl auf benutzerdefinierte Typen als auch auf von der Standardbibliothek
bereitgestellte Typen erweitern.</li>
</ul>
<h2><a class="header" href="#mit-strängen-threads-programmcode-gleichzeitig-ausführen" id="mit-strängen-threads-programmcode-gleichzeitig-ausführen">Mit Strängen (threads) Programmcode gleichzeitig ausführen</a></h2>
<p>In den meisten aktuellen Betriebssystemen wird der Code eines ausgeführten
Programms in einem <em>Prozess</em> ausgeführt und das Betriebssystem verwaltet
mehrere Prozesse gleichzeitig. Innerhalb deines Programms kannst du auch
unabhängige Teile haben, die gleichzeitig laufen. Die Funktionalitäten, die
diese unabhängigen Teile ausführen, werden <em>Stränge</em> (threads) genannt.</p>
<p>Das Aufteilen der Berechnung in deinem Programm in mehrere Stränge kann die
Performanz verbessern, da das Programm mehrere Aufgaben gleichzeitig ausführt,
aber es erhöht auch die Komplexität. Da Stränge gleichzeitig laufen können,
gibt es keine inhärente Garantie für die Reihenfolge, in der Teile deines Codes
in verschiedenen Strängen ausgeführt werden. Dies kann zu Problemen führen
wie:</p>
<ul>
<li>Wettlaufsituationen (race conditions), bei denen Stränge auf Daten oder
Ressourcen in einer inkonsistenten Reihenfolge zugreifen.</li>
<li>Deadlocks, bei denen zwei Stränge darauf warten, dass der jeweils andere
Strang eine Ressource freigibt, sodass beide Stränge nicht fortgesetzt werden
können.</li>
<li>Fehler, die nur in bestimmten Situationen auftreten und schwer zu
reproduzieren und zu beheben sind.</li>
</ul>
<p>Rust versucht, die negativen Auswirkungen bei der Verwendung von Strängen zu
mildern, aber die Programmierung in einem mehrsträngigen Kontext erfordert
immer noch sorgfältige Überlegungen und benötigt eine andere Code-Struktur als
bei Programmen, die in einem einzigen Strang laufen.</p>
<p>Programmiersprachen implementieren Stränge auf verschiedene Weise. Viele
Betriebssysteme bieten eine API zum Erstellen neuer Stränge. Dieses Modell, bei
dem eine Sprache die API des Betriebssystems aufruft, um Stränge zu erstellen,
wird manchmal <em>1:1</em> genannt, das bedeutet einen Betriebssystem-Strang pro
Strang in der Sprache.</p>
<p>Viele Programmiersprachen bringen ihre eigene spezielle Implementierung von
Strängen mit. Von Programmiersprachen bereitgestellte Stränge sind als <em>grüne</em>
Stränge (green threads) bekannt und Sprachen, die diese grünen Stränge
verwenden, führen sie im Kontext einer verschiedenen Zahl von
Betriebssystem-Strängen aus. Aus diesem Grund wird das Modell mit grünen
Strängen als <em>M:N</em>-Modell bezeichnet: Es gibt <code>M</code> grüne Stränge auf <code>N</code>
Betriebssystem-Strängen, wobei <code>M</code> und <code>N</code> nicht notwendigerweise die gleiche
Zahl sind.</p>
<p>Jedes Modell hat seine eigenen Vorteile und Kompromisse und der wichtigste
Kompromiss für Rust ist die Laufzeitunterstützung. <em>Laufzeit</em> (runtime) ist ein
verwirrender Begriff und kann in verschiedenen Kontexten unterschiedliche
Bedeutungen haben.</p>
<p>In diesem Zusammenhang meinen wir mit <em>Laufzeit</em> Code, der von der Sprache in
jeder Binärdatei enthalten ist. Dieser Code kann groß oder klein sein, abhängig
von der Sprache, aber jede Nicht-Assembler-Sprache wird eine gewisse Menge an
Laufzeit-Code haben. Aus diesem Grund meinen Leute umgangssprachlich, wenn sie
sagen, eine Sprache habe „keine Laufzeit“, dass sie oft eine „kleine Laufzeit“
hat. Kleinere Laufzeiten haben weniger Funktionen, haben aber den Vorteil, dass
sie zu kleineren Binärdateien führen, die es leichter machen, die Sprache mit
anderen Sprachen in mehr Kontexten zu kombinieren. Obwohl viele Sprachen damit
einverstanden sind, die Laufzeitgröße im Tausch gegen mehr Funktionen zu
erhöhen, kann Rust fast keine Laufzeit haben und kann keine Kompromisse
eingehen, wenn es darum geht, C zur Aufrechterhaltung der Performanz
aufzurufen.</p>
<p>Das M:N-Modell bei grünen Strängen erfordert eine größere Sprachlaufzeit zur
Verwaltung von Strängen. Daher bietet die Rust-Standardbibliothek nur eine
Implementierung von 1:1-Strängen. Da Rust solch eine Sprache auf niedriger
Ebene ist, gibt es Kisten (crates), die M:N-Stränge implementieren, wenn du den
Mehraufwand (overhead) lieber gegen Aspekte wie mehr Kontrolle darüber, welche
Stränge wann laufen, und geringere Kosten für den Kontextwechsel (context
switching) eintauschen möchtest.</p>
<p>Nachdem wir nun Stränge in Rust definiert haben, wollen wir untersuchen, wie
die Strang-bezogene API, die von der Standardbibliothek bereitgestellt wird,
verwendet werden kann.</p>
<h3><a class="header" href="#erstellen-eines-neuen-strangs-mit-spawn" id="erstellen-eines-neuen-strangs-mit-spawn">Erstellen eines neuen Strangs mit <code>spawn</code></a></h3>
<p>Um einen neuen Strang zu erstellen, rufen wir die Funktion <code>thread::spawn</code> auf
und übergeben ihr einen Funktionsabschluss (closure) (wir haben in Kapitel 13
über Funktionsabschlüsse gesprochen), der den Code enthält, den wir im neuen
Strang ausführen wollen. Das Beispiel in Codeblock 16-1 gibt etwas Text im
Hauptstrang und anderen Text im neuen Strang aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-1: Erstellen eines neuen Strangs, um eine
Sache auszugeben, während der Hauptstrang etwas anderes ausgibt</span></p>
<p>Beachte, dass mit dieser Funktion der neue Strang beendet wird, wenn der
Hauptstrang endet, unabhängig davon, ob er zu Ende gelaufen ist oder nicht. Die
Ausgabe dieses Programms kann jedes Mal ein wenig anders sein, aber sie wird
ähnlich wie die folgende aussehen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
</code></pre>
<p>Aufrufe von <code>thread::sleep</code> zwingen einen Strang, seine Ausführung für eine
kurze Zeit anzuhalten, sodass ein anderer Strang laufen kann. Die Stränge
werden sich wahrscheinlich abwechseln, aber das ist nicht garantiert: Es hängt
davon ab, wie dein Betriebssystem die Stränge organisiert (schedules). In
diesem Lauf wurde der Hauptstrang zuerst ausgegeben, obwohl die
Ausgabeanweisung aus dem erzeugten Strang zuerst im Code erscheint. Und obwohl
wir dem erzeugten Strang gesagt haben, er solle ausgeben, bis <code>i</code> 9 ist, kam er
nur bis 5, bis sich der Hauptstrang beendet hat.</p>
<p>Wenn du diesen Code ausführst und nur Ausgaben aus dem Hauptstrang siehst oder
keine Überschneidungen feststellst, versuche, die Zahlen in den Bereichen zu
erhöhen, um dem Betriebssystem mehr Gelegenheit zu geben, zwischen den Strängen
zu wechseln.</p>
<h3><a class="header" href="#warten-auf-das-ende-aller-stränge-mit-join" id="warten-auf-das-ende-aller-stränge-mit-join">Warten auf das Ende aller Stränge mit <code>join</code></a></h3>
<p>Der Code in Codeblock 16-1 beendet nicht nur den erzeugten Strang meist
vorzeitig aufgrund des Endes des Hauptstrangs, sondern kann auch nicht
garantieren, dass der erzeugte Strang überhaupt zum Laufen kommt. Der Grund
dafür ist, dass es keine Garantie für die Reihenfolge gibt, in der die Stränge
laufen!</p>
<p>Wir können das Problem, dass der erzeugte Strang nicht oder nicht vollständig
ausgeführt wird, beheben, indem wir den Rückgabewert von <code>thread::spawn</code> in
einer Variablen speichern. Der Rückgabetyp von <code>thread::spawn</code> ist
<code>JoinHandle</code>. Ein <code>JoinHandle</code> ist ein aneigenbarer (owned) Wert, der, wenn wir
die Methode <code>join</code> darauf aufrufen, darauf wartet, bis sich sein Strang
beendet. Codeblock 16-2 zeigt, wie der <code>JoinHandle</code> des Strangs, den wir in
Codeblock 16-1 erstellt haben, verwendet und <code>join</code> aufgerufen wird, um
sicherzustellen, dass der erzeugte Strang beendet wird, bevor <code>main</code> endet:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-2: Speichern eines <code>JoinHandle</code> von
<code>thread::spawn</code>, um zu garantieren, dass der Strang bis zum Ende ausgeführt
wird</span></p>
<p>Aufrufen von <code>join</code> auf <code>JoinHandle</code> blockiert den gerade laufenden Strang, bis
der durch <code>JoinHandle</code> repräsentierte Strang beendet ist. <em>Blockieren</em> eines
Strangs bedeutet, dass der Strang daran gehindert wird, Arbeit auszuführen oder
sich zu beenden. Da wir den Aufruf von <code>join</code> nach der <code>for</code>-Schleife im
Hauptstrang gesetzt haben, sollte das Ausführen von Codeblock 16-2 eine
ähnliche Ausgabe erzeugen:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem Hauptstrang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
</code></pre>
<p>Die beiden Stränge setzen abwechselnd fort, aber der Hauptstrang wartet wegen
des Aufrufs von <code>handle.join()</code> und endet nicht, bis der erzeugte Strang
beendet ist.</p>
<p>Aber lass uns sehen, was passiert, wenn wir stattdessen <code>handle.join()</code> vor die
<code>for</code>-Schleife in <code>main</code> schieben, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hallo Zahl {} aus dem erzeugten Strang!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;Hallo Zahl {} aus dem Hauptstrang!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>Der Hauptstrang wartet auf das Ende des erzeugten Strangs und führt dann seine
<code>for</code>-Schleife aus, sodass die Ausgabe nicht mehr überlappend ist, wie hier
gezeigt:</p>
<pre><code class="language-text">Hallo Zahl 1 aus dem erzeugten Strang!
Hallo Zahl 2 aus dem erzeugten Strang!
Hallo Zahl 3 aus dem erzeugten Strang!
Hallo Zahl 4 aus dem erzeugten Strang!
Hallo Zahl 5 aus dem erzeugten Strang!
Hallo Zahl 6 aus dem erzeugten Strang!
Hallo Zahl 7 aus dem erzeugten Strang!
Hallo Zahl 8 aus dem erzeugten Strang!
Hallo Zahl 9 aus dem erzeugten Strang!
Hallo Zahl 1 aus dem Hauptstrang!
Hallo Zahl 2 aus dem Hauptstrang!
Hallo Zahl 3 aus dem Hauptstrang!
Hallo Zahl 4 aus dem Hauptstrang!
</code></pre>
<p>Kleine Details, z.B. wo <code>join</code> aufgerufen wird, können beeinflussen, ob deine
Stränge zur gleichen Zeit laufen oder nicht.</p>
<h3><a class="header" href="#verwenden-von-move-funktionsabschlüssen-mit-strängen" id="verwenden-von-move-funktionsabschlüssen-mit-strängen">Verwenden von <code>move</code>-Funktionsabschlüssen mit Strängen</a></h3>
<p>Der <code>move</code>-Funktionsabschluss wird oft zusammen mit <code>thread::spawn</code> verwendet,
weil es dir erlaubt, Daten von einem Strang in einem anderen Strang zu
verwenden.</p>
<p>In Kapitel 13 haben wir erwähnt, dass wir das Schlüsselwort <code>move</code> vor der
Parameterliste eines Funktionsabschlusses verwenden können, um den
Funktionsabschluss dazu zu zwingen, die Eigentümerschaft der Werte zu
übernehmen, die er aus der Umgebung verwendet. Diese Technik ist besonders
nützlich, wenn neue Stränge erstellt werden, um die Eigentümerschaft an Werten
von einem Strang auf einen anderen zu übertragen.</p>
<p>Beachte in Codeblock 16-1, dass der Funktionsabschluss, den wir an
<code>thread::spawn</code> übergeben, keine Argumente erfordert: Wir verwenden keine Daten
aus dem Hauptstrang im Code des erzeugten Strangs. Um Daten aus dem Hauptstrang
im erzeugten Strang zu verwenden, muss der Funktionsabschluss des erzeugten
Strangs die benötigten Werte erfassen. Codeblock 16-3 zeigt einen Versuch,
einen Vektor im Hauptstrang zu erstellen und ihn im erzeugten Strang zu
verwenden. Dies wird jedoch noch nicht funktionieren, wie du gleich sehen
wirst.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-3: Versuch, einen durch den Hauptstrang
erzeugten Vektor in einem anderen Strang zu verwenden</span></p>
<p>Der Funktionsabschluss verwendet <code>v</code>, sodass er <code>v</code> erfasst und zum Teil der
Umgebung des Funktionsabschlusses macht. Da <code>thread::spawn</code> diesen
Funktionsabschluss in einem neuen Strang ausführt, sollten wir in der Lage
sein, auf <code>v</code> innerhalb dieses neuen Strangs zuzugreifen. Aber wenn wir dieses
Beispiel kompilieren, erhalten wir den folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
  |                                               - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust <em>folgert</em>, wie man <code>v</code> erfasst, und weil <code>println!</code> nur eine Referenz auf
<code>v</code> benötigt, versucht der Funktionsabschluss, <code>v</code> auszuleihen. Es gibt jedoch
ein Problem: Rust kann nicht sagen, wie lange der erzeugte Strang laufen wird,
sodass es nicht weiß, ob die Referenz auf <code>v</code> immer gültig sein wird.</p>
<p>Codeblock 16-4 zeigt ein Szenario, das eine Referenz auf <code>v</code> hat, die eher
nicht gültig ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    drop(v); // Oh nein!

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-4: Ein Strang mit einem Funktionsabschluss,
der versucht, eine Referenz auf <code>v</code> vom Hauptstrang zu erfassen, der <code>v</code>
aufräumt</span></p>
<p>Wenn wir diesen Code ausführen dürften, bestünde die Möglichkeit, dass der
erzeugte Strang sofort in den Hintergrund gestellt wird, ohne überhaupt zu
laufen. Der erzeugte Strang hat eine Referenz auf <code>v</code> im Inneren, aber der
Hauptstrang räumt <code>v</code> sofort auf, indem er die Funktion <code>drop</code> benutzt, die wir
in Kapitel 15 besprochen haben. Wenn der erzeugte Strang dann mit der
Ausführung beginnt, ist <code>v</code> nicht mehr gültig, sodass eine Referenz darauf
ebenfalls ungültig ist. Oh nein!</p>
<p>Um den Kompilierfehler in Codeblock 16-3 zu beheben, können wir die Hinweise
der Fehlermeldung verwenden:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Indem wir vor dem Funktionsabschluss das Schlüsselwort <code>move</code> hinzufügen,
zwingen wir den Funktionsabschluss dazu, die Eigentümerschaft der Werte zu
übernehmen, die er benutzt, anstatt zuzulassen, dass Rust daraus ableitet, dass
er sich die Werte ausleihen sollte. Die in Codeblock 16-5 gezeigte Änderung an
Codeblock 16-3 wird wie von uns beabsichtigt kompilieren und ausgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-5: Durch Verwenden des Schlüsselwortes
<code>move</code> zwigen wir den Funktionsabschluss, die Eigentümerschaft der von ihm
verwendeten Werte zu übernehmen</span></p>
<p>Was würde mit dem Code in Codeblock 16-4 geschehen, bei dem der Hauptstrang
<code>drop</code> aufruft, wenn wir einen <code>move</code>-Funktionsabschluss verwenden? Würde
<code>move</code> den Fall lösen? Leider nein; wir würden einen anderen Fehler erhalten,
weil das, was in Codeblock 16-4 versucht wird, aus einem anderen Grund nicht
erlaubt ist. Wenn wir dem Funktionsabschluss <code>move</code> hinzufügen würden, würden
wir <code>v</code> in die Umgebung des Funktionsabschlusses verschieben, und wir könnten im
Hauptstrang nicht mehr <code>drop</code> darauf aufrufen. Wir würden stattdessen diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Hier ist ein Vektor: {:?}&quot;, v);
   |                                               - variable moved due to use in closure
...
10 |     drop(v); // Oh nein!
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Eigentumsregeln von Rust haben uns wieder einmal gerettet! Wir haben einen
Fehler im Code in Codeblock 16-3 erhalten, weil Rust konservativ war und nur
<code>v</code> für den Strang auslieh, was bedeutete, dass der Hauptstrang theoretisch die
Referenz des erzeugte Strangs ungültig machen konnte. Indem wir Rust anweisen,
die Eigentümerschaft von <code>v</code> in den erzeugte Strang zu verlagern, garantieren
wir Rust, dass der Hauptstrang <code>v</code> nicht mehr benutzen wird. Wenn wir Codeblock
16-4 auf die gleiche Weise ändern, verletzen wir die Eigentumsregeln, wenn wir
versuchen, <code>v</code> im Hauptstrang zu benutzen. Das Schlüsselwort <code>move</code> setzt Rusts
konservative Standardausleihe außer Kraft; es lässt uns nicht gegen die
Eigentumsregeln verstoßen.</p>
<p>Mit einem grundlegenden Verständnis von Strängen und der Strang-API wollen wir
uns ansehen, was wir mit Strängen noch machen können.</p>
<h2><a class="header" href="#nachrichtenaustausch-zwischen-strängen-threads" id="nachrichtenaustausch-zwischen-strängen-threads">Nachrichtenaustausch zwischen Strängen (threads)</a></h2>
<p>Ein immer beliebter werdender Ansatz zur Gewährleistung einer sicheren
Nebenläufigkeit (safe concurrency) ist der <em>Nachrichtenaustausch</em> (message
passing), bei dem Stränge oder Akteure kommunizieren, indem sie sich
gegenseitig Nachrichten mit Daten senden. Hier ist die Idee in einem Slogan aus
<a href="https://golang.org/doc/effective_go.html#concurrency">der Go-Sprachdokumentation</a>: „Kommuniziere nicht, indem du
Arbeitsspeicher teilst; teile stattdessen Arbeitsspeicher durch Kommunikation.“</p>
<p>Ein Hauptwerkzeug von Rust zum Erreichen von nachrichtenübermittelnder
Nebenläufigkeit ist der <em>Kanal</em> (channel), ein Programmierkonzept, das in der
Standardbibliothek von Rust implementiert ist. Man kann sich einen Kanal in der
Programmierung wie einen Wasserkanal vorstellen, wie einen Bach oder einen
Fluss. Wenn du etwas wie eine Gummiente oder ein Boot in einen Fluss setzt,
wird sie/es flussabwärts bis zum Ende des Wasserwegs reisen.</p>
<p>Ein Kanal in der Programmierung hat zwei Hälften: Einen Sender und einen
Empfänger. Die Senderhälfte ist die stromaufwärts gelegene Stelle, an der du
Gummienten in den Fluss setzt, und die Empfängerhälfte ist die Stelle, an der
die Gummiente stromabwärts ankommt. Ein Teil deines Codes ruft Methoden auf dem
Sender mit den Daten auf, die du senden möchtest, und ein anderer Teil
überprüft die Empfangsseite auf ankommende Nachrichten. Ein Kanal gilt als
<em>geschlossen</em> (closed), wenn entweder die Sender- oder die Empfängerhälfte
aufgeräumt (dropped) wird.</p>
<p>Hier arbeiten wir uns zu einem Programm hoch, das einen Strang hat, um Werte zu
generieren und sie über einen Kanal zu senden, und einen anderen Strang, der
die Werte empfängt und ausgibt. Wir werden einfache Werte zwischen den Strängen
über einen Kanal senden, um die Funktionalität zu veranschaulichen. Sobald du
mit der Technik vertraut bist, kannst du Kanäle verwenden, um ein Chatsystem zu
implementieren oder ein System, bei dem viele Stränge Teile einer Berechnung
durchführen und die Teile an einen Strang senden, der die Ergebnisse
zusammenfasst.</p>
<p>Erstens werden wir in Codeblock 16-6 einen Kanal erstellen, aber nichts damit
machen. Beachte, dass sich dieser noch nicht kompilieren lässt, weil Rust nicht
sagen kann, welchen Typ von Werten wir über den Kanal senden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-6: Erstellen eines Kanals und Zuweisen der
beiden Hälften zu <code>tx</code> und <code>rx</code></span></p>
<p>Wir erstellen einen neuen Kanal mit der Funktion <code>mpsc::channel</code>; <code>mpsc</code> steht
für <em>mehrfacher Produzent, einzelner Konsument</em> (multiple producer, single
consumer). Kurz gesagt, die Art und Weise, wie die Standardbibliothek von Rust
Kanäle implementiert, bedeutet, dass ein Kanal mehrere <em>sendende</em> Enden haben
kann, die Werte produzieren, aber nur ein <em>empfangendes</em> Ende, das diese Werte
konsumiert. Stell dir vor, mehrere Bäche würden zu einem großen Fluss
zusammenfließen: Alles, was in einem der Bäche hinuntergeschickt wird, landet
am Ende in einem Fluss. Wir fangen zunächst mit einem einzigen Produzenten an,
aber wir fügen mehrere Produzenten hinzu, wenn dieses Beispiel funktioniert.</p>
<p>Die Funktion <code>mpsc::channel</code> gibt ein Tupel zurück, dessen erstes Element die
sendende Seite und dessen zweites Element die empfangende Seite ist. Die
Abkürzungen <code>tx</code> und <code>rx</code> werden traditionell in vielen Feldern für <em>Sender</em>
(transmitter) bzw. <em>Empfänger</em> (receiver) verwendet, daher benennen wir unsere
Variablen als solche, um jedes Ende anzugeben. Wir verwenden eine
<code>let</code>-Anweisung mit einem Muster, das die Tupel destrukturiert; wir werden die
Verwendung von Mustern in <code>let</code>-Anweisungen und die Destrukturierung in Kapitel
18 besprechen. Das Verwenden einer <code>let</code>-Anweisung auf diese Weise ist ein
bequemer Ansatz, um die Teile des Tupels zu extrahieren, die von
<code>mpsc::channel</code> zurückgegeben werden.</p>
<p>Verschieben wir das sendende Ende in einen erzeugten Strang und lassen es eine
Zeichenkette senden, sodass der erzeugte Strang mit dem Hauptstrang
kommuniziert, wie in Codeblock 16-7 gezeigt. Das ist so, als würde man eine
Gummiente flussaufwärts in den Fluss setzen oder eine Chat-Nachricht von einem
Strang zum anderen senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-7: Verschieben von <code>tx</code> in einen erzeugten
Strang und Senden von „hallo“</span></p>
<p>Wieder verwenden wir <code>thread::spawn</code>, um einen neuen Strang zu erstellen, und
dann <code>move</code>, um <code>tx</code> in den Funktionsabschluss zu verschieben, sodass der
erzeugte Strang <code>tx</code> besitzt. Der erzeugte Strang muss das sendende Ende des
Kanals besitzen, um in der Lage zu sein, Nachrichten durch den Kanal zu senden.</p>
<p>Auf der Sendeseite gibt es eine Methode <code>send</code>, die den Wert nimmt, den wir
senden wollen. Die Methode <code>send</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück; wenn also die
empfangende Seite bereits aufgeräumt wurde und es keinen Ort gibt, an den ein
Wert gesendet werden kann, wird die Sendeoperation einen Fehler zurückgeben. In
diesem Beispiel rufen wir <code>unwrap</code> auf, um im Falle eines Fehlers abzustürzen.
Aber in einer echten Anwendung würden wir es richtig handhaben: Kehre zu
Kapitel 9 zurück, um Strategien für eine korrekte Fehlerbehandlung anzusehen.</p>
<p>In Codeblock 16-8 erhalten wir den Wert vom empfangenden Ende des Kanals im
Hauptstrang. Das ist so, als würde man die Gummiente am Ende des Flusses aus
dem Wasser holen oder eine Chat-Nachricht erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Erhalten: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-8: Empfangen des Wertes „hallo“ im
Hauptstrang und Ausgeben des Wertes</span></p>
<p>Das empfangende Ende eines Kanals hat zwei nützliche Methoden: <code>recv</code> und
<code>try_recv</code>. Wir benutzen <code>recv</code>, kurz für <em>empfangen</em> (receive), was die
Ausführung des Hauptstrangs blockiert und wartet, bis ein Wert in den Kanal
geschickt wird. Sobald ein Wert gesendet wurde, wird er von <code>recv</code> in einem
<code>Result&lt;T, E&gt;</code> zurückgegeben. Wenn das Sendeende des Kanals geschlossen wird,
gibt <code>recv</code> einen Fehler zurück, um zu signalisieren, dass keine weiteren Werte
mehr kommen werden.</p>
<p>Die Methode <code>try_recv</code> blockiert nicht, sondern gibt stattdessen sofort ein
<code>Result&lt;T, E&gt;</code> zurück: Einen <code>Ok</code>-Wert, der eine Nachricht enthält, wenn eine
verfügbar ist, und einen <code>Err</code>-Wert, wenn diesmal keine Nachricht vorhanden
ist. Die Verwendung von <code>try_recv</code> ist nützlich, wenn dieser Strang während des
Wartens auf Nachrichten andere Arbeiten zu erledigen hat: Wir könnten eine
Schleife schreiben, die <code>try_recv</code> ab und zu aufruft, eine Nachricht
verarbeitet, wenn eine verfügbar ist, und ansonsten für eine Weile andere
Arbeiten erledigt, bis sie erneut überprüft wird.</p>
<p>Wir haben in diesem Beispiel der Einfachheit halber <code>recv</code> verwendet; wir haben
keine andere Arbeit für den Hauptstrang zu erledigen, außer auf Nachrichten zu
warten, daher ist es angebracht, den Hauptstrang zu blockieren.</p>
<p>Wenn wir den Code in Codeblock 16-8 ausführen, sehen wir den durch den
Hauptstrang ausgegebenen Wert:</p>
<pre><code class="language-text">Erhalten: hallo
</code></pre>
<p>Perfekt!</p>
<h3><a class="header" href="#kanäle-und-eigentümerschaftsübertragung" id="kanäle-und-eigentümerschaftsübertragung">Kanäle und Eigentümerschaftsübertragung</a></h3>
<p>Die Eigentumsregeln spielen beim Nachrichtenversand eine entscheidende Rolle,
da sie dir helfen, sicheren, nebenläufigen Code zu schreiben. Die Vermeidung
von Fehlern bei der nebenläufigen Programmierung ist der Vorteil, wenn du bei
deinen Rust-Programmen an die Eigentümerschaft denkst. Lass uns ein Experiment
machen, um zu zeigen, wie Kanäle und Eigentümerschaft zusammenwirken, um
Probleme zu vermeiden: Wir versuchen, einen <code>val</code>-Wert im erzeugten Strang zu
verwenden, <em>nachdem</em> wir ihn in den Kanal geschickt haben. Versuche, den Code
in Codeblock 16-9 zu kompilieren, um zu sehen, warum dieser Code nicht erlaubt
ist:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hallo&quot;);
        tx.send(val).unwrap();
        println!(&quot;val ist {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Erhalten: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-9: Versuch, <code>val</code> zu benutzen, nachdem wir
es in den Kanal geschickt haben</span></p>
<p>Hier versuchen wir, <code>val</code> auszugeben, nachdem wir es per <code>tx.send</code> in den Kanal
geschickt haben. Dies zuzulassen wäre eine schlechte Idee: Sobald der Wert an
einen anderen Strang gesendet wurde, könnte dieser Strang ihn ändern oder
aufräumen, bevor wir versuchen, den Wert erneut zu verwenden. Möglicherweise
können die Änderungen des anderen Strangs aufgrund inkonsistenter oder nicht
vorhandener Daten zu Fehlern oder unerwarteten Ergebnissen führen. Rust gibt
uns jedoch einen Fehler, wenn wir versuchen, den Code in Codeblock 16-9 zu kompilieren:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hallo&quot;);
   |             --- move occurs because `val` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val ist {}&quot;, val);
   |                                ^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Unser Nebenläufigkeitsfehler hat einen Kompilierzeitfehler verursacht. Die
Funktion <code>send</code> übernimmt die Eigentümerschaft an ihrem Parameter und wenn der
Wert verschoben wird, übernimmt der Empfänger die Eigentümerschaft an ihm.
Dadurch wird verhindert, dass wir den Wert nach dem Senden versehentlich wieder
verwenden; das Eigentumssystem prüft, ob alles in Ordnung ist.</p>
<h3><a class="header" href="#mehrere-werte-senden-und-den-empfänger-warten-sehen" id="mehrere-werte-senden-und-den-empfänger-warten-sehen">Mehrere Werte senden und den Empfänger warten sehen</a></h3>
<p>Der Code in Codeblock 16-8 wurde kompiliert und ausgeführt, aber er zeigte uns
nicht eindeutig, dass zwei getrennte Stränge über den Kanal miteinander
sprachen. In Codeblock 16-10 haben wir einige Änderungen vorgenommen, die
beweisen, dass der Code in Codeblock 16-8 nebenläufig ausgeführt wird: Der
erzeugte Strang sendet nun mehrere Nachrichten und macht dazwischen eine Pause
von einer Sekunde.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hallo&quot;),
            String::from(&quot;aus&quot;),
            String::from(&quot;dem&quot;),
            String::from(&quot;Strang&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Erhalten: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-10: Senden mehrerer Nachrichten und
Pausieren dazwischen</span></p>
<p>Diesmal hat der erzeugte Strang einen Vektor von Zeichenketten, die wir an den
Hauptstrang senden wollen. Wir iterieren über diese Zeichenketten, senden jede
einzeln und pausieren dazwischen, indem wir die Funktion <code>thread::sleep</code> mit
einem <code>Duration</code>-Wert von 1 Sekunde aufrufen.</p>
<p>Im Hauptstrang rufen wir die Funktion <code>recv</code> nicht mehr explizit auf:
Stattdessen behandeln wir <code>rx</code> als Iterator. Jeden empfangenen Wert geben wir
aus. Wenn der Kanal geschlossen wird, wird die Iteration beendet.</p>
<p>Wenn du den Code in Codeblock 16-10 ausführst, solltest du die folgende Ausgabe
mit einer 1-Sekunden-Pause zwischen jeder Zeile sehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: aus
Erhalten: dem
Erhalten: Strang
</code></pre>
<p>Da wir keinen Code haben, der die <code>for</code>-Schleife im Hauptstrang pausiert oder
verzögert, können wir sagen, dass der Hauptstrang darauf wartet, Werte vom
erzeugten Strang zu erhalten.</p>
<h3><a class="header" href="#erstellen-mehrerer-produzenten-durch-klonen-des-senders" id="erstellen-mehrerer-produzenten-durch-klonen-des-senders">Erstellen mehrerer Produzenten durch Klonen des Senders</a></h3>
<p>Vorhin haben wir erwähnt, dass <code>mpsc</code> ein Akronym für <em>mehrfacher Produzent,
einzelner Konsument</em> ist. Lass uns <code>mpsc</code> verwenden und den Code in Codeblock
16-10 erweitern, um mehrere Stränge zu erzeugen, die alle Werte an den gleichen
Empfänger senden. Wir können dies tun, indem wir die sendende Hälfte des Kanals
klonen, wie in Codeblock 16-11 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --abschneiden--

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hallo&quot;),
            String::from(&quot;aus&quot;),
            String::from(&quot;dem&quot;),
            String::from(&quot;Strang&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;mehr&quot;),
            String::from(&quot;Nachrichten&quot;),
            String::from(&quot;für&quot;),
            String::from(&quot;dich&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Erhalten: {}&quot;, received);
    }

    // --abschneiden--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 16-11: Senden mehrerer Nachrichten von mehreren
Produzenten</span></p>
<p>Bevor wir den ersten Strang erzeugen, rufen wir dieses Mal <code>clone</code> auf dem
sendenden Ende des Kanals auf. Dadurch erhalten wir ein weiteres sendendes
Ende, das wir an den ersten erzeugten Strang weitergeben können. Wir übergeben
das ursprüngliche sendende Ende des Kanals an einen zweiten erzeugten Strang.
Dadurch erhalten wir zwei Stränge, die jeweils unterschiedliche Nachrichten an
das empfangende Ende des Kanals senden.</p>
<p>Wenn du den Code ausführst, sollte deine Ausgabe in etwa so aussehen:</p>
<pre><code class="language-text">Erhalten: hallo
Erhalten: mehr
Erhalten: aus
Erhalten: Nachrichten
Erhalten: für
Erhalten: dem
Erhalten: Strang
Erhalten: dich
</code></pre>
<p>Möglicherweise siehst du die Werte in einer anderen Reihenfolge; dies hängt von
deinem System ab. Das macht die Nebenläufigkeit sowohl interessant als auch
schwierig. Wenn du mit <code>thread::sleep</code> experimentierst und ihm verschiedene
Werte in den verschiedenen Strängen gibst, wird jeder Durchlauf
nicht-deterministischer sein und jedes Mal eine andere Ausgabe erzeugen.</p>
<p>Nachdem wir uns nun angesehen haben, wie Kanäle funktionieren, wollen wir uns
eine andere Methode der Nebenläufigkeit ansehen.</p>
<h2><a class="header" href="#nebenläufigkeit-mit-gemeinsamem-zustand" id="nebenläufigkeit-mit-gemeinsamem-zustand">Nebenläufigkeit mit gemeinsamem Zustand</a></h2>
<p>Die Nachrichtenübermittlung ist eine gute Methode zur Behandlung von
Nebenläufigkeit, aber sie ist nicht die einzige. Betrachte folgenden Teil des
Slogans aus der Go-Sprachdokumentation noch einmal: „Kommuniziere nicht, indem
du Arbeitsspeicher teilst.“</p>
<p>Wie würde Kommunikation durch gemeinsame Nutzung von Arbeitsspeicher aussehen?
Darüber hinaus, warum würden nachrichtenübermittelnde Enthusiasten sie nicht
nutzen und stattdessen das Gegenteil tun?</p>
<p>In gewisser Weise ähneln Kanäle in jeder Programmiersprache dem Alleineigentum,
denn sobald du einen Wert in einen Kanal übertragen hast, solltest du diesen
Wert nicht mehr verwenden. Nebenläufigkeit mit gemeinsam genutztem
Arbeitsspeicher ist wie Mehrfacheigentum: Mehrere Stränge können gleichzeitig
auf denselben Speicherplatz zugreifen. Wie du in Kapitel 15 gesehen hast, wo
intelligente Zeiger Mehrfacheigentum ermöglichten, kann Mehrfacheigentum zu
zusätzlicher Komplexität führen, da die verschiedenen Eigentümer verwaltet
werden müssen. Das Typsystem und die Eigentumsregeln von Rust sind eine große
Hilfe, um diese Verwaltung korrekt zu gestalten. Betrachten wir als Beispiel
den Mutex, eines der gebräuchlicheren Nebenläufigkeitsprimitive für gemeinsam
genutzten Speicher.</p>
<h3><a class="header" href="#verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen" id="verwenden-von-mutex-um-datenzugriff-von-jeweils-einem-strang-zu-ermöglichen">Verwenden von Mutex, um Datenzugriff von jeweils einem Strang zu ermöglichen</a></h3>
<p><em>Mutex</em> ist eine Abkürzung für <em>mutual exclusion</em> (engl. wechselseitiger
Ausschluss), da ein Mutex zu einem bestimmten Zeitpunkt nur einem Strang
(thread) den Zugriff auf einige Daten erlaubt. Um auf die Daten in einem Mutex
zuzugreifen, muss ein Strang zunächst signalisieren, dass er Zugriff wünscht,
indem er darum bittet, die <em>Sperre</em> (lock) des Mutex zu erwerben. Die Sperre
ist eine Datenstruktur, die Teil des Mutex ist, der verfolgt, wer derzeit
exklusiven Zugriff auf die Daten hat. Daher wird der Mutex als <em>Schutz</em> der
Daten beschrieben, die er über das Schließsystem hält.</p>
<p>Mutexe haben den Ruf, dass sie schwierig anzuwenden sind, weil man sich zwei
Regeln merken muss:</p>
<ul>
<li>Du musst versuchen, die Sperre zu erwerben, bevor du die Daten verwendest.</li>
<li>Wenn du mit den Daten, die der Mutex schützt, fertig bist, musst du die Daten
entsperren, damit andere Stränge die Sperre übernehmen können.</li>
</ul>
<p>Als reale Metapher für einen Mutex stelle dir eine Podiumsdiskussion auf einer
Konferenz mit nur einem Mikrofon vor. Bevor ein Podiumsteilnehmer das Wort
ergreifen kann, muss er fragen oder signalisieren, dass er das Mikrofon
benutzen möchte. Wenn er das Mikrofon erhält, kann er so lange sprechen, wie er
möchte, und das Mikrofon dann dem nächsten Diskussionsteilnehmer übergeben, der
um das Wort bittet. Wenn ein Diskussionsteilnehmer vergisst, das Mikrofon
abzugeben, wenn er damit fertig ist, kann kein anderer mehr sprechen. Wenn die
Verwaltung des gemeinsam genutzten Mikrofons schief geht, funktioniert das
Podium nicht wie geplant!</p>
<p>Das Management von Mutexen kann unglaublich schwierig sein, weshalb so viele
Menschen von Kanälen begeistert sind. Dank des Typsystems und der
Eigentumsregeln von Rust kann man jedoch beim Sperren und Entsperren nichts
falsch machen.</p>
<h4><a class="header" href="#die-api-von-mutext" id="die-api-von-mutext">Die API von <code>Mutex&lt;T&gt;</code></a></h4>
<p>Als Beispiel für die Verwendung eines Mutex beginnen wir mit der Verwendung
eines Mutex in einem einsträngigen (single-threaded) Kontext, wie in Codeblock
16-12 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-12: Untersuchen der API von <code>Mutex&lt;T&gt;</code> in
einem einsträngigen Kontext zur Vereinfachung</span></p>
<p>Wie bei vielen Typen erzeugen wir einen <code>Mutex&lt;T&gt;</code> mit der zugehörigen Funktion
<code>new</code>. Um auf die Daten innerhalb des Mutex zuzugreifen, verwenden wir die
Methode <code>lock</code>, um die Sperre zu erhalten. Dieser Aufruf blockiert den
aktuellen Strang, sodass er keine Arbeit verrichten kann, bis wir an der Reihe
sind, die Sperre zu haben.</p>
<p>Der Aufruf von <code>lock</code> würde fehlschlagen, wenn ein anderer Strang, der die
Sperre hält, abstürzte. In diesem Fall wäre niemand jemals in der Lage, die
Sperre zu erhalten, also haben wir uns entschieden, <code>unwrap</code> zu benutzen und
diesen Strang abstürzen zu lassen, wenn wir uns in dieser Situation befinden.</p>
<p>Nachdem wir die Sperre erworben haben, können wir den Rückgabewert, in diesem
Fall <code>num</code> genannt, als veränderliche Referenz auf die darin enthaltenen Daten
verwenden. Das Typsystem stellt sicher, dass wir eine Sperre erwerben, bevor
wir den Wert in <code>m</code> verwenden: <code>Mutex&lt;i32&gt;</code> ist kein <code>i32</code>, also <em>müssen</em> wir
die Sperre erwerben, um den <code>i32</code>-Wert verwenden zu können. Wir können das
nicht vergessen, das Typsystem würde uns sonst keinen Zugriff auf das innere
<code>i32</code> erlauben.</p>
<p>Wie du vielleicht vermutest, ist <code>Mutex&lt;T&gt;</code> ein intelligenter Zeiger. Genauer
gesagt gibt der Aufruf von <code>lock</code> einen intelligenten Zeiger namens
<code>MutexGuard</code> zurück, der in ein <code>LockResult</code> verpackt ist, das wir mit dem
Aufruf von <code>unwrap</code> behandelt haben. Der intelligente Zeiger <code>MutexGuard</code>
implementiert <code>Deref</code>, um auf unsere inneren Daten zu zeigen; der intelligente
Zeiger hat auch eine <code>Drop</code>-Implementierung, die die Sperre automatisch
aufhebt, wenn ein <code>MutexGuard</code> den Gültigkeitsbereich verlässt, was am Ende des
inneren Gültigkeitsbereichs in Codeblock 16-12 geschieht. Dadurch laufen wir
nicht Gefahr, zu vergessen, die Sperre freizugeben und die Verwendung des Mutex
durch andere Stränge zu blockieren, da die Freigabe der Sperre automatisch
erfolgt.</p>
<p>Nachdem wir die Sperre aufgehoben haben, können wir den Mutex-Wert ausgeben und
sehen, dass wir den inneren <code>i32</code> in 6 ändern konnten.</p>
<h4><a class="header" href="#gemeinsames-nutzen-eines-mutext-von-mehreren-strängen" id="gemeinsames-nutzen-eines-mutext-von-mehreren-strängen">Gemeinsames Nutzen eines <code>Mutex&lt;T&gt;</code> von mehreren Strängen</a></h4>
<p>Versuchen wir nun, einen Wert zwischen mehreren Strängen mit <code>Mutex&lt;T&gt;</code> zu
teilen. Wir starten 10 Stränge und lassen sie jeweils einen Zählerwert um 1
erhöhen, sodass der Zähler von 0 auf 10 geht. Das nächste Beispiel in Codeblock
16-13 wird einen Kompilierfehler haben und wir werden diesen Fehler verwenden,
um mehr über die Verwendung von <code>Mutex&lt;T&gt;</code> zu erfahren und darüber, wie Rust
uns hilft, ihn korrekt zu verwenden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-13: Zehn Stränge inkrementieren jeweils
einen Zähler, der durch einen <code>Mutex&lt;T&gt;</code> geschützt ist</span></p>
<p>Wir erstellen eine Variable <code>counter</code>, um ein <code>i32</code> innerhalb eines <code>Mutex&lt;T&gt;</code>
zu halten, wie wir es in Codeblock 16-12 getan haben. Als Nächstes erstellen
wir 10 Stränge, indem wir über einen Zahlenbereich iterieren. Wir verwenden
<code>thread::spawn</code> und geben allen Strängen den gleichen Funktionsabschluss
(closure), der den Zähler in den Strang verschiebt, eine Sperre auf dem
<code>Mutex&lt;T&gt;</code> durch Aufrufen der <code>lock</code>-Methode erwirbt und dann 1 zum Wert im
Mutex addiert. Wenn ein Strang die Ausführung seines Funktionsabschlusses
beendet hat, verlässt <code>num</code> den Gültigkeitsbereich und gibt die Sperre frei,
sodass ein anderer Strang sie erwerben kann.</p>
<p>Im Hauptstrang sammeln wir alle <code>JoinHandle</code>. Dann rufen wir, wie wir es in
Codeblock 16-2 getan haben, <code>join</code> auf jedem Strang auf, um sicherzustellen,
dass alle Stränge beendet sind. An diesem Punkt erhält der Hauptstrang die
Sperre und gibt das Ergebnis dieses Programms aus.</p>
<p>Wir haben angedeutet, dass sich dieses Beispiel nicht kompilieren lässt. Jetzt
wollen wir herausfinden, warum!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Fehlermeldung besagt, dass der Wert <code>counter</code> in der vorherigen Iteration
der Schleife verschoben wurde. Rust sagt uns also, dass wir die
Eigentümerschaft der Sperre <code>counter</code> nicht in mehrere Stränge verschieben
können. Lass uns den Kompilierfehler mit einer Mehrfacheigentums-Methode
beheben, die wir in Kapitel 15 besprochen haben.</p>
<h4><a class="header" href="#mehrfacheigentum-mit-mehreren-strängen" id="mehrfacheigentum-mit-mehreren-strängen">Mehrfacheigentum mit mehreren Strängen</a></h4>
<p>In Kapitel 15 gaben wir einen Wert mit mehreren Eigentümern an, indem wir den
intelligenten Zeiger <code>Rc&lt;T&gt;</code> verwendeten, um einen Referenzzählwert zu
erstellen. Lass uns hier das Gleiche tun und sehen, was passiert. Wir packen
den <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Codeblock 16-14 ein und klonen den <code>Rc&lt;T&gt;</code>, bevor
wir die Eigentümerschaft an den Strang übertragen. Da wir die Fehler nun
gesehen haben, werden wir auch wieder die <code>for</code>-Schleife verwenden und das
Schlüsselwort <code>move</code> mit dem Funktionsabschluss beibehalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-14: Versuch, <code>Rc&lt;T&gt;</code> zu verwenden, um
mehreren Strängen zu erlauben, den <code>Mutex&lt;T&gt;</code> zu besitzen</span></p>
<p>Wir kompilieren nochmal und bekommen ... verschiedene Fehler! Der Compiler
lehrt uns eine Menge.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |         let handle = thread::spawn(move || {
    |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Toll, diese Fehlermeldung ist sehr wortreich! Hier ist der wichtige Teil, auf
den wir uns konzentrieren müssen: <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> kann nicht sicher zwischen
Strängen gesendet werden. Der Compiler teilt uns auch den Grund dafür mit: Das
Merkmal (trait) <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht implementiert. Wir werden
im nächsten Abschnitt über <code>Send</code> sprechen: Es ist eines der Merkmale, das
sicherstellt, dass die Typen, die wir mit Strängen verwenden, für die
Verwendung in nebenläufigen Situationen gedacht sind.</p>
<p>Leider ist es nicht sicher, <code>Rc&lt;T&gt;</code> über verschiedene Stränge hinweg gemeinsam
zu nutzen. Wenn <code>Rc&lt;T&gt;</code> den Referenzzähler verwaltet, inkrementiert es den
Zähler bei jedem Aufruf von <code>clone</code> und dekrementiert den Zähler bei jedem
Klon, der aufgeräumt wird. Es werden jedoch keine Nebenläufigkeitsprimitive
verwendet, um sicherzustellen, dass Änderungen am Zähler nicht durch einen
anderen Strang unterbrochen werden können. Dies könnte zu falschen Zählungen
führen – subtile Fehler, die wiederum zu Speicherlecks (memory leaks)
oder zum Aufräumen eines Wertes führen könnten, obwohl wir ihn noch nutzen
wollen. Was wir brauchen, ist ein Typ genau wie <code>Rc&lt;T&gt;</code>, aber einer, der
Änderungen am Referenzzähler auf Strang-sichere Weise vornimmt.</p>
<h4><a class="header" href="#atomare-referenzzählung-mit-arct" id="atomare-referenzzählung-mit-arct">Atomare Referenzzählung mit <code>Arc&lt;T&gt;</code></a></h4>
<p>Glücklicherweise ist <code>Arc&lt;T&gt;</code> ein Typ wie <code>Rc&lt;T&gt;</code>, der in nebenläufigen
Situationen sicher zu verwenden ist. Das <em>a</em> steht für <em>atomar</em>, d.h. es
handelt sich um einen <em>atomar referenzgezählten</em> (atomically reference
counted) Typ. Atomare Typen (atomics) sind eine zusätzliche Art von
Nebenläufigkeitsprimitiven, die wir hier nicht im Detail behandeln werden:
Weitere Einzelheiten findest du in der Standardbibliotheksdokumentation für
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a>. An dieser Stelle musst du nur wissen, dass
atomare Typen wie primitive Typen funktionieren, aber sicher über Stränge
hinweg gemeinsam genutzt werden können.</p>
<p>Du wirst dich dann vielleicht fragen, warum nicht alle primitiven Typen atomar
sind und warum Standardbibliothekstypen nicht so implementiert sind, dass sie
standardmäßig <code>Arc&lt;T&gt;</code> verwenden. Der Grund dafür ist, dass Strang-Sicherheit
mit Performanzeinbußen verbunden ist, die du nur dann zahlen willst, wenn du
sie wirklich brauchst. Wenn du nur Operationen an Werten innerhalb eines
einzelnen Strangs durchführst, kann dein Code schneller laufen, wenn er nicht
die Garantien erzwingen muss, die atomare Typen bieten.</p>
<p>Kehren wir zu unserem Beispiel zurück: <code>Arc&lt;T&gt;</code> und <code>Rc&lt;T&gt;</code> haben die gleiche
API, also reparieren wir unser Programm, indem wir die <code>use</code>-Zeile, den Aufruf
von <code>new</code> und den Aufruf von <code>clone</code> ändern. Der Code in Codeblock 16-15 wird
schließlich kompilieren und laufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Ergebnis: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Codeblock 16-15: Verwenden von <code>Arc&lt;T&gt;</code>, um den <code>Mutex&lt;T&gt;</code>
einzupacken, um die Eigentümerschaft mit mehreren Strängen teilen zu
können</span></p>
<p>Dieser Code gibt folgendes aus:</p>
<pre><code class="language-text">Ergebnis: 10
</code></pre>
<p>Wir haben es geschafft! Wir zählten von 0 bis 10, was nicht sehr beeindruckend
erscheinen mag, aber wir haben viel über <code>Mutex&lt;T&gt;</code> und Strangsicherheit
gelernt. Du kannst die Struktur dieses Programms auch dazu benutzen,
kompliziertere Operationen durchzuführen als nur einen Zähler zu
inkrementieren. Mit dieser Strategie kannst du eine Berechnung in unabhängige
Teile aufteilen, diese Teile auf Stränge aufteilen und dann <code>Mutex&lt;T&gt;</code>
verwenden, damit jeder Strang das Endergebnis mit seinem Teil aktualisiert.</p>
<h3><a class="header" href="#Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct" id="Ähnlichkeiten-zwischen-refcelltrct-und-mutextarct">Ähnlichkeiten zwischen <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> und <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Du hast vielleicht bemerkt, dass <code>counter</code> unveränderlich (immutable) ist, aber
wir könnten eine veränderliche (mutable) Referenz auf den Wert in seinem
Inneren erhalten; das bedeutet, dass <code>Mutex&lt;T&gt;</code> innere Veränderlichkeit
(interior mutability) bietet, wie es die <code>Cell</code>-Familie tut. Auf die gleiche
Weise, wie wir <code>RefCell&lt;T&gt;</code> in Kapitel 15 benutzt haben, um uns zu erlauben,
Inhalte innerhalb eines <code>Rc&lt;T&gt;</code> zu mutieren, benutzen wir <code>Mutex&lt;T&gt;</code>, um
Inhalte innerhalb eines <code>Arc&lt;T&gt;</code> zu mutieren.</p>
<p>Ein weiteres zu beachtendes Detail ist, dass Rust dich nicht vor allen Arten
von Logikfehlern schützen kann, wenn du <code>Mutex&lt;T&gt;</code> verwendest. Erinnere dich in
Kapitel 15 daran, dass die Verwendung von <code>Rc&lt;T&gt;</code> mit dem Risiko verbunden war,
Referenzzyklen zu erzeugen, bei denen zwei <code>Rc&lt;T&gt;</code> Werte aufeinander
referenzieren und dadurch Speicherlecks verursachen. In ähnlicher Weise ist
<code>Mutex&lt;T&gt;</code> mit dem Risiko verbunden, <em>Deadlocks</em> zu schaffen. Diese treten auf,
wenn eine Operation zwei Ressourcen sperren muss und zwei Stränge jeweils eine
der Sperren erworben haben, was dazu führt, dass sie ewig aufeinander warten.
Wenn du an Deadlocks interessiert bist, versuche, ein Programm in Rust zu
erstellen, das einen Deadlock hat; dann recherchiere Strategien zur Minderung
von Deadlocks für Mutexe in einer Sprache und versuche, sie in Rust zu
implementieren. Die Standardbibliotheks-API-Dokumentation für <code>Mutex&lt;T&gt;</code> und
<code>MutexGuard</code> bietet nützliche Informationen.</p>
<p>Wir runden dieses Kapitel ab, indem wir über die Merkmale <code>Send</code> und <code>Sync</code>
sprechen und wie wir sie mit benutzerdefinierten Typen verwenden können.</p>
<h2><a class="header" href="#erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-sync-und-send" id="erweiterbare-nebenläufigkeit-mit-den-merkmalen-traits-sync-und-send">Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und <code>Send</code></a></h2>
<p>Interessanterweise hat die Sprache Rust <em>sehr wenige</em>
Nebenläufigkeitsfunktionalitäten. Fast jede Nebenläufigkeitsfunktionalität,
über die wir bisher in diesem Kapitel gesprochen haben, war Teil der
Standardbibliothek, nicht der Sprache. Deine Möglichkeiten für den Umgang mit
Nebenläufigkeit sind nicht auf die Sprache oder die Standardbibliothek
beschränkt; du kannst deine eigenen Nebenläufigkeitsfunktionalitäten schreiben
oder die von anderen geschriebenen verwenden.</p>
<p>In der Sprache sind jedoch zwei Nebenläufigkeitskonzepte eingebettet: Die
<code>std::marker</code>-Merkmale (traits) <code>Sync</code> und <code>Send</code>.</p>
<h3><a class="header" href="#erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send" id="erlauben-der-eigentümerschaftübertragung-zwischen-strängen-mit-send">Erlauben der Eigentümerschaftübertragung zwischen Strängen mit <code>Send</code></a></h3>
<p>Das Markierungsmerkmal (marker trait) <code>Send</code> zeigt an, dass die
Eigentümerschaft am Typ, der <code>Send</code> implementiert, zwischen Strängen (threads)
übertragen werden kann. Fast jeder Rust-Typ ist <code>Send</code>, aber es gibt einige
Ausnahmen, einschließlich <code>Rc&lt;T&gt;</code>: Dieser kann nicht <code>Send</code> sein, denn wenn du
einen <code>Rc&lt;T&gt;</code> Wert geklont hast und versucht hast, die Eigentümerschaft am Klon
auf einen anderen Strang zu übertragen, könnten beide Stränge gleichzeitig die
Referenzzahl aktualisieren. Aus diesem Grund ist <code>Rc&lt;T&gt;</code> für die Verwendung in
einsträngigen Situationen implementiert, in denen du nicht die Strang-sichere
Performanzeinbuße zahlen willst.</p>
<p>Daher stellen das Typsystem und die Merkmalsabgrenzungen (trait bounds) von
Rust sicher, dass du niemals versehentlich einen <code>Rc&lt;T&gt;</code>-Wert über Stränge
unsicher senden kannst. Als wir dies in Codeblock 16-14 versuchten, erhielten
wir folgenden Fehler: Das Merkmal <code>Send</code> ist für <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> nicht
implementiert. Als wir zu <code>Arc&lt;T&gt;</code>, das <code>Send</code> ist, wechselten, wurde der Code
kompiliert.</p>
<p>Jeder Typ, der vollständig aus <code>Send</code>-Typen besteht, wird automatisch auch als
<code>Send</code> markiert. Fast alle primitiven Typen sind <code>Send</code>, abgesehen von
Roh-Zeigern, die wir in Kapitel 19 besprechen werden.</p>
<h3><a class="header" href="#erlauben-des-zugriffs-von-mehreren-strängen-mit-sync" id="erlauben-des-zugriffs-von-mehreren-strängen-mit-sync">Erlauben des Zugriffs von mehreren Strängen mit <code>Sync</code></a></h3>
<p>Das Markierungsmerkmal <code>Sync</code> zeigt an, dass es sicher ist, den Typ, der <code>Sync</code>
implementiert, von mehreren Strängen zu referenzieren. Mit anderen Worten,
jeder Typ <code>T</code> ist <code>Sync</code>, wenn <code>&amp;T</code> (eine Referenz auf <code>T</code>) <code>Send</code> ist, was
bedeutet, dass die Referenz sicher an einen anderen Strang gesendet werden
kann. Ähnlich wie bei <code>Send</code> sind primitive Typen <code>Sync</code> und Typen, die
vollständig aus Typen bestehen, die <code>Sync</code> sind, sind ebenfalls <code>Sync</code>.</p>
<p>Der intelligente Zeiger <code>Rc&lt;T&gt;</code> ist nicht <code>Sync</code>, aus den gleichen Gründen, aus
denen er nicht <code>Send</code> ist. Der Typ <code>RefCell&lt;T&gt;</code> (über den wir in Kapitel 15
gesprochen haben) und die Familie der verwandten <code>Cell&lt;T&gt;</code>-Typen sind nicht
<code>Sync</code>. Die Implementierung der Ausleihenprüfung (borrow checking), die
<code>RefCell&lt;T&gt;</code> zur Laufzeit durchführt, ist nicht Strang-sicher. Der intelligente
Zeiger <code>Mutex&lt;T&gt;</code> ist <code>Sync</code> und kann verwendet werden, um den Zugriff mit
mehreren Strängen zu teilen, wie du im Abschnitt <a href="ch16-03-shared-state.html#gemeinsames-nutzen-eines-mutext-von-mehreren-str%C3%A4ngen">„Gemeinsames Nutzen eines
<code>Mutex&lt;T&gt;</code> von mehreren Strängen“</a> gesehen hast.</p>
<h3><a class="header" href="#manuelles-implementieren-von-send-und-sync-ist-unsicher" id="manuelles-implementieren-von-send-und-sync-ist-unsicher">Manuelles Implementieren von <code>Send</code> und <code>Sync</code> ist unsicher</a></h3>
<p>Da Typen, die sich aus den Merkmalen <code>Send</code> und <code>Sync</code> zusammensetzen,
automatisch auch <code>Send</code> und <code>Sync</code> sind, müssen wir diese Merkmale nicht
manuell implementieren. Als Markierungsmerkmale haben sie noch nicht einmal
irgendwelche Methoden, um sie zu implementieren. Sie sind nur nützlich, um
Invarianten in Bezug auf die Nebenläufigkeit zu erzwingen.</p>
<p>Das manuelle Implementieren dieser Merkmale beinhaltet das Schreiben von
unsicherem Rust-Code. Wir werden über das Verwenden von unsicherem Rust-Code in
Kapitel 19 sprechen; für den Moment ist die wichtige Information, dass das
Erstellen neuer nebenläufiger Typen, die nicht aus <code>Send</code>- und <code>Sync</code>-Teilen
bestehen, sorgfältige Überlegungen erfordert, um die Sicherheitsgarantien
aufrechtzuerhalten. <a href="https://doc.rust-lang.org/nomicon/index.html">„Das Rustonomicon“</a> enthält weitere Informationen
über diese Garantien und wie man sie aufrechterhalten kann.</p>
<h2><a class="header" href="#zusammenfassung-15" id="zusammenfassung-15">Zusammenfassung</a></h2>
<p>Dies ist nicht das letzte Mal, dass du in diesem Buch der Nebenläufigkeit
begegnest: Das Projekt in Kapitel 20 wird die Konzepte in diesem Kapitel in
einer realistischeren Situation verwenden als die hier besprochenen kleinen
Beispiele.</p>
<p>Wie bereits erwähnt, ist nur sehr wenig davon, wie Rust mit Nebenläufigkeit
umgeht, Teil der Sprache; viele Nebenläufigkeitslösungen sind als Kisten
(crates) implementiert. Diese entwickeln sich schneller als die
Standardbibliothek. Stelle also sicher, dass du online nach den aktuellen,
hochmodernen Kisten suchst, die in mehrsträngigen Situationen verwendet werden
können.</p>
<p>Die Rust-Standardbibliothek bietet Kanäle (channels) für die
Nachrichtenübermittlung und intelligente Zeigertypen, wie <code>Mutex&lt;T&gt;</code> und
<code>Arc&lt;T&gt;</code>, die sicher in nebenläufigen Kontexten verwendet werden können. Das
Typsystem und der Ausleihenprüfer stellen sicher, dass der Code, der diese
Lösungen verwendet, nicht mit Daten-Wettlaufsituationen (data races) oder
ungültigen Referenzen endet. Sobald du deinen Code zum Kompilieren gebracht
hast, kannst du sicher sein, dass er problemlos mit mehreren Strängen läuft,
ohne die schwer aufzuspürenden Fehler, die in anderen Sprachen üblich sind.
Nebenläufige Programmierung ist kein Konzept mehr, vor dem man sich fürchten
muss: Gehe hinaus und mache deine Programme nebenläufig – furchtlos!</p>
<p>Als Nächstes werden wir über idiomatische Wege sprechen, Probleme zu
modellieren und Lösungen zu strukturieren, während deine Rust-Programme größer
werden. Darüber hinaus werden wir besprechen, wie Rusts Idiome mit denen
zusammenhängen, die dir vielleicht aus der objektorientierten Programmierung
bekannt sind.</p>
<h1><a class="header" href="#objektorientierte-sprachelemente-von-rust" id="objektorientierte-sprachelemente-von-rust">Objektorientierte Sprachelemente von Rust</a></h1>
<p>Objektorientierte Programmierung (OOP) ist eine Möglichkeit, Programme zu
modellieren. Objekte kamen von Simula in den 1960er Jahren. Diese Objekte
beeinflussten die Programmierarchitektur von Alan Kay, in der Objekte sich
gegenseitig Nachrichten übermitteln. Er prägte 1967 den Begriff
<em>objektorientierte Programmierung</em>, um diese Architektur zu beschreiben. Viele
konkurrierende Definitionen beschreiben, was OOP ist; einige Definitionen
würden Rust als objektorientiert klassifizieren, andere hingegen nicht. In
diesem Kapitel untersuchen wir bestimmte Charakteristiken, die gemeinhin als
objektorientiert gelten, und wie sich diese Charakteristiken in idiomatisches
Rust übersetzen lassen. Anschließend zeigen wir dir, wie du ein
objektorientiertes Entwurfsmuster in Rust implementieren kannst, und erörtern
die Kompromisse, die sich daraus gegenüber der Implementierung einer Lösung
ergeben, die stattdessen einige der Stärken von Rust nutzt.</p>
<h2><a class="header" href="#charakteristiken-objektorientierter-sprachen" id="charakteristiken-objektorientierter-sprachen">Charakteristiken objektorientierter Sprachen</a></h2>
<p>Es gibt in der Programmierergemeinschaft keinen Konsens darüber, welche
Funktionalitäten eine Sprache haben muss, um als objektorientiert zu gelten.
Rust wird von vielen Programmierparadigmen beeinflusst, einschließlich OOP; zum
Beispiel haben wir in Kapitel 13 die Funktionalitäten untersucht, die aus der
funktionalen Programmierung stammen. Die OOP-Sprachen haben wohl bestimmte
gemeinsame Charakteristiken, nämlich Objekte, Kapselung (encapsulation) und
Vererbung (inheritance). Schauen wir uns an, was jedes dieser Charakteristiken
bedeutet und ob Rust es unterstützt.</p>
<h3><a class="header" href="#objekte-enthalten-daten-und-verhalten" id="objekte-enthalten-daten-und-verhalten">Objekte enthalten Daten und Verhalten</a></h3>
<p>Das Buch <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> von
Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides (Addison-Wesley
Professional, 1994), umgangssprachlich als <em>The Gang of Four</em>-Buch bezeichnet,
ist ein Katalog von objektorientierten Entwurfsmustern. Es definiert OOP auf
diese Weise:</p>
<blockquote>
<p>Objektorientierte Programme setzen sich aus Objekten zusammen. Ein <em>Objekt</em>
verpackt sowohl Daten als auch Prozeduren, die auf diesen Daten operieren.
Die Prozeduren werden normalerweise <em>Methoden</em> oder <em>Operationen</em> genannt.</p>
</blockquote>
<p>Mit dieser Definition ist Rust objektorientiert: Strukturen (structs) und
Aufzählungen (enums) haben Daten, und <code>impl</code>-Blöcke stellen Methoden auf
Strukturen und Aufzählungen zur Verfügung. Auch wenn Strukturen und
Aufzählungen mit Methoden keine <em>aufgerufenen</em> Objekte sind, bieten sie
dieselbe Funktionalität gemäß der Definition von Objekten der Gang of Four.</p>
<h3><a class="header" href="#kapselung-die-implementierungsdetails-verbirgt" id="kapselung-die-implementierungsdetails-verbirgt">Kapselung, die Implementierungsdetails verbirgt</a></h3>
<p>Ein weiterer Aspekt, der gemeinhin mit OOP in Verbindung gebracht wird, ist die
Idee der <em>Kapselung</em> (encapsulation), was bedeutet, dass die
Implementierungsdetails eines Objekts nicht zugänglich sind für Code, der
dieses Objekt verwendet. Daher ist die einzige Möglichkeit, mit einem Objekt zu
interagieren, seine öffentliche API; Code, der das Objekt verwendet, sollte
nicht in der Lage sein, in die Interna des Objekts einzudringen und Daten oder
Verhalten direkt zu ändern. Dies ermöglicht es dem Programmierer, die Interna
eines Objekts zu ändern und umzugestalten, ohne Code ändern zu müssen, der das
Objekt verwendet.</p>
<p>Wie man die Kapselung steuert, haben wir in Kapitel 7 besprochen: Wir können
das Schlüsselwort <code>pub</code> benutzen, um zu entscheiden, welche Module, Typen,
Funktionen und Methoden in unserem Code öffentlich sein sollen, alles andere
ist standardmäßig privat. Zum Beispiel können wir eine Struktur
<code>AveragedCollection</code> definieren, die ein Feld hat, das einen Vektor mit
<code>i32</code>-Werten enthält. Die Struktur kann auch ein Feld haben, das den Mittelwert
der Werte im Vektor enthält, was bedeutet, dass der Mittelwert nicht auf
Anfrage berechnet werden muss, wenn jemand ihn braucht. Mit anderen Worten:
<code>AveragedCollection</code> wird den errechneten Durchschnitt für uns
zwischenspeichern. Codeblock 17-1 zeigt die Definition der Struktur
<code>AveragedCollection</code>:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-1: Eine Struktur <code>AveragedCollection</code>, die
eine Liste von ganzen Zahlen und den Durchschnitt der Elemente in der
Kollektion verwaltet</span></p>
<p>Die Struktur wird als <code>pub</code> markiert, damit anderer Code sie verwenden kann,
aber die Felder innerhalb der Struktur bleiben privat. Dies ist in diesem Fall
wichtig, weil wir sicherstellen wollen, dass immer dann, wenn ein Wert
hinzugefügt oder aus der Liste entfernt wird, auch der Durchschnitt
aktualisiert wird. Wir tun dies, indem wir die Methoden <code>add</code>, <code>remove</code> und
<code>average</code> auf der Struktur implementieren, wie in Codeblock 17-2 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-2: Implementierungen der öffentlichen
Methoden <code>add</code>, <code>remove</code> und <code>average</code> auf  <code>AveragedCollection</code></span></p>
<p>Die öffentlichen Methoden <code>add</code>, <code>remove</code> und <code>average</code> sind die einzigen
Möglichkeiten, auf Daten in einer <code>AveragedCollection</code>-Instanz zuzugreifen oder
sie zu ändern. Wenn ein Eintrag mit der Methode <code>add</code> zu <code>list</code> hinzugefügt
oder mit der Methode <code>remove</code> entfernt wird, rufen die Implementierungen der
einzelnen Methoden die private Methode <code>update_average</code> auf, die auch das
Aktualisieren des Feldes <code>average</code> übernimmt.</p>
<p>Wir lassen die Felder <code>list</code> und <code>average</code> privat, sodass es keine Möglichkeit
für externen Code gibt, Elemente direkt zum Feld <code>list</code> hinzuzufügen oder zu
entfernen; andernfalls könnte das Feld <code>average</code> inkonsistent werden, wenn sich
<code>list</code> ändert. Die Methode <code>average</code> gibt den Wert im Feld <code>average</code> zurück,
sodass externer Code den Wert <code>average</code> lesen, aber nicht verändern kann.</p>
<p>Da wir die Implementierungsdetails der Struktur <code>AveragedCollection</code> gekapselt
haben, können wir Aspekte, z.B. die Datenstruktur, in Zukunft leicht ändern.
Zum Beispiel könnten wir ein <code>HashSet&lt;i32&gt;</code> anstelle eines <code>Vec&lt;i32&gt;</code> für das
<code>list</code>-Feld verwenden. Solange die Signaturen der öffentlichen Methoden <code>add</code>,
<code>remove</code> und <code>average</code> gleich bleiben, würde Code, der <code>AveragedCollection</code>
verwendet, nicht geändert werden müssen. Wenn wir stattdessen <code>list</code> öffentlich
machen würden, wäre dies nicht unbedingt der Fall: <code>HashSet&lt;i32&gt;</code> und
<code>Vec&lt;i32&gt;</code> haben unterschiedliche Methoden zum Hinzufügen und Entfernen von
Elementen, sodass der externer Code wahrscheinlich geändert müsste, wenn er
<code>list</code> direkt modifizieren würde.</p>
<p>Wenn die Kapselung ein erforderlicher Aspekt ist, damit eine Sprache als
objektorientiert betrachtet werden kann, dann erfüllt Rust diese Anforderung.
Die Möglichkeit, <code>pub</code> für verschiedene Teile des Codes zu verwenden oder auch
nicht, ermöglicht die Kapselung von Implementierungsdetails.</p>
<h3><a class="header" href="#vererbung-als-typsystem-und-für-gemeinsamen-code" id="vererbung-als-typsystem-und-für-gemeinsamen-code">Vererbung als Typsystem und für gemeinsamen Code</a></h3>
<p><em>Vererbung</em> ist ein Mechanismus, mit dem ein Objekt von der Definition eines
anderen Objekts erben kann und so die Daten und das Verhalten des
übergeordneten Objekts erhält, ohne dass du diese erneut definieren musst.</p>
<p>Wenn eine Sprache Vererbung haben muss, um eine objektorientierte Sprache zu
sein, dann ist Rust keine solche. Es gibt keine Möglichkeit, eine Struktur zu
definieren, die die Felder und Methodenimplementierungen der Elternstruktur
erbt. Wenn du jedoch daran gewöhnt bist, Vererbung in deinem
Programmierwerkzeugkasten zu haben, kannst du in Rust andere Lösungen
verwenden, je nachdem, warum du überhaupt zu Vererbung gegriffen hast.</p>
<p>Du entscheidest dich aus zwei Hauptgründen für die Vererbung. Einer ist die
Wiederverwendung von Code: Du kannst ein bestimmtes Verhalten für einen Typ
implementieren und die Vererbung ermöglicht es dir, diese Implementierung für
einen anderen Typ wiederzuverwenden. Du kannst stattdessen Rust-Code unter
Verwendung von Standard-Merkmalsmethoden-Implementierungen freigeben, was du in
Codeblock 10-14 gesehen hast, als wir eine Standard-Implementierung der Methode
<code>summarize</code> für das Merkmal (trait) <code>Summary</code> hinzugefügt haben. Jeder Typ, der
das Merkmal <code>Summary</code> implementiert, hätte die Methode <code>summarize</code> ohne
weiteren Code darauf zur Verfügung. Dies ist vergleichbar mit einer
Elternklasse, die eine Implementierung einer Methode hat, und einer erbenden
Kindklasse, die ebenfalls die Implementierung der Methode hat. Wir können auch
die Standard-Implementierung der Methode <code>summarize</code> außer Kraft setzen, wenn
wir das Markmal <code>Summary</code> implementieren, die einer Kindklasse ähnelt, die die
Implementierung einer von einer Elternklasse geerbten Methode außer Kraft
setzt.</p>
<p>Der andere Grund, Vererbung zu verwenden, bezieht sich auf das Typsystem: Ein
untergeordneter Typ soll an den gleichen Stellen wie der übergeordnete Typ
verwendet werden können. Dies wird auch <em>Polymorphismus</em> (polymorphism)
genannt, d.h. du kannst mehrere Objekte zur Laufzeit gegeneinander austauschen,
wenn sie bestimmte Eigenschaften gemeinsam haben.</p>
<blockquote>
<h3><a class="header" href="#polymorphismus" id="polymorphismus">Polymorphismus</a></h3>
<p>Für viele Menschen ist Polymorphismus gleichbedeutend mit Vererbung. Aber es
ist eigentlich ein allgemeinerer Begriff, der sich auf Code bezieht, der mit
Daten unterschiedlichen Typs arbeiten kann. Für die Vererbung sind diese
Typen im Allgemeinen Unterklassen.</p>
<p>Rust verwendet stattdessen generische Datentypen (generics), um über
verschiedene mögliche Typen und Merkmalsabgrenzungen (trait bounds) zu
abstrahieren, um Beschränkungen für das aufzuerlegen, was diese Typen bieten
müssen. Dies wird manchmal als <em>begrenzter parametrischer Polymorphismus</em>
(bounded parametric polymorphism) bezeichnet.</p>
</blockquote>
<p>Die Vererbung ist in letzter Zeit als Lösung für das Programmierdesign in
vielen Programmiersprachen in Ungnade gefallen, da sie oft das Risiko birgt,
mehr Code als nötig zu teilen. Unterklassen sollten nicht immer alle
Charakteristiken ihrer Elternklasse teilen, bei Vererbung tun sie es aber. Dies
kann den Programmentwurf weniger flexibel machen. Es wird auch die Möglichkeit
eingeführt, Methoden auf Unterklassen aufzurufen, die keinen Sinn machen oder
die Fehler verursachen, weil die Methoden nicht auf die Unterklasse zutreffen.
Darüber hinaus ermöglichen einige Sprachen einer Unterklasse, lediglich von
einer Klasse zu erben, was die Flexibilität des Programmdesigns weiter
einschränkt.</p>
<p>Aus diesen Gründen verfolgt Rust einen anderen Ansatz und verwendet
Merkmalsobjekte (trait objects) anstelle der Vererbung. Schauen wir uns an, wie
Merkmalsobjekte Polymorphismus in Rust ermöglichen.</p>
<h2><a class="header" href="#merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben" id="merkmalsobjekte-trait-objects-die-werte-unterschiedlicher-typen-erlauben">Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></h2>
<p>In Kapitel 8 haben wir erwähnt, dass eine Einschränkung von Vektoren darin
besteht, dass sie nur Elemente eines einzigen Typs speichern können. Wir haben
in Codeblock 8-10 eine Abhilfe geschaffen, indem wir eine
<code>SpreadsheetCell</code>-Aufzählung (enum) definiert haben, die Varianten zur Aufnahme
von Ganzzahlen, Fließkommazahlen und Text enthielt. Das bedeutete, dass wir in
jeder Zelle verschiedene Typen von Daten speichern konnten und trotzdem einen
Vektor hatten, der eine Reihe von Zellen darstellte. Dies ist eine perfekte
Lösung, wenn unsere austauschbaren Elemente ein fester Satz von Typen sind, die
wir kennen, wenn unser Code kompiliert wird.</p>
<p>Manchmal möchten wir jedoch, dass unsere Bibliotheksbenutzer in der Lage sind,
die Menge der Typen, die in einer bestimmten Situation erlaubt sind, zu
erweitern. Um zu zeigen, wie wir dies erreichen können, werden wir ein Beispiel
für ein GUI-Werkzeug (Graphical User Interface) erstellen, das über eine Liste
von Elementen iteriert, wobei auf jedem Element eine Methode <code>draw</code> aufgerufen
wird, um es auf den Bildschirm zu zeichnen – eine übliche Technik für
GUI-Werkzeuge. Wir werden eine Bibliothekskiste (library crate) namens <code>gui</code>
erstellen, die die Struktur einer GUI-Bibliothek enthält. Diese Kiste (crate)
könnte einige Typen enthalten, die Leute benutzen können, z.B. <code>Button</code> und
<code>TextField</code>. Darüber hinaus werden <code>gui</code>-Benutzer ihre eigenen Typen erstellen
wollen, die gezeichnet werden können: Zum Beispiel könnte ein Programmierer ein
<code>Image</code> und ein anderer eine <code>SelectBox</code> hinzufügen.</p>
<p>Wir werden für dieses Beispiel keine vollwertige GUI-Bibliothek implementieren,
aber wir werden zeigen, wie die Teile zusammenpassen würden. Zum Zeitpunkt des
Schreibens der Bibliothek können wir nicht alle Typen kennen und definieren,
die andere Programmierer vielleicht erstellen möchten. Aber wir wissen, dass
<code>gui</code> den Überblick über viele Werte unterschiedlicher Typen behalten muss, und
es muss für jeden dieser unterschiedlich typisierten Werte eine Methode <code>draw</code>
aufrufen. Es muss nicht genau wissen, was passieren wird, wenn wir die Methode
<code>draw</code> aufrufen, sondern nur, dass der Wert diese Methode für uns zum Aufruf
bereithält.</p>
<p>Um dies in einer Sprache mit Vererbung zu tun, könnten wir eine Klasse namens
<code>Component</code> definieren, die eine Methode namens <code>draw</code> enthält. Die anderen
Klassen, z.B. <code>Button</code>, <code>Image</code> und <code>SelectBox</code>, würden von <code>Component</code> erben
und somit die Methode <code>draw</code> erben. Sie könnten jeweils die <code>draw</code>-Methode
überschreiben, um ihr eigenes Verhalten zu definieren, aber das
Programmiergerüst (framework) könnte alle Typen so behandeln, als wären sie
<code>Component</code>-Instanzen, und <code>draw</code> aufrufen. Aber da Rust keine Vererbung hat,
brauchen wir einen anderen Weg, die <code>gui</code>-Bibliothek zu strukturieren, damit
die Benutzer sie um neue Typen erweitern können.</p>
<h3><a class="header" href="#definieren-eines-merkmals-trait-für-allgemeines-verhalten" id="definieren-eines-merkmals-trait-für-allgemeines-verhalten">Definieren eines Merkmals (trait) für allgemeines Verhalten</a></h3>
<p>Um das Verhalten zu implementieren, das wir <code>gui</code> haben wollen, werden wir ein
Merkmal namens <code>Draw</code> definieren, die eine Methode namens <code>draw</code> haben wird.
Dann können wir einen Vektor definieren, der ein <em>Merkmalsobjekt</em> (trait
object) annimmt. Ein Merkmalsobjekt verweist sowohl auf eine Instanz eines
Typs, der die von uns spezifizierte Merkmal implementiert, als auch auf eine
Tabelle, in der Merkmalsmethoden dieses Typs zur Laufzeit nachgeschlagen werden
können. Wir erstellen ein Merkmalsobjekt, indem wir eine Art Zeiger angeben,
z.B. eine Referenz <code>&amp;</code> oder einen intelligenten Zeiger <code>Box&lt;T&gt;</code>, dann das
Schlüsselwort <code>dyn</code> und dann das relevante Merkmal. (Wir werden über den Grund,
warum Merkmalsobjekte einen Zeiger verwenden müssen, in Kapitel 19 im Abschnitt
<a href="ch19-04-advanced-types.html#dynamisch-gro%C3%9Fe-typen-und-das-merkmal-sized">„Dynamisch große Typen und das Merkmal <code>Sized</code>“</a>) sprechen.
Wir können Merkmalsobjekte an Stelle eines generischen oder konkreten Typs
verwenden. Wo immer wir ein Merkmalsobjekt verwenden, stellt Rusts Typsystem
zur Kompilierzeit sicher, dass jeder in diesem Kontext verwendete Wert das
Merkmal des Merkmalsobjekts implementiert. Folglich müssen wir zur
Kompilierzeit nicht alle möglichen Typen kennen.</p>
<p>Wir haben erwähnt, dass wir in Rust davon absehen, Strukturen (structs) und
Aufzählungen „Objekte“ zu nennen, um sie von den Objekten anderer Sprachen zu
unterscheiden. In einer Struktur oder Aufzählung sind die Daten in den
Struktur-Feldern vom Verhalten in <code>impl</code>-Blöcken getrennt, während in anderen
Sprachen die Daten und das Verhalten, die in einem Konzept zusammengefasst
sind, oft als ein Objekt bezeichnet werden. Merkmalsobjekte <em>sind</em> jedoch eher
wie Objekte in anderen Sprachen in dem Sinne, dass sie Daten und Verhalten
kombinieren. Aber Merkmalsobjekte unterscheiden sich von traditionellen
Objekten dadurch, dass wir einem Merkmalsobjekt keine Daten hinzufügen können.
Merkmalsobjekte sind nicht so allgemein einsetzbar wie Objekte in anderen
Sprachen: Ihr spezifischer Zweck besteht darin, Abstraktion über allgemeines
Verhalten zu ermöglichen.</p>
<p>In Codeblock 17-3 wird gezeigt, wie ein Merkmal namens <code>Draw</code> mit einer Methode
namens <code>draw</code> definiert werden kann:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-3: Definition des Merkmals <code>Draw</code></span></p>
<p>Diese Syntax sollte uns aus unseren Diskussionen über die Definition von
Merkmalen in Kapitel 10 bekannt vorkommen. Als nächstes kommt eine neue Syntax:
Codeblock 17-4 definiert eine Struktur namens <code>Screen</code>, die einen Vektor namens
<code>components</code> enthält. Dieser Vektor ist vom Typ <code>Box&lt;dyn Draw&gt;</code>, der ein
Merkmalsobjekt ist; er ist ein Stellvertreter für jeden Typ innerhalb einer
<code>Box</code>, der das Merkmal <code>Draw</code> implementiert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-4: Definition der Struktur <code>Screen</code> mit
einem Feld <code>components</code>, das einen Vektor von Merkmalsobjekten enthält, die das
<code>Draw</code>-Merkmal implementieren</span></p>
<p>Auf der Struktur <code>Screen</code> definieren wir eine Methode namens <code>run</code>, die die
<code>draw</code>-Methode auf jeder ihrer <code>components</code> aufruft, wie in Codeblock 17-5 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-5: Eine Methode <code>run</code> auf <code>Screen</code>, die die
<code>draw</code>-Methode jeder Komponente aufruft</span></p>
<p>Dies funktioniert anders als die Definition einer Struktur, die einen
generischen Typparameter mit Merkmalsabgrenzungen (trait bounds) verwendet. Ein
generischer Typparameter kann jeweils nur durch einen konkreten Typ ersetzt
werden, während Merkmalsobjekte die Möglichkeit bieten, zur Laufzeit mehrere
konkrete Typen für das Merkmalsobjekt einzusetzen. Beispielsweise hätten wir
die Struktur <code>Screen</code> mit einem generischen Typ und einer Merkmalsabgrenzung
wie in Codeblock 17-6 definieren können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-6: Eine alternative Implementierung der
Struktur <code>Screen</code> und ihrer <code>run</code>-Methode unter Verwendung generischer Typen
und Merkmalsabgrenzungen</span></p>
<p>Dies schränkt uns auf eine <code>Screen</code>-Instanz ein, die eine Liste von Komponenten
hat, die alle vom Typ <code>Button</code> oder alle vom Typ <code>TextField</code> sind. Wenn du
immer nur homogene Kollektionen haben wirst, ist das Verwenden von generischen
Typen und Merkmalsabgrenzungen vorzuziehen, da die Definitionen zur
Kompilierszeit monomorphisiert werden, um die konkreten Typen zu verwenden.</p>
<p>Andererseits kann bei der Methode mit Merkmalsobjekten eine <code>Screen</code>-Instanz
einen <code>Vec&lt;T&gt;</code> enthalten, der sowohl eine <code>Box&lt;Button&gt;</code> als auch eine
<code>Box&lt;TextField&gt;</code> enthält. Schauen wir uns an, wie dies funktioniert, und dann
werden wir über die Auswirkungen auf die Laufzeitperformanz sprechen.</p>
<h3><a class="header" href="#implementieren-des-merkmals" id="implementieren-des-merkmals">Implementieren des Merkmals</a></h3>
<p>Nun fügen wir einige Typen hinzu, die das Merkmal <code>Draw</code> implementieren. Wir
werden den Typ <code>Button</code> zur Verfügung stellen. Auch hier liegt die eigentliche
Implementierung einer GUI-Bibliothek jenseits des Rahmens dieses Buches, sodass
die <code>draw</code>-Methode keine nützliche Implementierung in ihrem Rumpf haben wird.
Um sich vorzustellen, wie die Implementierung aussehen könnte, könnte eine
Struktur <code>Button</code> Felder für <code>width</code>, <code>height</code> und <code>label</code> haben, wie in
Codeblock 17-7 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen einer Schaltfläche
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-7: Eine Struktur <code>Button</code>, die das Merkmal
<code>Draw</code> implementiert</span></p>
<p>Die Felder <code>width</code>, <code>height</code> und <code>label</code> in <code>Button</code> unterscheiden sich von den
Feldern anderer Komponenten, z.B. dem Typ <code>TextField</code>, die diese Felder und
zusätzlich ein <code>placeholder</code> haben könnte. Jeder der Typen, die wir auf dem
Bildschirm zeichnen wollen, wird das Merkmal <code>Draw</code> implementieren, aber
unterschiedlichen Code in der <code>draw</code>-Methode verwenden, um zu definieren, wie
dieser bestimmte Typ gezeichnet werden soll, wie es hier bei <code>Button</code> der Fall
ist (ohne den eigentlichen GUI-Code, der den Rahmen dieses Kapitels sprengt).
Der Typ <code>Button</code> könnte zum Beispiel einen zusätzlichen <code>impl</code>-Block haben, der
Methoden enthält, die sich darauf beziehen, was passiert, wenn ein Benutzer auf
die Schaltfläche klickt. Diese Art von Methoden trifft nicht auf Typen wie
<code>TextField</code> zu.</p>
<p>Wenn sich jemand, der unsere Bibliothek benutzt, dazu entschließt, eine
Struktur <code>SelectBox</code> zu implementieren, die die Felder <code>width</code>, <code>height</code> und
<code>options</code> enthält, implementiert er ebenfalls das Merkmal <code>Draw</code> für den Typ
<code>SelectBox</code>, wie in Codeblock 17-8 gezeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">Codeblock 17-8: Eine weitere Kiste, die <code>gui</code> verwendet
und das Merkmal <code>Draw</code> auf einer <code>SelectBox</code>-Struktur implementiert</span></p>
<p>Der Benutzer unserer Bibliothek kann nun seine Funktion <code>main</code> schreiben, um
eine <code>Screen</code>-Instanz zu erzeugen. Der <code>Screen</code>-Instanz kann er eine
<code>SelectBox</code> und einen <code>Button</code> hinzufügen, indem er jede in eine <code>Box&lt;T&gt;</code>
setzt, um ein Merkmalsobjekt zu werden. Er kann dann die <code>run</code>-Methode auf der
<code>Screen</code>-Instanz aufrufen, die dann <code>draw</code> auf jeder der Komponenten aufruft.
Der Codeblock 17-9 zeigt diese Umsetzung:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // Code zum tatsächlichen Zeichnen eines Auswahlfeldes
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Ja&quot;),
                    String::from(&quot;Vielleicht&quot;),
                    String::from(&quot;Nein&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Codeblock 17-9: Verwenden von Merkmalsobjekten zum
Speichern von Werten verschiedener Typen, die das gleiche Merkmal
implementieren</span></p>
<p>Als wir die Bibliothek schrieben, wussten wir nicht, dass jemand den Typ
<code>SelectBox</code> hinzufügen könnte, aber unsere <code>Screen</code>-Implementierung war in der
Lage, mit dem neuen Typ umzugehen und ihn zu zeichnen, weil <code>SelectBox</code> das
Merkmal <code>Draw</code> implementiert, was bedeutet, dass sie die <code>draw</code>-Methode
implementiert.</p>
<p>Dieses Konzept – sich nur mit den Nachrichten zu befassen, auf die ein
Wert reagiert, und nicht mit dem konkreten Typ des Wertes – ähnelt dem
Konzept des <em>Duck-Typing</em> in dynamisch typisierten Sprachen: Wenn es wie eine
Ente läuft und wie eine Ente quakt, dann muss es eine Ente sein! Bei der
Implementierung von <code>run</code> auf <code>Screen</code> in Codeblock 17-5 braucht <code>run</code> nicht zu
wissen, was der konkrete Typ jeder Komponente ist. Es prüft nicht, ob eine
Komponente eine Instanz eines <code>Buttons</code> oder einer <code>SelectBox</code> ist, es ruft nur
die <code>draw</code>-Methode auf der Komponente auf. Durch die Spezifikation von
<code>Box&lt;dyn Draw&gt;</code> als Typ der Werte im <code>components</code>-Vektor haben wir <code>Screen</code> so
definiert, dass wir Werte benötigen, auf denen wir die <code>draw</code>-Methode aufrufen
können.</p>
<p>Der Vorteil der Verwendung von Merkmalsobjekten und des Rust-Typsystems zum
Schreiben von Code, der dem Code mit Duck-Typing ähnelt, besteht darin, dass
wir nie prüfen müssen, ob ein Wert eine bestimmte Methode zur Laufzeit
implementiert, oder uns Sorgen machen müssen, Fehler zu bekommen, wenn ein Wert
eine Methode nicht implementiert, wir sie aber trotzdem aufrufen. Rust wird
unseren Code nicht kompilieren, wenn die Werte nicht die Merkmale
implementieren, die die Merkmalsobjekte benötigen.</p>
<p>Beispielsweise zeigt Codeblock 17-10, was passiert, wenn wir versuchen, einen
<code>Screen</code> mit einem <code>String</code> als Komponente zu erstellen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hallo&quot;))],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Codeblock 17-10: Versuch, einen Typ zu verwenden, der das
Merkmal des Merkmalsobjekts nicht implementiert</span></p>
<p>Wir werden diesen Fehler erhalten, weil <code>String</code> das Merkmal <code>Draw</code> nicht
implementiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hallo&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Draw` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Draw`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieser Fehler lässt uns wissen, dass wir entweder etwas an <code>Screen</code> übergeben,
das wir nicht übergeben wollten und einen anderen Typ übergeben sollten, oder
wir sollten <code>Draw</code> auf <code>String</code> implementieren, sodass <code>Screen</code> in der Lage
ist, <code>Draw</code> darauf aufzurufen.</p>
<h3><a class="header" href="#merkmalsobjekte-führen-dynamischen-aufruf-durch" id="merkmalsobjekte-führen-dynamischen-aufruf-durch">Merkmalsobjekte führen dynamischen Aufruf durch</a></h3>
<p>Erinnere dich im Abschnitt <a href="ch10-01-syntax.html#code-performanz-beim-verwenden-generischer-datentypen">„Code-Performanz beim Verwenden generischer
Datentypen“</a> in Kapitel 10 an unsere
Diskussion über den Monomorphisierungsprozess, den der Compiler durchführt,
wenn wir bei generischen Typen Merkmalsabgrenzungen verwenden: Der Compiler
generiert nicht-generische Implementierungen von Funktionen und Methoden für
jeden konkreten Typ, den wir anstelle eines generischen Typparameters
verwenden. Der Code, der sich aus der Monomorphisierung ergibt, macht
<em>statische Aufrufe</em> (static dispatch), d.h. wenn der Compiler weiß, welche
Methode du zur Kompilierzeit aufrufst. Dies steht im Gegensatz zum <em>dynamischen
Aufruf</em> (dynamic dispatch), bei dem der Compiler zur Kompilierzeit nicht weiß,
welche Methode du aufrufst. In Fällen von dynamischem Aufruf erzeugt der
Compiler Code, der zur Laufzeit herausfindet, welche Methode aufzurufen ist.</p>
<p>Wenn wir Merkmalsobjekte verwenden, muss Rust dynamische Aufrufe verwenden. Der
Compiler kennt nicht alle Typen, die mit dem Code verwendet werden könnten, der
Merkmalsobjekte verwendet, sodass er nicht weiß, welche Methode auf welchem Typ
implementiert ist, um sie aufzurufen. Stattdessen verwendet Rust zur Laufzeit
die Zeiger innerhalb des Merkmalsobjekts, um zu wissen, welche Methode
aufgerufen werden soll. Durch dieses Nachschlagen entstehen Laufzeitkosten, die
beim statischen Aufruf nicht anfallen. Der dynamische Aufruf verhindert auch,
dass der Compiler sich dafür entscheiden kann, den Code einer Methode inline zu
verwenden, was wiederum einige Optimierungen verhindert. Wir haben jedoch
zusätzliche Flexibilität im Code erhalten, den wir in Codeblock 17-5
geschrieben haben und in Codeblock 17-9 unterstützen konnten, sodass es sich um
einen Kompromiss handelt, den es zu berücksichtigen gilt.</p>
<h3><a class="header" href="#objektsicherheit-ist-für-merkmalsobjekte-erforderlich" id="objektsicherheit-ist-für-merkmalsobjekte-erforderlich">Objektsicherheit ist für Merkmalsobjekte erforderlich</a></h3>
<p>Du kannst nur <em>objektsichere</em> (object-safe) Merkmale zu Merkmalsobjekten
machen. Einige komplexe Regeln bestimmen alle Eigenschaften, die ein
Merkmalsobjekt sicher machen, aber in der Praxis sind nur zwei Regeln relevant.
Ein Merkmal ist objektsicher, wenn alle im Merkmal definierten Methoden die
folgenden Eigenschaften haben:</p>
<ul>
<li>Der Rückgabetyp ist nicht <code>Self</code>.</li>
<li>Es gibt keine generischen Typparameter.</li>
</ul>
<p>Das Schlüsselwort <code>Self</code> ist ein Alias für den Typ, auf dem wir das Merkmal
oder Methoden implementieren. Merkmalsobjekte müssen objektsicher sein, denn
sobald du ein Merkmalsobjekt verwendet hast, kennt Rust nicht mehr den
konkreten Typ, der dieses Merkmal implementiert. Wenn eine Merkmalsmethode den
konkreten <code>Self</code>-Typ zurückgibt, aber ein Merkmalsobjekt den genauen Typ
vergisst, der <code>Self</code> ist, gibt es keine Möglichkeit, dass die Methode den
ursprünglichen konkreten Typ verwenden kann. Dasselbe gilt für generische
Typparameter, die bei der Verwendung des Merkmals mit konkreten Typparametern
ausgefüllt werden: Die konkreten Typen werden Teil des Typs, der das Merkmal
implementiert. Wenn der Typ durch das Verwenden eines Merkmalsobjekts vergessen
wird, gibt es keine Möglichkeit zu wissen, mit welchen Typen die generischen
Typparameter zu füllen sind.</p>
<p>Ein Beispiel für ein Merkmal, dessen Methoden nicht objektsicher sind, ist das
Merkmal <code>Clone</code> der Standardbibliothek. Die Signatur für die Methode <code>clone</code> im
Merkmal <code>Clone</code> sieht wie folgt aus:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Der Typ <code>String</code> implementiert das Merkmal <code>Clone</code>, und wenn wir die Methode
<code>clone</code> auf einer Instanz von <code>String</code> aufrufen, erhalten wir eine Instanz von
<code>String</code> zurück. In ähnlicher Weise erhalten wir eine Instanz von <code>Vec&lt;T&gt;</code>
zurück, wenn wir die Methode <code>clone</code> für eine Instanz von <code>Vec&lt;T&gt;</code> aufrufen.
Die Signatur von <code>clone</code> muss wissen, welcher Typ für <code>Self</code> steht, denn das
ist der Rückgabetyp.</p>
<p>Der Compiler zeigt an, wenn du versuchst, etwas zu tun, das gegen die Regeln
der Objektsicherheit in Bezug auf Merkmalsobjekte verstößt. Nehmen wir zum
Beispiel an, wir würden versuchen, die Struktur <code>Screen</code> in Codeblock 17-4 zu
implementieren, um Typen zu halten, die das Merkmal <code>Clone</code> statt dem Merkmal
<code>Draw</code> implementieren, so wie hier:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Wir würden diesen Fehler bekommen:</p>
<pre><code class="language-console">$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieser Fehler bedeutet, dass du dieses Merkmal auf diese Weise nicht als
Merkmalsobjekt verwenden kannst. Wenn du an weiteren Details zur
Objektsicherheit interessiert sind, lies <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<h2><a class="header" href="#ein-objektorientiertes-entwurfsmuster-implementieren" id="ein-objektorientiertes-entwurfsmuster-implementieren">Ein objektorientiertes Entwurfsmuster implementieren</a></h2>
<p>Das <em>Zustandsmuster</em> (state pattern) ist ein objektorientiertes Entwurfsmuster.
Der springende Punkt des Musters ist, dass ein Wert einen internen Zustand hat,
der durch eine Menge von <em>Zustandsobjekten</em> (state objects) repräsentiert wird,
und dass sich das Verhalten des Wertes auf der Grundlage des internen Zustands
ändert. Die Zustandsobjekte haben eine gemeinsame Funktionalität: In Rust
verwenden wir Strukturen (structs) und Merkmale (traits) und nicht Objekte und
Vererbung. Jedes Zustandsobjekt ist für sein eigenes Verhalten verantwortlich
und bestimmt, wann es in einen anderen Zustand übergehen soll. Der Wert, der
ein Zustandsobjekt enthält, weiß nichts über das unterschiedliche Verhalten der
Zustände oder den Zeitpunkt des Übergangs zwischen den Zuständen.</p>
<p>Die Verwendung des Zustandsmusters bedeutet, dass wir, wenn sich die
Geschäftsanforderungen des Programms ändern, weder den Code des Wertes, der den
Zustand hält, noch den Code, der den Wert verwendet, ändern müssen. Wir müssen
nur den Code innerhalb eines der Zustandsobjekte aktualisieren, um seine Regeln
zu ändern oder vielleicht weitere Zustandsobjekte hinzufügen. Sehen wir uns ein
Beispiel für das Zustandsentwurfsmuster und seine Verwendung in Rust an.</p>
<p>Wir werden einen Blog-Beitrags-Workflow inkrementell implementieren. Die finale
Funktionalität des Blogs wird wie folgt aussehen:</p>
<ol>
<li>Ein Blog-Beitrag (post) beginnt als leerer Entwurf.</li>
<li>Wenn der Entwurf fertig ist, wird um eine Überprüfung des Beitrags gebeten.</li>
<li>Wenn der Beitrag genehmigt ist, wird er veröffentlicht.</li>
<li>Nur veröffentlichte Blog-Beiträge geben anzuzeigenden Inhalt zurück, sodass
nicht genehmigte Beiträge nicht versehentlich veröffentlicht werden können.</li>
</ol>
<p>Alle anderen Änderungen, die an einem Beitrag versucht werden, sollten keine
Auswirkungen haben. Wenn wir zum Beispiel versuchen, den Entwurf eines
Blog-Beitrags zu genehmigen, bevor wir eine Überprüfung beantragt haben, sollte
der Beitrag ein unveröffentlichter Entwurf bleiben.</p>
<p>Codeblock 17-11 zeigt diesen Workflow in Codeform: Dies ist eine
Beispielverwendung der API, die wir in einer Bibliothekskiste (library crate)
<code>blog</code> implementieren werden. Dieser Code wird sich noch nicht kompilieren
lassen, da wir die Kiste (crate) <code>blog</code> noch nicht implementiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
}
</code></pre>
<p><span class="caption">Codeblock 17-11: Code, der das gewünschte Verhalten
demonstriert, das wir für unsere Kiste <code>blog</code> haben wollen</span></p>
<p>Wir möchten dem Benutzer erlauben, einen neuen Entwurf eines Blog-Beitrags mit
<code>Post::new</code> zu erstellen. Dann möchten wir dem Blog-Beitrag erlauben, Text
hinzuzufügen, während er sich im Entwurfszustand befindet. Wenn wir versuchen,
den Inhalt des Beitrags sofort, vor der Genehmigung, zu erhalten, sollte nichts
passieren, weil der Beitrag noch ein Entwurf ist. Wir haben zu
Demonstrationszwecken <code>assert_eq!</code> in den Code eingefügt. Ein ausgezeichneter
Unit-Test dafür wäre die Zusicherung, dass ein Entwurf eines Blog-Beitrags eine
leere Zeichenkette aus der Methode <code>content</code> zurückgibt, aber wir werden für
dieses Beispiel keine Tests schreiben.</p>
<p>Als nächstes wollen wir einen Antrag auf Überprüfung des Beitrags ermöglichen
und wir wollen, dass <code>content</code> eine leere Zeichenkette zurückgibt, solange wir
auf die Überprüfung warten. Wenn der Beitrag die Genehmigung erhält, soll er
veröffentlicht werden, d.h. der Text des Beitrags wird zurückgegeben, wenn
<code>content</code> aufgerufen wird.</p>
<p>Beachte, dass der einzige Typ, mit dem wir von der Kiste aus interagieren, der
<code>Post</code>-Typ ist. Dieser Typ verwendet das Zustandsmuster und enthält einen Wert,
der eines von drei Zustandsobjekten ist, die die verschiedenen Zustände
repräsentieren, in denen sich ein Beitrag im Entwurf befinden, auf eine
Überprüfung warten oder veröffentlicht werden kann. Der Wechsel von einem
Zustand in einen anderen wird intern innerhalb des <code>Post</code>-Typs verwaltet. Die
Zustände ändern sich als Reaktion auf die Methoden, die von den Benutzern
unserer Bibliothek auf der <code>Post</code>-Instanz aufgerufen werden, aber sie müssen
die Zustandsänderungen nicht direkt verwalten. Auch können die Benutzer keinen
Fehler mit den Zuständen machen, z.B. einen Beitrag veröffentlichen, bevor er
überprüft wurde.</p>
<h3><a class="header" href="#definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand" id="definieren-von-post-und-erstellen-einer-neuen-instanz-im-entwurfszustand">Definieren von <code>Post</code> und Erstellen einer neuen Instanz im Entwurfszustand</a></h3>
<p>Fangen wir mit der Implementierung der Bibliothek an! Wir wissen, dass wir eine
öffentliche Struktur <code>Post</code> benötigen, die einige Inhalte enthält, also
beginnen wir mit der Definition der Struktur und einer zugehörigen öffentlichen
Funktion <code>new</code>, um eine Instanz von <code>Post</code> zu erzeugen, wie in Codeblock 17-12
gezeigt. Wir werden auch ein privates Merkmal <code>State</code> anlegen. Dann wird <code>Post</code>
ein Merkmalsobjekt (trait object) von <code>Box&lt;dyn State&gt;</code> innerhalb einer
<code>Option&lt;T&gt;</code> in einem privaten Feld namens <code>state</code> halten. Du wirst gleich
sehen, warum die <code>Option&lt;T&gt;</code> notwendig ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-12: Definition einer Struktur <code>Post</code> und
einer Funktion <code>new</code>, die eine neue <code>Post</code>-Instanz erzeugt, einem Merkmal
<code>State</code> und einer Struktur <code>Draft</code></span></p>
<p>Das Merkmal <code>State</code> definiert das Verhalten, das die verschiedenen
Beitragszustände gemeinsam haben, und die Zustände <code>Draft</code>, <code>PendingReview</code> und
<code>Published</code> implementieren alle das Merkmal <code>State</code>. Im Moment hat das Merkmal
noch keine Methoden und wir werden damit beginnen, nur den Zustand <code>Draft</code> zu
definieren, weil das der Zustand ist, in dem ein Beitrag beginnen soll.</p>
<p>Wenn wir einen neuen <code>Post</code> erstellen, setzen wir sein <code>state</code>-Feld auf einen
<code>Some</code>-Wert, der eine <code>Box</code> enthält. Diese <code>Box</code> verweist auf eine neue Instanz
der Struktur <code>Draft</code>. Dies stellt sicher, dass jedes Mal, wenn wir eine neue
Instanz von <code>Post</code> erzeugen, diese als Entwurf beginnt. Da das Feld <code>state</code> von
<code>Post</code> privat ist, gibt es keine Möglichkeit, einen <code>Post</code> in einem anderen
Zustand zu erzeugen! In der Funktion <code>Post::new</code> setzen wir das Feld <code>content</code>
auf einen neuen, leeren <code>String</code>.</p>
<h3><a class="header" href="#speichern-des-textes-des-beitragsinhalts" id="speichern-des-textes-des-beitragsinhalts">Speichern des Textes des Beitragsinhalts</a></h3>
<p>Codeblock 17-11 zeigte, dass wir in der Lage sein wollen, eine Methode namens
<code>add_text</code> aufzurufen und ihr einen <code>&amp;str</code> zu übergeben, die dann dem
Textinhalt des Blog-Beitrags hinzugefügt wird. Wir implementieren dies als
Methode, anstatt das Feld <code>content</code> mit <code>pub</code> offenzulegen. Das bedeutet, dass
wir später eine Methode implementieren können, die steuert, wie die Daten des
Feldes <code>content</code> gelesen werden. Die Methode <code>add_text</code> ist ziemlich einfach,
also lass uns die Implementierung in Codeblock 17-13 zum Block <code>impl Post</code>
hinzufügen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-13: Implementierung der Methode <code>add_text</code>
zum Hinzufügen von Text zum <code>content</code> eines Beitrags</span></p>
<p>Die Methode <code>add_text</code> nimmt eine veränderliche Referenz auf <code>self</code>, weil wir
die <code>Post</code>-Instanz, auf der wir <code>add_text</code> aufrufen, ändern. Dann rufen wir
<code>push_str</code> auf den <code>String</code> in <code>content</code> auf und übergeben das Argument <code>text</code>,
um es zum gespeicherten <code>content</code> hinzuzufügen. Dieses Verhalten hängt nicht
vom Zustand ab, in dem sich der Beitrag befindet, es ist also nicht Teil des
Zustandsmusters. Die Methode <code>add_text</code> interagiert überhaupt nicht mit dem
Feld <code>state</code>, aber sie ist Teil des Verhaltens, das wir unterstützen wollen.</p>
<h3><a class="header" href="#sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist" id="sicherstellen-dass-der-inhalt-eines-beitragsentwurfs-leer-ist">Sicherstellen, dass der Inhalt eines Beitragsentwurfs leer ist</a></h3>
<p>Selbst nachdem wir <code>add_text</code> aufgerufen und unserem Beitrag etwas Inhalt
hinzugefügt haben, wollen wir immer noch, dass die Methode <code>content</code> einen
leeren Zeichenkettenanteilstyp (string slice) zurückgibt, weil sich der Beitrag
noch im Entwurfszustand befindet, wie in Zeile 7 von Codeblock 17-11 gezeigt
wird. Lass uns fürs Erste die <code>content</code>-Methode mit der einfachsten Sache
implementieren, die diese Anforderung erfüllt: Immer einen leeren
Zeichenkettenanteilstyp zurückgeben. Wir werden dies später ändern, sobald wir
die Möglichkeit implementiert haben, den Zustand eines Beitrags zu ändern,
damit er veröffentlicht werden kann. Bislang können Beiträge nur im
Entwurfszustand sein, daher sollte der Beitragsinhalt immer leer sein.
Codeblock 17-14 zeigt diese Platzhalter-Implementierung:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-14: Hinzufügen einer
Platzhalter-Implementierung für die <code>content</code>-Methode auf <code>Post</code>, die immer
einen leeren Zeichenkettenanteilstyp zurückgibt</span></p>
<p>Mit dieser zusätzlichen Methode <code>content</code> funktioniert alles in Codeblock 17-11
bis hin zu Zeile 7 wie beabsichtigt.</p>
<h3><a class="header" href="#antrag-auf-Überprüfung-des-beitrags-ändert-seinen-zustand" id="antrag-auf-Überprüfung-des-beitrags-ändert-seinen-zustand">Antrag auf Überprüfung des Beitrags ändert seinen Zustand</a></h3>
<p>Als nächstes müssen wir eine Funktionalität hinzufügen, um eine Überprüfung
eines Beitrags zu beantragen, die seinen Zustand von <code>Draft</code> in <code>PendingReview</code>
ändern sollte. Codeblock 17-15 zeigt diesen Code:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-15: Implementierung der Methoden
<code>request_review</code> für <code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir geben <code>Post</code> eine öffentliche Methode namens <code>request_review</code>, die eine
veränderliche Referenz auf <code>self</code> nimmt. Dann rufen wir eine interne
<code>request_review</code>-Methode über den aktuellen Zustand von <code>Post</code> auf und diese
zweite <code>request_review</code>-Methode konsumiert den aktuellen Zustand und gibt einen
neuen Zustand zurück.</p>
<p>Wir haben die Methode <code>request_review</code> zum Merkmal <code>State</code> hinzugefügt; alle
Typen, die das Merkmal implementieren, müssen nun die Methode <code>request_review</code>
implementieren. Beachte, dass wir statt <code>self</code>, <code>&amp;self</code> oder <code>&amp;mut self</code> als
ersten Parameter der Methode <code>self: Box&lt;Self&gt;</code> haben. Diese Syntax bedeutet,
dass die Methode nur gültig ist, wenn sie auf einer <code>Box</code> mit dem Typ
aufgerufen wird. Diese Syntax übernimmt die Eigentümerschaft von <code>Box&lt;Self&gt;</code>,
wodurch der alte Zustand ungültig wird, sodass der Zustandswert von <code>Post</code> in
einen neuen Zustand transformiert werden kann.</p>
<p>Um den alten Zustand zu konsumieren, muss die <code>request_review</code>-Methode die
Eigentümerschaft des Zustandswerts übernehmen. Hier kommt die <code>Option</code> im Feld
<code>state</code> von <code>Post</code> ins Spiel: Wir rufen die Methode <code>take</code> auf, um den
<code>Some</code>-Wert aus dem <code>state</code>-Feld zu nehmen und an seiner Stelle ein <code>None</code> zu
hinterlassen, weil Rust es nicht zulässt, dass wir unbestückte Felder in
Strukturen haben. Dadurch können wir den Wert <code>state</code> aus <code>Post</code> herausnehmen,
anstatt ihn auszuleihen. Dann setzen wir den Wert <code>state</code> des Beitrags auf das
Ergebnis dieser Operation.</p>
<p>Wir müssen <code>state</code> vorübergehend auf <code>None</code> setzen, anstatt es direkt mit Code
wie <code>self.state = self.state.request_review();</code> zu setzen, um die
Eigentümerschaft des <code>state</code>-Wertes zu erhalten. Das stellt sicher, dass <code>Post</code>
nicht den alten <code>state</code>-Wert verwenden kann, nachdem wir ihn in einen neuen
Zustand transformiert haben.</p>
<p>Die Methode <code>request_review</code> auf <code>Draft</code> muss eine neue, in einer Box
gespeicherte Instanz einer neuen <code>PendingReview</code>-Struktur zurückgeben, die den
Zustand darstellt, in dem ein Beitrag auf eine Überprüfung wartet. Die Struktur
<code>PendingReview</code> implementiert auch die Methode <code>request_review</code>, führt aber
keine Transformationen durch. Vielmehr gibt sie sich selbst zurück, denn wenn
wir eine Überprüfung für einen Beitrag anfordern, der sich bereits im
<code>PendingReview</code>-Zustand befindet, sollte er im <code>PendingReview</code>-Zustand bleiben.</p>
<p>Jetzt können wir anfangen, die Vorteile des Zustandsmusters zu erkennen: Die
Methode <code>request_review</code> auf <code>Post</code> ist die gleiche, unabhängig von ihrem
<code>state</code>-Wert. Jeder Zustand ist für seine eigenen Regeln verantwortlich.</p>
<p>Wir lassen die Methode <code>content</code> auf <code>Post</code> so wie sie ist und geben einen
leeren Zeichenkettenanteilstyp zurück. Wir können jetzt einen <code>Post</code> sowohl im
Zustand <code>PendingReview</code> als auch im Zustand <code>Draft</code> haben, aber wir wollen das
gleiche Verhalten im Zustand <code>PendingReview</code>. Codeblock 17-11 funktioniert
jetzt bis Zeile 10!</p>
<h3><a class="header" href="#hinzufügen-der-methode-approve-die-das-verhalten-von-content-ändert" id="hinzufügen-der-methode-approve-die-das-verhalten-von-content-ändert">Hinzufügen der Methode <code>approve</code>, die das Verhalten von <code>content</code> ändert</a></h3>
<p>Die Methode <code>approve</code> ähnelt der Methode <code>request_review</code>: Sie setzt den
<code>state</code> auf den Wert, den der aktuelle Zustand nach der Genehmigung haben
sollte, wie in Codeblock 17-16 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-16: Implementierung der Methode <code>approve</code>
bei <code>Post</code> und des Merkmals <code>State</code></span></p>
<p>Wir fügen die Methode <code>approve</code> zum Merkmal <code>State</code> hinzu und fügen eine neue
Struktur <code>State</code> hinzu, die den Zustand <code>Published</code> implementiert.</p>
<p>Ähnlich wie bei <code>request_review</code>, wenn wir die Methode <code>approve</code> auf einem
<code>Draft</code> aufrufen, wird sie keine Wirkung haben, weil sie <code>self</code> zurückgibt.
Wenn wir die Methode <code>approve</code> bei <code>PendingReview</code> aufrufen, gibt sie eine
neue, geschlossene Instanz der Struktur <code>Published</code> zurück. Die Struktur
<code>Published</code> implementiert das Merkmal <code>State</code> und sowohl bei der Methode
<code>request_review</code> als auch bei der Methode <code>approve</code> gibt sie sich selbst
zurück, weil der Beitrag in diesen Fällen im Zustand <code>Published</code> bleiben
sollte.</p>
<p>Jetzt müssen wir die Methode <code>content</code> auf <code>Post</code> aktualisieren: Wenn der
Zustand <code>Published</code> ist, wollen wir den Wert im Feld <code>content</code> des Beitrags
zurückgeben; andernfalls wollen wir einen leeren Zeichenkettenanteilstyp
zurückgeben, wie in Codeblock 17-17 gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --abschneiden--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-17: Aktualisieren der Methode <code>content</code> auf
<code>Post</code> zum Delegieren an eine Methode <code>content</code> auf <code>State</code></span></p>
<p>Da das Ziel darin besteht, all diese Regeln innerhalb der Strukturen zu halten,
die <code>State</code> implementieren, rufen wir eine Methode <code>content</code> auf dem Wert in
<code>state</code> auf und übergeben die Post-Instanz (d.h. <code>self</code>) als Argument. Dann
geben wir den Wert zurück, der von der Verwendung der Methode <code>content</code> für den
<code>state</code>-Wert zurückgegeben wird.</p>
<p>Wir rufen die Methode <code>as_ref</code> auf <code>Option</code> auf, weil wir eine Referenz auf den
Wert innerhalb <code>Option</code> wollen und nicht die Eigentümerschaft am Wert. Weil
<code>State</code> eine <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> ist, wird beim Aufruf von <code>as_ref</code> eine
<code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> zurückgegeben. Würden wir nicht <code>as_ref</code> aufrufen,
bekämen wir einen Fehler, weil wir <code>state</code> nicht aus dem ausgeliehenen <code>&amp;self</code>
im Funktionsparameter herausverschieben können.</p>
<p>Wir rufen dann die <code>unwrap</code>-Methode auf, von der wir wissen, dass sie das
Programm niemals abstürzen lassen wird, weil wir wissen, dass die Methoden auf
<code>Post</code> sicherstellen, dass <code>state</code> stets einen <code>Some</code>-Wert enthält, wenn diese
Methoden zu Ende sind. Dies ist einer der Fälle, über die wir im Abschnitt
<a href="ch09-03-to-panic-or-not-to-panic.html#f%C3%A4lle-in-denen-du-mehr-informationen-als-der-compiler-hast">„Fälle, in denen du mehr Informationen als der Compiler
hast“</a> in Kapitel 9 gesprochen haben, wenn wir wissen,
dass ein <code>None</code>-Wert niemals möglich ist, obwohl der Compiler nicht in der Lage
ist, das zu verstehen.</p>
<p>Wenn wir nun <code>content</code> auf der <code>&amp;Box&lt;dyn State&gt;</code> aufrufen, wird eine
automatische Umwandlung (deref coercion) auf <code>&amp;</code> und <code>Box</code> stattfinden, sodass
die <code>content</code>-Methode letztlich auf dem Typ aufgerufen wird, der das Merkmal
<code>State</code> implementiert. Das bedeutet, dass wir die Definition des Merkmals
<code>State</code> um <code>content</code> erweitern müssen, und hier werden wir die Logik dafür
unterbringen, welcher Inhalt je nach Zustand zurückgegeben wird, wie in
Codeblock 17-18 gezeigt wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --abschneiden--
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;

    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --abschneiden--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-18: Hinzufügen der Methode <code>content</code> zum
Merkmal <code>State</code></span></p>
<p>Wir fügen eine Standard-Implementierung für die Methode <code>content</code> hinzu, die
einen leeren Zeichenkettenanteilstyp zurückgibt. Das bedeutet, dass wir
<code>content</code> in den Strukturen <code>Draft</code> und <code>PendingReview</code> nicht implementieren
müssen. Die Struktur <code>Published</code> überschreibt die Methode <code>content</code> und gibt
den Wert in <code>post.content</code> zurück.</p>
<p>Beachte, dass wir Lebensdauer-Annotationen bei dieser Methode benötigen, wie
wir in Kapitel 10 besprochen haben. Wir nehmen eine Referenz auf ein <code>post</code> als
Argument und geben eine Referenz auf einen Teil dieses <code>post</code> zurück, sodass
die Lebensdauer der zurückgegebenen Referenz mit der Lebensdauer des
<code>post</code>-Arguments zusammenhängt.</p>
<p>Und wir sind fertig – der Codeblock 17-11 funktioniert jetzt! Wir haben
das Zustandsmuster mit den Regeln des Blog-Beitrags-Workflows implementiert.
Die Logik, die sich auf die Regeln bezieht, lebt in den Zustandsobjekten und
ist nicht über den gesamten <code>Post</code> verstreut.</p>
<h3><a class="header" href="#kompromisse-des-zustandsmusters" id="kompromisse-des-zustandsmusters">Kompromisse des Zustandsmusters</a></h3>
<p>Wir haben gezeigt, dass Rust in der Lage ist, das objektorientierte
Zustandsmuster zu implementieren, um die verschiedenen Verhaltensweisen, die
ein Beitrag im jeweiligen Zustand haben sollte, zu kapseln. Die Methoden auf
<code>Post</code> wissen nichts über die verschiedenen Verhaltensweisen. So, wie wir den
Code organisiert haben, müssen wir nur an einem einzigen Ort suchen, um zu
wissen, wie sich ein veröffentlichter Beitrag verhalten kann: Die
Implementierung des Merkmals <code>State</code> auf der Struktur <code>Published</code>.</p>
<p>Wenn wir eine alternative Implementierung erstellen würden, die nicht das
Zustandsmuster verwendet, könnten wir stattdessen <code>match</code>-Ausdrücke in den
Methoden auf <code>Post</code> oder sogar im <code>main</code>-Code verwenden, die den Zustand des
Beitrags überprüfen und das Verhalten an diesen Stellen ändern. Das würde
bedeuten, dass wir an mehreren Stellen nachschauen müssten, um alle
Auswirkungen eines Beitrags im veröffentlichten Zustand zu verstehen! Dies
würde sich nur noch erhöhen, je mehr Zustände wir hinzufügen: Jeder dieser
<code>match</code>-Ausdrücke würde einen weiteren Zweig benötigen.</p>
<p>Mit dem Zustandsmuster, den <code>Post</code>-Methoden und den Stellen, an denen wir
<code>Post</code> verwenden, brauchen wir keine <code>match</code>-Ausdrücke, und um einen neuen
Zustand hinzuzufügen, müssten wir nur eine neue Struktur hinzufügen und die
Merkmalsmethoden auf dieser einen Struktur implementieren.</p>
<p>Die Implementierung unter Verwendung des Zustandsmusters ist leicht zu
erweitern, um weitere Funktionalität hinzuzufügen. Um zu sehen, wie einfach es
ist, Code zu pflegen, der das Zustandsmuster verwendet, probiere einige dieser
Vorschläge aus:</p>
<ul>
<li>Füge eine <code>reject</code>-Methode hinzu, die den Zustand des Beitrags von
<code>PendingReview</code> zurück zu <code>Draft</code> ändert.</li>
<li>Verlange zwei <code>approve</code>-Aufrufe, bevor der Zustand in <code>Published</code> geändert
werden kann.</li>
<li>Erlaube Benutzern das Hinzufügen von Textinhalten nur dann, wenn sich ein
Beitrag im Zustand <code>Draft</code> befindet. Hinweis: Lasse das Zustandsobjekt dafür
verantwortlich sein, was sich am Inhalt ändern könnte, aber nicht für die
Änderung des Beitrags.</li>
</ul>
<p>Ein Nachteil des Zustandsmusters besteht darin, dass einige der Zustände
miteinander gekoppelt sind, weil die Zustände die Übergänge zwischen den
Zuständen implementieren. Wenn wir einen weiteren Zustand zwischen
<code>PendingReview</code> und <code>Published</code> hinzufügen, z.B. <code>Scheduled</code>, müssten wir den
Code in <code>PendingReview</code> ändern und stattdessen zu <code>Scheduled</code> übergehen. Es
wäre weniger Arbeit, wenn <code>PendingReview</code> nicht mit dem Hinzufügen eines neuen
Zustands geändert werden müsste, aber das würde bedeuten, zu einem anderen
Entwurfsmuster zu wechseln.</p>
<p>Ein weiterer Nachteil ist, dass wir eine gewisse Logik dupliziert haben. Um
einen Teil der Duplikation zu eliminieren, könnten wir versuchen,
Standard-Implementierungen für die Methoden <code>request_review</code> und <code>approval</code> für
das Merkmal <code>State</code> zu erstellen, die <code>self</code> zurückgeben; dies würde jedoch die
Objektsicherheit verletzen, da das Merkmal nicht weiß, was das konkrete <code>self</code>
genau sein wird. Wir wollen in der Lage sein, <code>State</code> als Merkmalsobjekt zu
verwenden, deshalb müssen seine Methoden objektsicher sein.</p>
<p>Eine weitere Duplikation sind die ähnlichen Implementierungen der Methoden
<code>request_review</code> und <code>approve</code> auf <code>Post</code>. Beide Methoden delegieren die
Implementierung der gleichen Methode auf den Wert im Feld <code>state</code> von <code>Option</code>
und setzen den neuen Wert des Feldes <code>state</code> auf das Ergebnis. Wenn wir eine
Menge Methoden auf <code>Post</code> hätten, die diesem Muster folgen, könnten wir in
Erwägung ziehen, ein Makro zu definieren, um die Wiederholung zu eliminieren
(siehe den Abschnitt <a href="ch19-06-macros.html">„Makros“</a> in Kapitel 19).</p>
<p>Indem wir das Zustandsmuster genau so implementieren, wie es für
objektorientierte Sprachen definiert ist, nutzen wir die Stärken Rusts nicht so
aus, wie wir es könnten. Sehen wir uns einige Änderungen an, die wir an der
Kiste <code>blog</code> vornehmen können, die ungültige Zustände und Übergänge in
Kompilierzeitfehler verwandeln können.</p>
<h4><a class="header" href="#kodieren-von-zuständen-und-verhalten-als-typen" id="kodieren-von-zuständen-und-verhalten-als-typen">Kodieren von Zuständen und Verhalten als Typen</a></h4>
<p>Wir werden dir zeigen, wie du das Zustandsmuster überdenken kannst, um andere
Kompromisse zu erzielen. Anstatt die Zustände und Übergänge vollständig zu
kapseln, sodass Außenstehende keine Kenntnis von ihnen haben, werden wir die
Zustände in verschiedene Typen kodieren. Folglich wird Rusts
Typprüfungssystem Versuche verhindern, Entwurfsbeiträge zu verwenden, bei denen
nur veröffentlichte Beiträge erlaubt sind, indem ein Kompilierfehler ausgegeben
wird.</p>
<p>Betrachten wir den ersten Teil von <code>main</code> in Codeblock 17-11:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
</span>}
</code></pre>
<p>Wir ermöglichen nach wie vor das Erstellen neuer Beiträge im Entwurfsstadium
unter Verwendung von <code>Post::new</code> und der Möglichkeit, dem Inhalt des Beitrags
Text hinzuzufügen. Aber anstatt eine <code>content</code>-Methode bei einem
Beitragsentwurf zu haben, die eine leere Zeichenkette zurückgibt, werden wir
es so einrichten, dass Beitragsentwürfe überhaupt keine <code>content</code>-Methode
haben. Wenn wir auf diese Weise versuchen, den Inhalt eines Beitragsentwurfs
zu erhalten, erhalten wir einen Kompilierfehler, der uns sagt, dass die Methode
nicht existiert. Infolgedessen wird es für uns unmöglich, versehentlich den
Inhalt eines Beitragsentwurfs in der Produktion anzuzeigen, weil sich dieser
Code nicht einmal kompilieren lässt. Codeblock 17-19 zeigt die Definition einer
Struktur <code>Post</code> und einer Struktur <code>DraftPost</code> sowie die Methoden dieser
Strukturen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-19: Ein <code>Post</code> mit einer Methode <code>content</code>
und ein <code>DraftPost</code> ohne Methode <code>content</code></span></p>
<p>Die beiden Strukturen <code>Post</code> und <code>DraftPost</code> haben ein privates Feld <code>content</code>,
in dem der Text des Blog-Beitrags gespeichert wird. Die Strukturen haben nicht
mehr das <code>state</code>-Feld, weil wir die Kodierung des Zustands auf die Typen der
Strukturen verlagert haben. Die Struktur <code>Post</code> wird einen veröffentlichten
Beitrag repräsentieren und sie hat eine Methode <code>content</code>, die den <code>content</code>
zurückgibt.</p>
<p>Wir haben immer noch die Funktion <code>Post::new</code>, aber anstatt eine Instanz von
<code>Post</code> zurückzugeben, gibt sie eine Instanz von <code>DraftPost</code> zurück. Da
<code>content</code> privat ist und es keine Funktion gibt, die <code>Post</code> zurückgibt, ist es
im Moment nicht möglich, eine Instanz von <code>Post</code> zu erzeugen.</p>
<p>Die Struktur <code>DraftPost</code> hat eine Methode <code>add_text</code>, sodass wir wie bisher
Text zum <code>content</code> hinzufügen können, aber beachte, dass <code>DraftPost</code> keine
Methode <code>content</code> definiert hat! Daher stellt das Programm jetzt sicher, dass
alle Beiträge als Beitragsentwürfe beginnen und dass der Inhalt von
Beitragsentwürfen nicht zur Anzeige verfügbar ist. Jeder Versuch, diese
Einschränkungen zu umgehen, führt zu einem Kompilierfehler.</p>
<h4><a class="header" href="#umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen" id="umsetzen-von-Übergängen-als-transformationen-in-verschiedene-typen">Umsetzen von Übergängen als Transformationen in verschiedene Typen</a></h4>
<p>Wie bekommen wir also einen veröffentlichten Beitrag? Wir wollen die Regel
durchsetzen, dass ein Beitragsentwurf geprüft und genehmigt werden muss, bevor
er veröffentlicht werden kann. Ein Beitrag, der sich im Stadium der Überprüfung
befindet, sollte noch immer keinen Inhalt haben. Lass uns diese Bedingung
implementieren, indem wir eine weitere Struktur <code>PendingReviewPost</code> hinzufügen,
indem wir die Methode <code>request_review</code> auf <code>DraftPost</code> definieren, um einen
<code>PendingReviewPost</code> zurückzugeben, und eine Methode <code>approve</code> auf
<code>PendingReviewPost</code>, um einen <code>Post</code> zurückzugeben, wie in Codeblock 17-20
gezeigt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --abschneiden--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 17-20: Ein <code>PendingReviewPost</code>, der durch
Aufrufen von <code>request_review</code> auf <code>DraftPost</code> erzeugt wird, und eine
<code>approve</code>-Methode, die einen <code>PendingReviewPost</code> in einen veröffentlichten
<code>Post</code> verwandelt</span></p>
<p>Die Methoden <code>request_review</code> und <code>approve</code> übernehmen die Eigentümerschaft von
<code>self</code>, wodurch die Instanzen <code>DraftPost</code> und <code>PendingReviewPost</code> verbraucht
und in einen <code>PendingReviewPost</code> bzw. einen veröffentlichten <code>Post</code> umgewandelt
werden. Auf diese Weise werden wir keine <code>DraftPost</code>-Instanzen mehr haben,
nachdem wir <code>request_review</code> darauf aufgerufen haben, und so weiter. Die
<code>PendingReviewPost</code>-Struktur hat keine <code>content</code>-Methode definiert, sodass der
Versuch, ihren Inhalt zu lesen, zu einem Kompilierfehler führt, wie bei
<code>DraftPost</code>. Da der einzige Weg, eine veröffentlichte <code>Post</code>-Instanz zu
erhalten, die eine <code>content</code>-Methode definiert hat, der Aufruf der
<code>approve</code>-Methode auf einem <code>PendingReviewPost</code> ist, und der einzige Weg, einen
<code>PendingReviewPost</code> zu erhalten, der Aufruf der <code>request_review</code>-Methode auf
einem <code>DraftPost</code> ist, haben wir jetzt den Blog-Beitrags-Workflow in das
Typsystem kodiert.</p>
<p>Aber wir müssen auch einige kleine Änderungen an <code>main</code> vornehmen. Die Methoden
<code>request_review</code> und <code>approve</code> geben neue Instanzen zurück, anstatt die
Struktur, auf der sie aufgerufen werden, zu modifizieren, sodass wir mehr <code>let post =</code> Beschattungs-Zuweisungen (shadowing assignments) hinzufügen müssen, um
die zurückgegebenen Instanzen zu speichern. Wir können auch nicht zulassen,
dass die Zusicherungen über den Inhalt des Entwurfs und der anstehenden
Überprüfungsbeiträge leere Zeichenketten sind, und wir brauchen sie auch nicht:
Wir können keinen Code mehr kompilieren, der versucht, den Inhalt von Beiträgen
in diesen Zuständen zu verwenden. Der aktualisierte Code in <code>main</code> ist in
Codeblock 17-21 aufgeführt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;Ich habe heute Mittag einen Salat gegessen&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;Ich habe heute Mittag einen Salat gegessen&quot;, post.content());
}
</code></pre>
<p><span class="caption">Codeblock 17-21: Änderungen an <code>main</code>, um die neue
Implementierung des Blog-Beitrags-Workflows zu nutzen</span></p>
<p>Die Änderungen, die wir an <code>main</code> vornehmen mussten, um <code>post</code> neu zuzuweisen,
bedeuten, dass diese Implementierung nicht mehr ganz dem objektorientierten
Zustandsmuster folgt: Die Transformationen zwischen den Zuständen sind nicht
mehr vollständig in der <code>Post</code>-Implementierung gekapselt. Unser Vorteil ist
jedoch, dass ungültige Zustände aufgrund des Typsystems und der Typprüfung, die
zur Kompilierzeit stattfindet, jetzt unmöglich sind! Dadurch wird
sichergestellt, dass bestimmte Fehler, z.B. das Anzeigen des Inhalts eines
unveröffentlichten Beitrags, entdeckt werden, bevor sie in die Produktion
gelangen.</p>
<p>Versuche es mit den Aufgaben, die für zusätzliche Anforderungen vorgeschlagen
wurden und die wir zu Beginn dieses Abschnitts über die Kiste <code>blog</code> nach
Codeblock 17-20 erwähnt haben, um zu sehen, was du über das Design dieser
Version des Codes denkst. Beachte, dass einige der Aufgaben möglicherweise
bereits in diesem Entwurf abgeschlossen sind.</p>
<p>Wir haben gesehen, dass, obwohl Rust in der Lage ist, objektorientierte
Entwurfsmuster zu implementieren, auch andere Muster, z.B. das Kodieren des
Zustands in das Typsystem, in Rust verfügbar sind. Diese Muster weisen
unterschiedliche Kompromisse auf. Auch wenn du mit objektorientierten Mustern
sehr vertraut bist, kann ein Überdenken des Problems, um die Funktionen von
Rust zu nutzen, Vorteile bringen, z.B. das Vermeiden einiger Fehler zur
Kompilierzeit. Objektorientierte Muster werden in Rust nicht immer die beste
Lösung sein, da objektorientierte Sprachen bestimmte Funktionalitäten, z.B.
Eigentümerschaft, nicht haben.</p>
<h2><a class="header" href="#zusammenfassung-16" id="zusammenfassung-16">Zusammenfassung</a></h2>
<p>Unabhängig davon, ob du nach der Lektüre dieses Kapitels der Meinung bist, dass
Rust eine objektorientierte Sprache ist oder nicht, weißt du jetzt, dass du
Merkmalsobjekte verwenden kannst, um einige objektorientierte Funktionalitäten
in Rust zu erhalten. Dynamische Aufrufe können deinem Code eine gewisse
Flexibilität im Austausch gegen ein wenig Laufzeitperformanz verleihen. Du
kannst diese Flexibilität nutzen, um objektorientierte Muster zu
implementieren, die die Wartbarkeit deines Codes verbessern können. Rust hat
auch andere Funktionalitäten, z.B. Eigentümerschaft, die objektorientierte
Sprachen nicht haben. Ein objektorientiertes Muster wird nicht immer der beste
Weg sein, um die Stärken von Rust zu nutzen, ist aber eine verfügbare Option.</p>
<p>Als nächstes werden wir uns mit Mustern befassen, die eine weitere
Funktionalität von Rust sind und viel Flexibilität ermöglichen. Wir haben sie
uns im Laufe des Buches kurz angeschaut, haben aber noch nicht ihre volle
Leistungsfähigkeit gesehen. Los geht's!</p>
<h1><a class="header" href="#muster-patterns-und-abgleich-matching" id="muster-patterns-und-abgleich-matching">Muster (patterns) und Abgleich (matching)</a></h1>
<p>Muster sind eine spezielle Syntax in Rust für den Abgleich mit der Struktur von
Typen, sowohl komplexen als auch einfachen Typen. Das Verwenden von Mustern in
Verbindung mit <code>match</code>-Ausdrücken und anderen Konstrukten gibt dir mehr
Kontrolle über den Kontrollfluss eines Programms. Ein Muster besteht aus einer
Kombination der folgenden Elemente:</p>
<ul>
<li>Literale</li>
<li>Destrukturierte Arrays, Aufzählungen (enums), Strukturen (structs) oder Tupel</li>
<li>Variablen</li>
<li>Wildcards</li>
<li>Platzhalter</li>
</ul>
<p>Diese Komponenten beschreiben die Form der Daten, mit denen wir arbeiten, die
wir dann mit Werten abgleichen, um festzustellen, ob unser Programm über die
richtigen Daten verfügt, um ein bestimmtes Stück Code weiter auszuführen.</p>
<p>Um ein Muster zu verwenden, vergleichen wir es mit einem Wert. Wenn das Muster
zum Wert passt, verwenden wir die Wertteile in unserem Code. Erinnere dich an
die <code>match</code>-Ausdrücke in Kapitel 6, in denen Muster verwendet wurden, z.B. die
Münzsortiermaschine. Wenn der Wert zur Form des Musters passt, können wir die
genannten Teile verwenden. Wenn dies nicht der Fall ist, wird der mit dem
Muster verbundene Code nicht ausgeführt.</p>
<p>Dieses Kapitel ist eine Referenz zu allen Dingen, die mit Mustern zu tun haben.
Wir behandeln die gültigen Stellen, an denen Muster verwendet werden können,
den Unterschied zwischen abweisbaren (refutable) und unabweisbaren
(irrefutable) Mustern und die verschiedenen Arten der Mustersyntax, die du
sehen kannst. Am Ende des Kapitels wirst du wissen, wie du Muster verwenden
kannst, um viele Konzepte auf klare Weise auszudrücken.</p>
<h2><a class="header" href="#alle-stellen-an-denen-muster-patterns-verwendet-werden-können" id="alle-stellen-an-denen-muster-patterns-verwendet-werden-können">Alle Stellen an denen Muster (patterns) verwendet werden können</a></h2>
<p>Muster tauchen an vielen Stellen in Rust auf und du hast sie oft benutzt, ohne
es zu merken! In diesem Abschnitt werden alle Stellen besprochen, an denen
Muster gültig sind.</p>
<h3><a class="header" href="#match-zweige" id="match-zweige"><code>match</code>-Zweige</a></h3>
<p>Wie in Kapitel 6 besprochen, verwenden wir Muster in den Zweigen von
<code>match</code>-Ausdrücken. Formal werden <code>match</code>-Ausdrücke definiert mit dem
Schlüsselwort <code>match</code>, einem Wert, mit dem verglichen wird, und einem oder
mehreren <code>match</code>-Zweigen, die aus einem Muster und einem Ausdruck bestehen, der
ausgeführt wird, wenn der Wert zum Muster dieses Zweigs passt, wie hier:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Eine Anforderung für <code>match</code>-Ausdrücke ist, dass sie <em>erschöpfend</em> (exhaustive)
in dem Sinne sein müssen, dass alle Möglichkeiten für den Wert im
<code>match</code>-Ausdruck berücksichtigt sein müssen. Ein Weg, um sicherzustellen, dass
alle Möglichkeiten abgedeckt sind, ist ein Sammel-Muster (catchall pattern) für
den letzten Zweig: Zum Beispiel kann ein Variablenname, der zu einem beliebigen
Wert passt, niemals fehlschlagen und deckt somit jeden verbleibenden Fall ab.</p>
<p>Das spezielle Muster <code>_</code> wird auf alles passen, aber es bindet nie an eine
Variable, daher wird es oft im letzten <code>match</code>-Zweig verwendet. Das Muster <code>_</code>
kann zum Beispiel nützlich sein, wenn du jeden nicht angegebenen Wert
ignorieren willst. Wir werden das Muster <code>_</code> im Abschnitt <a href="ch18-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von
Werten in einem Muster“</a> später in diesem Kapitel
ausführlicher behandeln.</p>
<h3><a class="header" href="#bedingte-if-let-ausdrücke" id="bedingte-if-let-ausdrücke">Bedingte <code>if let</code>-Ausdrücke</a></h3>
<p>In Kapitel 6 haben wir erörtert, wie man <code>if let</code>-Ausdrücke hauptsächlich als
kürzeren Weg verwendet, um das Äquivalent eines <code>match</code>-Ausdrucks zu schreiben,
der nur einen Fall prüft. Optional kann <code>if let</code> ein entsprechendes <code>else</code>
haben mit Code, der ausgeführt wird, wenn das Muster in <code>if let</code> nicht passt.</p>
<p>Codeblock 18-1 zeigt, dass es auch möglich ist, die Ausdrücke <code>if let</code>, <code>else if</code> und <code>else if let</code> zu mischen und anzupassen. Dies gibt uns mehr
Flexibilität als ein <code>match</code>-Ausdruck, in dem wir nur einen Wert zum Abgleich
mit den Mustern haben können. Auch die Bedingungen in einer Reihe von <code>if let</code>-, <code>else if</code>- und <code>else if let</code>-Zweigen müssen sich nicht notwendigerweise
aufeinander beziehen.</p>
<p>Der Code in Codeblock 18-1 zeigt eine Reihe von Prüfungen für verschiedene
Bedingungen, die darüber entscheiden, welche Hintergrundfarbe verwendet werden
soll. Für dieses Beispiel haben wir Variablen mit hartkodierten Werten
erstellt, die ein reales Programm von Benutzereingaben erhalten könnte.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Verwende deine Lieblingsfarbe {} als Hintergrund&quot;, color);
    } else if is_tuesday {
        println!(&quot;Dienstag ist grüner Tag!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Verwende violett als Hintergrundfarbe&quot;);
        } else {
            println!(&quot;Verwende orange als Hintergrundfarbe&quot;);
        }
    } else {
        println!(&quot;Verwende blau als Hintergrundfarbe&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-1: Mischen von <code>if let</code>, <code>else if</code>, <code>else if let</code> und <code>else</code></span></p>
<p>Wenn der Benutzer eine Lieblingsfarbe angibt, ist diese Farbe die
Hintergrundfarbe. Wenn heute Dienstag ist, ist die Hintergrundfarbe grün. Wenn
der Benutzer sein Alter als Zeichenkette angibt und wir es erfolgreich als Zahl
parsen können, ist die Farbe entweder violett oder orange, je nach dem Wert der
Zahl. Wenn keine dieser Bedingungen zutrifft, ist die Hintergrundfarbe blau.</p>
<p>Mit dieser bedingten Struktur können wir komplexe Anforderungen unterstützen.
Mit den hartkodierten Werten, die wir hier haben, wird dieses Beispiel
<code>Verwende violett als Hintergrundfarbe</code> ausgeben.</p>
<p>Du kannst sehen, dass <code>if let</code> auch beschattete Variablen (shadowed variables)
auf die gleiche Weise einführen kann wie bei <code>match</code>-Zweigen: Die Zeile <code>if let Ok(age) = age</code> führt eine neue beschattete Variable <code>age</code> ein, die den Wert
innerhalb der <code>Ok</code>-Variante enthält. Das bedeutet, dass wir die Bedingung <code>if age &gt; 30</code> innerhalb dieses Blocks platzieren müssen: Wir können diese beiden
Bedingungen nicht in <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> kombinieren. Das
beschattete <code>age</code>, das wir mit 30 vergleichen wollen, ist erst gültig, wenn der
neue Gültigkeitsbereich mit der geschweiften Klammer beginnt.</p>
<p>Der Nachteil der Verwendung von <code>if let</code>-Ausdrücken ist, dass der Compiler die
Vollständigkeit nicht prüft, während er dies bei <code>match</code>-Ausdrücken tut. Wenn
wir den letzten <code>else</code>-Block weglassen und daher einige Fälle nicht behandelt
haben, würde uns der Compiler nicht auf den möglichen Logikfehler hinweisen.</p>
<h3><a class="header" href="#while-let-bedingte-schleifen" id="while-let-bedingte-schleifen"><code>while let</code>-bedingte Schleifen</a></h3>
<p>Ähnlich konstruiert wie <code>if let</code> erlaubt die <code>while let</code>-bedingte Schleife,
dass eine <code>while</code>-Schleife so lange läuft, wie ein Muster weiterhin passt. Das
Beispiel in Codeblock 18-2 zeigt eine <code>while let</code>-Schleife, die einen Vektor
als Stapel (stack) verwendet und die Werte im Vektor in der umgekehrten
Reihenfolge ausgibt, in der sie auf den Stapel gelegt wurden.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-2: Das Verwenden einer <code>while let</code>-Schleife,
um Werte so lange auszugeben, wie <code>stack.pop()</code> ein <code>Some</code> zurückgibt</span></p>
<p>Dieses Beispiel gibt 3, 2 und 1 aus. Die <code>pop</code>-Methode nimmt das letzte Element
aus dem Vektor und gibt <code>Some(value)</code> zurück. Wenn der Vektor leer ist, gibt
<code>pop</code> den Wert <code>None</code> zurück. Die <code>while</code>-Schleife fährt den Code in ihrem
Block so lange aus, wie <code>pop</code> ein <code>Some</code> zurückgibt. Wenn <code>pop</code> den Wert <code>None</code>
zurückgibt, stoppt die Schleife. Wir können <code>while let</code> benutzen, um jedes
Element von unserem Stapel zu holen.</p>
<h3><a class="header" href="#for-schleifen" id="for-schleifen"><code>for</code>-Schleifen</a></h3>
<p>In Kapitel 3 haben wir erwähnt, dass die <code>for</code>-Schleife die häufigste
Schleifenkonstruktion in Rust-Code ist, aber wir haben das Muster, das <code>for</code>
annimmt, noch nicht besprochen. In einer <code>for</code>-Schleife ist das Muster der
Wert, der direkt auf das Schlüsselwort <code>for</code> folgt, sodass in <code>for x in y</code> das
<code>x</code> das Muster ist.</p>
<p>Codeblock 18-3 zeigt, wie ein Muster in einer <code>for</code>-Schleife verwendet werden
kann, um ein Tupel als Teil der <code>for</code>-Schleife zu destrukturieren oder
auseinanderzubrechen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} ist beim Index {}&quot;, value, index);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-3: Verwenden eines Musters in einer
<code>for</code>-Schleife zum Destrukturieren eines Tupels</span></p>
<p>Der Code in Codeblock 18-3 wird Folgendes ausgeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a ist beim Index 0
b ist beim Index 1
c ist beim Index 2
</code></pre>
<p>Wir verwenden die Methode <code>enumerate</code>, um einen Iterator so anzupassen, dass er
einen Wert und den Index dieses Wertes im Iterator erzeugt, die in ein Tupel
gesetzt werden. Der erste Aufruf von <code>enumerate</code> erzeugt das Tupel <code>(0, 'a')</code>.
Wenn dieser Wert zum Muster <code>(index, value)</code> passt, ist <code>index</code> gleich <code>0</code> und
<code>value</code> gleich <code>'a'</code>, wodurch die erste Zeile der Ausgabe ausgegeben wird.</p>
<h3><a class="header" href="#let-anweisungen" id="let-anweisungen"><code>let</code>-Anweisungen</a></h3>
<p>Vor diesem Kapitel hatten wir das Verwenden von Mustern nur explizit mit
<code>match</code> und <code>if let</code> besprochen, aber tatsächlich haben wir Muster auch an
anderen Stellen verwendet, auch in <code>let</code>-Anweisungen. Betrachte zum Beispiel
diese einfache Variablenzuweisung mit <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>In diesem Buch haben wir <code>let</code> wie dieses hunderte Male verwendet und obwohl du
es vielleicht nicht bemerkt hast, hast du ein Muster verwendet! Formell gesehen
sieht eine <code>let</code>-Anweisung so aus:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In Anweisungen wie <code>let x = 5;</code> mit einem Variablennamen an der Stelle
<code>PATTERN</code> ist der Variablenname nur eine besonders einfache Form eines Musters.
Rust vergleicht den Ausdruck mit dem Muster und weist alle gefundenen Namen zu.
Im Beispiel <code>let x = 5;</code> ist <code>x</code> also ein Muster, das bedeutet: „Binde das, was
hier passt, an die Variable <code>x</code>.“ Da der Name <code>x</code> das gesamte Muster ist,
bedeutet dieses Muster effektiv „Binde alles an die Variable <code>x</code>, was auch
immer der Wert ist.“.</p>
<p>Um den Aspekt des Musterabgleichs (pattern matching) von <code>let</code> deutlicher zu
sehen, betrachte Codeblock 18-4, der ein Muster mit <code>let</code> verwendet, um ein
Tupel zu destrukturieren.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-4: Verwenden eines Musters zum
Destrukturieren eines Tupels und zum gleichzeitigen Erzeugen von drei
Variablen</span></p>
<p>Hier vergleichen wir ein Tupel mit einem Muster. Rust vergleicht den Wert <code>(1, 2, 3)</code> mit dem Muster <code>(x, y, z)</code> und sieht, dass der Wert zum Muster passt,
also bindet Rust <code>1</code> an <code>x</code>, <code>2</code> an <code>y</code> und <code>3</code> an <code>z</code>. Man kann sich dieses
Tupelmuster als Verschachtelung von drei einzelnen Variablen-Mustern darin
vorstellen.</p>
<p>Wenn die Anzahl der Elemente im Muster nicht mit der Anzahl der Elemente im
Tupel übereinstimmt, passt der Gesamttyp nicht, und wir erhalten einen
Kompilierfehler. Beispielsweise zeigt Codeblock 18-5 einen Versuch, ein Tupel
mit drei Elementen in zwei Variablen zu destrukturieren, was nicht
funktioniert.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);


<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-5: Fehlerhaft aufgebautes Musters, dessen
Variablen nicht mit der Anzahl der Elemente im Tupel übereinstimmen</span></p>
<p>Der Versuch, diesen Code zu kompilieren, führt zu diesem Typfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wenn wir einen oder mehrere der Werte im Tupel ignorieren wollten, könnten wir
<code>_</code> oder <code>..</code> verwenden, wie du im Abschnitt <a href="ch18-03-pattern-syntax.html#ignorieren-von-werten-in-einem-muster">„Ignorieren von Werten in einem
Muster“</a> sehen wirst. Wenn das Problem darin
besteht, dass wir zu viele Variablen im Muster haben, besteht die Lösung darin,
die Typen aufeinander abzustimmen, indem Variablen entfernt werden, sodass die
Anzahl der Variablen gleich der Anzahl der Elemente im Tupel ist.</p>
<h3><a class="header" href="#funktionsparameter-1" id="funktionsparameter-1">Funktionsparameter</a></h3>
<p>Funktionsparameter können auch Muster sein. Der Code in Codeblock 18-6, der
eine Funktion namens <code>foo</code> deklariert, die einen Parameter namens <code>x</code> vom Typ
<code>i32</code> benötigt, sollte inzwischen bekannt aussehen.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // Code kommt hierher
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-6: Eine Funktionssignatur verwendet Muster
in den Parametern</span></p>
<p>Der Teil <code>x</code> ist ein Muster! Wie wir es mit <code>let</code> taten, konnten wir ein Tupel
in den Argumenten einer Funktion dem Muster zuordnen. Codeblock 18-7 teilt die
Werte in einem Tupel auf, wenn wir es an eine Funktion übergeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Aktuelle Position: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-7: Eine Funktion mit Parametern, die ein
Tupel destrukturieren</span></p>
<p>Dieser Code gibt <code>Aktuelle Position: (3, 5)</code> aus. Die Werte <code>&amp;(3, 5)</code> passen
zum Muster <code>&amp;(x, y)</code>, sodass <code>x</code> den Wert <code>3</code> und <code>y</code> den Wert <code>5</code> hat.</p>
<p>Wir können auch Muster in Funktionsabschlussparameterlisten (closure parameter
lists) auf die gleiche Weise wie in Funktionsparameterlisten verwenden, da
Funktionsabschlüsse ähnlich wie Funktionen sind, wie in Kapitel 13 besprochen.</p>
<p>An diesem Punkt hast du verschiedene Möglichkeiten der Verwendung von Mustern
gesehen, aber Muster funktionieren nicht an allen Stellen, an denen wir sie
verwenden können, gleich. An manchen Stellen müssen die Muster unabweisbar
(irrefutable) sein, unter anderen Umständen können sie abweisbar (refutable)
sein. Wir werden diese beiden Konzepte als Nächstes besprechen.</p>
<h2><a class="header" href="#abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt" id="abweisbarkeit-falls-ein-muster-pattern-mal-nicht-passt">Abweisbarkeit: Falls ein Muster (pattern) mal nicht passt</a></h2>
<p>Es gibt zwei Arten von Mustern: Abweisbare (refutable) und unabweisbare
(irrefutable). Muster, die für jeden möglichen übergebenen Wert passen, sind
<em>unabweisbar</em>. Ein Beispiel wäre <code>x</code> in der Anweisung <code>let x = 5;</code> weil <code>x</code> auf
alles passt und daher nicht fehlschlagen kann. Muster, die für irgendeinen
möglichen Wert nicht passen können, sind <em>abweisbar</em>. Ein Beispiel wäre
<code>Some(x)</code> im Ausdruck <code>if let Some(x) = a_value</code>, denn wenn der Wert in der
Variablen <code>a_value</code> eher <code>None</code> als <code>Some</code> ist, wird das Muster <code>Some(x)</code> nicht
passen. </p>
<p>Funktionsparameter, <code>let</code>-Anweisungen und <code>for</code>-Schleifen können nur
unabweisbare Muster akzeptieren, da das Programm nichts Sinnvolles tun kann,
wenn die Werte nicht passen. Die Ausdrücke <code>if let</code> und <code>while let</code> akzeptieren
abweisbare und unabweisbare Muster, aber der Compiler warnt vor unabweisbaren
Mustern, weil sie per Definition dazu gedacht sind, mit einem möglichen
Fehlerfall umzugehen: Die Funktionalität einer Bedingung besteht in ihrer
Fähigkeit, sich abhängig von Erfolg oder Fehlerfall unterschiedlich zu
verhalten.</p>
<p>Im Allgemeinen solltest du dich nicht um die Unterscheidung zwischen
abweisbaren und unabweisbaren Mustern kümmern müssen; du musst jedoch mit dem
Konzept der Abweisbarkeit vertraut sein, damit du reagieren kannst, wenn du es
in einer Fehlermeldung siehst. In diesen Fällen musst du entweder das Muster
oder das Konstrukt, in dem du das Muster verwendest, ändern, je nach dem
beabsichtigten Verhalten des Codes.</p>
<p>Betrachten wir ein Beispiel dafür, was passiert, wenn wir versuchen, ein
abweisbares Muster zu verwenden, wo Rust ein unabweisbares Muster erfordert und
umgekehrt. Codeblock 18-8 zeigt eine <code>let</code>-Anweisung, allerdings haben wir für
das Muster <code>Some(x)</code> angegeben, ein abweisbares Muster. Wie zu erwarten ist,
lässt sich dieser Code nicht kompilieren.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-8: Versuch, ein abweisbares Muster mit <code>let</code>
zu verwenden</span></p>
<p>Wenn <code>some_option_value</code> ein <code>None</code>-Wert wäre, würde er nicht zum Muster
<code>Some(x)</code> passen, was bedeutet, dass das Muster abweisbar ist. Die
<code>let</code>-Anweisung kann jedoch nur ein unabweisbares Muster akzeptieren, weil es
nichts Gültiges gibt, was der Code mit einem <code>None</code>-Wert tun kann. Zur
Kompilierzeit wird sich Rust beschweren, dass wir versucht haben, ein
abweisbares Muster zu verwenden, wo ein unabweisbares Muster erforderlich ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = some_option_value { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Da wir nicht jeden gültigen Wert mit dem Muster <code>Some(x)</code> abgedeckt haben (und
auch nicht abdecken konnten!), erzeugt Rust zu Recht einen Kompilierfehler.</p>
<p>Um das Problem zu beheben, bei dem wir ein abweisbares Muster haben, obwohl ein
unabweisbares Muster benötigt wird, können wir den Code ändern, der das Muster
verwendet: Anstatt <code>let</code> zu verwenden, können wir <code>if let</code> verwenden. Wenn das
Muster dann nicht passt, überspringt der Code einfach den Code in den
geschweiften Klammern und gibt ihm die Möglichkeit, gültig fortzufahren.
Codeblock 18-9 zeigt, wie der Code in Codeblock 18-8 zu korrigieren ist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-9: Verwenden von <code>if let</code> und eines Blocks
mit abweisbaren Mustern anstelle von <code>let</code></span></p>
<p>Wir haben den Code repariert! Dieser Code ist vollkommen gültig, obwohl er
bedeutet, dass wir kein unabweisbares Muster verwenden können, ohne einen
Fehler zu erhalten. Wenn wir <code>if let</code> ein Muster geben, das immer passen wird,
z.B. <code>x</code>, wie in Codeblock 18-10 gezeigt, gibt der Compiler eine Warnung aus.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-10: Der Versuch, ein unabweisbares Muster
mit <code>if let</code> zu verwenden</span></p>
<p>Rust beklagt, dass es keinen Sinn macht, <code>if let</code> mit einem unabweisbaren
Muster zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 --&gt; src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!(&quot;{}&quot;, x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Aus diesem Grund müssen <code>match</code>-Zweige abweisbare Muster verwenden, mit
Ausnahme des letzten Zweigs, bei dem alle verbleibenden Werte mit einem
unabweisbaren Muster übereinstimmen sollten. Rust erlaubt es uns, ein
unabweisbares Muster in einem <code>match</code> mit nur einem Zweig zu verwenden, aber
diese Syntax ist nicht besonders nützlich und könnte durch eine einfachere
<code>let</code>-Anweisung ersetzt werden.</p>
<p>Nun, da du weißt, wo du Muster verwenden kannst und den Unterschied zwischen
abweisbaren und unabweisbaren Mustern kennst, lass uns alle Syntaxen behandeln,
die wir zum Erstellen von Mustern verwenden können.</p>
<h2><a class="header" href="#mustersyntax" id="mustersyntax">Mustersyntax</a></h2>
<p>Im ganzen Buch hast du Beispiele für viele Arten von Mustern gesehen. In diesem
Abschnitt stellen wir die gesamte Syntax gültiger Muster zusammen und erörtern,
wann du jedes einzelne Muster verwenden solltest.</p>
<h3><a class="header" href="#passende-literale" id="passende-literale">Passende Literale</a></h3>
<p>Wie du in Kapitel 6 gesehen hast, kannst du Muster direkt mit Literalen
abgleichen. Der folgende Code enthält einige Beispiele:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;eins&quot;),
        2 =&gt; println!(&quot;zwei&quot;),
        3 =&gt; println!(&quot;drei&quot;),
        _ =&gt; println!(&quot;sonstige&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt <code>eins</code> aus, weil der Wert in <code>x</code> 1 ist. Diese Syntax ist
nützlich, wenn du willst, dass dein Code eine Aktion ausführt, wenn er einen
bestimmten konkreten Wert erhält.</p>
<h3><a class="header" href="#benannte-variablen-abgleichen" id="benannte-variablen-abgleichen">Benannte Variablen abgleichen</a></h3>
<p>Benannte Variablen (named variables) sind unabweisbare Muster, die zu jedem
Wert passen, und wir haben sie in diesem Buch schon oft verwendet. Es gibt
jedoch eine Komplikation, wenn du benannte Variablen in <code>match</code>-Ausdrücken
verwendest. Da <code>match</code> einen neuen Gültigkeitsbereich beginnt, werden
Variablen, die als Teil eines Musters innerhalb des <code>match</code>-Ausdrucks
deklariert sind, diejenigen mit dem gleichen Namen außerhalb des
<code>match</code>-Konstrukts beschatten (shadow), wie es bei allen Variablen der Fall
ist. In Codeblock 18-11 deklarieren wir eine Variable mit dem Namen <code>x</code> mit dem
Wert <code>Some(5)</code> und eine Variable <code>y</code> mit dem Wert <code>10</code>. Dann erzeugen wir einen
<code>match</code>-Ausdruck für den Wert <code>x</code>. Sieh dir die Muster in den <code>match</code>-Zweigen
und <code>println!</code> am Ende an und versuche herauszufinden, was der Code ausgeben
wird, bevor du diesen Code ausführst oder weiterliest.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Habe 50 erhalten&quot;),
        Some(y) =&gt; println!(&quot;Passt, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Standardfall, x = {:?}&quot;, x),
    }

    println!(&quot;Am Ende: x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-11: Ein <code>match</code>-Ausdruck mit einem Zweig,
der eine beschattete Variable <code>y</code> einführt</span></p>
<p>Lass uns durchgehen, was passiert, wenn der <code>match</code>-Ausdruck ausgeführt wird.
Das Muster im ersten Zweig passt nicht zum definierten Wert von <code>x</code>, also setzt
der Code fort.</p>
<p>Das Muster im zweiten Zweig führt eine neue Variable namens <code>y</code> ein, die zu
jedem Wert innerhalb eines <code>Some</code>-Wertes passt. Da wir uns in einem neuen
Gültigkeitsbereich innerhalb des <code>match</code>-Ausdrucks befinden, ist dies eine neue
Variable <code>y</code>, nicht das <code>y</code>, das wir am Anfang mit dem Wert 10 deklariert
haben. Diese neue <code>y</code>-Bindung wird mit jedem Wert innerhalb eines <code>Some</code>
übereinstimmen, das ist das, was wir in <code>x</code> haben. Daher bindet dieses neue <code>y</code>
an den inneren Wert des <code>Some</code> in <code>x</code>. Dieser Wert ist <code>5</code>, sodass der Ausdruck
für diesen Zweig ausgeführt und <code>Passt, y = 5</code> ausgegeben wird.</p>
<p>Wäre <code>x</code> ein <code>None</code>-Wert anstelle von <code>Some(5)</code> gewesen, hätten die Muster in
den ersten beiden Zweigen nicht gepasst, sodass der Wert zum Unterstrich
gepasst hätte. Wir haben die Variable <code>x</code> nicht im Muster des
Unterstrich-Zweigs verwendet, sodass <code>x</code> im Ausdruck immer noch das äußere <code>x</code>
ist, das nicht beschattet wurde. In diesem hypothetischen Fall würde <code>match</code>
den Text <code>Standardfall, x = None</code> ausgeben.</p>
<p>Wenn der <code>match</code>-Ausdruck zu Ende ist, endet sein Gültigkeitsbereich und damit
auch der Gültigkeitsbereich des inneren <code>y</code>. Das letzte <code>println!</code> gibt <code>Am Ende: x = Some(5), y = 10</code> aus.</p>
<p>Um einen <code>match</code>-Ausdruck zu erstellen, der die Werte der äußeren <code>x</code> und <code>y</code>
abgleicht anstatt eine beschattete Variable einzuführen, müssten wir
stattdessen eine Abgleichsbedingung (match guard conditional) verwenden. Wir
werden über Abgleichsbedingungen später im Abschnitt <a href="ch18-03-pattern-syntax.html#extra-bedingungen-mit-abgleichsbedingungen">„Extra-Bedingungen mit
Abgleichsbedingungen“</a> sprechen.</p>
<h3><a class="header" href="#mehrfache-muster" id="mehrfache-muster">Mehrfache Muster</a></h3>
<p>In <code>match</code>-Ausdrücken kannst du mehrere Muster mit der Syntax <code>|</code> abgleichen,
die <em>oder</em> bedeutet. Zum Beispiel gleicht der folgende Code den Wert von <code>x</code>
mit den <code>match</code>-Zweigen ab, wobei der erste davon eine <em>oder</em>-Option hat, was
bedeutet, wenn der Wert von <code>x</code> zu einem der Werte in diesem Zweig passt, wird
der Code dieses Zweigs ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;eins oder zwei&quot;),
        3 =&gt; println!(&quot;drei&quot;),
        _ =&gt; println!(&quot;sonstige&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt <code>eins oder zwei</code> aus.</p>
<h3><a class="header" href="#abgleichen-von-wertebereichen-mit-" id="abgleichen-von-wertebereichen-mit-">Abgleichen von Wertebereichen mit <code>..=</code></a></h3>
<p>Die Syntax <code>..=</code> erlaubt es uns, einen inklusiven Wertebereich abzugleichen.
Wenn im folgenden Code ein Muster zu einem der Werte innerhalb des Bereichs
passt, wird dieser Zweig ausgeführt:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;eins bis fünf&quot;),
        _ =&gt; println!(&quot;etwas anderes&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Wenn <code>x</code> 1, 2, 3, 4 oder 5 ist, passt der erste Zweig. Diese Syntax ist
bequemer als das Verwenden des <code>|</code>-Operators, um die gleiche Idee auszudrücken;
statt <code>1..=5</code> müssten wir <code>1 | 2 | 3 | 4 | 5</code> angeben, wenn wir <code>|</code> verwenden
würden. Die Angabe eines Bereichs ist viel kürzer, besonders wenn wir
beispielsweise eine beliebige Zahl zwischen 1 und 1.000 angeben wollen!</p>
<p>Bereiche sind nur mit numerischen Werten oder <code>char</code>-Werten erlaubt, da der
Compiler zur Kompilierzeit prüft, dass der Bereich nicht leer ist. Die einzigen
Typen, bei denen Rust erkennen kann, ob ein Bereich leer ist oder nicht, sind
<code>char</code> und numerische Werte.</p>
<p>Hier ist ein Beispiel mit Bereichen von <code>char</code>-Werten:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;früher ASCII-Buchstabe&quot;),
        'k'..='z' =&gt; println!(&quot;später ASCII-Buchstabe&quot;),
        _ =&gt; println!(&quot;etwas anderes&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust kann erkennen, dass <code>c</code> innerhalb des Bereichs des ersten Musters liegt
und gibt <code>früher ASCII-Buchstabe</code> aus.</p>
<h3><a class="header" href="#destrukturieren-um-werte-aufzuteilen" id="destrukturieren-um-werte-aufzuteilen">Destrukturieren, um Werte aufzuteilen</a></h3>
<p>Wir können auch Muster verwenden, um Strukturen (structs), Aufzählungen
(enums), Tupel und Referenzen zu destrukturieren, um verschiedene Teile dieser
Werte zu verwenden. Lass uns jeden Wert durchgehen.</p>
<h4><a class="header" href="#destrukturieren-von-strukturen" id="destrukturieren-von-strukturen">Destrukturieren von Strukturen</a></h4>
<p>Codeblock 18-12 zeigt eine Struktur <code>Point</code> mit zwei Feldern, <code>x</code> und <code>y</code>, die
wir mit einem Muster in einer <code>let</code>-Anweisung aufteilen können.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-12: Destrukturieren der Felder einer
Struktur in separate Variablen</span></p>
<p>Dieser Code erzeugt die Variablen <code>a</code> und <code>b</code>, die den Werten der Felder <code>x</code>
und <code>y</code> der Struktur <code>p</code> entsprechen. Dieses Beispiel zeigt, dass die Namen der
Variablen im Muster nicht mit den Feldnamen der Struktur übereinstimmen müssen.
Aber es ist üblich, dass die Variablennamen mit den Feldnamen übereinstimmen,
damit man sich leichter merken kann, welche Variablen aus welchen Feldern
stammen.</p>
<p>Weil es üblich ist, dass die Variablennamen mit den Feldnamen übereinstimmen,
und weil das Schreiben von <code>let Point { x: x, y: y } = p;</code> viel Duplikation
enthält, gibt es eine Kurzform für Muster, die mit Struktur-Feldern
übereinstimmen: Du musst nur die Namen des Struktur-Felder auflisten, und die
Variablen, die aus dem Muster erzeugt werden, haben die gleichen Namen.
Codeblock 18-13 zeigt Code, der sich gleich verhält wie der Code in Codeblock
18-12, aber die Variablen, die im Muster <code>let</code> erzeugt werden, sind <code>x</code> und <code>y</code>
anstelle von <code>a</code> und <code>b</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-13: Destrukturieren von Strukturfeldern mit
Hilfe der Strukturfeldkurznotation (struct field shorthand)</span></p>
<p>Dieser Code erzeugt die Variablen <code>x</code> und <code>y</code>, die mit den Feldern <code>x</code> und <code>y</code>
der Variablen <code>p</code> übereinstimmen. Das Ergebnis ist, dass die Variablen <code>x</code> und
<code>y</code> die Werte aus der Struktur <code>p</code> enthalten.</p>
<p>Wir können auch mit literalen Werten als Teil des Strukturmusters
destrukturieren, anstatt Variablen für alle Felder zu erstellen. Auf diese
Weise können wir einige der Felder auf bestimmte Werte testen, während wir
Variablen zum Destrukturieren der anderen Felder erstellen.</p>
<p>Codeblock 18-14 zeigt einen <code>match</code>-Ausdruck, der <code>Point</code>-Werte in drei Fälle
unterscheidet: Punkte, die direkt auf der <code>x</code>-Achse liegen (was zutrifft, wenn
<code>y = 0</code>), auf der <code>y</code>-Achse liegen (<code>x = 0</code>) oder keines von beiden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Auf der x-Achse bei {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Auf der y-Achse bei {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Auf keiner Achse: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-14: Destrukturieren und Abgleichen literaler
Werte in einem Muster</span></p>
<p>Der erste Zweig passt zu jedem Punkt, der auf der <code>x</code>-Achse liegt, indem er
angibt, dass der Wert des <code>y</code>-Felds zum Literal <code>0</code> passt. Das Muster erzeugt
immer noch eine Variable <code>x</code>, die wir im Code für diesen Zweig verwenden
können.</p>
<p>In ähnlicher Weise passt der zweite Zweig zu jedem Punkt auf der y-Achse, indem
er angibt, dass der Wert des <code>x</code>-Feldes 0 ist, und eine Variable <code>y</code>  für den
Wert des <code>y</code> -Feldes erzeugt. Der dritte Zweig spezifiziert keine Literale,
sodass er zu jedem anderen <code>Punkt</code> passt und Variablen für die Felder <code>x</code> und
<code>y</code> erzeugt.</p>
<p>In diesem Beispiel passt der Wert <code>p</code> zum zweiten Zweig, da <code>x</code> eine 0 enthält,
sodass dieser Code <code>Auf der y-Achse bei 7</code> ausgeben wird.</p>
<h4><a class="header" href="#destrukturieren-von-auszählungen" id="destrukturieren-von-auszählungen">Destrukturieren von Auszählungen</a></h4>
<p>Wir haben früher Aufzählungen in diesem Buch destrukturiert, zum Beispiel, als
wir <code>Option&lt;i32&gt;</code> in Codeblock 6-5 in Kapitel 6 destrukturiert haben. Ein
Detail, das wir nicht explizit erwähnt haben, ist, dass das Muster zum
Destrukturieren einer Aufzählung mit der Art und Weise übereinstimmen sollte,
wie die in der Aufzählung gespeicherten Daten definiert sind. Als Beispiel
verwenden wir in Codeblock 18-15 die Aufzählung <code>Message</code> aus Codeblock 6-2 und
schreiben ein <code>match</code> mit Mustern, das jeden inneren Wert destrukturiert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;Die Quit-Variante hat keine Daten zu destrukturieren.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Bewege in x-Richtung {} und in y-Richtung {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Textnachricht: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Ändere die Farbe in rot {}, grün {} und blau {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-15: Destrukturieren von
Aufzählungsvarianten, die verschiedene Arten von Werten enthalten</span></p>
<p>Dieser Code gibt <code>Ändere die Farbe in rot 0, grün 160 und blau 255</code> aus.
Versuche, den Wert von <code>msg</code> zu ändern, um den Code der anderen Zweige laufen
zu sehen.</p>
<p>Bei Aufzählungs-Varianten ohne Daten, wie <code>Message::Quit</code>, können wir den Wert
nicht weiter destrukturieren. Wir können nur mit dem Literalwert
<code>Message::Quit</code> abgleichen und es gibt keine Variablen in diesem Muster.</p>
<p>Für strukturähnliche Aufzählungsvarianten, z.B. <code>Message::Move</code>, können wir ein
Muster verwenden, das dem von uns angegebenen Muster ähnlich ist, um Strukturen
abzugleichen. Nach dem Variantennamen setzen wir geschweifte Klammern und
listen dann die Felder mit Variablen auf, sodass wir die Teile aufteilen, die
im Code für diesen Zweig verwendet werden sollen. Hier verwenden wir die
Kurznotation, wie wir es in Codeblock 18-13 getan haben.</p>
<p>Bei tupelähnlichen Aufzählungsvarianten wie <code>Message::Write</code>, die ein Tupel mit
einem Element enthält, und <code>Message::ChangeColor</code>, die ein Tupel mit drei
Elementen enthält, ähnelt das Muster dem Muster, das wir für den Abgleich von
Tupeln angeben. Die Anzahl der Variablen im Muster muss mit der Anzahl der
Elemente in der Variante, die wir abgleichen, übereinstimmen.</p>
<h4><a class="header" href="#destrukturieren-verschachtelter-strukturen-und-aufzählungen" id="destrukturieren-verschachtelter-strukturen-und-aufzählungen">Destrukturieren verschachtelter Strukturen und Aufzählungen</a></h4>
<p>Bis jetzt haben all unsere Beispiele zu Strukturen oder Aufzählungen gepasst,
die eine Ebene tief waren. Der Abgleich kann auch auf verschachtelte Elemente
angewendet werden!</p>
<p>Beispielsweise können wir den Code in Codeblock 18-15 so umformulieren, dass
RGB- und HSV-Farben in der <code>ChangeColor</code>-Nachricht unterstützt werden, wie in
Codeblock 18-16 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Ändere die Farbe in rot {}, grün {} und blau {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Ändere die Farbe in Farbwert {}, Sättigung {} und Hellwert {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-16: Abgleich bei verschachtelten
Aufzählungen</span></p>
<p>Das Muster des ersten Zweigs im <code>match</code>-Ausdruck passt zu einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, die eine <code>Color::Rgb</code>-Variante
enthält; dann bindet das Muster an die drei inneren <code>i32</code>-Werte. Das Muster des
zweiten Zweigs passt ebenfalls mit einer
<code>Message::ChangeColor</code>-Aufzählungsvariante, aber die innere Aufzählung passt
stattdessen zur <code>Color::Hsv</code>-Variante. Wir können diese komplexen Bedingungen
in einem einzigen <code>match</code>-Ausdruck angeben, auch wenn es sich um zwei
Aufzählungen handelt.</p>
<h4><a class="header" href="#destrukturieren-von-strukturen-und-tupeln" id="destrukturieren-von-strukturen-und-tupeln">Destrukturieren von Strukturen und Tupeln</a></h4>
<p>Wir können das Abgleichen und Destrukturieren verschachtelter Muster auf noch
komplexere Weise mischen. Das folgende Beispiel zeigt eine komplizierte
Destrukturierung, bei der wir Strukturen und Tupel innerhalb eines Tupels
verschachteln und alle primitiven Werte herausdestrukturieren:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code ermöglicht es uns, komplexe Typen in ihre Bestandteile zu zerlegen,
sodass wir die Werte, an denen wir interessiert sind, separat verwenden können.</p>
<p>Das Destrukturieren mit Mustern ist eine bequeme Möglichkeit, Wertteile, z.B.
Werte aus den Feldern in einer Struktur, getrennt voneinander zu verwenden.</p>
<h3><a class="header" href="#ignorieren-von-werten-in-einem-muster" id="ignorieren-von-werten-in-einem-muster">Ignorieren von Werten in einem Muster</a></h3>
<p>Du hast gesehen, dass es manchmal nützlich ist, Werte in einem Muster zu
ignorieren, z.B. im letzten Zweig eines <code>match</code>, um einen Sammelzweig zu
erhalten, der eigentlich nichts tut, aber alle verbleibenden möglichen Werte
berücksichtigt. Es gibt ein paar Möglichkeiten, ganze Werte oder Teile von
Werten in einem Muster zu ignorieren: Verwenden des Musters <code>_</code> (das du gesehen
hast), Verwenden des Musters <code>_</code> innerhalb eines anderen Musters, Verwenden
eines Namens, der mit einem Unterstrich beginnt, oder Verwenden von <code>..</code>, um
verbleibende Teile eines Wertes zu ignorieren. Lass uns untersuchen, wie und
wann jedes dieser Muster zu verwenden ist.</p>
<h4><a class="header" href="#ignorieren-eines-gesamtwertes-mit-_" id="ignorieren-eines-gesamtwertes-mit-_">Ignorieren eines Gesamtwertes mit <code>_</code></a></h4>
<p>Wir haben den Unterstrich (<code>_</code>) als Platzhalter verwendet, der zu jedem Wert
passt, aber nicht an den Wert gebunden ist. Obwohl das Unterstrichmuster <code>_</code>
besonders nützlich als letzter Zweig in einem <code>match</code>-Ausdruck ist, können wir
es in jedem Muster verwenden, einschließlich Funktionsparameter, wie in
Codeblock 18-17 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;Dieser Code verwendet nur den Parameter y: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-17: Verwenden von <code>_</code> in einer
Funktionssignatur</span></p>
<p>Dieser Code ignoriert den als erstes Argument übergebenen Wert <code>3</code> vollständig
und gibt <code>Dieser Code verwendet nur den Parameter y: 4</code> aus.</p>
<p>In den meisten Fällen, wenn du einen bestimmten Funktionsparameter nicht mehr
benötigst, würdest du die Signatur so ändern, dass sie den unbenutzten
Parameter nicht mehr enthält. Das Ignorieren eines Funktionsparameters kann in
einigen Fällen besonders nützlich sein, z.B. bei der Implementierung eines
Merkmals (trait), wenn du eine bestimmte Typsignatur benötigst, der
Funktionsrumpf in deiner Implementierung jedoch keinen der Parameter benötigt.
Der Compiler wird dann nicht vor unbenutzten Funktionsparametern warnen, wie es
der Fall wäre, wenn du stattdessen einen Namen verwenden würdest.</p>
<h4><a class="header" href="#ignorieren-von-teilen-eines-wertes-mit-einem-verschachtelten-_" id="ignorieren-von-teilen-eines-wertes-mit-einem-verschachtelten-_">Ignorieren von Teilen eines Wertes mit einem verschachtelten <code>_</code></a></h4>
<p>Wir können <code>_</code> auch innerhalb eines anderen Musters verwenden, um nur einen
Teil eines Wertes zu ignorieren, z.B. wenn wir nur auf einen Teil eines Wertes
testen wollen, aber keine Verwendung für die anderen Teile in dem
entsprechenden Code haben, den wir ausführen wollen. Der Codeblock 18-18 zeigt
den Code, der für die Verwaltung des Wertes einer Einrichtung verantwortlich
ist. Die Geschäftsanforderungen bestehen darin, dass es dem Benutzer nicht
erlaubt sein soll, eine bestehende Anpassung einer Einstellung zu
überschreiben, sondern dass er die Einstellung rückgängig machen kann und ihr
einen Wert zuweisen kann, wenn sie derzeit nicht gesetzt ist.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;Einstellung ist {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-18: Das Verwenden eines Unterstrichs
innerhalb von Mustern, die zu <code>Some</code>-Varianten passen, wenn wir den Wert
innerhalb <code>Some</code> nicht benötigen</span></p>
<p>Dieser Code gibt <code>Kann einen vorhandenen benutzerdefinierten Wert nicht überschreiben.</code> aus und dann <code>Einstellung ist Some(5)</code>. Im ersten
<code>match</code>-Zweig müssen wir nicht die Werte innerhalb der beiden <code>Some</code>-Varianten
abgleichen oder diese verwenden, aber wir müssen den Fall prüfen, dass
<code>setting_value</code> und <code>new_setting_value</code> jeweils <code>Some</code>-Varianten sind. In
diesem Fall geben wir aus, warum wir <code>setting_value</code> nicht ändern, und es wird
nicht geändert.</p>
<p>In allen anderen Fällen (wenn entweder <code>setting_value</code> oder <code>new_setting_value</code>
den Wert <code>None</code> hat), die durch das Muster <code>_</code> im zweiten Zweig ausgedrückt
werden, wollen wir erlauben, dass <code>setting_value</code> den Wert von
<code>new_setting_value</code> erhält.</p>
<p>Wir können Unterstriche auch an mehreren Stellen innerhalb eines Musters
verwenden, um bestimmte Werte zu ignorieren. Codeblock 18-19 zeigt ein Beispiel
für das Ignorieren des zweiten und vierten Wertes in einem Tupel von fünf
Elementen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Einige Zahlen: {}, {}, {}&quot;, first, third, fifth)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-19: Ignorieren mehrerer Teile eines
Tupels</span></p>
<p>Dieser Code gibt <code>Einige Zahlen: 2, 8, 32</code> aus und die Werte 4 und 16 werden
ignoriert.</p>
<h4><a class="header" href="#ignorieren-einer-unbenutzten-variable-indem-ihr-name-mit-_-beginnt" id="ignorieren-einer-unbenutzten-variable-indem-ihr-name-mit-_-beginnt">Ignorieren einer unbenutzten Variable, indem ihr Name mit <code>_</code> beginnt</a></h4>
<p>Wenn du eine Variable erstellst, sie aber nirgendwo verwendest, wird Rust
normalerweise eine Warnung ausgeben, weil das ein Fehler sein könnte. Aber
manchmal ist es nützlich, eine Variable zu erstellen, die du noch nicht
verwenden wirst, z.B. wenn du einen Prototyp erstellst oder gerade ein Projekt
beginnst. In dieser Situation kannst du Rust anweisen, dich nicht vor der
unbenutzten Variablen zu warnen, indem du den Namen der Variablen mit einem
Unterstrich beginnst. In Codeblock 18-20 erstellen wir zwei unbenutzte
Variablen, aber wenn wir diesen Code ausführen, sollten wir nur vor einer von
ihnen eine Warnung erhalten.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Codeblock 18-20: Beginnen eines Variablennamens mit einem
Unterstrich, um Warnungen zu unbenutzten Variablen zu vermeiden</span></p>
<p>Hier erhalten wir eine Warnung zur unbenutzten Variablen <code>y</code>, aber wir erhalten
keine Warnung zur unbenutzten Variablen mit vorangestelltem Unterstrich.</p>
<p>Beachte, dass es einen feinen Unterschied gibt zwischen dem Verwenden von <code>_</code>
und dem Verwenden eines Namens, der mit einem Unterstrich beginnt. Die Syntax
<code>_x</code> bindet immer noch den Wert an die Variable, während <code>_</code> überhaupt nicht
bindet. Um einen Fall zu zeigen, in dem diese Unterscheidung von Bedeutung ist,
wird uns Codeblock 18-21 einen Fehler liefern.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hallo!&quot;));

    if let Some(_s) = s {
        println!(&quot;Zeichenkette gefunden&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-21: Eine unbenutzte Variable, die mit einem
Unterstrich beginnt, bindet immer noch den Wert, der die Eigentümerschaft des
Wertes übernehmen könnte</span></p>
<p>Wir werden einen Fehler erhalten, weil der Wert <code>s</code> immer noch in <code>_s</code>
verschoben wird, was uns daran hindert, <code>s</code> wieder zu verwenden. Das Verwenden
des Unterstrichs an sich bindet jedoch niemals einen Wert. Codeblock 18-22 wird
ohne Fehler kompilieren, weil <code>s</code> nicht in <code>_</code> verschoben wird.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hallo!&quot;));

    if let Some(_) = s {
        println!(&quot;Zeichenkette gefunden&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-22: Das Verwenden eines Unterstrichs bindet
den Wert nicht</span></p>
<p>Dieser Code funktioniert prima, weil wir <code>s</code> nie an etwas binden; es wird nicht
verschoben.</p>
<h4><a class="header" href="#ignorieren-der-verbleibenden-teile-eines-wertes-mit-" id="ignorieren-der-verbleibenden-teile-eines-wertes-mit-">Ignorieren der verbleibenden Teile eines Wertes mit <code>..</code></a></h4>
<p>Bei Werten, die viele Teile haben, können wir die Syntax <code>..</code> verwenden, um nur
einige wenige Teile zu verwenden und den Rest zu ignorieren, sodass es nicht
notwendig ist, für jeden ignorierten Wert Unterstriche aufzulisten. Das Muster
<code>..</code> ignoriert alle Teile eines Wertes, die wir im Rest des Musters nicht
explizit zugeordnet haben. In Codeblock 18-23 haben wir eine Struktur <code>Point</code>,
die eine Koordinate im dreidimensionalen Raum enthält. Im <code>match</code>-Ausdruck
wollen wir nur mit der Koordinate <code>x</code> operieren und die Werte in den Feldern
<code>y</code> und <code>z</code> ignorieren.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x ist {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-23: Ignorieren aller Felder eines <code>Point</code>
mit Ausnahme von <code>x</code> durch Verwenden von <code>..</code></span></p>
<p>Wir listen den Wert <code>x</code> auf und fügen dann einfach das Muster <code>..</code> ein. Das
geht schneller, als <code>y: _</code> und <code>z: _</code> anzugeben, insbesondere wenn wir mit
Strukturen arbeiten, die viele Felder haben, in Situationen, in denen nur ein
oder zwei Felder relevant sind.</p>
<p>Die Syntax <code>..</code> wird auf so viele Werte wie nötig erweitert. Codeblock 18-24
zeigt, wie man <code>..</code> mit einem Tupel verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Einige Zahlen: {}, {}&quot;, first, last);
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-24: Nur den ersten und letzten Wert in einem
Tupel abgleichen und alle anderen Werte ignorieren</span></p>
<p>In diesem Code werden der erste und der letzte Wert mit <code>first</code> und <code>last</code>
abgeglichen. Das <code>..</code> passt zu allem in der Mitte und ignoriert es.</p>
<p>Das Verwenden von <code>..</code> muss jedoch eindeutig sein. Wenn unklar ist, welche
Werte zum Abgleich vorgesehen sind und welche ignoriert werden sollten, gibt
uns Rust einen Fehler. Codeblock 18-25 zeigt ein Beispiel für die mehrdeutige
Verwendung von <code>..</code>, sodass es sich nicht kompilieren lässt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Einige Zahlen: {}&quot;, second)
        },
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-25: Ein Versuch, <code>..</code> auf mehrdeutige Weise
zu verwenden</span></p>
<p>Wenn wir dieses Beispiel kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Es ist für Rust unmöglich zu bestimmen, wie viele Werte im Tupel zu ignorieren
sind, bevor ein Wert zu <code>second</code> passt, und wie viele weitere Werte danach zu
ignorieren sind. Dieser Code könnte bedeuten, dass wir <code>2</code> ignorieren wollen,
<code>second</code> an <code>4</code> binden und dann <code>8</code>, <code>16</code> und <code>32</code> ignorieren wollen; oder dass
wir <code>2</code> und <code>4</code> ignorieren wollen, <code>second</code> an <code>8</code> binden und dann <code>16</code> und
<code>32</code> ignorieren wollen; und so weiter. Der Variablenname <code>second</code> bedeutet für
Rust nichts Besonderes, sodass wir einen Kompilierfehler erhalten, weil das
Verwenden von <code>..</code> an zwei Stellen wie dieser mehrdeutig ist.</p>
<h3><a class="header" href="#extra-bedingungen-mit-abgleichsbedingungen" id="extra-bedingungen-mit-abgleichsbedingungen">Extra-Bedingungen mit Abgleichsbedingungen</a></h3>
<p>Eine <em>Abgleichsbedingung</em> (match guard) ist eine zusätzliche <code>if</code>-Bedingung,
die nach dem Muster in einem <code>match</code>-Zweig angegeben wird und die zusammen mit
dem Musterabgleich ebenfalls übereinstimmen muss, damit dieser Zweig ausgewählt
wird. Abgleichsbedingungen sind nützlich, um komplexere Ideen auszudrücken, als
es ein Muster allein erlaubt.</p>
<p>Die Bedingung kann Variablen verwenden, die im Muster erstellt wurden.
Codeblock 18-26 zeigt ein <code>match</code>, wobei der erste Zweig das Muster <code>Some(x)</code>
und die Abgleichsbedingung <code>if x &lt; 5</code> hat.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&quot;kleiner als fünf: {}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-26: Hinzufügen einer Abgleichsbedingung zu
einem Muster</span></p>
<p>In diesem Beispiel wird <code>kleiner als fünf: 4</code> ausgegeben. Wenn <code>num</code> mit dem
Muster im ersten Zweig abgeglichen wird, passt es, weil <code>Some(4)</code> zu <code>Some(x)</code>
passt. Dann prüft die Abgleichsbedingung, ob der Wert in <code>x</code> kleiner als <code>5</code>
ist, und weil dies der Fall ist, wird der erste Zweig ausgewählt.</p>
<p>Hätte <code>num</code> stattdessen den Wert <code>Some(10)</code> gehabt, wäre die Abgleichsbedingung
im ersten Zweig falsch gewesen, denn 10 ist nicht weniger als 5. Rust würde
dann zum zweiten Zweig gehen, der passen würde, weil der zweite Zweig keine
Abgleichsbedingung hat und daher zu allen <code>Some</code>-Varianten passt.</p>
<p>Es gibt keine Möglichkeit, die Bedingung <code>if x &lt; 5</code> innerhalb eines Musters
auszudrücken, also gibt uns die Abgleichsbedingung die Möglichkeit, diese Logik
anzugeben.</p>
<p>In Codeblock 18-11 haben wir erwähnt, dass wir zur Lösung unseres
Musterbeschattungsproblems (pattern-shadowing problem) Abgleichsbedingungen
verwenden könnten. Erinnere dich daran, dass eine neue Variable innerhalb des
Musters im <code>match</code>-Ausdruck erstellt wurde, anstatt die Variable außerhalb von
<code>match</code> zu verwenden. Diese neue Variable bedeutete, dass wir nicht gegen den
Wert der äußeren Variable testen konnten. Codeblock 18-27 zeigt, wie wir eine
Abgleichsbedingung verwenden können, um dieses Problem zu beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Habe 50 erhalten&quot;),
        Some(n) if n == y =&gt; println!(&quot;Passt, n = {}&quot;, n),
        _ =&gt; println!(&quot;Standardfall, x = {:?}&quot;, x),
    }

    println!(&quot;Am Ende: x = {:?}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-27: Verwenden einer Abgleichsbedingung zum
Testen der Gleichheit mit einer äußeren Variablen</span></p>
<p>Dieser Code gibt nun <code>Standardfall, x = Some(5)</code> aus. Das Muster im zweiten
<code>match</code>-Zweig führt keine neue Variable <code>y</code> ein, die das äußere <code>y</code> beschatten
würde, was bedeutet, dass wir das äußere <code>y</code> in der Abgleichsbedingung
verwenden können. Anstatt das Muster mit <code>Some(y)</code> zu spezifizieren, was das
äußere <code>y</code> beschattet hätte, spezifizieren wir <code>Some(n)</code>. Dies erzeugt eine
neue Variable <code>n</code>, die nichts beschattet, weil es keine Variable <code>n</code> außerhalb
von <code>match</code> gibt.</p>
<p>Die Abgleichsbedingung <code>if n == y</code> ist kein Muster und führt daher keine neuen
Variablen ein. Dieses <code>y</code> <em>ist</em> das äußere <code>y</code> und nicht ein neues beschattetes
<code>y</code>, und wir können nach einem Wert suchen, der den gleichen Wert wie das
äußere <code>y</code> hat, indem wir <code>n</code> mit <code>y</code> vergleichen.</p>
<p>Du kannst auch den <em>oder</em>-Operator <code>|</code> in einer Abgleichsbedingung verwenden,
um mehrere Muster anzugeben; die Abgleichsbedingung gilt dann für alle Muster.
Codeblock 18-28 zeigt den Vorrang der Kombination einer Abgleichsbedingung mit
einem Muster, das <code>|</code> verwendet. Der wichtige Teil dieses Beispiels ist, dass
die Abgleichsbedingung <code>if y</code> auf <code>4</code>, <code>5</code> <em>und</em> <code>6</code> zutrifft, auch wenn es so
aussehen mag, als ob <code>if y</code> nur auf <code>6</code> zutrifft.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;ja&quot;),
        _ =&gt; println!(&quot;nein&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-28: Kombinieren mehrerer Muster mit einer
Abgleichsbedingung</span></p>
<p>Die Abgleichsbedingung besagt, dass der Zweig nur dann passt, wenn der Wert von
<code>x</code> gleich <code>4</code>, <code>5</code> oder <code>6</code> ist <em>und</em> wenn <code>y</code> <code>wahr</code> ist. Wenn dieser Code
ausgeführt wird, passt das Muster des ersten Zweigs, weil <code>x</code> gleich <code>4</code> ist,
allerdings ist die Abgleichsbedingung <code>if y</code> falsch, sodass der erste Zweig
nicht ausgewählt wird. Der Code geht weiter zum zweiten Zweig, der passt, und
dieses Programm gibt <code>nein</code> aus. Der Grund dafür ist, dass die <code>if</code>-Bedingung
für das gesamte Muster <code>4 | 5 | 6</code> gilt, nicht nur für den letzten Wert <code>6</code>.
Mit anderen Worten, der Vorrang einer Abgleichsbedingung in Bezug auf ein
Muster verhält sich wie folgt:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>und nicht so:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Nach dem Ausführen des Codes ist das Vorrangsverhalten offensichtlich: Würde
die Abgleichsbedingung nur auf den Endwert in der mit dem <code>|</code>-Operator
angegebenen Werteliste angewendet, hätte der Zweig gepasst und das Programm
hätte <code>ja</code> ausgegeben.</p>
<h3><a class="header" href="#-bindungen" id="-bindungen"><code>@</code>-Bindungen</a></h3>
<p>Mit dem <em>at</em>-Operator (<code>@</code>) können wir eine Variable erstellen, die einen Wert
enthält, während wir gleichzeitig diesen Wert testen, um festzustellen, ob er
zu einem Muster passt. Codeblock 18-29 zeigt ein Beispiel, bei dem wir testen
wollen, dass ein <code>Message::Hello</code>-Feld <code>id</code> innerhalb des Bereichs <code>3..=7</code>
liegt. Aber wir wollen den Wert auch an die Variable <code>id_variable</code> binden,
damit wir ihn in dem mit dem Zweig verbundenen Code verwenden können. Wir
könnten diese Variable <code>id</code> nennen, so wie das Feld, aber für dieses Beispiel
werden wir einen anderen Namen verwenden.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;id im Bereich gefunden: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;id in einem anderen Bereich gefunden&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Eine andere id gefunden: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 18-29: Verwenden von <code>@</code>, um an einen Wert in
einem Muster zu binden und ihn gleichzeitig zu testen</span></p>
<p>In diesem Beispiel wird <code>id im Bereich gefunden: 5</code> ausgegeben. Durch das
Angeben von <code>id_variable @</code> vor dem Bereich <code>3..=7</code> erfassen wir den Wert, der
mit dem Bereich übereinstimmt, und testen gleichzeitig, ob der Wert zum
Bereichsmuster passt.</p>
<p>Im zweiten Zweig, wo wir im Muster nur einen Bereich spezifiziert haben, hat
der zum Zweig gehörende Code keine Variable, die den tatsächlichen Wert des
<code>id</code>-Feldes enthält. Der Wert des <code>id</code>-Feldes hätte 10, 11 oder 12 sein können,
aber der Code, der zu diesem Muster gehört, weiß nicht, welcher es ist. Der
Code des Musters ist nicht in der Lage, den Wert des <code>id</code>-Feldes zu verwenden,
weil wir den <code>id</code>-Wert nicht in einer Variablen gespeichert haben.</p>
<p>Im letzten Zweig, in dem wir eine Variable ohne Bereich angegeben haben, haben
wir den Wert, der im Code des Zweigs verfügbar ist, in einer Variablen namens
<code>id</code>. Der Grund dafür ist, dass wir die Syntax des Struktur-Feldes in
Kurznotation verwendet haben. Aber wir haben keinen Test auf den Wert im Feld
<code>id</code> in diesem Zweig angewandt, wie wir es bei den ersten beiden Zweigen getan
haben: Jeder Wert würde zu diesem Muster passen.</p>
<p>Mit <code>@</code> können wir einen Wert testen und ihn in einer Variablen innerhalb eines
Musters speichern.</p>
<h2><a class="header" href="#zusammenfassung-17" id="zusammenfassung-17">Zusammenfassung</a></h2>
<p>Die Muster in Rust sind sehr nützlich, da sie helfen, zwischen verschiedenen
Arten von Daten zu unterscheiden. Wenn sie in <code>match</code>-Ausdrücken verwendet
werden, stellt Rust sicher, dass deine Muster jeden möglichen Wert abdecken
oder dein Programm sich nicht kompilieren lässt. Muster in <code>let</code>-Anweisungen
und Funktionsparametern machen diese Konstrukte nützlicher und ermöglichen das
Destrukturieren von Werten in kleinere Teile und gleichzeitig das Zuweisen an
Variablen. Wir können einfache oder komplexe Muster erstellen, die unseren
Bedürfnissen entsprechen.</p>
<p>Als nächstes werden wir uns im vorletzten Kapitel des Buches mit einigen
fortgeschrittenen Aspekten einer Vielzahl von Rusts Funktionalitäten befassen.</p>
<h1><a class="header" href="#fortgeschrittene-sprachelemente" id="fortgeschrittene-sprachelemente">Fortgeschrittene Sprachelemente</a></h1>
<p>Inzwischen hast du die am häufigsten verwendeten Teile der Programmiersprache
Rust gelernt. Bevor wir in Kapitel 20 ein weiteres Projekt durchführen, werden
wir uns einige Aspekte der Sprache ansehen, auf die du hin und wieder stoßen
könntest. Du kannst dieses Kapitel als Referenz verwenden, wenn du beim
Verwenden von Rust auf Unbekanntes stößt. Die Funktionalitäten, die du in
diesem Kapitel lernen wirst, sind in sehr speziellen Situationen nützlich. Auch
wenn du vielleicht nicht oft danach greifst, möchten wir sicherstellen, dass du
alle Funktionen, die Rust zu bieten hat, beherrschst.</p>
<p>In diesem Kapitel werden wir behandeln:</p>
<ul>
<li>Unsicheres Rust: Wie kann man einige der Garantien von Rust ausschalten und
Verantwortung für das manuelle Aufrechterhalten dieser Garantien übernehmen?</li>
<li>Fortgeschrittene Merkmale (traits): Assoziierte Typen, Standardtypparameter,
voll qualifizierte Syntax, Supermerkmale (supertraits) und das Newtype-Muster
in Bezug auf Merkmale</li>
<li>Fortgeschrittene Typen: Mehr über das Newtype-Muster, Typ-Aliase, den Typ
never und Typen dynamischer Größe</li>
<li>Erweiterte Funktionen und Funktionsabschlüsse: Funktionszeiger und
Zurückgeben von Funktionsabschlüssen</li>
<li>Makros: Möglichkeiten, Code zu definieren, der zur Kompilierzeit mehr Code
definiert</li>
</ul>
<p>Es ist eine Reihe von Rust-Funktionalitäten, die für jeden etwas bietet! Lass
uns eintauchen!</p>
<h2><a class="header" href="#unsicheres-unsafe-rust" id="unsicheres-unsafe-rust">Unsicheres (unsafe) Rust</a></h2>
<p>Bei allem Code, den wir bisher besprochen haben, wurden Rusts
Speichersicherheitsgarantien zur Kompilierzeit erzwungen. Allerdings ist in
Rust eine zweite Sprache versteckt, die diese Speichersicherheitsgarantien
nicht erzwingt: Sie heißt <em>unsicheres Rust</em> (unsafe Rust) und funktioniert
genau wie das normale Rust, gibt uns aber zusätzliche Superkräfte.</p>
<p>Unsicheres Rust existiert, weil die statische Analyse von Natur aus konservativ
ist. Wenn der Compiler versucht festzustellen, ob der Code die Garantien
einhält oder nicht, ist es besser für ihn, einige gültige Programme
zurückzuweisen, als einige ungültige Programme zu akzeptieren. Der Code mag
zwar in Ordnung sein, aber soweit Rust es beurteilen kann, ist er es nicht! In
diesen Fällen kannst du unsicheren Code verwenden, um dem Compiler zu sagen:
„Vertraue mir, ich weiß, was ich tue.“ Der Nachteil ist, dass du ihn auf
eigenes Risiko verwendest: Wenn du unsicheren Code falsch verwendest, können
Probleme aufgrund von Speicherunsicherheiten, z.B. Dereferenzierung von
Null-Zeigern, auftreten.</p>
<p>Ein weiterer Grund, warum Rust ein unsicheres zweites Ich hat, ist, dass die
zugrunde liegende Computer-Hardware von Natur aus unsicher ist. Wenn Rust dich
keine unsicheren Operationen durchführen ließe, könntest du bestimmte Aufgaben
nicht ausführen. Rust muss es dir ermöglichen, Low-Level-Systemprogrammierung
zu machen, z.B. direkt mit dem Betriebssystem zu interagieren oder sogar dein
eigenes Betriebssystem zu schreiben. Arbeiten mit
Low-Level-Systemprogrammierung ist eines der Ziele der Sprache. Lass uns
untersuchen, was wir mit unsicherem Rust tun können und wie wir es tun können.</p>
<h3><a class="header" href="#unsichere-superkräfte" id="unsichere-superkräfte">Unsichere Superkräfte</a></h3>
<p>Um auf unsicheres Rust umzuschalten, verwendest du das Schlüsselwort <code>unsafe</code>
und startest dann einen neuen Block, der den unsicheren Code enthält. Du kannst
in unsicherem Rust fünf Aktionen durchführen, die als <em>unsichere Superkräfte</em>
bezeichnet werden und in sicherem Rust nicht möglich sind. Diese Superkräfte
beinhalten folgende Möglichkeiten:</p>
<ul>
<li>Dereferenzieren eines Rohzeigers</li>
<li>Aufrufen einer unsicheren Funktion oder Methode</li>
<li>Zugreifen auf oder Ändern einer veränderlichen statischen Variablen</li>
<li>Implementieren eines unsicheren Merkmals (trait)</li>
<li>Zugreifen auf Feldern in <code>union</code></li>
</ul>
<p>Es ist wichtig zu verstehen, dass <code>unsafe</code> weder den Ausleihenprüfer (borrow
checker) abschaltet noch andere Sicherheitsprüfungen von Rust deaktiviert: Wenn
du eine Referenz in einem unsicheren Code verwendest, wird diese trotzdem
geprüft. Das Schlüsselwort <code>unsafe</code> gibt dir nur Zugriff auf diese fünf
Funktionalitäten, die dann vom Compiler nicht auf Speichersicherheit geprüft
werden. In einem unsicheren Block erhältst du immer noch ein gewisses Maß an
Sicherheit.</p>
<p>Darüber hinaus bedeutet <code>unsafe</code> nicht, dass der Code innerhalb des Blocks
notwendigerweise gefährlich ist oder dass er definitiv
Speichersicherheitsprobleme haben wird: Das Ziel ist, dass du als Programmierer
sicherstellst, dass der Code innerhalb eines <code>unsafe</code>-Blocks auf gültige Weise
auf den Speicher zugreifen wird.</p>
<p>Menschen sind fehlbar und Fehler werden passieren, aber wenn du verlangst, dass
diese fünf unsicheren Operationen innerhalb von Blöcken mit dem Vermerk
<code>unsafe</code> durchgeführt werden müssen, weißt du, dass alle Fehler im Zusammenhang
mit der Speichersicherheit innerhalb eines <code>unsafe</code>-Blocks liegen müssen. Halte
<code>unsafe</code>-Blöcke klein; du wirst später dankbar sein, wenn du Speicherfehler
untersuchst.</p>
<p>Um unsicheren Code so weit wie möglich zu isolieren, ist es am besten,
unsicheren Code in eine sichere Abstraktion einzupacken und eine sichere API
bereitzustellen, auf die wir später im Kapitel eingehen werden, wenn wir
unsichere Funktionen und Methoden untersuchen. Teile der Standardbibliothek
sind als sichere Abstraktionen über unsicheren, geprüften Code implementiert.
Das Einpacken von unsicherem Code in eine sichere Abstraktion verhindert, dass
sich die Verwendung von <code>unsafe</code> auf alle Stellen auswirkt, an denen du oder
deine Benutzer die mit <code>unsafe</code>-Code implementierte Funktionalität verwenden
möchtest, da das Verwenden einer sicheren Abstraktion sicher ist.</p>
<p>Betrachten wir der Reihe nach jede der fünf unsicheren Superkräfte. Wir werden
uns auch einige Abstraktionen ansehen, die eine sichere Schnittstelle zu
unsicheren Codes bieten.</p>
<h3><a class="header" href="#dereferenzieren-eines-rohzeigers" id="dereferenzieren-eines-rohzeigers">Dereferenzieren eines Rohzeigers</a></h3>
<p>In Kapitel 4 haben wir im Abschnitt <a href="ch04-02-references-and-borrowing.html#h%C3%A4ngende-referenzen">„Hängende
Referenzen“</a> erwähnt, dass der Compiler sicherstellt,
dass Referenzen immer gültig sind. Unsicheres Rust hat zwei neue Typen namens
<em>Rohzeiger</em> (raw pointers), die ähnlich wie Referenzen sind. Wie bei Referenzen
können Rohzeiger unveränderlich oder veränderlich sein und werden als <code>*const T</code> bzw. <code>*mut T</code> geschrieben. Das Sternchen ist nicht der
Dereferenzierungsoperator (dereference operator); es ist Teil des Typnamens. Im
Zusammenhang mit Rohzeigern bedeutet <em>unveränderlich</em> (immutable), dass der
Zeiger nach der Dereferenzierung nicht direkt zugewiesen werden kann.</p>
<p>Rohzeiger sind anders als Referenzen und intelligente Zeiger:</p>
<ul>
<li>Sie dürfen die Ausleihregeln ignorieren, indem sie sowohl unveränderliche als
auch veränderliche Zeiger oder mehrere veränderliche Zeiger auf die gleiche
Stelle haben.</li>
<li>Sie zeigen nicht garantiert auf gültigen Speicher.</li>
<li>Sie dürfen null sein.</li>
<li>Sie implementieren keine automatische Bereinigung.</li>
</ul>
<p>Wenn du dich dagegen entscheidest, diese Garantien von Rust erzwingen zu
lassen, kannst du auf garantierte Sicherheit verzichten und stattdessen eine
höhere Performanz oder die Möglichkeit der Interaktion mit einer anderen
Sprache oder Hardware erhalten, für die die Rust-Garantien nicht gelten.</p>
<p>Codeblock 19-1 zeigt, wie man aus Referenzen einen unveränderlichen und einen
veränderlichen Rohzeiger erzeugt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-1: Erstellen von Rohzeigern aus
Referenzen</span></p>
<p>Beachte, dass wir das Schlüsselwort <code>unsafe</code> in diesem Code nicht verwenden.
Wir können Rohzeiger in sicherem Code erzeugen; wir können nur keine Rohzeiger
außerhalb eines unsicheren Blocks dereferenzieren, wie du gleich sehen wirst.</p>
<p>Wir haben Rohzeiger erstellt, indem wir <code>as</code> angegeben haben, um eine
unveränderliche und eine veränderliche Referenz in die entsprechenden
Rohzeigertypen umzuwandeln (cast). Da wir sie direkt aus Referenzen erstellt
haben, deren Gültigkeit garantiert ist, wissen wir, dass diese speziellen
Rohzeiger gültig sind, aber wir können diese Annahme nicht für jeden beliebigen
Rohzeiger treffen.</p>
<p>Als Nächstes werden wir einen Rohzeiger erstellen, bei dem wir uns nicht sicher
sein können, das er gültig ist. Codeblock 19-2 zeigt, wie man einen Rohzeiger
auf eine willkürliche Stelle im Speicher erstellt. Der Versuch, willkürlichen
Speicher zu verwenden, ist undefiniert: Es könnten Daten an dieser Adresse
vorhanden sein oder auch nicht, der Compiler könnte den Code so optimieren,
dass es keinen Speicherzugriff gibt, oder das Programm könnte eine
Schutzverletzung (segmentation fault) verursachen. Normalerweise gibt es keinen
guten Grund, Code wie diesen zu schreiben, aber es ist möglich.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-2: Erzeugen eines Rohzeigers auf eine
willkürliche Speicheradresse</span></p>
<p>Erinnere dich, dass wir Rohzeiger in sicherem Code erstellen können, aber wir
können keine Rohzeiger <em>dereferenzieren</em> und die Daten lesen, auf die gezeigt
wird. In Codeblock 19-3 wenden wir den Dereferenzierungsoperator <code>*</code> auf einen
Rohzeiger an, was einen <code>unsafe</code>-Block erfordert.</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 ist: {}&quot;, *r1);
        println!(&quot;r2 ist: {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-3: Dereferenzieren von Rohzeigern innerhalb
eines <code>unsafe</code>-Blocks</span></p>
<p>Das Erstellen eines Zeigers schadet nicht; erst wenn wir versuchen, auf den
Wert zuzugreifen, auf den er zeigt, könnten wir es am Ende mit einem ungültigen
Wert zu tun haben.</p>
<p>Beachte auch, dass wir in Codeblock 19-1 und 19-3 die Rohzeiger <code>*const i32</code>
und <code>*mut i32</code> erstellt haben, die beide auf die gleiche Speicherstelle
zeigten, in der <code>num</code> gespeichert ist. Wenn wir stattdessen versucht hätten,
eine unveränderliche und einen veränderliche Referenz auf <code>num</code> zu erstellen,
hätte sich der Code nicht kompilieren lassen, weil die Eigentümerschaftsregeln
von Rust eine veränderliche Referenz nicht gleichzeitig mit unveränderlichen
Referenzen zulassen. Mit Rohzeigern können wir einen veränderlichen und
einen unveränderlichen Zeiger auf denselben Ort erstellen und Daten über den
veränderlichen Zeiger ändern, wodurch möglicherweise eine
Daten-Wettlaufsituation (data race) entsteht. Sei vorsichtig!</p>
<p>Warum solltest du bei all diesen Gefahren jemals Rohzeiger verwenden? Ein
Hauptanwendungsfall ist die Kopplung mit C-Code, wie du im nächsten Abschnitt
<a href="ch19-01-unsafe-rust.html#aufrufen-einer-unsicheren-funktion-oder-methode">„Aufrufen einer unsicheren Funktion oder
Methode“</a> sehen wirst. Ein
anderer Fall ist der Aufbau von sicheren Abstraktionen, die der Ausleihenprüfer
nicht versteht. Wir stellen unsichere Funktionen vor und betrachten dann ein
Beispiel für eine sichere Abstraktion, die unsicheren Code verwendet.</p>
<h3><a class="header" href="#aufrufen-einer-unsicheren-funktion-oder-methode" id="aufrufen-einer-unsicheren-funktion-oder-methode">Aufrufen einer unsicheren Funktion oder Methode</a></h3>
<p>Die zweite Art von Operationen, die einen unsicheren Block erfordern, sind
Aufrufe von unsicheren Funktionen. Unsichere Funktionen und Methoden sehen
genau wie reguläre Funktionen und Methoden aus, aber sie haben ein zusätzliches
<code>unsafe</code> vor dem Rest der Definition. Das Schlüsselwort <code>unsafe</code> weist in
diesem Zusammenhang darauf hin, dass die Funktion Anforderungen hat, die wir
einhalten müssen, wenn wir diese Funktion aufrufen, denn Rust kann nicht
garantieren, dass wir diese Anforderungen erfüllt haben. Indem wir eine
unsichere Funktion innerhalb eines <code>unsafe</code>-Blocks aufrufen, sagen wir, dass
wir die Dokumentation dieser Funktion gelesen haben und die Verantwortung für
die Einhaltung der Verträge der Funktion übernehmen.</p>
<p>Hier ist eine unsichere Funktion namens <code>dangerous</code>, die in ihrem Rumpf nichts
tut:</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<p>Wir müssen die Funktion <code>dangerous</code> innerhalb eines separaten <code>unsafe</code>-Blocks
aufrufen. Wenn wir versuchen, <code>dangerous</code> ohne den <code>unsafe</code>-Block aufzurufen,
erhalten wir einen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Indem wir den <code>unsafe</code>-Block um unseren Aufruf von <code>dangerous</code> legen,
versichern wir Rust, dass wir die Dokumentation der Funktion gelesen haben,
dass wir verstehen, wie sie richtig zu benutzen ist, und dass wir überprüft
haben, dass wir den Vertrag der Funktion erfüllen.</p>
<p>Rümpfe von unsicheren Funktionen sind effektiv <code>unsafe</code>-Blöcke, d.h. wir können
andere unsichere Operationen innerhalb einer unsicheren Funktion ausführen,
ohne einen weiteren <code>unsafe</code>-Block hinfügen zu müssen.</p>
<h4><a class="header" href="#erstellen-einer-sicheren-abstraktion-von-unsicherem-code" id="erstellen-einer-sicheren-abstraktion-von-unsicherem-code">Erstellen einer sicheren Abstraktion von unsicherem Code</a></h4>
<p>Nur weil eine Funktion unsicheren Code enthält, bedeutet das nicht, dass wir
die gesamte Funktion als unsicher markieren müssen. Tatsächlich ist das
Einpacken von unsicherem Codes in eine sichere Funktion eine gängige
Abstraktion. Als Beispiel betrachten wir die Funktion <code>split_at_mut</code> aus der
Standardbibliothek, die unsicheren Code verwendet, und untersuchen, wie wir sie
implementieren könnten. Diese sichere Methode ist auf veränderlichen
Anteilstypen definiert: Sie nimmt einen Anteilstyp und macht zwei daraus, indem
sie den Anteilstyp an dem als Argument angegebenen Index teilt. Codeblock 19-4
zeigt, wie man <code>split_at_mut</code> verwendet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-4: Verwenden der sicheren Funktion
<code>split_at_mut</code></span></p>
<p>Wir können diese Funktion nicht nur mit sicherem Rust implementieren. Ein
Versuch könnte in etwa wie in Codeblock 19-5 aussehen, der sich nicht
kompilieren lässt. Der Einfachheit halber implementieren wir <code>split_at_mut</code> als
Funktion und nicht als Methode und nur für Anteilstypen von <code>i32</code>-Werten, nicht
für einen generischen Typ <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-5: Versuch einer Implementierung von
<code>split_at_mut</code> unter ausschließlicher Verwendung von sicherem Rust</span></p>
<p>Diese Funktion ermittelt zunächst die Gesamtlänge des Anteilstypen. Dann stellt
sie fest, dass der als Parameter angegebene Index innerhalb des Anteilstypen
liegt, indem sie prüft, ob er kleiner oder gleich der Länge ist. Die
Zusicherung (assertion) bedeutet, dass die Funktion abstürzt, wenn wir einen
Index übergeben, der größer als die Länge ist, bei der der Anteilstyp geteilt
werden soll, bevor sie versucht, diesen Index zu verwenden.</p>
<p>Dann geben wir zwei veränderliche Anteilstypen in einem Tupel zurück: Einen vom
Anfang des ursprünglichen Anteilstyps bis zum Index <code>mid</code> und einen weiteren
von <code>mid</code> bis zum Ende des Anteilstyps.</p>
<p>Wenn wir versuchen, den Code in Codeblock 19-5 zu kompilieren, erhalten wir
einen Fehler.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Ausleihenprüfer von Rust kann nicht verstehen, dass wir verschiedene Teile
des Anteilstyps ausleihen; er weiß nur, dass wir zweimal vom selben Anteilstyp
ausleihen. Das Ausleihen verschiedener Teile eines Anteilstyps ist
grundsätzlich in Ordnung, weil sich die beiden Anteilstypen nicht überlappen,
aber Rust ist nicht schlau genug, um das zu wissen. Wenn wir wissen, dass der
Code in Ordnung ist, Rust aber nicht, ist es an der Zeit, unsicheren Code zu
verwenden.</p>
<p>Codeblock 19-6 zeigt, wie man einen <code>unsafe</code>-Block, einen Rohzeiger und einige
Aufrufe unsicherer Funktionen verwendet, um die Implementierung von
<code>split_at_mut</code> zum Funktionieren zu bringen.</p>
<pre><pre class="playground"><code class="language-rust unsafe">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-6: Verwenden von unsicherem Codes bei der
Implementierung der Funktion <code>split_at_mut</code></span></p>
<p>Erinnere dich an Abschnitt <a href="ch04-03-slices.html">„Der Anteilstyp (slice)“</a> in
Kapitel 4, dass Anteilstypen Zeiger auf Daten und die Länge des Anteilstyps
sind. Wir verwenden die Methode <code>len</code>, um die Länge eines Anteilstyps zu
erhalten, und die Methode <code>as_mut_ptr</code>, um auf den Rohzeiger eines Anteilstyps
zuzugreifen. Da wir in diesem Fall einen veränderlichen Anteilstyp von
<code>i32</code>-Werten haben, gibt <code>as_mut_ptr</code> einen Rohzeiger vom Typ <code>*mut i32</code>
zurück, den wir in der Variable <code>ptr</code> gespeichert haben.</p>
<p>Wir halten an der Zusicherung fest, dass der Index <code>mid</code> innerhalb des
Anteilstyps liegt. Dann kommen wir zum unsicheren Code: Die Funktion
<code>slice::from_raw_parts_mut</code> nimmt einen Rohzeiger und eine Länge und erzeugt
einen Anteilstyp. Wir verwenden diese Funktion, um einen Anteilstyp zu
erstellen, der mit <code>ptr</code> beginnt und <code>mid</code> Elemente lang ist. Dann rufen wir
die Methode <code>add</code> auf <code>ptr</code> mit <code>mid</code> als Argument auf, um einen Rohzeiger
zu erhalten, der bei <code>mid</code> beginnt, und wir erzeugen einen Anteilstyp mit
diesem Zeiger und der verbleibenden Anzahl von Elementen nach <code>mid</code>.</p>
<p>Die Funktion <code>slice::from_raw_parts_mut</code> ist unsicher, weil sie einen Rohzeiger
nimmt und darauf vertrauen muss, dass dieser Zeiger gültig ist. Die Methode
<code>add</code> auf dem Rohzeiger ist ebenfalls unsicher, weil sie darauf vertrauen muss,
dass die Offset-Position ebenfalls ein gültiger Zeiger ist. Deshalb mussten wir
einen <code>unsafe</code>-Block um unsere Aufrufe von <code>slice::from_raw_parts_mut</code> und
<code>add</code> legen, damit wir sie aufrufen konnten. Wenn wir uns den Code ansehen und
die Zusicherung hinzufügen, dass <code>mid</code> kleiner oder gleich <code>len</code> sein muss,
können wir sagen, dass alle Rohzeiger innerhalb des <code>unsafe</code>-Blocks gültige
Zeiger auf Daten innerhalb des Anteilstyps sind. Dies ist eine akzeptable und
angemessene Verwendung von <code>unsafe</code>.</p>
<p>Beachte, dass wir die resultierende Funktion <code>split_at_mut</code> nicht als <code>unsafe</code>
markieren müssen, und wir können diese Funktion aus dem sicheren Rust aufrufen.
Wir haben eine sichere Abstraktion des unsicheren Codes mit einer
Implementierung der Funktion geschaffen, die <code>unsafe</code> Code auf sichere Weise
verwendet, weil sie nur gültige Zeiger aus den Daten erzeugt, auf die diese
Funktion Zugriff hat.</p>
<p>Im Gegensatz dazu würde die Verwendung von <code>slice::from_raw_parts_mut</code> in
Codeblock 19-7 wahrscheinlich abstürzen, wenn der Anteilstyp verwendet wird.
Dieser Code nimmt einen beliebigen Speicherplatz und erzeugt einen Anteilstyp
mit einer Länge von 10.000 Elementen.</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-7: Erstellen eines Anteilstyps aus einer
beliebigen Speicherstelle</span></p>
<p>Wir besitzen den Speicher an dieser beliebigen Stelle nicht und es gibt keine
Garantie, dass der von diesem Code erzeugte Anteilstyp gültige <code>i32</code>-Werte
enthält. Der Versuch, <code>slice</code> so zu benutzen, als ob er ein gültiger Anteilstyp
ist, führt zu undefiniertem Verhalten.</p>
<h4><a class="header" href="#verwenden-von-extern-funktionen-um-externen-code-aufzurufen" id="verwenden-von-extern-funktionen-um-externen-code-aufzurufen">Verwenden von <code>extern</code>-Funktionen um externen Code aufzurufen</a></h4>
<p>Manchmal muss dein Rust-Code möglicherweise mit Code interagieren, der in einer
anderen Sprache geschrieben wurde. Hierfür hat Rust das Schlüsselwort <code>extern</code>,
das das Erstellen und Verwenden einer <em>Fremdfunktionsschnittstelle</em> (Foreign
Function Interface, kurz FFI) erleichtert. Eine FFI ist eine Möglichkeit für
eine Programmiersprache, Funktionen zu definieren und es einer anderen
(fremden) Programmiersprache zu ermöglichen, diese Funktionen aufzurufen.</p>
<p>In Codeblock 19-8 wird gezeigt, wie eine Integration der Funktion <code>abs</code> aus der
C-Standardbibliothek erfolgt. Funktionen, die in <code>extern</code>-Blöcken deklariert
sind, sind immer unsicher, wenn sie aus Rust Code aufgerufen werden. Der Grund
dafür ist, dass andere Sprachen die Regeln und Garantien von Rust nicht
erzwingen und Rust sie nicht überprüfen kann, sodass die Verantwortung für die
Sicherheit beim Programmierer liegt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolutwert von -3 gemäß C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-8: Deklarieren und Aufrufen einer
<code>extern</code>-Funktion, die in einer anderen Sprache definiert wurde</span></p>
<p>Innerhalb des Blocks <code>extern &quot;C&quot;</code> listen wir die Namen und Signaturen von
externen Funktionen aus einer anderen Sprache auf, die wir aufrufen wollen. Der
Teil <code>&quot;C&quot;</code> definiert, welche <em>Binärschnittstelle</em> (application binary
interface, kurz ABI) die externe Funktion benutzt: Die ABI definiert, wie die
Funktion auf der technischen Ebene (assembly level) aufgerufen wird. Die ABI
<code>&quot;C&quot;</code> ist die gebräuchlichste und folgt der ABI der Programmiersprache C.</p>
<blockquote>
<h4><a class="header" href="#aufrufen-von-rust-funktionen-aus-anderen-sprachen" id="aufrufen-von-rust-funktionen-aus-anderen-sprachen">Aufrufen von Rust-Funktionen aus anderen Sprachen</a></h4>
<p>Wir können auch <code>extern</code> verwenden, um eine Schnittstelle zu schaffen, die es
anderen Sprachen erlaubt, Rust-Funktionen aufzurufen. Anstelle eines
<code>extern</code>-Blocks fügen wir das Schlüsselwort <code>extern</code> hinzu und geben die zu
verwendende ABI unmittelbar vor dem Schlüsselwort <code>fn</code> an. Wir müssen auch
eine Annotation <code>#[no_mangle]</code> hinzufügen, um dem Rust-Compiler mitzuteilen,
dass er den Namen dieser Funktion nicht verändern soll. <em>Mangling</em> bedeutet,
dass ein Compiler den Namen, den wir einer Funktion gegeben haben, in einen
anderen Namen ändert, der mehr Informationen für andere Teile des
Kompiliervorgangs enthält, aber weniger menschenlesbar ist. Jeder
Programmiersprachen-Compiler verändert Namen etwas anders. Damit eine
Rust-Funktion von anderen Sprachen aufgerufen werden kann, müssen wir also
die Namensveränderung des Rust-Compilers deaktivieren.</p>
<p>Im folgenden Beispiel machen wir die Funktion <code>call_from_c</code> von C-Code aus
zugänglich, nachdem sie in eine gemeinsame Bibliothek kompiliert und von C
gelinkt wurde:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Rust-Funktion von C aufgerufen!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese Verwendung von <code>extern</code> erfordert kein <code>unsafe</code>.</p>
</blockquote>
<h3><a class="header" href="#zugreifen-oder-Ändern-einer-veränderlichen-statischen-variable" id="zugreifen-oder-Ändern-einer-veränderlichen-statischen-variable">Zugreifen oder Ändern einer veränderlichen, statischen Variable</a></h3>
<p>Bis jetzt haben wir noch nicht über <em>globale Variablen</em> gesprochen, die Rust
zwar unterstützt, die aber wegen der Eigentümerschaftsregeln von Rust
problematisch sein können. Wenn zwei Stränge (threads) auf dieselbe
veränderliche, globale Variable zugreifen, kann dies zu einer
Daten-Wettlaufsituation (data race) führen.</p>
<p>In Rust werden globale Variablen als <em>statische</em> Variablen bezeichnet.
Codeblock 19-9 zeigt ein Beispiel für die Deklaration und Verwendung einer
statischen Variablen mit einem Zeichenkettenanteilstyp als Wert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hallo Welt!&quot;;

fn main() {
    println!(&quot;Name ist: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-9: Definieren und Verwenden einer
unveränderlichen, statischen Variablen</span></p>
<p>Statische Variablen ähneln Konstanten, die wir im Abschnitt <a href="ch03-01-variables-and-mutability.html#unterschiede-zwischen-variablen-und-konstanten">„Unterschiede
zwischen Variablen und Konstanten“</a>
in Kapitel 3 besprochen haben. Die Namen von statischen Variablen stehen per
Konvention in <code>SCHREIENDER_SCHLANGENSCHRIFT</code> und wir <em>müssen</em> den Typ der
Variablen annotieren, der in diesem Beispiel <code>&amp;'static str</code> ist. Statische
Variablen können nur Referenzen mit der Lebensdauer <code>'static</code> speichern, was
bedeutet, dass der Rust-Compiler die Lebensdauer herausfinden kann; wir
brauchen sie nicht explizit anzugeben. Der Zugriff auf eine unveränderliche,
statische Variable ist sicher.</p>
<p>Konstanten und unveränderliche, statische Variablen mögen ähnlich aussehen,
aber ein subtiler Unterschied besteht darin, dass Werte in einer statischen
Variable eine feste Adresse im Speicher haben. Beim Verwenden des Wertes wird
immer auf die gleichen Daten zugegriffen. Konstanten hingegen dürfen ihre Daten
duplizieren, wann immer sie verwendet werden.</p>
<p>Ein weiterer Unterschied zwischen Konstanten und statischen Variablen besteht
darin, dass statische Variablen veränderlich sein können. Der Zugriff auf und
die Änderung von veränderlichen, statischen Variablen ist <em>unsicher</em>. Codeblock
19-10 zeigt, wie man eine veränderliche, statische Variable namens <code>COUNTER</code>
deklariert, auf sie zugreift und sie modifiziert.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-10: Lesen von und Schreiben in eine
veränderliche, statische Variable ist unsicher</span></p>
<p>Wie bei regulären Variablen spezifizieren wir die Veränderlichkeit mit dem
Schlüsselwort <code>mut</code>. Jeder Code, der <code>COUNTER</code> liest oder schreibt, muss
innerhalb eines <code>unsafe</code>-Blocks liegen. Dieser Code kompiliert und gibt
<code>COUNTER: 3</code> so, wie wir es erwarten würden, weil er nur einen einzigen Strang
hat. Wenn mehrere Stränge auf <code>COUNTER</code> zugreifen, würde dies wahrscheinlich zu
einer Daten-Wettlaufsituation führen.</p>
<p>Bei veränderlichen Daten, die global zugänglich sind, ist es schwierig,
sicherzustellen, dass es keine Daten-Wettlaufsituationen gibt, weshalb Rust
veränderliche, statische Variablen als unsicher betrachtet. Wann immer möglich,
ist es vorzuziehen, die in Kapitel 16 besprochenen Nebenläufigkeitstechniken
und Strang-sicheren, intelligenten Zeiger zu verwenden, damit der Compiler
prüft, ob der Datenzugriff von verschiedenen Strängen sicher ist.</p>
<h3><a class="header" href="#implementieren-eines-unsicheren-merkmals" id="implementieren-eines-unsicheren-merkmals">Implementieren eines unsicheren Merkmals</a></h3>
<p>Die letzte Aktion, die nur bei <code>unsafe</code> funktioniert, ist das Implementieren
eines unsicheren Merkmals (unsafe trait). Ein Merkmal ist unsicher, wenn
mindestens eine ihrer Methoden eine Invariante hat, die der Compiler nicht
verifizieren kann. Wir können erklären, dass ein Merkmal <code>unsafe</code> ist, indem
wir das Schlüsselwort <code>unsafe</code> vor <code>trait</code> einfügen und die Implementierung des
Merkmals ebenfalls mit <code>unsafe</code> markieren, wie in Codeblock 19-11 gezeigt.</p>
<pre><pre class="playground"><code class="language-rust unsafe">unsafe trait Foo {
    // Methoden kommen hierhin
}

unsafe impl Foo for i32 {
    // Methoden-Implementierungen kommen hierhin
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-11: Definition und Implementierung eines
unsicheren Merkmals</span></p>
<p>Indem wir <code>unsafe impl</code> verwenden, versprechen wir, dass wir die Invarianten
aufrechterhalten, die der Compiler nicht verifizieren kann.</p>
<p>Erinnere dich als Beispiel an die Marker-Merkmale <code>Sync</code> und <code>Send</code>, die wir im
Abschnitt <a href="ch16-04-extensible-concurrency-sync-and-send.html">„Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) <code>Sync</code> und
<code>Send</code>“</a> in Kapitel 16
besprochen haben: Der Compiler implementiert diese Merkmale automatisch, wenn
unsere Typen vollständig aus <code>Send</code>- und <code>Sync</code>-Typen zusammengesetzt sind.
Wenn wir einen Typ implementieren, der einen Typ enthält, der nicht <code>Send</code> oder
<code>Sync</code> ist, z.B. Rohzeiger, und wir diesen Typ als <code>Send</code> oder <code>Sync</code> markieren
wollen, müssen wir <code>unsafe</code> verwenden. Rust kann nicht überprüfen, ob unser Typ
die Garantien aufrechterhält, dass er sicher über Stränge gesendet oder von
mehreren Strängen aus zugegriffen werden kann; daher müssen wir diese Prüfungen
manuell durchführen und als solche mit <code>unsafe</code> kennzeichnen.</p>
<h3><a class="header" href="#zugreifen-auf-felder-einer-vereinigung-union" id="zugreifen-auf-felder-einer-vereinigung-union">Zugreifen auf Felder einer Vereinigung (union)</a></h3>
<p>Eine <code>union</code> ist ähnlich wie eine <code>struct</code>, aber es wird jeweils nur ein
deklariertes Feld in einer bestimmten Instanz verwendet. Vereinigung werden
hauptsächlich als Schnittstelle zu Vereinigung im C-Code verwendet. Der Zugriff
auf Vereinigungsfelder ist unsicher, da Rust den Typ der Daten, die derzeit in
der Vereinigungsinstanz gespeichert sind, nicht garantieren kann. Weitere
Informationen über Vereinigung findest du in <a href="https://doc.rust-lang.org/reference/items/unions.html">der Referenz</a>.</p>
<h3><a class="header" href="#wann-unsicheren-code-verwenden" id="wann-unsicheren-code-verwenden">Wann unsicheren Code verwenden?</a></h3>
<p>Es ist nicht falsch oder gar verpönt, eine der fünf soeben besprochenen
Aktionen (Superkräfte) mit <code>unsafe</code> zu verwenden. Aber es ist kniffliger,
<code>unsafe</code> Code korrekt zu schreiben, weil der Compiler nicht helfen kann, die
Speichersicherheit aufrechtzuerhalten. Wenn du einen Grund hast, <code>unsafe</code> Code
zu verwenden, kannst du dies tun, und die explizite <code>unsafe</code>-Annotation macht
es einfacher, die Quelle von Problemen aufzuspüren, wenn sie auftreten.</p>
<h2><a class="header" href="#fortgeschrittene-merkmale-traits" id="fortgeschrittene-merkmale-traits">Fortgeschrittene Merkmale (traits)</a></h2>
<p>Merkmale behandelten wir als Erstes im Abschnitt <a href="ch10-02-traits.html">„Merkmale (traits):
Gemeinsames Verhalten definieren“</a> in Kapitel
10, aber wie bei der Lebensdauer haben wir die fortgeschrittenen Details nicht
besprochen. Jetzt, da du mehr über Rust weißt, können wir zum Kern der Sache
kommen.</p>
<h3><a class="header" href="#spezifizieren-von-platzhaltertypen-in-merkmalsdefinitionen-mit-assoziierten-typen" id="spezifizieren-von-platzhaltertypen-in-merkmalsdefinitionen-mit-assoziierten-typen">Spezifizieren von Platzhaltertypen in Merkmalsdefinitionen mit assoziierten Typen</a></h3>
<p><em>Assoziierte Typen</em> (associated types) verbinden einen Typ-Platzhalter mit
einem Merkmal, sodass die Definitionen der Merkmalsmethoden diese
Platzhaltertypen in ihren Signaturen verwenden können. Der Implementierer eines
Merkmals gibt den konkreten Typ an, der anstelle dieses Typs für die jeweilige
Implementierung verwendet werden soll. Auf diese Weise können wir ein Merkmal
definieren, das einige Typen verwendet, ohne dass wir genau wissen müssen, um
welche Typen es sich dabei handelt, bis das Merkmal implementiert ist.</p>
<p>Wir haben die meisten der fortgeschrittenen Funktionalitäten in diesem Kapitel
als selten benötigt beschrieben. Assoziierte Typen liegen irgendwo dazwischen:
Sie werden seltener verwendet als die im Rest des Buches erläuterten
Funktionalitäten, aber häufiger als viele der anderen in diesem Kapitel
besprochenen Funktionalitäten.</p>
<p>Ein Beispiel für ein Merkmal mit einem assoziierten Typ ist das Merkmal
<code>Iterator</code>, das die Standardbibliothek zur Verfügung stellt. Der assoziierte
Typ wird <code>Item</code> genannt und steht für den Typ der Werte, über die der Typ, der
das Merkmal <code>Iterator</code> implementiert, iteriert. Im Abschnitt <a href="ch13-02-iterators.html#das-merkmal-trait-iterator-und-die-methode-next">„Das Merkmal
(trait) <code>Iterator</code> und die Methode <code>next</code>“</a>
des Kapitels 13 erwähnten wir, dass die Definition des Merkmals <code>Iterator</code> der
Definition in Codeblock 19-12 entspricht.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-12: Definition des Merkmals <code>Iterator</code>, das
einen assoziierten Typ <code>Item</code> hat</span></p>
<p>Der Typ <code>Item</code> ist ein Platzhaltertyp und die Definition der Methode <code>next</code>
zeigt, dass sie Werte vom Typ <code>Option&lt;Self::Item&gt;</code> zurückgibt.
Implementierungen des Merkmals <code>Iterator</code> geben den konkreten Typ für <code>Item</code> an
und die Methode <code>next</code> gibt eine <code>Option</code> zurück, die einen Wert dieses
konkreten Typs enthält.</p>
<p>Assoziierte Typen scheinen ein ähnliches Konzept wie generische Datentypen
(generics) zu sein, da letztere es uns ermöglichen, eine Funktion zu
definieren, ohne anzugeben, welche Typen sie handhaben kann. Warum also
assoziierte Typen verwenden?</p>
<p>Untersuchen wir den Unterschied zwischen den beiden Konzepten anhand eines
Beispiels aus Kapitel 13, das das Merkmal <code>Iterator</code> auf der Struktur
<code>Counter</code> implementiert. In Codeblock 13-21 haben wir angegeben, dass der
<code>Item</code>-Typ <code>u32</code> ist:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --abschneiden--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Diese Syntax scheint mit der von generischen Datentypen vergleichbar zu sein.
Warum also nicht einfach das Merkmal <code>Iterator</code> mit generischen Datentypen
definieren, wie in Codeblock 19-13 gezeigt?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-13: Eine hypothetische Definition des
Merkmals <code>Iterator</code> unter Verwendung eines generischen Datentyps</span></p>
<p>Der Unterschied ist, dass wir beim Verwenden von generischen Datentypen, wie in
Codeblock 19-13, die Typen in jeder Implementierung annotieren müssen; da wir
auch <code>Iterator&lt;String&gt; for Counter</code> oder jeden anderen Typ implementieren
können, könnten wir mehrere Implementierungen von <code>Iterator</code> für <code>Counter</code>
haben. Mit anderen Worten, wenn ein Merkmal einen generischen Parameter hat,
kann es für einen Typ mehrfach implementiert werden, wobei die konkreten Typen
der generischen Typparameter jedes Mal geändert werden können. Wenn wir die
Methode <code>next</code> auf <code>Counter</code> verwenden, müssten wir Typ-Annotationen
bereitstellen, um anzugeben, welche Implementierung des <code>Iterators</code> wir
verwenden wollen.</p>
<p>Bei assoziierten Typen brauchen wir Typen nicht zu annotieren, weil wir ein
Merkmal auf einem Typ nicht mehrfach implementieren können. In Codeblock 19-12
mit der Definition, die assoziierte Typen verwendet, können wir nur einmal
wählen, was der Typ von <code>Item</code> sein wird, weil es nur einen <code>impl Iterator for Counter</code> geben kann. Wir müssen nicht angeben, dass wir einen Iterator von
<code>u32</code>-Werten überall dort haben wollen, wo wir <code>next</code> auf <code>Counter</code> aufrufen.</p>
<h3><a class="header" href="#standardparameter-für-generische-typen-und-operatorüberladung" id="standardparameter-für-generische-typen-und-operatorüberladung">Standardparameter für generische Typen und Operatorüberladung</a></h3>
<p>Wenn wir generische Typparameter verwenden, können wir einen konkreten
Standardtyp für den generischen Typ angeben. Dadurch entfällt die Notwendigkeit
für Implementierer des Merkmals, einen konkreten Typ anzugeben, wenn der
Standardtyp passt. Die Syntax für die Angabe eines Standardtyps für einen
generischen Typ ist <code>&lt;PlaceholderType=ConcreteType&gt;</code> bei der Deklaration des
generischen Typs.</p>
<p>Ein hervorragendes Beispiel für eine Situation, in der diese Technik nützlich
ist, ist die Operatorüberladung. Unter <em>Operatorüberladung</em> (operator
overloading) versteht man das Anpassen des Verhaltens eines Operators (z.B.
<code>+</code>) in bestimmten Situationen.</p>
<p>Rust erlaubt es dir nicht, eigene Operatoren zu erstellen oder beliebige
Operatoren zu überladen. Aber du kannst die in <code>std::ops</code> aufgeführten
Operationen und entsprechenden Merkmale überladen, indem du die mit dem
Operator assoziierten Merkmale implementierst. Beispielsweise überladen wir in
Codeblock 19-14 den Operator <code>+</code>, um zwei <code>Point</code>-Instanzen zu addieren. Wir
tun dies, indem wir das Merkmal <code>Add</code> auf eine <code>Point</code>-Struktur implementieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-14: Implementieren des Merkmals <code>Add</code>, um
den Operator <code>+</code> für <code>Point</code>-Instanzen zu überladen</span></p>
<p>Die Methode <code>add</code> addiert die <code>x</code>-Werte zweier <code>Point</code>-Instanzen und die
<code>y</code>-Werte zweier <code>Point</code>-Instanzen, um einen neuen <code>Point</code> zu erzeugen. Das
Merkmal <code>Add</code> hat einen assoziierten Typ namens <code>Output</code>, der den von der
Methode <code>add</code> zurückgegebenen Typ bestimmt.</p>
<p>Der generische Standardtyp in diesem Code befindet sich innerhalb des Merkmals
<code>Add</code>. Hier ist seine Definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code sollte allgemein bekannt aussehen: Ein Merkmal mit einer Methode
und einem assoziierten Typ. Der neue Teil ist <code>Rhs=Self</code>: Diese Syntax heißt
<em>Standardtypparameter</em> (default type parameters). Der generische Typparameter
<code>Rhs</code> (kurz für „right hand side“, engl. „rechte Seite“) definiert den Typ des
Parameters <code>rhs</code> in der Methode <code>add</code>. Wenn wir keinen konkreten Typ für <code>Rhs</code>
angeben, wenn wir das Merkmal <code>Add</code> implementieren, wird der Typ <code>Rhs</code>
standardmäßig auf <code>Self</code> gesetzt, was der Typ sein wird, auf dem wir <code>Add</code>
implementieren.</p>
<p>Als wir <code>Add</code> für <code>Point</code> implementiert haben, haben wir den Standardwert für
<code>Rhs</code> verwendet, weil wir zwei <code>Point</code>-Instanzen addieren wollten. Schauen wir
uns ein Beispiel für die Implementierung des Merkmals <code>Add</code> an, bei dem wir den
Typ <code>Rhs</code> anpassen wollen, anstatt den Standardwert zu verwenden.</p>
<p>Wir haben zwei Strukturen <code>Millimeters</code> und <code>Meters</code>, die Werte in
verschiedenen Einheiten enthalten. Wir wollen Werte in Millimeter zu Werten in
Meter addieren und die Implementierung von <code>Add</code> die Umrechnung korrekt
durchführen lassen. Wir können <code>Add</code> für <code>Millimeters</code> mit <code>Meters</code> als <code>Rhs</code>
implementieren, wie in Codeblock 19-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-15: Implementieren des Merkmals <code>Add</code> auf
<code>Millimeters</code>, um <code>Millimeters</code> zu <code>Meters</code> zu addieren</span></p>
<p>Um <code>Millimeters</code> und <code>Meters</code> zu addieren, geben wir <code>impl Add&lt;Meters&gt;</code> an, um
den Wert des Parameters vom Typ <code>Rhs</code> zu setzen, anstatt den Standardwert
<code>Self</code> zu verwenden.</p>
<p>Du wirst Standardtypparameter auf zwei Arten verwenden:</p>
<ul>
<li>Um einen Typ zu erweitern, ohne bestehenden Code zu brechen.</li>
<li>Um eine Anpassung in bestimmten Fällen zu ermöglichen, die die meisten
Benutzer nicht benötigen.</li>
</ul>
<p>Das Merkmal <code>Add</code> der Standardbibliothek ist ein Beispiel für den zweiten
Zweck: Normalerweise addierst du zwei ähnliche Typen, aber das Merkmal <code>Add</code>
bietet die Möglichkeit, darüber hinausgehende Anpassungen vorzunehmen. Das
Verwenden eines Standardtypparameters in der Merkmalsdefinition <code>Add</code> bedeutet,
dass du den zusätzlichen Parameter die meiste Zeit nicht angeben musst. Mit
anderen Worten kann etwas Implementierungscode eingespart werden, was das
Verwenden des Merkmals erleichtert.</p>
<p>Der erste Zweck ist ähnlich zum zweiten, nur umgekehrt: Wenn du einem
vorhandenen Merkmal einen Typparameter hinzufügen möchtest, kannst du ihm einen
Standardwert geben, um eine Erweiterung der Funktionalität des Merkmals zu
ermöglichen, ohne den vorhandenen Implementierungscode zu brechen.</p>
<h3><a class="header" href="#vollständig-qualifizierte-syntax-zur-vereindeutigung-aufrufen-von-methoden-mit-gleichem-namen" id="vollständig-qualifizierte-syntax-zur-vereindeutigung-aufrufen-von-methoden-mit-gleichem-namen">Vollständig qualifizierte Syntax zur Vereindeutigung: Aufrufen von Methoden mit gleichem Namen</a></h3>
<p>Nichts in Rust hindert ein Merkmal daran, eine Methode mit demselben Namen wie
die Methode eines anderen Merkmals zu haben, und Rust hindert dich auch nicht
daran, beide Merkmale auf einem Typ zu implementieren. Es ist auch möglich,
eine Methode direkt auf dem Typ mit dem gleichen Namen wie Methoden von
Merkmalen zu implementieren.</p>
<p>Wenn du Methoden mit dem gleichen Namen aufrufst, musst du Rust mitteilen,
welche du verwenden willst. Betrachte den Code in Codeblock 19-16, wo wir zwei
Merkmale <code>Pilot</code> und <code>Wizard</code> definiert haben, die beide eine Methode namens
<code>fly</code> haben. Wir implementieren dann beide Merkmale auf einem Typ <code>Human</code>, der
bereits eine Methode namens <code>fly</code> implementiert hat. Jede <code>fly</code>-Methode macht
etwas anderes.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Hoch!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-16: Zwei Merkmale sind so definiert, dass
sie eine Methode <code>fly</code> haben und auf dem Typ <code>Human</code> implementiert sind, und
eine Methode <code>fly</code> ist direkt auf dem Typ <code>Human</code> implementiert</span></p>
<p>Wenn wir <code>fly</code> auf einer Instanz von <code>Human</code> aufrufen, ruft der Compiler
standardmäßig die Methode auf, die direkt auf dem Typ implementiert ist, wie in
Codeblock 19-17 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hoch!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-17: Aufrufen von <code>fly</code> auf einer Instanz von
<code>Human</code></span></p>
<p>Wenn man diesen Code ausführt, wird <code>*Wütend mit den Armen wedeln*</code> ausgegeben,
was zeigt, dass Rust die Methode <code>fly</code>, die direkt auf <code>Human</code> implementiert
wurde, aufgerufen hat.</p>
<p>Um die Methoden <code>fly</code> entweder vom Merkmal <code>Pilot</code> oder vom Merkmal <code>Wizard</code>
aufzurufen, müssen wir eine explizitere Syntax verwenden, um anzugeben, welche
Methode <code>fly</code> wir meinen. Codeblock 19-18 demonstriert diese Syntax.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hier spricht Ihr Kapitän.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Hoch!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*Wütend mit den Armen wedeln*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-18: Angeben, welche Methode <code>fly</code> wir
aufrufen wollen</span></p>
<p>Das Angeben des Merkmalsnamens vor dem Methodennamen verdeutlicht Rust, welche
Implementierung von <code>fly</code> wir aufrufen wollen. Wir könnten auch
<code>Human::fly(&amp;person)</code> schreiben, was äquivalent zu <code>person.fly()</code> ist, das wir
in Codeblock 19-18 verwendet haben, aber das ist etwas länger zu schreiben, wenn
wir nicht vereindeutigen müssen.</p>
<p>Beim Ausführen dieses Codes wird Folgendes ausgegeben:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Hier spricht Ihr Kapitän.
Hoch!
*Wütend mit den Armen wedeln*
</code></pre>
<p>Da die Methode <code>fly</code> einen Parameter <code>self</code> benötigt, könnte Rust, wenn wir
zwei <em>Typen</em> hätten, die beide ein <em>Merkmal</em> implementieren, herausfinden,
welche Implementierung eines Merkmals basierend auf dem Typ von <code>self</code> zu
verwenden ist.</p>
<p>Assoziierte Funktionen, die Teil von Merkmalen sind, haben jedoch keinen
<code>self</code>-Parameter. Wenn zwei Typen im gleichen Gültigkeitsbereich dieses Merkmal
implementieren, kann Rust nicht herausfinden, welchen Typ du meinst, es sei
denn, du verwendest eine <em>vollständig qualifizierte Syntax</em>. Zum Beispiel hat
das Merkmal <code>Animal</code> in Codeblock 19-19 die assoziierte Funktion <code>baby_name</code>,
die Implementierung von <code>Animal</code> für die Struktur <code>Dog</code> und die assoziierte
Funktion <code>baby_name</code>, die direkt auf <code>Dog</code> definiert ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Welpe&quot;)
    }
}

fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-19: Ein Merkmal mit einer assoziierten
Funktion und ein Typ mit einer assoziierten Funktion desselben Namens, der das
Merkmal ebenfalls implementiert</span></p>
<p>Dieser Code ist für ein Tierheim, das allen Welpen den Namen Spot geben möchte,
der in der assoziierten Funktion <code>baby_name</code> implementiert ist, die auf <code>Dog</code>
definiert ist. Der Typ <code>Dog</code> implementiert auch das Merkmal <code>Animal</code>, das
Charakteristiken beschreibt, die alle Tiere haben. Hundebabys werden Welpen
genannt und das drückt sich in der Implementierung des Merkmals <code>Animal</code> auf
<code>Dog</code> in der Funktion <code>baby_name</code> aus, die mit dem Merkmal <code>Animal</code> assoziiert
ist.</p>
<p>In <code>main</code> rufen wir die Funktion <code>Dog::baby_name</code> auf, die die assoziierte
Funktion, die auf <code>Dog</code> definiert ist, direkt aufruft. Dieser Code gibt
Folgendes aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
Ein Hundebaby wird Spot genannt.
</code></pre>
<p>Diese Ausgabe ist nicht das, was wir wollten. Wir wollen die Funktion
<code>baby_name</code> aufrufen, die Teil des Merkmals <code>Animal</code> ist, das wir auf <code>Dog</code>
implementiert haben, sodass der Code <code>Ein Hundebaby wird Welpe genannt</code>
ausgibt. Die Technik der Angabe des Merkmalsnamens, die wir in Codeblock 19-18
verwendet haben, hilft hier nicht weiter; wenn wir <code>main</code> in den Code in
Codeblock 19-20 ändern, erhalten wir einen Kompilierfehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Welpe&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, Animal::baby_name());
}

</code></pre></pre>
<p><span class="caption">Codeblock 19-20: Versuch, die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufzurufen, aber Rust weiß nicht, welche Implementierung es
verwenden soll</span></p>
<p>Da <code>Animal::baby_name</code> eine assoziierte Funktion ist und keine Methode und
somit keinen Parameter <code>self</code> hat, kann Rust nicht herausfinden, welche
Implementierung von <code>Animal::baby_name</code> wir wollen. Wir werden diesen
Kompilierfehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- required by `Animal::baby_name`
...
20 |     println!(&quot;Ein Hundebaby wird {} genannt.&quot;, Animal::baby_name());
   |                                                ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Um zu vereindeutigen und Rust zu sagen, dass wir die Implementierung von
<code>Animal</code> für <code>Dog</code> verwenden wollen, müssen wir eine vollständig qualifizierte
Syntax verwenden. Codeblock 19-21 zeigt, wie man eine vollständig qualifizierte
Syntax verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Welpe&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Ein Hundebaby wird {} genannt.&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-21: Verwenden einer vollständig
qualifizierten Syntax, um anzugeben, dass wir die Funktion <code>baby_name</code> des
Merkmals <code>Animal</code> aufrufen wollen, wie sie auf <code>Dog</code> implementiert ist</span></p>
<p>Wir geben Rust mit einer Typ-Annotation innerhalb spitzer Klammern an, dass wir
die Methode <code>baby_name</code> des Merkmals <code>Animal</code>, die auf <code>Dog</code> implementiert ist,
aufrufen wollen, indem wir sagen, dass wir den Typ <code>Dog</code> für diesen
Funktionsaufruf als <code>Animal</code> behandeln wollen. Dieser Code wird nun ausgeben,
was wir wollen:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Ein Hundebaby wird Welpe genannt.
</code></pre>
<p>Im Allgemeinen wird die vollständig qualifizierte Syntax wie folgt definiert:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>Für assoziierte Funktionen gäbe es keinen <code>receiver</code>: Es gäbe nur die Liste der
anderen Argumente. Du könntest eine vollständig qualifizierte Syntax überall
dort verwenden, wo du Funktionen oder Methoden aufrufst. Du darfst jedoch jeden
Teil dieser Syntax weglassen, den Rust aus anderen Informationen im Programm
herausfinden kann. Du musst diese ausführlichere Syntax nur in Fällen
verwenden, in denen es mehrere Implementierungen gibt, die denselben Namen
verwenden, und Rust Hilfe benötigt, um herauszufinden, welche Implementierung
du aufrufen möchtest.</p>
<h3><a class="header" href="#verwenden-von-supermerkmalen-um-die-funktionalität-eines-merkmals-innerhalb-eines-anderen-merkmals-zu-erfordern" id="verwenden-von-supermerkmalen-um-die-funktionalität-eines-merkmals-innerhalb-eines-anderen-merkmals-zu-erfordern">Verwenden von Supermerkmalen um die Funktionalität eines Merkmals innerhalb eines anderen Merkmals zu erfordern</a></h3>
<p>Manchmal benötigst du vielleicht die Funktionalität eines Merkmal für ein
anderes Merkmal. In diesem Fall musst du dich darauf verlassen, dass das
abhängige Merkmal ebenfalls implementiert wird. Das Merkmal, auf das du dich
verlässt, ist ein <em>Supermerkmal</em> (supertrait) des Merkmals, das du
implementierst.</p>
<p>Nehmen wir zum Beispiel an, wir wollen ein Merkmal <code>OutlinePrint</code> mit einer
Methode <code>outline_print</code> erstellen, das einen in Sternchen eingerahmten Wert
ausgibt. Das heißt, wenn wir eine Struktur <code>Point</code> haben, die <code>Display</code> so
implementiert, dass sie <code>(x, y)</code> ausgibt, dann gibt der Aufruf von
<code>outline_print</code> einer <code>Point</code>-Instanz, die <code>1</code> für <code>x</code> und <code>3</code> für <code>y</code> hat,
folgendes aus:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Bei der Implementierung von <code>outline_print</code> wollen wir die Funktionalität des
Merkmals <code>Display</code> nutzen. Daher müssen wir festlegen, dass das Merkmal
<code>OutlinePrint</code> nur bei Typen funktioniert, die auch <code>Display</code> implementieren
und die Funktionalität bieten, die <code>OutlinePrint</code> benötigt. Wir können dies in
der Merkmalsdefinition tun, indem wir <code>OutlinePrint: Display</code> angeben. Diese
Technik ähnelt dem Angeben einer Merkmalsabgrenzung (trait bound) bei einem
Merkmal. Codeblock 19-22 zeigt eine Implementierung des Merkmals
<code>OutlinePrint</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-22: Implementieren des Merkmals
<code>OutlinePrint</code>, das die Funktionalität von <code>Display</code> erfordert</span></p>
<p>Da wir festgelegt haben, dass <code>OutlinePrint</code> das Merkmal <code>Display</code> erfordert,
können wir die Funktion <code>to_string</code> verwenden, die automatisch für jeden Typ
implementiert wird, der <code>Display</code> implementiert. Wenn wir versuchen würden,
<code>to_string</code> zu verwenden, ohne einen Doppelpunkt und das Merkmal <code>Display</code> nach
dem Merkmalsnamen anzugeben, würden wir eine Fehlermeldung erhalten, die
besagt, dass keine Methode mit dem Namen <code>to_string</code> für den Typ <code>&amp;Self</code> im
aktuellen Gültigkeitsbereich gefunden wurde.</p>
<p>Lass uns sehen, was passiert, wenn wir versuchen, <code>OutlinePrint</code> auf einem Typ
zu implementieren, der <code>Display</code> nicht implementiert, z.B. die Struktur
<code>Point</code>:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>Wir erhalten einen Fehler, der besagt, dass <code>Display</code> erforderlich, aber nicht
implementiert ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Um dies zu beheben, implementieren wir <code>Display</code> auf <code>Point</code> und erfüllen die
Bedingung, die <code>OutlinePrint</code> erfordert, in etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>Dann wird die Implementierung des Merkmals <code>OutlinePrint</code> auf <code>Point</code>
erfolgreich kompilieren und wir können <code>outline_print</code> auf einer
<code>Point</code>-Instanz aufrufen, um sie in Sternchen eingerahmt anzuzeigen.</p>
<h3><a class="header" href="#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen" id="verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf externen Typen</a></h3>
<p>In Kapitel 10 im Abschnitt <a href="ch10-02-traits.html#ein-merkmal-f%C3%BCr-einen-typ-implementieren">„Ein Merkmal für einen Typ
implementieren“</a> erwähnten wir die Waisenregel,
die besagt, dass wir ein Merkmal auf einem Typ implementieren dürfen, solange
entweder das Merkmal oder der Typ lokal in unserer Kiste (crate) vorhanden ist.
Es ist möglich, diese Einschränkung zu umgehen, indem man das <em>Newtype-Muster</em>
(newtype pattern) verwendet, bei dem ein neuer Typ in einer Tupelstruktur
erzeugt wird. (Wir haben Tupelstrukturen im Abschnitt <a href="ch05-01-defining-structs.html#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">„Verwenden von
Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu
erzeugen“</a> in Kapitel 5 behandelt.) Die Tupelstruktur wird ein
Feld haben und eine dünne Verpackung um den Typ sein, für den wir ein Merkmal
implementieren wollen. Dann ist der Verpackungstyp lokal in unserer Kiste und
wir können das Merkmal auf dem Verpackungstyp (wrapper type) implementieren.
<em>Newtype</em> ist ein Begriff, der aus der Programmiersprache Haskell stammt. Beim
Verwenden dieses Musters gibt es keine Beeinträchtigung der Laufzeitperformanz
und der Verpackungstyp wird zur Kompilierzeit elidiert.</p>
<p>Nehmen wir als Beispiel an, wir wollen <code>Display</code> auf <code>Vec&lt;T&gt;</code> implementieren,
was uns die Waisenregel direkt verbietet, weil das Merkmal <code>Display</code> und der
Typ <code>Vec&lt;T&gt;</code> außerhalb unserer Kiste definiert sind. Wir können eine Struktur
<code>Wrapper</code> erstellen, die eine Instanz von <code>Vec&lt;T&gt;</code> enthält; dann können wir
<code>Display</code> auf <code>Wrapper</code> implementieren und den Wert <code>Vec&lt;T&gt;</code> verwenden, wie in
Codeblock 19-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;Hallo&quot;), String::from(&quot;Welt&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-23: Erstellen eines Typs <code>Wrapper</code> um
<code>Vec&lt;String&gt;</code> zur Implementierung von <code>Display</code></span></p>
<p>Die Implementierung von <code>Display</code> verwendet <code>self.0</code>, um auf den inneren
<code>Vec&lt;T&gt;</code> zuzugreifen, da <code>Wrapper</code> eine Tupelstruktur ist und <code>Vec&lt;T&gt;</code> das
Element mit dem Index 0 im Tupel ist. Dann können wir die Funktionalität des
<code>Display</code>-Typs auf <code>Wrapper</code> verwenden.</p>
<p>Der Nachteil der Verwendung dieser Technik ist, dass <code>Wrapper</code> ein neuer Typ
ist, sodass er nicht die Methoden des Wertes hat, den er hält. Wir müssten alle
Methoden von <code>Vec&lt;T&gt;</code> direkt auf <code>Wrapper</code> implementieren, sodass die Methoden
an <code>self.0</code> delegieren, was uns erlauben würde, <code>Wrapper</code> genau wie einen
<code>Vec&lt;T&gt;</code> zu behandeln. Wenn wir wollten, dass der neue Typ jede Methode hat,
die der innere Typ hat, wäre es eine Lösung, das Merkmal <code>Deref</code> (das in
Kapitel 15 im Abschnitt <a href="ch15-02-deref.html">„Intelligente Zeiger wie normale Referenzen behandeln
mit dem Merkmal (trait) <code>Deref</code>“</a> behandelt wird) auf dem
<code>Wrapper</code> zu implementieren, um den inneren Typ zurückzugeben. Wenn wir nicht
wollen, dass der <code>Wrapper</code>-Typ alle Methoden des inneren Typs hat – zum
Beispiel, um das Verhalten des <code>Wrapper</code>-Typs einzuschränken – müssten
wir nur die Methoden manuell implementieren, die wir wollen.</p>
<p>Jetzt weißt du, wie das Newtype-Muster in Bezug auf Merkmale verwendet wird; es
ist auch dann ein nützliches Muster, wenn keine Merkmale beteiligt sind.
Wechseln wir den Schwerpunkt und sehen wir uns einige fortgeschrittene
Möglichkeiten an, mit Rusts Typsystem zu interagieren.</p>
<h2><a class="header" href="#fortgeschrittene-typen" id="fortgeschrittene-typen">Fortgeschrittene Typen</a></h2>
<p>Das Rust-Typsystem weist einige Funktionalitäten auf, die wir in diesem Buch
erwähnt, aber noch nicht besprochen haben. Wir beginnen mit einer allgemeinen
Diskussion über Newtypes, während wir untersuchen, warum Newtypes als Typen
nützlich sind. Dann gehen wir zu Typ-Alias über, einer Funktionalität, die den
Newtypes ähnlich ist, aber eine etwas andere Semantik hat. Wir werden auch den
Typ <code>!</code> und dynamisch große Typen besprechen.</p>
<blockquote>
<p>Hinweis: Der nächste Abschnitt geht davon aus, dass du den früheren Abschnitt
<a href="ch19-03-advanced-traits.html#verwenden-des-newtype-musters-zum-implementieren-von-externen-merkmalen-auf-externen-typen">„Verwenden des Newtype-Musters zum Implementieren von externen Merkmalen auf
externen Typen“</a> gelesen hast.</p>
</blockquote>
<h3><a class="header" href="#verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion" id="verwenden-des-newtype-musters-für-typsicherheit-und-abstraktion">Verwenden des Newtype-Musters für Typsicherheit und Abstraktion</a></h3>
<p>Das Newtype-Muster ist nützlich für Aufgaben, die über die bisher besprochenen
hinausgehen, einschließlich statisch sicherzustellen, dass Werte niemals
verwechselt werden, und dem Angeben von Einheiten eines Wertes. Ein Beispiel
für die Verwendung von Newtypes zum Angeben von Einheiten hast du in Codeblock
19-15 gesehen: Erinnere dich daran, dass die Strukturen <code>Millimeters</code> und
<code>Meters</code> <code>u32</code>-Werte in einem Newtype einpacken. Wenn wir eine Funktion mit
einem Parameter vom Typ <code>Millimeters</code> schreiben würden, könnten wir kein
Programm kompilieren, das versehentlich versucht, diese Funktion mit einem Wert
vom Typ <code>Meters</code> oder einem einfachen <code>u32</code> aufzurufen.</p>
<p>Eine weitere Verwendung des Newtype-Musters besteht darin, einige
Implementierungsdetails eines Typs zu abstrahieren: Der neue Typ kann eine
öffentliche API bereitstellen, die sich von der API des privaten, inneren Typs
unterscheidet, wenn wir den neuen Typ z.B. direkt verwendet haben, um die
verfügbare Funktionalität einzuschränken.</p>
<p>Newtypes können auch die interne Implementierung verbergen. Zum Beispiel
könnten wir einen Typ <code>People</code> zur Verfügung stellen, um eine <code>HashMap&lt;i32, String&gt;</code> einzupacken, die die ID einer Person in Verbindung mit ihrem Namen
speichert. Code, der <code>People</code> verwendet, würde nur mit der öffentlichen API
interagieren, die wir zur Verfügung stellen, z.B. eine Methode, um eine
Namenszeichenkette zur <code>People</code>-Kollektion hinzuzufügen; dieser Code müsste
nicht wissen, dass wir Namen intern eine <code>i32</code>-ID zuordnen. Das Newtype-Muster
ist ein leichtgewichtiger Weg, eine Kapselung zu erreichen, um
Implementierungsdetails zu verbergen, die wir im Abschnitt <a href="ch17-01-what-is-oo.html#kapselung-die-implementierungsdetails-verbirgt">„Kapselung, die
Implementierungsdetails verbirgt“</a> in Kapitel 17 besprochen
haben.</p>
<h3><a class="header" href="#erstellen-von-typ-synonymen-mit-typ-alias" id="erstellen-von-typ-synonymen-mit-typ-alias">Erstellen von Typ-Synonymen mit Typ-Alias</a></h3>
<p>Zusammen mit dem Newtype-Muster bietet Rust die Möglichkeit, einen <em>Typ-Alias</em>
zu deklarieren, um einem vorhandenen Typ einen anderen Namen zu geben. Hierfür
verwenden wir das Schlüsselwort <code>type</code>. Zum Beispiel können wir den Alias
<code>Kilometers</code> für <code>i32</code> so anlegen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<p>Der Alias <code>Kilometers</code> ist ein <em>Synonym</em> für <code>i32</code>; im Gegensatz zu den Typen
<code>Millimeters</code> und <code>Meters</code>, die wir in Codeblock 19-15 erstellt haben, ist
<code>Kilometers</code> kein separater, neuer Typ. Werte, die den Typ <code>Kilometers</code> haben,
werden genauso behandelt wie Werte des Typs <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Da <code>Kilometers</code> und <code>i32</code> vom gleichen Typ sind, können wir Werte beider Typen
addieren und wir können <code>Kilometers</code>-Werte an Funktionen übergeben, die
<code>i32</code>-Parameter verwenden. Mit dieser Methode erhalten wir jedoch nicht die
Vorteile der Typprüfung, die wir vom zuvor besprochenen Newtype-Muster haben.</p>
<p>Der Hauptanwendungsfall für Typ-Synonyme ist das Reduzieren von Wiederholungen.
Zum Beispiel könnten wir einen längeren Typ wie diesen haben:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>Das Schreiben dieses langen Typs in Funktionssignaturen und als
Typ-Annotationen im gesamten Code kann ermüdend und fehleranfällig sein. Stelle
dir vor, du hättest ein Projekt voller Code wie das in Codeblock 19-24.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hallo&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-24: Verwenden eines langen Typs an vielen
Stellen</span></p>
<p>Ein Typ-Alias macht diesen Code leichter handhabbar, indem er die Wiederholung
reduziert. In Codeblock 19-25 haben wir einen Alias namens <code>Thunk</code> für den
verbosen Typ eingeführt und können alle Verwendungen des Typs durch den
kürzeren Alias <code>Thunk</code> ersetzen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hallo&quot;));

    fn takes_long_type(f: Thunk) {
        // --abschneiden--
    }

    fn returns_long_type() -&gt; Thunk {
        // --abschneiden--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-25: Einführen eines Typ-Alias <code>Thunk</code> zur
Reduzierung von Wiederholungen</span></p>
<p>Dieser Code ist viel einfacher zu lesen und zu schreiben! Die Wahl eines
aussagekräftigen Namens für einen Typ-Alias kann auch helfen, deine Absicht zu
kommunizieren (<em>thunk</em> ist ein Wort für Code, der zu einem späteren Zeitpunkt
ausgewertet wird, also ein passender Name für einen Funktionsabschluss
(closure), der gespeichert wird).</p>
<p>Typ-Alias werden auch häufig mit dem Typ <code>Result&lt;T, E&gt;</code> verwendet, um
Wiederholungen zu reduzieren. Betrachte das Modul <code>std::io</code> in der
Standardbibliothek. E/A-Operationen geben oft ein <code>Result&lt;T, E&gt;</code> zurück, um
Situationen zu behandeln, in denen Operationen nicht funktionieren. Diese
Bibliothek hat eine Struktur <code>std::io::Error</code>, die alle möglichen E/A-Fehler
repräsentiert. Viele der Funktionen in <code>std::io</code> geben <code>Result&lt;T, E&gt;</code> zurück,
wobei für <code>E</code> der Typ <code>std::io::Error</code> verwendet wird, so wie bei diesen
Funktionen im Merkmal (trait) <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result&lt;..., Error&gt;</code> wird oft wiederholt. Daher hat <code>std::io</code> diese Art von
Alias-Deklaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Da sich diese Deklaration im Modul <code>std::io</code> befindet, können wir den
vollständig qualifizierten Alias <code>std::io::Result&lt;T&gt;</code> verwenden – das ist
ein <code>Result&lt;T, E&gt;</code> mit <code>E</code> als <code>std::io::Error</code>. Die Funktionssignaturen des
Merkmals <code>Write</code> sehen am Ende so aus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Der Typ-Alias hilft in zweierlei Hinsicht: Er macht es einfacher, Code zu
schreiben <em>und</em> er gibt uns eine konsistente Schnittstelle innerhalb <code>std::io</code>.
Weil es ein Alias ist, ist es nur ein weiteres <code>Result&lt;T, E&gt;</code>, was bedeutet,
dass wir alle Methoden, die mit <code>Result&lt;T, E&gt;</code> funktionieren, mit ihm verwenden
können, einschließlich spezieller Syntax wie der <code>?</code>-Operator.</p>
<h3><a class="header" href="#der-niemals-typ-der-niemals-zurückkehrt" id="der-niemals-typ-der-niemals-zurückkehrt">Der Niemals-Typ, der niemals zurückkehrt</a></h3>
<p>Rust hat einen speziellen Typ namens <code>!</code>, der im Fachjargon der Typtheorie als
<em>leerer Typ</em> (empty type) bekannt ist, weil er keine Werte hat. Wir ziehen es
vor, ihn den <em>Niemals-Typ</em> (never type) zu nennen, weil er an der Stelle des
Rückgabetyps steht, wenn eine Funktion niemals zurückkehrt. Hier ist ein
Beispiel:</p>
<pre><pre class="playground"><code class="language-rust">fn bar() -&gt; ! {
    // --abschneiden--
<span class="boring">    panic!();
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Dieser Code wird als „die Funktion <code>bar</code> kehrt niemals zurück“ gelesen.
Funktionen, die niemals zurückkehren, werden <em>divergierende Funktionen</em>
(diverging functions) genannt. Wir können keine Werte vom Typ <code>!</code> erzeugen,
also kann <code>bar</code> niemals zurückkehren.</p>
<p>Aber was nützt ein Typ, für den man niemals Werte erzeugen kann? Erinnere dich
an den Code aus Codeblock 2-5; wir haben einen Teil davon hier in Codeblock
19-26 wiedergegeben.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Geheimzahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Bitte gib deine Schätzung ein.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Du hast geschätzt: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">        // --abschneiden--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Du hast gewonnen!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 19-26: Ein <code>match</code> mit einem Zweig, der in
<code>continue</code> endet</span></p>
<p>Damals haben wir einige Details in diesem Code übersprungen. In Kapitel 6 des
Abschnitts <a href="ch06-02-match.html">„Der Kontrollflussoperator <code>match</code>“</a> haben wir
erwähnt, dass alle Zweige den gleichen Typ zurückgeben müssen. So funktioniert
zum Beispiel der folgende Code nicht:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hallo&quot;,
    };
<span class="boring">}
</span></code></pre></pre>
<p>Der Typ von <code>guess</code> in diesem Code müsste eine ganze Zahl <em>und</em> eine
Zeichenkette sein und Rust verlangt, dass <code>guess</code> nur einen Typ hat. Was gibt
also <code>continue</code> zurück? Wie war es uns erlaubt, ein <code>u32</code> von einem Zweig
zurückzugeben und einen anderen Zweig zu haben, der in Codeblock 19-26 mit
<code>continue</code> endet?</p>
<p>Wie du vielleicht schon vermutet hast, hat <code>continue</code> einen <code>!</code>-Wert. Das
heißt, wenn Rust den Typ von <code>guess</code> berechnet, betrachtet es beide
<code>match</code>-Zweige, den ersten mit einem Wert von <code>u32</code> und den zweiten mit einem
<code>!</code>-Wert. Da <code>!</code> niemals einen Wert haben kann, entscheidet Rust, dass <code>guess</code>
den Typ <code>u32</code> hat.</p>
<p>Der formale Weg, dieses Verhalten zu beschreiben, besteht darin, dass Ausdrücke
vom Typ <code>!</code> in jeden anderen Typ umgewandelt werden können. Es ist uns erlaubt,
diesen <code>match</code>-Zweig mit <code>continue</code> zu beenden, weil <code>continue</code> keinen Wert
zurückgibt; stattdessen bringt es die Kontrolle zurück an den Anfang der
Schleife, sodass wir im <code>Err</code>-Fall <code>guess</code> niemals einen Wert zuweisen.</p>
<p>Der Niemals-Typ ist auch beim Makro <code>panic!</code> nützlich. Erinnere dich an die
Funktion <code>unwrap</code>, die wir auf <code>Option&lt;T&gt;</code> Werte aufrufen, um einen Wert zu
erzeugen oder das Programm abstürzen zu lassen. Hier ist ihre Definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>In diesem Code geschieht dasselbe wie bei <code>match</code> in Codeblock 19-26: Rust
sieht, dass <code>val</code> den Typ <code>T</code> und <code>panic!</code> den Typ <code>!</code> hat, sodass das Ergebnis
des gesamten <code>match</code>-Ausdrucks <code>T</code> ist. Dieser Code funktioniert, weil <code>panic!</code>
keinen Wert produziert; es beendet das Programm. Im Fall von <code>None</code> geben wir
keinen Wert von <code>unwrap</code> zurück, also ist dieser Code gültig.</p>
<p>Ein letzter Ausdruck, der den Typ <code>!</code> hat, ist <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    print!(&quot;für immer &quot;);

    loop {
        print!(&quot;und ewig &quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Hier endet die Schleife nie, also ist <code>!</code> der Typ des Ausdrucks. Dies wäre
jedoch nicht der Fall, wenn wir <code>break</code> einfügen würden, da die Schleife enden
würde, wenn sie bei <code>break</code> ankommt.</p>
<h3><a class="header" href="#dynamisch-große-typen-und-das-merkmal-sized" id="dynamisch-große-typen-und-das-merkmal-sized">Dynamisch große Typen und das Merkmal <code>Sized</code></a></h3>
<p>Aufgrund Rusts Bedürfnis, bestimmte Details zu kennen, z.B. wie viel Platz für
einen Wert eines bestimmten Typs zuzuweisen ist, gibt es eine Ecke seines
Typsystems, die verwirrend sein kann: Das Konzept der <em>dynamisch großen Typen</em>
(dynamically sized types). Diese Typen, die manchmal als <em>DSTs</em> oder <em>Typen
ohne Größe</em> (unsized types) bezeichnet werden, erlauben es uns, Code mit Werten
zu schreiben, deren Größe wir nur zur Laufzeit kennen können.</p>
<p>Schauen wir uns die Details eines dynamisch großen Typs namens <code>str</code> an, den
wir im ganzen Buch verwendet haben. Das stimmt, nicht <code>&amp;str</code>, sondern <code>str</code> an
sich ist ein DST. Wir können nicht wissen, wie lang die Zeichenkette zur
Laufzeit ist, d.h. wir können weder eine Variable vom Typ <code>str</code> erzeugen, noch
können wir ein Argument vom Typ <code>str</code> nehmen. Betrachte den folgenden Code, der
nicht funktioniert:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1: str = &quot;Guten Tag!&quot;;
    let s2: str = &quot;Wie geht es dir?&quot;;

<span class="boring">}
</span></code></pre></pre>
<p>Rust muss wissen, wie viel Speicher jedem Wert eines bestimmten Typs zuzuweisen
ist, und alle Werte eines Typs müssen die gleiche Speichermenge verwenden. Wenn
Rust uns erlauben würde, diesen Code zu schreiben, müssten diese beiden
<code>str</code>-Werte die gleiche Speichermenge beanspruchen. Aber sie haben
unterschiedliche Längen: <code>s1</code> benötigt 10 Bytes Speicherplatz und <code>s2</code> 16
Bytes. Aus diesem Grund ist es nicht möglich, eine Variable zu erzeugen, die
einen dynamisch großen Typ enthält.</p>
<p>Was sollen wir also tun? In diesem Fall kennst du die Antwort bereits: Wir
machen die Typen <code>s1</code> und <code>s2</code> zu einem <code>&amp;str</code> anstatt zu einem <code>str</code>. Erinnere
dich, dass wir im Abschnitt <a href="ch04-03-slices.html#zeichenkettenanteilstypen-string-slices">„Zeichenkettenanteilstypen
(string slices)“</a> in Kapitel 4 gesagt haben, dass die
Anteilstypen-Datenstruktur die Startposition und die Länge des Anteilstyps
speichert.</p>
<p>Obwohl also <code>&amp;T</code> ein einzelner Wert ist, der die Speicheradresse des Ortes
speichert, an dem sich <code>T</code> befindet, hat <code>&amp;str</code> <em>zwei</em> Werte: Die Adresse von
<code>str</code> und seine Länge. Als solches können wir die Größe eines <code>&amp;str</code>-Wertes zur
Kompilierzeit kennen: Er ist doppelt so lang wie ein <code>usize</code>. Das heißt, wir
wissen immer die Größe einer <code>&amp;str</code>, egal wie lang die Zeichenkette ist, auf
die sie sich bezieht. Im Allgemeinen werden in Rust Typen mit dynamischer Größe
auf diese Weise verwendet: Sie haben ein zusätzliches Stück Metadaten, das die
Größe der dynamischen Information speichert. Die goldene Regel für Typen
dynamischer Größe lautet, dass wir Werte von Typen mit dynamischer Größe immer
hinter eine Art Zeiger stellen müssen.</p>
<p>Wir können <code>str</code> mit allen Arten von Zeigern kombinieren: Zum Beispiel
<code>Box&lt;str&gt;</code> oder <code>Rc&lt;str&gt;</code>. Tatsächlich hast du das schon einmal gesehen, aber
mit einem anderen dynamisch großen Typ: Merkmale (traits). Jedes Merkmal ist
ein dynamisch großer Typ, auf den wir uns beziehen können, indem wir den Namen
des Merkmals verwenden. In Kapitel 17 im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait
objects) die Werte unterschiedlicher Typen erlauben“</a>
haben wir erwähnt, dass wir, um Merkmale als Merkmalsobjekte zu verwenden,
diese hinter einen Zeiger setzen müssen, z.B. <code>&amp;dyn Trait</code> oder <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> würde auch funktionieren).</p>
<p>Um mit DSTs zu arbeiten, hat Rust ein bestimmtes Merkmal, das <code>Sized</code> genannt
wird, um zu bestimmen, ob die Größe eines Typs zur Kompilierzeit bekannt ist
oder nicht. Dieses Merkmal wird automatisch für alles implementiert, dessen
Größe zur Kompilierzeit bekannt ist. Zusätzlich fügt Rust implizit jeder
generischen Funktion eine Merkmalsabgrenzung auf <code>Sized</code> hinzu. Das heißt, eine
generische Funktionsdefinition wie diese:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}
</span></code></pre></pre>
<p>wird tatsächlich so behandelt, als hätten wir das geschrieben:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --abschneiden--
}
<span class="boring">}
</span></code></pre></pre>
<p>Standardmäßig funktionieren generische Funktionen nur bei Typen, die zur
Kompilierzeit eine bekannte Größe haben. Du kannst jedoch die folgende
spezielle Syntax verwenden, um diese Einschränkung zu lockern:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --abschneiden--
}
<span class="boring">}
</span></code></pre></pre>
<p>Eine Merkmalsabgrenzung durch <code>?Sized</code> ist das Gegenteil einer
Merkmalsabgrenzung durch <code>Sized</code>: Wir würden dies lesen als „<code>T</code> kann aber muss
nicht <code>Sized</code> sein“. Diese Syntax ist nur für <code>Sized</code> verfügbar, nicht für
andere Merkmale.</p>
<p>Beachte auch, dass wir den Typ des Parameters <code>t</code> von <code>T</code> auf <code>&amp;T</code> geändert
haben. Da der Typ möglicherweise nicht <code>Sized</code> ist, müssen wir ihn hinter einer
Art Zeiger verwenden. In diesem Fall haben wir eine Referenz gewählt.</p>
<p>Als nächstes werden wir über Funktionen und Funktionsabschlüsse sprechen!</p>
<h2><a class="header" href="#erweiterte-funktionen-und-funktionsabschlüsse-closures" id="erweiterte-funktionen-und-funktionsabschlüsse-closures">Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></h2>
<p>Als Nächstes werden wir einige fortgeschrittene Funktionalitäten bezüglich
Funktionen und Funktionsabschlüsse untersuchen, zu denen Funktionszeiger und
das Zurückgeben von Funktionsabschlüssen gehören.</p>
<h3><a class="header" href="#funktionszeiger" id="funktionszeiger">Funktionszeiger</a></h3>
<p>Wir haben darüber gesprochen, wie man Funktionsabschlüsse an Funktionen
übergibt; man kann auch reguläre Funktionen an Funktionen übergeben! Diese
Technik ist nützlich, wenn du eine Funktion, die du bereits definiert hast,
übergeben willst, anstatt einen neuen Funktionsabschluss zu definieren. Wenn du
dies mit Funktionszeigern tust, kannst du Funktionen als Argumente für andere
Funktionen verwenden. Funktionen erzwingen den Typ <code>fn</code> (mit einem kleinen f),
nicht zu verwechseln mit dem Funktionsabschlussmerkmal (closure trait) <code>Fn</code>.
Der Typ <code>fn</code> wird als <em>Funktionszeiger</em> (function pointer) bezeichnet. Die
Syntax für die Angabe, dass ein Parameter ein Funktionszeiger ist, ist ähnlich
der von Funktionsabschlüssen, wie in Codeblock 19-27 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;Die Antwort ist: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Codeblock 19-27: Verwenden des Typs <code>fn</code> zum
Entgegennehmen eines Funktionszeigers als Argument</span></p>
<p>Dieser Code gibt <code>Die Antwort ist: 12</code> aus. Wir spezifizieren, dass der
Parameter <code>f</code> in <code>do_twice</code> ein <code>fn</code> ist, das einen Parameter vom Typ <code>i32</code>
nimmt und ein <code>i32</code> zurückgibt. Wir können dann <code>f</code> im Rumpf von <code>do_twice</code>
aufrufen. In <code>main</code> können wir den Funktionsnamen <code>add_one</code> als erstes Argument
an <code>do_twice</code> übergeben.</p>
<p>Im Gegensatz zu Funktionsabschlüssen ist <code>fn</code> ein Typ, nicht ein Merkmal, daher
spezifizieren wir <code>fn</code> direkt als Parametertyp, anstatt einen generischen
Typparameter mit einem Merkmal <code>Fn</code> als Merkmalsabgrenzung (trait bound) zu
deklarieren.</p>
<p>Funktionszeiger implementieren alle drei Funktionsabschlussmerkmale (<code>Fn</code>,
<code>FnMut</code> und <code>FnOnce</code>), sodass du immer einen Funktionszeiger als Argument an
eine Funktion übergeben kannst, die einen Funktionsabschluss erwartet. Es ist
am besten, Funktionen mit einem generischen Typ und einer der
Funktionsabschlussmerkmale zu schreiben, sodass deine Funktionen entweder
Funktionen oder Funktionsabschlüsse akzeptieren können.</p>
<p>Ein Fall, bei dem du nur <code>fn</code> und keine Funktionsabschlüsse akzeptieren
möchtest, ist die Kopplung mit externem Code, der keine Funktionsabschlüsse
hat: C-Funktionen können Funktionen als Argumente akzeptieren, aber C hat keine
Funktionsabschlüsse.</p>
<p>Als Beispiel dafür, wo du entweder einen inline definierten Funktionsabschluss
oder eine benannte Funktion verwenden könntest, sehen wir uns die Verwendung
von <code>map</code> an. Um die Funktion <code>map</code> zu verwenden, um einen Vektor von Zahlen in
einen Vektor von Zeichenketten zu verwandeln, könnten wir einen
Funktionsabschluss wie diesen verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Oder wir könnten eine Funktion als Argument für <code>map</code> angeben anstelle des
Funktionsabschlusses, so wie hier:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass wir die vollständig qualifizierte Syntax verwenden müssen, über
die wir vorhin im Abschnitt <a href="ch19-03-advanced-traits.html">„Fortgeschrittene Merkmale
(traits)“</a> gesprochen haben, weil es mehrere Funktionen namens
<code>to_string</code> gibt. Hier verwenden wir die Funktion <code>to_string</code>, die im Merkmal
<code>ToString</code> definiert ist, welche die Standardbibliothek für jeden Typ
implementiert hat, der <code>Display</code> implementiert.</p>
<p>Wir haben ein weiteres nützliches Muster, das ein Implementierungsdetail von
Tupel-Strukturen und Tupel-Struktur-Aufzählungs-Varianten ausnutzt. Diese Typen
verwenden <code>()</code> als Initialisierungssyntax, die wie ein Funktionsaufruf
aussieht. Die Initialisierer sind eigentlich als Funktionen implementiert, die
eine Instanz zurückgeben, die aus ihren Argumenten konstruiert wurde. Wir
können diese Initialisierungsfunktionen als Funktionszeiger verwenden, die die
Funktionsabschlussmerkmale implementieren, was bedeutet, dass wir die
Initialisierungsfunktionen als Argumente für Methoden angeben können, die
Funktionsabschlüsse wie diese nehmen:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Hier erzeugen wir <code>Status::Value</code>-Instanzen für die <code>u32</code>-Werte im Bereich, für
den <code>map</code> aufgerufen wird, indem wir die Initialisierungsfunktion von
<code>Status::Value</code> verwenden. Einige Leute bevorzugen diesen Stil und einige Leute
ziehen es vor, Funktionsabschlüsse zu verwenden. Sie kompilieren zum gleichen
Code, also verwende den Stil, der für dich am klarsten ist.</p>
<h3><a class="header" href="#zurückgeben-von-funktionsabschlüssen" id="zurückgeben-von-funktionsabschlüssen">Zurückgeben von Funktionsabschlüssen</a></h3>
<p>Funktionsabschlüsse werden durch Merkmale repräsentiert, was bedeutet, dass du
Funktionsabschlüsse nicht direkt zurückgeben kannst. In den meisten Fällen, in
denen du ein Merkmal zurückgeben möchtest, kannst du stattdessen den konkreten
Typ, der das Merkmal implementiert, als Rückgabewert der Funktion verwenden.
Aber das kannst du bei Funktionsabschlüssen nicht tun, weil sie keinen
konkreten Typ haben, der rückgabefähig ist; es ist dir beispielsweise nicht
erlaubt, den Funktionszeiger <code>fn</code> als Rückgabetyp zu verwenden.</p>
<p>Der folgende Code versucht, einen Funktionsabschluss direkt zurückzugeben, aber
er lässt sich nicht kompilieren:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Der Kompilierfehler ist folgender:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` cannot be known at compilation time
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 --&gt; src/lib.rs:2:5
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ------------------ expected `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler bezieht sich wieder auf das Merkmal <code>Sized</code>! Rust weiß nicht, wie
viel Platz benötigt wird, um den Funktionsabschluss zu speichern. Wir haben
vorhin eine Lösung für dieses Problem gesehen. Wir können ein Merkmalsobjekt
(trait object) verwenden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code lässt sich sehr gut kompilieren. Weitere Informationen über
Merkmalsobjekte findest du im Abschnitt <a href="ch17-02-trait-objects.html">„Merkmalsobjekte (trait objects) die
Werte unterschiedlicher Typen erlauben“</a> in Kapitel 17.</p>
<p>Als nächstes wollen wir uns Makros ansehen!</p>
<h2><a class="header" href="#makros" id="makros">Makros</a></h2>
<p>Wir haben in diesem Buch Makros wie <code>println!</code> verwendet, aber wir haben noch
nicht vollständig erforscht, was ein Makro ist und wie es funktioniert. Der
Begriff <em>Makro</em> bezieht sich auf eine Familie von Funktionalitäten in Rust:
<em>Deklarative</em> Makros mit <code>macro_rules!</code> und drei Arten <em>prozeduraler</em> Makros:</p>
<ul>
<li>Benutzerdefinierte Makros mit <code>#[derive]</code>, die Code spezifizieren, der mit
dem Attribut <code>derive</code> hinzugefügt wurde, das bei Strukturen (structs) und
Aufzählungen (enums) verwendet wird</li>
<li>Attribut-ähnliche Makros, die benutzerdefinierte Attribute definieren, die
bei jedem Element verwendet werden können</li>
<li>Funktions-ähnliche Makros, die wie Funktionsaufrufe aussehen, aber auf den
als Argument angegebenen Token operieren</li>
</ul>
<p>Wir werden der Reihe nach über jedes dieser Themen sprechen, aber zuerst wollen
wir uns ansehen, warum wir Makros überhaupt brauchen, wenn wir bereits
Funktionen haben.</p>
<h3><a class="header" href="#der-unterschied-zwischen-makros-und-funktionen" id="der-unterschied-zwischen-makros-und-funktionen">Der Unterschied zwischen Makros und Funktionen</a></h3>
<p>Im Grunde genommen sind Makros eine Möglichkeit, Code zu schreiben, der anderen
Code schreibt, was als <em>Metaprogrammierung</em> bekannt ist. In Anhang C besprechen
wir das Attribut <code>derive</code>, das dir eine Implementierung verschiedener Merkmale
(traits) generiert. Wir haben im ganzen Buch auch die Makros <code>println!</code> und
<code>vec!</code> verwendet. All diese Makros werden <em>expandiert</em>, um mehr Code zu
erzeugen als der Code, den du manuell geschrieben hast.</p>
<p>Metaprogrammierung ist nützlich, um die Menge an Code zu reduzieren, die du
schreiben und pflegen musst, was auch eine der Aufgaben von Funktionen ist.
Makros haben jedoch einige zusätzliche Fähigkeiten, die Funktionen nicht haben.</p>
<p>Eine Funktionssignatur muss die Anzahl und den Typ der Parameter deklarieren,
die die Funktion hat. Makros hingegen können eine variable Anzahl von
Parametern entgegennehmen: Wir können <code>println!(&quot;Hallo&quot;)</code> mit einem Argument
oder <code>println!(&quot;Hallo {}&quot;, name)</code> mit zwei Argumenten aufrufen. Außerdem werden
Makros expandiert, bevor der Compiler die Bedeutung des Codes interpretiert,
sodass ein Makro beispielsweise ein Merkmal auf einen bestimmten Typ
implementieren kann. Eine Funktion kann das nicht, weil sie zur Laufzeit
aufgerufen wird und ein Merkmal zur Kompilierzeit implementiert werden muss.</p>
<p>Der Nachteil des Implementierens eines Makros anstelle einer Funktion besteht
darin, dass Makrodefinitionen komplexer sind als Funktionsdefinitionen, weil du
Rust-Code schreibst, der Rust-Code schreibt. Aufgrund dieser Indirektion sind
Makrodefinitionen im Allgemeinen schwieriger zu lesen, zu verstehen und zu
pflegen als Funktionsdefinitionen.</p>
<p>Ein weiterer wichtiger Unterschied zwischen Makros und Funktionen besteht
darin, dass du Makros definieren oder in den Gültigkeitsbereich bringen musst,
<em>bevor</em> du sie in einer Datei aufrufst, im Gegensatz zu Funktionen, die du
überall definieren und überall aufrufen kannst.</p>
<h3><a class="header" href="#deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung" id="deklarative-makros-mit-macro_rules-für-allgemeine-metaprogrammierung">Deklarative Makros mit <code>macro_rules!</code> für allgemeine Metaprogrammierung</a></h3>
<p>Die am weitesten verbreitete Form von Makros in Rust sind <em>deklarative Makros</em>.
Diese werden manchmal auch als „Beispielmakros“ (macros by example),
„<code>macro_rules!</code>-Makros“ oder einfach nur „Makros“ bezeichnet. In ihrem Kern
erlauben deklarative Makros etwas Ähnliches wie einen Rust-Ausdruck zu
schreiben. Wie in Kapitel 6 besprochen, sind <code>match</code>-Ausdrücke
Kontrollstrukturen, die einen Ausdruck entgegennehmen, den resultierenden Wert
des Ausdrucks mit Mustern abgleichen und dann den Code ausführen, der mit dem
passenden Muster assoziiert ist. Makros vergleichen ebenfalls einen Wert mit
Mustern, die mit einem bestimmten Code assoziiert sind: In dieser Situation ist
der Wert der literale Rust-Quellcode, der an das Makro übergeben wird; die
Muster werden mit der Struktur dieses Quellcodes verglichen; und der mit jedem
Muster assoziierte Code ersetzt, wenn er passt, den an das Makro übergebenen
Code. Dies alles geschieht während der Kompilierung.</p>
<p>Um ein Makro zu definieren, verwendest du das Konstrukt <code>macro_rules!</code>. Lass
uns untersuchen, wie man <code>macro_rules!</code> benutzt, indem wir uns ansehen, wie das
Makro <code>vec!</code> definiert wird. Kapitel 8 behandelte, wie wir das Makro <code>vec!</code>
verwenden können, um einen neuen Vektor mit bestimmten Werten zu erzeugen. Zum
Beispiel erzeugt das folgende Makro einen neuen Vektor, der drei ganze Zahlen
enthält:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>Wir könnten auch das Makro <code>vec!</code> verwenden, um einen Vektor aus zwei ganzen
Zahlen oder einen Vektor aus fünf Zeichenkettenanteilstypen (string slices) zu
erstellen. Wir wären nicht in der Lage, eine Funktion zu verwenden, um dasselbe
zu tun, weil wir die Anzahl oder den Typ der Werte nicht im Voraus kennen
würden.</p>
<p>Codeblock 19-28 zeigt eine leicht vereinfachte Definition des Makros <code>vec!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 19-28: Eine vereinfachte Version der
Makrodefinition <code>vec!</code></span></p>
<blockquote>
<p>Hinweis: Die eigentliche Definition des Makros <code>vec!</code> in der
Standardbibliothek enthält Code zum Vorbelegen der korrekten Speichermenge.
Dieser Code ist eine Optimierung, die wir hier nicht angeben, um das Beispiel
einfacher zu machen.</p>
</blockquote>
<p>Die Annotation <code>#[macro_export]</code> gibt an, dass dieses Makro immer dann zur
Verfügung gestellt werden soll, wenn die Kiste (crate), in der das Makro
definiert ist, in den Gültigkeitsbereich gebracht wird. Ohne diese Annotation
kann das Makro nicht in den Gültigkeitsbereich gebracht werden.</p>
<p>Dann beginnen wir die Makrodefinition mit <code>macro_rules!</code> und dem Namen des
Makros, den wir <em>ohne</em> Ausrufezeichen definieren. Der Name, in diesem Fall
<code>vec</code>, wird von geschweiften Klammern gefolgt, die den Rumpf der
Makrodefinition kennzeichnen.</p>
<p>Die Struktur im <code>vec!</code> -Rumpf ähnelt der Struktur eines <code>match</code>-Ausdrucks. Hier
haben wir einen Zweig mit dem Muster <code>( $( $x:expr ),* )</code>, gefolgt von <code>=&gt;</code> und
dem mit diesem Muster assoziierten Codeblock. Wenn das Muster passt, wird der
zugehörige Codeblock ausgegeben. Da dies das einzige Muster in diesem Makro
ist, gibt es nur einen gültigen Weg der passen kann; jedes andere Muster führt
zu einem Fehler. Komplexere Makros werden mehr als einen Zweig haben.</p>
<p>Die gültige Mustersyntax in Makrodefinitionen unterscheidet sich von der in
Kapitel 18 behandelten Mustersyntax, da Makromuster mit der Rust-Codestruktur
und nicht mit Werten abgeglichen werden. Lass uns durchgehen, was die
Musterteile in Listing 19-28 bedeuten; die vollständige Makromustersyntax
findest du in <a href="https://doc.rust-lang.org/reference/macros-by-example.html">der Referenz</a>.</p>
<p>Zunächst umfasst eine Reihe von Klammern das gesamte Muster. Als Nächstes folgt
ein Dollarzeichen (<code>$</code>), gefolgt von einem Satz von Klammern, der Werte
erfasst, die mit dem Muster innerhalb der Klammern übereinstimmen, um sie im
Ersatzcode zu verwenden. Innerhalb von <code>$()</code> befindet sich <code>$x:expr</code>, das zu
jedem beliebigen Rust-Ausdruck passt und dem Ausdruck den Namen <code>$x</code> gibt.</p>
<p>Das Komma nach <code>$()</code> gibt an, dass ein literales Komma-Trennzeichen optional
nach dem Code erscheinen könnte, der dem Code in <code>$()</code> entspricht. Der <code>*</code> gibt
an, dass das Muster keinmal oder mehrmals zu dem passt, was vor dem <code>*</code> steht.</p>
<p>Wenn wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, passt das Muster <code>$x</code>
dreimal zu den drei Ausdrücken <code>1</code>, <code>2</code> und <code>3</code>.</p>
<p>Betrachten wir nun das Muster im Hauptteil des mit diesem Zweig assoziierten
Codes: <code>temp_vec.push()</code> innerhalb von <code>$()*</code> wird für jeden Teil erzeugt, der
keinmal oder mehrmals mit <code>$()</code> im Muster übereinstimmt, je nachdem, wie oft
das Muster passt. Das <code>$x</code> wird durch jeden passenden Ausdruck ersetzt. Wenn
wir dieses Makro mit <code>vec![1, 2, 3];</code> aufrufen, wird der generierte Code, der
diesen Makroaufruf ersetzt, wie folgt aussehen:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>Wir haben ein Makro definiert, das eine beliebige Anzahl von Argumenten
beliebigen Typs aufnehmen und Code erzeugen kann, um einen Vektor zu erstellen,
der die angegebenen Elemente enthält.</p>
<p>Es gibt einige seltsame Randfälle mit <code>macro_rules!</code>. In Zukunft wird Rust eine
zweite Art deklarativer Makros haben, die auf ähnliche Weise funktionieren,
aber einige dieser Randfälle beheben. Nach diesem Update wird <code>macro_rules!</code>
effektiv veraltet sein. Vor diesem Hintergrund und angesichts der Tatsache,
dass die meisten Rust-Programmierer Makros eher <em>verwenden</em> als Makros
<em>schreiben</em> werden, werden wir nicht weiter auf <code>macro_rules!</code> eingehen. Um
mehr darüber zu erfahren, wie man Makros schreibt, konsultiere die
Online-Dokumentation oder andere Ressourcen, wie zum Beispiel <a href="https://danielkeep.github.io/tlborm/book/index.html">„The Little Book
of Rust Macros“</a> (engl. „Das kleine Buch der Rust-Makros“).</p>
<h3><a class="header" href="#prozedurale-makros-zur-code-generierung-aus-attributen" id="prozedurale-makros-zur-code-generierung-aus-attributen">Prozedurale Makros zur Code-Generierung aus Attributen</a></h3>
<p>Die zweite Form von Makros sind <em>prozedurale Makros</em>, die sich eher wie
Funktionen verhalten (und eine Art Prozedur sind). Prozedurale Makros
akzeptieren etwas Code als Eingabe, operieren mit diesem Code und erzeugen
etwas Code als Ausgabe, anstatt gegen Muster abzugleichen und den Code durch
anderen Code zu ersetzen, wie es deklarative Makros tun.</p>
<p>Die drei Arten von prozeduralen Makros (benutzerdefinierte derive-Makros,
Attribut-ähnliche und Funktions-ähnliche) arbeiten alle auf ähnliche Weise.</p>
<p>Beim Erstellen von prozeduralen Makros müssen sich die Definitionen in einer
eigenen Kiste mit einem speziellen Kistentyp befinden. Dies geschieht aus
komplexen technischen Gründen, die wir hoffentlich in Zukunft eliminieren
werden. Das Verwenden von prozeduralen Makros sieht aus wie der Code in
Codeblock 19-29, wobei <code>some_attribute</code> ein Platzhalter für die Verwendung
eines bestimmten Makros ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Codeblock 19-29: Beispiel für die Verwendung eines
prozeduralen Makros</span></p>
<p>Die Funktion, die ein prozedurales Makro definiert, nimmt einen <code>TokenStream</code>
als Eingabe und erzeugt einen <code>TokenStream</code> als Ausgabe. Der Typ <code>TokenStream</code>
wird durch die Kiste <code>proc_macro</code> definiert, die in Rust enthalten ist und eine
Folge von Token darstellt. Dies ist der Kern des Makros: Der Quellcode, mit dem
das Makro arbeitet, bildet die Eingabe <code>TokenStream</code>, und der Code, den das
Makro erzeugt, ist die Ausgabe <code>TokenStream</code>. Die Funktion hat auch ein
Attribut, das angibt, welche Art prozedurales Makro wir erstellen. Wir können
mehrere Arten prozeduraler Makros in derselben Kiste haben.</p>
<p>Schauen wir uns die verschiedenen Arten prozeduraler Makros an. Wir beginnen
mit einem benutzerdefinierten derive-Makro und erklären dann die kleinen
Unterschiede, in denen sich die anderen Formen unterscheiden.</p>
<h3><a class="header" href="#wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt" id="wie-man-ein-benutzerdefiniertes-makro-mit-derive-schreibt">Wie man ein benutzerdefiniertes Makro mit <code>derive</code> schreibt</a></h3>
<p>Lass uns eine Kiste namens <code>hello_macro</code> erstellen, die ein Merkmal namens
<code>HelloMacro</code> mit einer assoziierten Funktion namens <code>hello_macro</code> definiert.
Anstatt unsere Kisten-Benutzer dazu zu bringen, das Merkmal <code>HelloMacro</code> für
jeden ihrer Typen zu implementieren, werden wir ein prozedurales Makro zur
Verfügung stellen, damit die Benutzer ihren Typ mit <code>#[derive(HelloMacro)]</code>
annotieren können, um eine Standardimplementierung der Funktion <code>hello_macro</code>
zu erhalten. Die Standardimplementierung gibt <code>Hallo Makro! Mein Name ist TypeName!</code> aus, wobei <code>TypeName</code> der Name des Typs ist, auf dem dieses Merkmal
definiert wurde. Mit anderen Worten, wir werden eine Kiste schreiben, die es
einem anderen Programmierer ermöglicht, mit unserer Kiste Code wie Codeblock
19-30 zu schreiben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Codeblock 19-30: Code, den ein Benutzer unserer Kiste
schreiben kann, wenn er unser prozedurales Makro benutzt</span></p>
<p>Dieser Code gibt <code>Hallo Makro! Mein Name ist Pancakes!</code> aus, wenn wir fertig
sind. Der erste Schritt ist das Erstellen einer neuen Bibliothekskiste (library
crate), etwa so:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Als Nächstes definieren wir das Merkmal <code>HelloMacro</code> und die damit assoziierte
Funktion:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben ein Merkmal und seine Funktion. An diesem Punkt könnte unser
Kistenbenutzer das Merkmal so implementieren, dass die gewünschte
Funktionalität erreicht wird:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hallo Makro! Mein Name ist Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>Allerdings müssten sie den Implementierungsblock für jeden Typ, den sie mit
<code>hello_macro</code> verwenden wollten, schreiben; wir wollen ihnen diese Arbeit
ersparen.</p>
<p>Außerdem können wir die Funktion <code>hello_macro</code> noch nicht mit einer
Standardimplementierung versehen, die den Namen des Typs ausgibt, auf dem das
Merkmal implementiert ist: Rust hat keine Reflektionsfähigkeiten, sodass es den
Namen des Typs zur Laufzeit nicht nachschlagen kann. Wir benötigen ein Makro,
um zur Kompilierzeit Code zu generieren.</p>
<p>Der nächste Schritt ist das Definieren des prozeduralen Makros. Zum Zeitpunkt
der Abfassung dieses Dokuments müssen sich die prozeduralen Makros in einer
eigenen Kiste befinden. Irgendwann könnte diese Einschränkung aufgehoben
werden. Die Konvention für die Strukturierung von Kisten und Makrokisten lautet
wie folgt: Für eine Kiste mit dem Namen <code>foo</code> wird eine prozedurale Makrokiste
mit einem benutzerdefinierten derive-Makro als <code>foo_derive</code> bezeichnet.
Beginnen wir eine neue Kiste mit dem Namen <code>hello_macro_derive</code> innerhalb
unseres <code>hello_macro</code>-Projekts:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Unsere beiden Kisten sind eng miteinander verwandt, daher erstellen wir die
prozedurale Makrokiste innerhalb des Verzeichnisses unserer Kiste
<code>hello_macro</code>. Wenn wir die Merkmalsdefinition in <code>hello_macro</code> ändern, müssen
wir auch die Implementierung des prozeduralen Makros in <code>hello_macro_derive</code>
ändern. Die beiden Kisten müssen getrennt veröffentlicht werden und
Programmierer, die diese Kisten verwenden, müssen beide als Abhängigkeiten
hinzufügen und beide in den Gültigkeitsbereich bringen. Wir könnten stattdessen
die Kiste <code>hello_macro</code> als Abhängigkeit <code>hello_macro_derive</code> verwenden lassen
und den prozeduralen Makrocode erneut exportieren. Wie auch immer, die Art und
Weise, wie wir das Projekt strukturiert haben, ermöglicht es den
Programmierern, <code>hello_macro</code>  zu benutzen, selbst wenn sie die
<code>derive</code>-Funktionalität nicht wollen.</p>
<p>Wir müssen die Kiste <code>hello_macro_derive</code> als prozedurale Makro-Kiste
deklarieren. Wie du gleich sehen wirst, benötigen wir auch Funktionalität von
den Kisten <code>syn</code> und <code>quote</code>, also müssen wir sie als Abhängigkeiten angeben.
Füge das Folgende zur Datei <em>Cargo.toml</em> für <code>hello_macro_derive</code> hinzu:</p>
<p><span class="filename">Dateiname: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Um mit der Definition des prozeduralen Makros zu beginnen, platziere den Code
in Codeblock 19-31 in deine Datei <em>src/lib.rs</em> der Kiste <code>hello_macro_derive</code>.
Beachte, dass dieser Code nicht kompiliert werden kann, bis wir eine Definition
für die Funktion <code>impl_hello_macro</code> hinzufügen.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
    // den wir manipulieren können
    let ast = syn::parse(input).unwrap();

    // Baue die Merkmal-Implementierung
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">Codeblock 19-31: Code, den die meisten prozeduralen
Makrokisten benötigen, um Rust-Code zu verarbeiten</span></p>
<p>Beachte, dass wir den Code aufgeteilt haben in die Funktion
<code>hello_macro_derive</code>, die für das Parsen des <code>TokenStream</code> verantwortlich ist,
und die Funktion <code>impl_hello_macro</code>, die für die Transformation des Syntaxbaums
verantwortlich ist: Dies macht das Schreiben eines prozeduralen Makros
bequemer. Der Code in der äußeren Funktion (in diesem Fall
<code>hello_macro_derive</code>) wird für fast jede prozedurale Makro-Kiste, die du siehst
oder erstellst, derselbe sein. Der Code, den du im Rumpf der inneren Funktion
(in diesem Fall <code>impl_hello_macro</code>) angibst, wird je nach Zweck deines
prozeduralen Makros unterschiedlich sein.</p>
<p>Wir haben drei neue Kisten eingeführt: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a> und
<a href="https://crates.io/crates/quote"><code>quote</code></a>. Die Kiste <code>proc_macro</code> kommt mit Rust, sodass wir das
nicht zu den Abhängigkeiten in <em>Cargo.toml</em> hinzufügen mussten. Die Kiste
<code>proc_macro</code> ist die API des Compilers, die es uns erlaubt, den Rust-Code aus
unserem Code zu lesen und zu manipulieren.</p>
<p>Die Kiste <code>syn</code> parst den Rust-Code von einer Zeichenkette in eine
Datenstruktur, auf der wir Operationen durchführen können. Die Kiste <code>quote</code>
wandelt <code>syn</code>-Datenstrukturen wieder in Rust-Code um. Diese Kisten machen es
viel einfacher, jede Art von Rust-Code zu parsen, den wir vielleicht
verarbeiten wollen: Einen vollständigen Parser für Rust-Code zu schreiben, ist
keine einfache Aufgabe.</p>
<p>Die Funktion <code>hello_macro_derive</code> wird aufgerufen, wenn ein Benutzer unserer
Bibliothek <code>#[derive(HelloMacro)]</code> an einen Typ spezifiziert. Dies ist möglich,
weil wir die Funktion <code>hello_macro_derive</code> hier mit <code>proc_macro_derive</code>
annotiert und den Namen <code>HelloMacro</code> angegeben haben, der unserem Merkmalsnamen
entspricht; dies ist die Konvention, der die meisten prozeduralen Makros
folgen.</p>
<p>Die Funktion <code>hello_macro_derive</code> wandelt zunächst <code>input</code> aus einem
<code>TokenStream</code> in eine Datenstruktur um, die wir dann interpretieren und
Operationen darauf ausführen können. Hier kommt <code>syn</code> ins Spiel. Die Funktion
<code>parse</code> in <code>syn</code> nimmt einen <code>TokenStream</code> und gibt eine <code>DeriveInput</code>-Struktur
zurück, die den geparsten Rust-Code repräsentiert. Codeblock 19-32 zeigt die
relevanten Teile der Struktur <code>DeriveInput</code>, die wir vom Parsen der
Zeichenkette <code>struct Pancakes;</code> erhalten:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --abschneiden--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Codeblock 19-32: Die <code>DeriveInput</code>-Instanz erhalten wir
beim Parsen des Codes, den das Attribut des Makros in Codeblock 19-30
hat</span></p>
<p>Die Felder dieser Struktur zeigen, dass der Rust-Code, den wir geparst haben,
eine Einheitsstruktur (unit struct) mit dem <code>ident</code> (identifier, engl.
Bezeichner, d.h. dem Namen) von <code>Pancakes</code> ist. Es gibt weitere Felder in
dieser Struktur zur Beschreibung aller Arten von Rust-Code; weitere
Informationen findest du in der <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code>-Dokumentation für
<code>DeriveInput</code></a>.</p>
<p>Bald werden wir die Funktion <code>impl_hello_macro</code> definieren, wo wir den neuen
Rust-Code bauen werden, den wir einbinden wollen. Aber bevor wir das tun,
beachte, dass die Ausgabe für unser derive-Makro ebenfalls ein <code>TokenStream</code>
ist. Der zurückgegebene <code>TokenStream</code> wird dem Code hinzugefügt, den unsere
Kisten-Benutzer schreiben. Wenn sie also ihre Kiste kompilieren, erhalten sie
die zusätzliche Funktionalität, die wir im modifizierten <code>TokenStream</code> zur
Verfügung stellen.</p>
<p>Du hast vielleicht bemerkt, dass wir <code>unwrap</code> aufrufen, um die Funktion
<code>hello_macro_derive</code> abstürzen zu lassen, wenn der Aufruf der Funktion
<code>syn::parse</code> hier fehlschlägt. Es ist notwendig, dass unser prozedurales Makro
bei Fehlern abstürzt, weil <code>proc_macro_derive</code>-Funktionen einen <code>TokenStream</code>
zurückgeben müssen, kein <code>Result</code>, um mit der prozeduralen Makro-API konform zu
sein. Wir haben dieses Beispiel vereinfacht, indem wir <code>unwrap</code> verwendet
haben; in Produktionscode solltest du spezifischere Fehlermeldungen darüber
angeben, was schief gelaufen ist, indem du <code>panic!</code> oder <code>expect</code> verwendest.</p>
<p>Da wir nun den Code haben, um den annotierten Rust-Code aus einem <code>TokenStream</code>
in eine <code>DeriveInput</code>-Instanz zu verwandeln, lass uns den Code generieren, der
das Merkmal <code>HelloMacro</code> auf dem annotierten Typ implementiert, wie in
Codeblock 19-33 gezeigt.</p>
<p><span class="filename">Dateiname: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Konstruiere eine Repräsentation des Rust-Codes als Syntaxbaum,
</span><span class="boring">    // den wir manipulieren können
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Baue die Merkmal-Implementierung
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hallo Makro! Mein Name ist {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">Codeblock 19-33: Implementierung des Merkmals
<code>HelloMacro</code> unter Verwendung des geparsten Rust-Codes</span></p>
<p>Wir erhalten eine <code>Ident</code>-Strukturinstanz, die den Namen (Bezeichner) des
annotierten Typs enthält, indem wir <code>ast.ident</code> verwenden. Die Struktur in
Codeblock 19-32 zeigt, dass, wenn wir die Funktion <code>impl_hello_macro</code> auf den
Code in Codeblock 19-30 anwenden, das erhaltene <code>ident</code> ein Feld <code>ident</code> mit
dem Wert <code>&quot;Pancakes&quot;</code> enthält. So wird die Variable <code>name</code> in Codeblock 19-33
eine Instanz der Struktur <code>Ident</code> enthalten, die die Zeichenkette <code>&quot;Pancakes&quot;</code>
ausgibt, der Name der Struktur in Codeblock 19-30.</p>
<p>Mit dem Makro <code>quote!</code> können wir den Rust-Code definieren, den wir zurückgeben
wollen. Der Compiler erwartet etwas anderes als das direkte Ergebnis der
Ausführung des <code>quote!</code>-Makros, also müssen wir es in einen <code>TokenStream</code>
konvertieren. Wir tun dies, indem wir die <code>into</code>-Methode aufrufen, die diese
Zwischendarstellung konsumiert und einen Wert des erforderlichen Typs
<code>TokenStream</code> zurückgibt.</p>
<p>Das Makro <code>quote!</code> bietet auch einige sehr coole Vorlage-Mechanismen: Wir
können <code>#name</code> eingeben und <code>quote!</code> wird es durch den Wert in der Variablen
<code>name</code> ersetzen. Du kannst sogar einige Wiederholungen machen, ähnlich wie
normale Makros funktionieren. Schaue dir die <a href="https://docs.rs/quote">Dokumentation der Kiste
<code>quote!</code></a> für eine gründliche Einführung an.</p>
<p>Wir wollen, dass unser prozedurales Makro eine Implementierung unseres Merkmals
<code>HelloMacro</code> für den Typ, den der Benutzer annotiert hat, erzeugt, die wir mit
<code>#name</code> erhalten können. Die Merkmalssimplementierung hat eine Funktion
<code>hello_macro</code>, deren Rumpf die Funktionalität enthält, die wir zur Verfügung
stellen wollen: Ausgeben von <code>Hallo Makro! Mein Name ist</code> und dann der Name des
annotierten Typs.</p>
<p>Das hier verwendete Makro <code>stringify!</code> ist in Rust eingebaut. Es nimmt einen
Rust-Ausdruck, z.B. <code>1 + 2</code>, und verwandelt diesen zur Kompilierzeit in ein
Zeichenketten-Literal, z.B. <code>&quot;1 + 2&quot;</code>. Dies unterscheidet sich von <code>format!</code>
oder <code>println!</code>; Makros, die den Ausdruck auswerten und dann das Ergebnis in
einen <code>String</code> umwandeln. Es besteht die Möglichkeit, dass die Eingabe <code>#Name</code>
ein Ausdruck ist, der literal auszugeben ist, also verwenden wir <code>stringify!</code>.
Die Verwendung von <code>stringify!</code> erspart zudem eine Speicherzuweisung, indem
<code>#name</code> zur Kompilierzeit in ein Zeichenketten-Literal umgewandelt wird.</p>
<p>An diesem Punkt sollte <code>cargo build</code> sowohl bei <code>hello_macro</code> als auch bei
<code>hello_macro_derive</code> erfolgreich durchlaufen. Schließen wir diese Kisten an den
Code in Codeblock 19-30 an, um das prozedurale Makro in Aktion zu sehen!
Erstelle ein neues Binärprojekt in deinem <em>projects</em>-Verzeichnis durch Aufrufen
von <code>cargo new pancakes</code>. </p>
<p>Wir müssen <code>hello_macro</code> und <code>hello_macro_derive</code> als Abhängigkeiten in der
Datei <em>Cargo.toml</em> der Kiste <code>pancakes</code> hinzufügen. Wenn du deine Versionen von
<code>hello_macro</code> und <code>hello_macro_derive</code> in <a href="https://crates.io/">crates.io</a>
veröffentlichst, wären das reguläre Abhängigkeiten; wenn nicht, kannst du sie
wie folgt als <code>path</code>-Abhängigkeiten angeben:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Gib den Code in Codeblock 19-30 in <em>src/main.rs</em> ein und rufe <code>cargo run</code> auf:
Es sollte <code>Hallo Makro! Mein Name ist Pancakes!</code> ausgeben. Die Implementierung
des Merkmals <code>HelloMacro</code> aus dem prozeduralen Makro wurde eingefügt, ohne dass
die Kiste <code>pancakes</code> es implementieren musste; <code>#[derive(HelloMacro)]</code> fügte
die Merkmalsimplementierung hinzu.</p>
<p>Als Nächstes wollen wir untersuchen, inwiefern sich die anderen Arten
prozeduraler Makros von den benutzerdefinierten derive-Makros unterscheiden.</p>
<h3><a class="header" href="#attribut-ähnliche-makros" id="attribut-ähnliche-makros">Attribut-ähnliche Makros</a></h3>
<p>Attribut-ähnliche Makros ähneln den benutzerdefinierten derive-Makros, aber
anstatt Code für das <code>derive</code>-Attribut zu generieren, erlauben sie dir, neue
Attribute zu erstellen. Sie sind auch flexibler: <code>derive</code> funktioniert nur bei
Strukturen und Aufzählungen; Attribute können auch auf andere Elemente, z.B.
Funktionen, angewendet werden. Hier ist ein Beispiel für die Verwendung eines
Attribut-ähnlichen Makros: Nehmen wir an, du hast ein Attribut namens <code>route</code>,
das Funktionen annotiert, wenn du ein Webapplikations-Framework verwendest:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>Dieses Attribut <code>#[route]</code> würde durch das Framework als prozedurales Makro
definiert werden. Die Signatur der Makrodefinitionsfunktion würde wie folgt
aussehen:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Hier haben wir zwei Parameter vom Typ <code>TokenStream</code>. Der erste ist für die
Inhalte <code>GET, &quot;/&quot;</code> des Attributs. Der zweite ist für den Rumpf des Elements, an
den das Attribut angehängt ist: In diesem Fall <code>fn index() {}</code> und der Rest des
Funktionsrumpfs.</p>
<p>Abgesehen davon funktionieren Attribut-ähnliche Makros auf die gleiche Weise
wie benutzerdefinierte derive-Makros: Sie erstellen eine Kiste mit dem
Kistentyp <code>proc-macro</code> und implementieren eine Funktion, die den gewünschten
Code generiert!</p>
<h3><a class="header" href="#funktions-ähnliche-makros" id="funktions-ähnliche-makros">Funktions-ähnliche Makros</a></h3>
<p>Funktions-ähnliche Makros definieren Makros, die wie Funktionsaufrufe aussehen.
Ähnlich wie <code>macro_rules!</code>-Makros sind sie flexibler als Funktionen; sie können
zum Beispiel eine unbekannte Anzahl von Argumenten aufnehmen. Makros können
jedoch nur mit der <code>match</code>-ähnlichen Syntax definiert werden, die wir im
Abschnitt <a href="ch19-06-macros.html#deklarative-makros-mit-macro_rules-f%C3%BCr-allgemeine-metaprogrammierung">„Deklarative Makros mit <code>macro_rules!</code> für allgemeine
Metaprogrammierung“</a> besprochen haben. Funktions-ähnliche Makros nehmen
einen <code>TokenStream</code>-Parameter und ihre Definition manipuliert diesen
<code>TokenStream</code> unter Verwendung von Rust-Code, wie es die beiden anderen Arten
prozeduraler Makros tun. Ein Beispiel für ein Funktions-ähnliches Makro ist ein
Makro <code>sql!</code>, das auf diese Weise aufgerufen werden könnte:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>Dieses Makro würde die darin enthaltene SQL-Anweisung parsen und prüfen, ob sie
syntaktisch korrekt ist, was eine viel komplexere Verarbeitung ist, als es ein
<code>macro_rules!</code>-Makro tun kann. Das Makro <code>sql!</code> würde wie folgt definiert
werden:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Diese Definition ähnelt der Signatur des benutzerdefinierten derive-Makros: Wir
erhalten die Token, die sich innerhalb der Klammern befinden, und geben den
Code zurück, den wir generieren wollen.</p>
<h2><a class="header" href="#zusammenfassung-18" id="zusammenfassung-18">Zusammenfassung</a></h2>
<p>Puh! Jetzt hast du einige Rust-Funktionalitäten in deinem Werkzeugkasten, die
du nicht oft verwenden wirst, aber du wirst wissen, dass sie unter ganz
bestimmten Umständen verfügbar sind. Wir haben mehrere komplexe Themen
eingeführt, sodass du diese Konzepte und Syntax erkennen kannst, wenn du ihnen
in Vorschlägen für Fehlermeldungen oder im Code anderer Leute begegnest.
Verwende dieses Kapitel als Referenz, um Lösungen zu finden.</p>
<p>Als Nächstes werden wir alles, was wir im Laufe des Buches besprochen haben, in
die Praxis umsetzen und ein weiteres Projekt durchführen!</p>
<h1><a class="header" href="#abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen" id="abschlussprojekt-einen-mehrsträngigen-multi-threaded-webserver-erstellen">Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></h1>
<p>Es war eine lange Reise, aber wir haben das Ende des Buches erreicht. In diesem
Kapitel werden wir gemeinsam ein weiteres Projekt aufbauen, um einige der
Konzepte zu demonstrieren, die wir in den letzten Kapiteln behandelt haben, und
einige frühere Lektionen zusammenfassen.</p>
<p>Für unser Abschlussprojekt werden wir einen Webserver erstellen, der „Hallo“
sagt und in einem Webbrowser wie Abbildung 20-1 aussieht.</p>
<p><img src="img/trpl20-01.png" alt="Hallo von Rust" /></p>
<p><span class="caption">Abbildung 20-1: Unser letztes gemeinsames Projekt</span></p>
<p>Hier ist der Plan zum Bauen des Webservers:</p>
<ol>
<li>Lerne ein wenig über TCP und HTTP.</li>
<li>Lausche auf TCP-Verbindungen an einem Netzwerkknoten (socket).</li>
<li>Parse eine kleine Anzahl von HTTP-Anfragen.</li>
<li>Erstelle eine korrekte HTTP-Antwort.</li>
<li>Verbessere den Durchsatz unseres Servers mit einem Strang-Vorrat (thread
pool).</li>
</ol>
<p>Aber bevor wir anfangen, sollten wir ein Detail erwähnen: Die Methode, die wir
verwenden werden, wird nicht der beste Weg sein, einen Webserver mit Rust zu
bauen. Auf <a href="https://crates.io/">crates.io</a> sind etliche produktionsreife Kisten
(crates) verfügbar, die umfassendere Webserver- und
Strang-Vorrats-Implementierungen bereitstellen, als wir bauen werden.</p>
<p>Unsere Absicht in diesem Kapitel ist es jedoch, dir beim Lernen zu helfen, und
nicht, den einfachen Weg zu gehen. Da es sich bei Rust um eine
Systemprogrammiersprache handelt, können wir die Abstraktionsebene wählen, mit
der wir arbeiten wollen, und können auf eine niedrigere Ebene gehen, als dies
in anderen Sprachen möglich oder zweckmäßig ist. Wir werden den grundlegenden
HTTP-Server und den Strang-Vorrat manuell schreiben, damit du die allgemeinen
Ideen und Techniken hinter den Kisten lernst, die du in Zukunft verwenden
kannst.</p>
<h2><a class="header" href="#einen-einsträngigen-single-threaded-webserver-erstellen" id="einen-einsträngigen-single-threaded-webserver-erstellen">Einen einsträngigen (single-threaded) Webserver erstellen</a></h2>
<p>Wir beginnen damit, einen einsträngigen Webserver zum Laufen zu bringen. Bevor
wir beginnen, wollen wir uns einen kurzen Überblick über die Protokolle
verschaffen, die beim Aufbau von Webservern eine Rolle spielen. Die
Einzelheiten dieser Protokolle sprengen den Rahmen dieses Buches, aber ein
kurzer Überblick wird dir die Informationen geben, die du benötigst.</p>
<p>Die beiden wichtigsten Protokolle, die bei Webservern zum Einsatz kommen, sind
das <em>Hypertext-Übertragungsprotokoll</em> (Hypertext Transfer Protocol, kurz
<em>HTTP</em>) und das <em>Übertragungssteuerungsprotokoll</em> (Transmission Control
Protocol, kurz <em>TCP</em>). Beide Protokolle sind <em>Anfrage-Antwort-Protokolle</em>, d.h.
ein <em>Client</em> initiiert Anfragen und ein <em>Server</em> hört auf die Anfragen und gibt
eine Antwort an den Client. Der Inhalt dieser Anfragen und Antworten wird durch
die Protokolle definiert.</p>
<p>TCP ist das Protokoll der untergeordneten Ebene, das im Detail beschreibt, wie
Informationen von einem Server zu einem anderen gelangen, aber nicht
spezifiziert, um welche Informationen es sich dabei handelt. HTTP baut auf TCP
auf, indem es den Inhalt der Anfragen und Antworten definiert. Es ist technisch
möglich, HTTP mit anderen Protokollen zu verwenden, aber in den allermeisten
Fällen sendet HTTP seine Daten über TCP. Wir werden mit den Roh-Bytes von TCP-
und HTTP-Anfragen und -Antworten arbeiten.</p>
<h3><a class="header" href="#lauschen-auf-eine-tcp-verbindung" id="lauschen-auf-eine-tcp-verbindung">Lauschen auf eine TCP-Verbindung</a></h3>
<p>Unser Webserver muss auf eine TCP-Verbindung lauschen (listen), also ist das
der erste Teil, an dem wir arbeiten werden. Die Standardbibliothek bietet ein
Modul <code>std::net</code> an, mit dem wir dies tun können. Lass uns ein neues Projekt
auf die übliche Art und Weise erstellen:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Gib nun den Code in Codeblock 20-1 in <em>src/main.rs</em> ein, um zu beginnen. Dieser
Code lauscht unter der Adresse <code>127.0.0.1:7878</code> auf eingehende TCP-Ströme (TCP
streams). Wenn er einen eingehenden Strom erhält, wird er <code>Verbindung hergestellt!</code> ausgeben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Verbindung hergestellt!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-1: Warten auf eingehende Ströme und Ausgeben
einer Nachricht, wenn wir einen Strom empfangen</span></p>
<p>Mit <code>TcpListener</code> können wir unter der Adresse <code>127.0.0.1:7878</code> auf
TCP-Verbindungen warten. In der Adresse ist der Abschnitt vor dem Doppelpunkt
eine IP-Adresse, die deinen Computer repräsentiert (dies ist auf jedem Computer
gleich und gilt nicht nur speziell für den Computer der Autoren), und <code>7878</code>
ist der Port. Wir haben diesen Port aus zwei Gründen gewählt: HTTP wird
normalerweise auf diesem Port akzeptiert und 7878 ist <em>rust</em> auf einem Telefon
getippt.</p>
<p>Die Funktion <code>bind</code> in diesem Szenario arbeitet wie die Funktion <code>new</code>, indem
sie eine neue <code>TcpListener</code>-Instanz zurückgibt. Der Grund dafür, dass die
Funktion <code>bind</code> genannt wird, liegt darin, dass in Netzwerken das Verbinden mit
einem Port zum Lauschen als „Binden (binding) an einen Port“ bezeichnet wird.</p>
<p>Die Funktion <code>bind</code> gibt ein <code>Result&lt;T, E&gt;</code> zurück, was anzeigt, dass das
Binden fehlschlagen könnte. Zum Beispiel erfordert das Binden an Port 80
Administrator-Rechte (Nicht-Administratoren können nur auf Ports größer als
1024 lauschen). Wenn wir also versuchen würden, an Port 80 zu lauschen, ohne
Administrator zu sein, würde das Binden nicht funktionieren. Ein weiteres
Beispiel: Binden ist nicht möglich, wenn wir zwei Instanzen unseres Programms
laufen lassen und somit zwei Programme auf dem gleichen Port lauschen würden.
Da wir einen einfachen Server nur für Lernzwecke schreiben, werden wir uns
nicht um die Behandlung dieser Art von Fehlern kümmern; stattdessen verwenden
wir <code>unwrap</code>, um das Programm zu stoppen, wenn Fehler auftreten.</p>
<p>Die Methode <code>incoming</code> von <code>TcpListener</code> gibt einen Iterator zurück, der uns
eine Sequenz von Strömen (genauer gesagt Ströme vom Typ <code>TcpStream</code>) liefert.
Ein einzelner <em>Strom</em> (stream) stellt eine offene Verbindung zwischen dem
Client und dem Server dar. Eine <em>Verbindung</em> (connection) ist der Name für den
vollständigen Anfrage- und Antwortprozess, bei dem sich ein Client mit dem
Server verbindet, der Server eine Antwort erzeugt und der Server die Verbindung
schließt. Als solches liest <code>TcpStream</code> von sich selbst, um zu sehen, was der
Kunde gesendet hat, und erlaubt uns dann, unsere Antwort in den Strom zu
schreiben. Insgesamt wird diese <code>for</code>-Schleife jede Verbindung der Reihe nach
verarbeiten und eine Reihe von Strömen erzeugen, die wir verarbeiten müssen.</p>
<p>Im Moment besteht unsere Behandlung des Stroms darin, dass wir <code>unwrap</code>
aufrufen, um unser Programm zu beenden, wenn der Strom Fehler aufweist; wenn
keine Fehler vorliegen, gibt das Programm eine Nachricht aus. Wir werden im
nächsten Codeblock mehr Funktionalität für den Erfolgsfall hinzufügen. Der
Grund, warum wir Fehler von der <code>incoming</code>-Methode erhalten könnten, wenn sich
ein Client mit dem Server verbindet, ist, dass wir nicht wirklich über
Verbindungen iterieren. Stattdessen iterieren wir über <em>Verbindungsversuche</em>.
Die Verbindung kann aus einer Reihe von Gründen nicht erfolgreich sein, viele
davon sind betriebssystemspezifisch. Zum Beispiel haben viele Betriebssysteme
ein Limit für die Anzahl der gleichzeitig offenen Verbindungen, die sie
unterstützen können; neue Verbindungsversuche über diese Anzahl hinaus führen
zu einem Fehler, bis einige der offenen Verbindungen geschlossen werden.</p>
<p>Lass uns versuchen, diesen Code auszuführen! Rufe <code>cargo run</code> im Terminal auf
und öffne dann <em>127.0.0.1:7878</em> in einem Web-Browser. Der Browser sollte eine
Fehlermeldung wie „Verbindung abgebrochen“ anzeigen, da der Server derzeit
keine Daten zurücksendet. Aber wenn du auf dein Terminal siehst, solltest du
mehrere Meldungen sehen, die ausgegeben wurden, als der Browser eine Verbindung
mit dem Server herstellte!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Verbindung hergestellt!
Verbindung hergestellt!
Verbindung hergestellt!
</code></pre>
<p>Manchmal werden mehrere Nachrichten für eine Browser-Anfrage ausgegeben; der
Grund dafür könnte sein, dass der Browser sowohl eine Anfrage für die Seite als
auch eine Anfrage für andere Ressourcen stellt, z.B. das Symbol <em>favicon.ico</em>,
das in der Browser-Registerkarte erscheint.</p>
<p>Es könnte auch sein, dass der Browser mehrmals versucht, eine Verbindung mit
dem Server herzustellen, weil der Server nicht mit Daten antwortet. Wenn
<code>stream</code> den Gültigkeitsbereich verlässt und am Ende der Schleife aufgeräumt
wird, wird die Verbindung als Teil der <code>drop</code>-Implementierung geschlossen.
Browser reagieren auf geschlossene Verbindungen manchmal damit, es erneut zu
versuchen, weil das Problem möglicherweise nur vorübergehend ist. Der wichtige
Punkt ist, dass wir erfolgreich eine TCP-Verbindung hergestellt haben!</p>
<p>Denke daran, das Programm durch Drücken von <span
class="keystroke">Strg+c</span> zu beenden, wenn du mit der Ausführung einer
bestimmten Version des Codes fertig bist. Starte dann <code>cargo run</code> erneut,
nachdem du jede Menge Code-Änderungen vorgenommen hast, um sicherzustellen,
dass du den neuesten Code ausführst.</p>
<h3><a class="header" href="#lesen-der-anfrage" id="lesen-der-anfrage">Lesen der Anfrage</a></h3>
<p>Lass uns die Funktionalität zum Lesen der Anfrage vom Browser implementieren!
Um die Zuständigkeiten zu trennen, also zuerst eine Verbindung entgegenzunehmen
und dann mit der Verbindung etwas zu machen, werden wir eine neue Funktion zur
Verarbeitung von Verbindungen anfangen. In dieser neuen Funktion
<code>handle_connection</code> lesen wir Daten aus dem TCP-Strom und geben sie aus, sodass
wir sehen können, welche Daten vom Browser gesendet werden. Ändere den Code so,
dass er wie Codeblock 20-2 aussieht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Anfrage: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-2: Lesen aus dem <code>TcpStream</code> und Ausgeben
der Daten</span></p>
<p>Wir bringen <code>std::io::prelude</code> in den Gültigkeitsbereich, um Zugang zu
bestimmten Merkmalen (traits) zu erhalten, die es uns ermöglichen, aus dem
Strom zu lesen und in den Strom zu schreiben. In der <code>for</code>-Schleife in der
Funktion <code>main</code> rufen wir jetzt, statt eine Nachricht auszugeben, dass wir eine
Verbindung hergestellt haben, die neue Funktion <code>handle_connection</code> auf und
übergeben ihr den <code>stream</code>.</p>
<p>In der Funktion <code>handle_connection</code> haben wir den Parameter <code>stream</code>
veränderlich gemacht. Der Grund dafür ist, dass die <code>TcpStream</code>-Instanz
verfolgt, welche Daten sie intern an uns zurückgibt. Sie liest möglicherweise
mehr Daten, als wir angefordert haben, und speichert diese Daten für die
nächste Datenanforderung. Sie muss daher <code>mut</code> sein, weil sich ihr interner
Zustand ändern könnte; normalerweise denken wir beim „Lesen“ nicht an eine
Veränderung, aber in diesem Fall brauchen wir das Schlüsselwort <code>mut</code>.</p>
<p>Als Nächstes müssen wir tatsächlich aus dem Strom lesen. Wir tun dies in zwei
Schritten: Zuerst deklarieren wir einen <code>buffer</code> auf dem Stapelspeicher
(stack), um die eingelesenen Daten aufzunehmen. Wir haben den Puffer 1024 Bytes
groß gemacht, was groß genug ist, um die Daten einer einfachen Anfrage
aufzunehmen und für unsere Zwecke in diesem Kapitel ausreicht. Wenn wir
Anfragen beliebiger Größe bearbeiten wollten, müsste die Pufferverwaltung
komplizierter sein; wir werden es vorerst einfach halten. Wir übergeben den
Puffer an die Funktion <code>stream.read</code>, die Bytes aus dem <code>TcpStream</code> liest und
sie in den Puffer legt.</p>
<p>Zweitens wandeln wir die Bytes im Puffer in eine Zeichenkette (string) um und
geben diese Zeichenkette aus. Die Funktion <code>String::from_utf8_lossy</code> nimmt ein
<code>&amp;[u8]</code> und erzeugt daraus einen <code>String</code>. Der „verlustbehaftete“ (lossy) Teil
des Namens weist auf das Verhalten dieser Funktion hin, wenn sie eine ungültige
UTF-8-Sequenz erhält: Sie ersetzt die ungültige Sequenz durch <code>�</code>, dem
Ersetzungszeichen <code>U+FFFD</code>. Möglicherweise siehst du Ersatzzeichen für Zeichen
im Puffer, die nicht durch Anforderungsdaten gefüllt sind.</p>
<p>Lass uns diesen Code ausprobieren! Starte das Programm und stelle erneut eine
Anfrage in einem Webbrowser. Beachte, dass wir immer noch eine Fehlerseite im
Browser erhalten, aber die Ausgabe unseres Programms im Terminal wird nun
ähnlich aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Je nach Browser erhältst du möglicherweise eine etwas andere Ausgabe. Jetzt, wo
wir die Anfragedaten ausgeben, können wir sehen, warum wir mehrere Verbindungen
von einer Browser-Anfrage erhalten, wenn wir uns den Pfad nach <code>Request: GET</code>
ansehen. Wenn die wiederholten Verbindungen alle <code>/</code> anfordern, wissen wir,
dass der Browser wiederholt versucht, <code>/</code> abzurufen, weil er keine Antwort von
unserem Programm erhält.</p>
<p>Lass uns diese Anfragedaten aufschlüsseln, um zu verstehen, was der Browser von
unserem Programm will.</p>
<h3><a class="header" href="#ein-genauerer-blick-auf-eine-http-anfrage" id="ein-genauerer-blick-auf-eine-http-anfrage">Ein genauerer Blick auf eine HTTP-Anfrage</a></h3>
<p>HTTP ist ein textbasiertes Protokoll und eine Anfrage hat dieses Format an:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist die <em>Anfragezeile</em> (request line), die Informationen
darüber enthält, was der Client anfragt. Der erste Teil der Anfragezeile gibt
die <em>Methode</em> an, die verwendet wird, z.B. <code>GET</code> oder <code>POST</code>, die beschreibt,
wie der Client diese Anfrage stellt. Unser Client benutzte eine <code>GET</code>-Anfrage.</p>
<p>Der nächste Teil der Anfragezeile ist <code>/</code>, der den <em>einheitlichen
Ressourcenbezeichner</em> (Uniform Resource Identifier, kurz <em>URI</em>) angibt, den der
Client anfragt: Ein URI ist fast, aber nicht ganz dasselbe wie ein
<em>einheitlicher Ressourcenzeiger</em> (Uniform Resource Locator, kurz <em>URL</em>). Der
Unterschied zwischen URIs und URLs ist für unsere Zwecke in diesem Kapitel
nicht wichtig, aber die HTTP-Spezifikation verwendet den Begriff URI, sodass
wir hier einfach gedanklich URL durch URI ersetzen können.</p>
<p>Der letzte Teil ist die HTTP-Version, die der Client verwendet, und dann endet
die Anfragezeile mit einer <em>CRLF-Sequenz</em>. (CRLF steht für <em>carriage return</em>
(Wagenrücklauf) und <em>line feed</em> (Zeilenvorschub), das sind Begriffe aus der
Schreibmaschinenzeit!) Die CRLF-Sequenz kann auch als <code>\r\n</code> geschrieben
werden, wobei <code>\r</code> ein Wagenrücklauf und <code>\n</code> ein Zeilenvorschub ist. Die
CRLF-Sequenz trennt die Anfragezeile von den restlichen Anfragedaten. Beachte,
dass wir beim Ausgeben von CRLF eine neue Zeile sehen und nicht <code>\r\n</code>.</p>
<p>Wenn wir uns die Daten der Anfragezeile ansehen, die wir bisher beim Ausführen
unseres Programms erhalten haben, sehen wir, dass <code>GET</code> die Methode, <code>/</code> die
Anfrage-URI und <code>HTTP/1.1</code> die Version ist.</p>
<p>Nach der Anfragezeile sind die restlichen Zeilen ab <code>Host:</code> Kopfzeilen.
<code>GET</code>-Anfragen haben keinen Rumpf (body).</p>
<p>Versuche, eine Anfrage von einem anderen Browser aus zu stellen oder nach einer
anderen Adresse zu fragen, z.B. <em>127.0.0.1:7878/test</em>, um zu sehen, wie sich
die Anfragedaten ändern.</p>
<p>Jetzt, da wir wissen, was der Browser anfragt, schicken wir ein paar Daten
zurück!</p>
<h3><a class="header" href="#schreiben-einer-antwort" id="schreiben-einer-antwort">Schreiben einer Antwort</a></h3>
<p>Jetzt werden wir das Senden von Daten als Antwort auf eine Clientanfrage
implementieren. Die Antworten haben das folgende Format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Die erste Zeile ist eine <em>Statuszeile</em>, die die in der Antwort verwendete
HTTP-Version, einen numerischen Statuscode, der das Ergebnis der Anfrage
zusammenfasst, und eine Begründungsphrase, die eine Textbeschreibung des
Statuscodes liefert, enthält. Nach der CRLF-Sequenz folgen beliebige
Kopfzeilen, eine weitere CRLF-Sequenz und der Rumpf der Antwort.</p>
<p>Hier ist eine Beispielantwort, die HTTP-Version 1.1 verwendet, den Statuscode
200, eine OK-Begründungsphrase, keine Kopfzeilen und keinen Rumpf hat:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Der Statuscode 200 ist die Standard-Erfolgsantwort. Der Text ist eine winzige
erfolgreiche HTTP-Antwort. Lass uns dies als Antwort auf eine erfolgreiche
Anfrage in den Strom schreiben! Entferne aus der Funktion <code>handle_connection</code>
das <code>println!</code>, das die Anfragedaten ausgegeben hat, und ersetze es durch den
Code in Codeblock 20-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-3: Schreiben einer kleinen erfolgreichen
HTTP-Antwort in den Strom</span></p>
<p>Die erste neue Zeile definiert die Variable <code>response</code>, die die Daten der
Erfolgsmeldung enthält. Dann rufen wir <code>as_bytes</code> auf unserer <code>response</code> auf,
um die Zeichenkettendaten in Bytes zu konvertieren. Die Methode <code>write</code> auf
<code>stream</code> nimmt ein <code>&amp;[u8]</code> und sendet diese Bytes direkt in die Verbindung.</p>
<p>Da die Operation <code>write</code> fehlschlagen könnte, verwenden wir wie bisher bei
jedem Fehlerergebnis <code>unwrap</code> . Auch hier würdest du in einer echten Anwendung
eine Fehlerbehandlung hinzufügen. Schließlich wird <code>flush</code> aufgerufen, damit
das Programm wartet, bis alle Bytes in die Verbindung geschrieben sind;
<code>TcpStream</code> enthält einen internen Puffer, um Aufrufe an das darunterliegende
Betriebssystem zu minimieren.</p>
<p>Lass uns mit diesen Änderungen unseren Code ausführen und eine Anfrage stellen.
Wir geben keine Daten mehr im Terminal aus, sodass wir außer der Ausgabe von
Cargo keine weiteren Ausgaben sehen werden. Wenn du <em>127.0.0.1:7878</em> in einem
Webbrowser lädst, solltest du statt eines Fehlers eine leere Seite sehen. Du
hast gerade eine HTTP-Anfrage und -Antwort von Hand kodiert!</p>
<h3><a class="header" href="#echtes-html-zurückgeben" id="echtes-html-zurückgeben">Echtes HTML zurückgeben</a></h3>
<p>Lass uns die Funktionalität für die Rückgabe von mehr als einer leeren Seite
implementieren. Erstelle eine neue Datei <em>hello.html</em> in der Wurzel deines
Projektverzeichnisses, nicht im Verzeichnis <em>src</em>. Du kannst beliebiges HTML
eingeben, das du willst; Codeblock 20-4 zeigt eine Möglichkeit.</p>
<p><span class="filename">Dateiname: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hallo!&lt;/h1&gt;
    &lt;p&gt;Hallo von Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 20-4: Eine Beispiel-HTML-Datei, die in einer
Antwort zurückgegeben werden soll</span></p>
<p>Dies ist ein minimales HTML5-Dokument mit einer Überschrift und etwas Text. Um
dies vom Server zurückzugeben, wenn eine Anfrage empfangen wird, modifizieren
wir <code>handle_connection</code> wie in Codeblock 20-5 gezeigt, um die HTML-Datei zu
lesen, sie der Antwort als Rumpf hinzuzufügen und sie zu senden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// --abschneiden--

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let response = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-5: Senden des Inhalts von <em>hello.html</em> als
Rumpf der Antwort</span></p>
<p>Wir haben oben eine Zeile hinzugefügt, um das Dateisystemmodul der
Standardbibliothek in den Gültigkeitsbereich zu bringen. Der Code zum Lesen des
Inhalts einer Datei in eine Zeichenkette sollte vertraut aussehen; wir haben
ihn in Kapitel 12 verwendet, als wir den Inhalt einer Datei für unser
E/A-Projekt in Codeblock 12-4 gelesen haben.</p>
<p>Als Nächstes verwenden wir <code>format!</code>, um den Inhalt der Datei als Rumpf der
Erfolgsantwort hinzuzufügen. Um eine gültige HTTP-Antwort zu gewährleisten,
fügen wir den Header <code>Content-Length</code> hinzu, der auf die Größe unseres
Antwortrumpfs gesetzt wird, in diesem Fall auf die Größe von <code>hello.html</code>. </p>
<p>Führe diesen Code mit <code>cargo run</code> aus und lade <em>127.0.0.1:7878</em> im Browser; du
solltest dein HTML gerendert sehen!</p>
<p>Gegenwärtig ignorieren wir die Anfragedaten in <code>buffer</code> und senden einfach den
Inhalt der HTML-Datei bedingungslos zurück. Das heißt, wenn du versuchst,
<em>127.0.0.1:7878/something-else</em> in deinem Browser anzufragen, erhältst du immer
noch dieselbe HTML-Antwort zurück. Unser Server ist sehr begrenzt und ist nicht
das, was die meisten Webserver tun. Wir wollen unsere Antworten je nach Anfrage
anpassen und nur die HTML-Datei für eine wohlgeformte Anfrage an <code>/</code>
zurücksenden.</p>
<h3><a class="header" href="#validieren-der-anfrage-und-selektives-beantworten" id="validieren-der-anfrage-und-selektives-beantworten">Validieren der Anfrage und selektives Beantworten</a></h3>
<p>Im Moment wird unser Webserver das HTML in der Datei zurückgeben, unabhängig
davon, was der Client angefragt hat. Fügen wir Funktionen hinzu, um zu
überprüfen, ob der Browser <code>/</code> anfragt, bevor er die HTML-Datei zurückgibt, und
um einen Fehler zurückzugeben, wenn der Browser etwas anderes anfragt. Dazu
müssen wir <code>handle_connection</code> modifizieren, wie in Codeblock 20-6 gezeigt.
Dieser neue Code prüft den Inhalt der erhaltenen Anfrage, ob <code>/</code> angefragt
wird, und fügt <code>if</code>- und <code>else</code>-Blöcke hinzu, um die Anfragen unterschiedlich
zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let response = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // eine andere Anfrage
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-6: Abgleichen der Anfrage und Behandeln von
Anfragen an <code>/</code> anders als bei anderen Anfragen</span></p>
<p>Zuerst werden die Daten, die der <code>/</code>-Anfrage entsprechen, fest in die Variable
<code>get</code> kodiert. Da wir Roh-Bytes in den Puffer einlesen, wandeln wir <code>get</code> in
eine Byte-Zeichenkette um, indem wir die Byte-Zeichenkettensyntax <code>b&quot;&quot;</code> am
Anfang der Inhaltsdaten hinzufügen. Dann prüfen wir, ob <code>buffer</code> mit den Bytes
in <code>get</code> beginnt. Wenn dies der Fall ist, bedeutet es, dass wir eine
wohlgeformte Anfrage an <code>/</code> erhalten haben, was der Erfolgsfall ist, den wir im
<code>if</code>-Block behandeln, der den Inhalt unserer HTML-Datei zurückgibt.</p>
<p>Wenn <code>buffer</code> <em>nicht</em> mit den Bytes in <code>get</code> beginnt, bedeutet das, dass wir
eine andere Anfrage erhalten haben. Wir fügen gleich Code zum <code>else</code>-Block
hinzu, um auf alle anderen Anfragen zu antworten.</p>
<p>Führe diesen Code jetzt aus und frage <em>127.0.0.1:7878</em> an; du solltest das HTML
in <em>hello.html</em> erhalten. Wenn du eine andere Anfrage stellst, z.B.
<em>127.0.0.1:7878/something-else</em>, erhältst du einen Verbindungsfehler, wie du
ihn beim Ausführen des Codes in Codeblock 20-1 und Codeblock 20-2 gesehen hast.</p>
<p>Fügen wir nun den Code in Codeblock 20-7 in den <code>else</code>-Block ein, um eine
Antwort mit dem Statuscode 404 zurückzugeben, der signalisiert, dass der Inhalt
für die Anfrage nicht gefunden wurde. Wir geben auch etwas HTML für eine Seite
zurück, die im Browser dargestellt werden soll, um dem Endbenutzer die Antwort
anzuzeigen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if buffer.starts_with(get) {
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contents.len(),
</span><span class="boring">            contents
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write(response.as_bytes()).unwrap();
</span><span class="boring">        stream.flush().unwrap();
</span>    // --abschneiden--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let response = format!(&quot;{}{}&quot;, status_line, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-7: Antworten mit Statuscode 404 und einer
Fehlerseite, wenn etwas anderes als <code>/</code> angefragt wurde</span></p>
<p>Hier hat unsere Antwort eine Statuszeile mit Statuscode 404 und der
Begründungsphrase <code>NOT FOUND</code> (nicht gefunden). Wir geben immer noch keine
Kopfzeilen zurück und der Rumpf der Antwort wird das HTML in der Datei
<em>404.html</em> sein. Du musst neben <em>hallo.html</em> eine Datei <em>404.html</em> für die
Fehlerseite erstellen; auch hier kannst du jedes beliebige HTML verwenden oder
das Beispiel-HTML in Codeblock 20-8.</p>
<p><span class="filename">Dateiname: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hallo!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Ups!&lt;/h1&gt;
    &lt;p&gt;Entschuldige, ich weiß nicht wonach du gefragt hast.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Codeblock 20-8: Beispielinhalt für die Seite, die mit
jeder 404-Antwort zurückgesendet werden soll</span></p>
<p>Lass deinen Server mit diesen Änderungen erneut laufen. Die Anfrage
<em>127.0.0.1:7878</em> sollte den Inhalt von <em>hallo.html</em> zurückgeben und jede andere
Anfrage, wie <em>127.0.0.1:7878/foo</em>, sollte das Fehler-HTML von <em>404.html</em>
zurückgeben.</p>
<h3><a class="header" href="#ein-hauch-von-refaktorierung" id="ein-hauch-von-refaktorierung">Ein Hauch von Refaktorierung</a></h3>
<p>Im Moment haben die <code>if</code>- und <code>else</code>-Blöcke eine Menge Wiederholungen: Sie
lesen beide Dateien und schreiben den Inhalt der Dateien in den Strom. Die
einzigen Unterschiede sind die Statuszeile und der Dateiname. Lass uns den Code
prägnanter gestalten, indem wir diese Unterschiede in separate <code>if</code>- und
<code>else</code>-Zeilen herausziehen, die die Werte der Statuszeile und des Dateinamens
Variablen zuweisen; wir können diese Variablen dann bedingungslos im Code
verwenden, um die Datei zu lesen und die Antwort zu schreiben. Codeblock 20-9
zeigt den resultierenden Code nach dem Ersetzen der großen <code>if</code>- und
<code>else</code>-Blöcke.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">Codeblock 20-9: Refaktorieren der <code>if</code>- und
<code>else</code>-Blöcke, sodass sie nur den Code enthalten, der sich zwischen den beiden
Fällen unterscheidet</span></p>
<p>Die Blöcke <code>if</code> und <code>else</code> geben jetzt nur noch die entsprechenden Werte für
die Statuszeile und den Dateinamen in einem Tupel zurück; wir verwenden dann
die Destrukturierung, um diese beiden Werte den Variablen <code>status_line</code> und
<code>filename</code> zuzuweisen, unter Verwendung eines Musters in der <code>let</code>-Anweisung,
wie in Kapitel 18 besprochen.</p>
<p>Der zuvor duplizierte Code befindet sich jetzt außerhalb der Blöcke <code>if</code> und
<code>else</code> und verwendet die Variablen <code>status_line</code> und <code>filename</code>. Dies macht es
einfacher, den Unterschied zwischen den beiden Fällen zu erkennen, und es
bedeutet, dass wir nur einen Ort haben, an dem wir den Code aktualisieren
müssen, wenn wir ändern wollen, wie das Lesen der Datei und das Schreiben der
Antwort funktionieren. Das Verhalten des Codes in Codeblock 20-9 ist dasselbe
wie in Codeblock 20-8.</p>
<p>Fantastisch! Wir haben jetzt einen einfachen Webserver mit etwa 40 Zeilen
Rust-Code, der auf eine Anfrage mit einer Inhaltsseite antwortet und auf alle
anderen Anfragen mit einer 404-Antwort.</p>
<p>Derzeit läuft unser Server in einem einzigen Strang (thread), d.h. er kann
immer nur eine Anfrage gleichzeitig bedienen. Lass uns untersuchen, warum das
ein Problem sein kann, indem wir einige langsame Anfragen simulieren. Dann
werden wir es beheben, indem unser Server mehrere Anfragen auf einmal
bearbeiten kann.</p>
<h2><a class="header" href="#unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln" id="unseren-einsträngigen-single-threaded-webserver-in-einen-mehrsträngigen-multi-threaded-webserver-verwandeln">Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></h2>
<p>Im Moment verarbeitet der Server jede Anfrage der Reihe nach, d.h. er wird erst
dann eine zweite Verbindung verarbeiten, wenn die erste abgeschlossen ist.
Würde der Server mehr und mehr Anfragen erhalten, wäre diese serielle
Ausführung immer weniger optimal. Wenn der Server eine Anfrage erhält, deren
Bearbeitung sehr lange dauert, müssen nachfolgende Anfragen warten, bis die
lange dauernde Anfrage beendet ist, auch wenn die neuen Anfragen schnell
bearbeitet werden können. Das müssen wir beheben, aber zuerst werden wir uns
das Problem in Aktion ansehen.</p>
<h3><a class="header" href="#simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung" id="simulieren-einer-langsamen-anfrage-in-der-aktuellen-server-implementierung">Simulieren einer langsamen Anfrage in der aktuellen Server-Implementierung</a></h3>
<p>Wir werden untersuchen, wie sich eine Anfrage mit langsamer Verarbeitung auf
andere Anfragen an unsere aktuelle Server-Implementierung auswirken kann.
Codeblock 20-10 implementiert die Behandlung einer Anfrage an <em>/sleep</em> mit
einer simulierten langsamen Antwort, die den Server veranlasst, 5 Sekunden lang
zu schlafen, bevor er antwortet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span>use std::thread;
use std::time::Duration;
// --abschneiden--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    // --abschneiden--

<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span>    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --abschneiden--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 20-10: Simulieren einer langsamen Anfrage durch
Erkennen von <em>/sleep</em> und 5 Sekunden Schlafen</span></p>
<p>Dieser Code ist etwas unordentlich, aber für Simulationszwecke gut genug. Wir
haben eine zweite Anfrage <code>sleep</code> erstellt, deren Daten unser Server erkennt.
Wir haben nach dem <code>if</code>-Block ein <code>else if</code> hinzugefügt, um die Anfrage auf
<em>/sleep</em> zu prüfen. Wenn diese Anfrage empfangen wird, wird der Server für 5
Sekunden schlafen, bevor er die Erfolgs-HTML-Seite rendert.</p>
<p>Du kannst sehen, wie primitiv unser Server ist: Echte Bibliotheken würden das
Erkennen mehrerer Anfragen viel weniger wortreich handhaben!</p>
<p>Starte den Server mit <code>cargo run</code>. Öffne dann zwei Browser-Fenster: Eines für
<em>http://127.0.0.1:7878/</em> und das andere für <em>http://127.0.0.1:7878/sleep</em>. Wenn
du die URI <code>/</code> wie bisher ein paar Mal eingibst, wirst du sehen, dass er
schnell reagiert. Aber wenn du <em>/sleep</em> eingibst und dann <code>/</code> lädst, wirst du
sehen, dass <code>/</code> wartet, bis <code>sleep</code> für volle 5 Sekunden geschlafen hat, bevor
es geladen wird.</p>
<p>Es gibt mehrere Möglichkeiten, wie wir die Funktionsweise unseres Webservers
ändern könnten, um zu vermeiden, dass hinter einer langsamen Anfrage weitere
Anfragen warten müssen; die eine, die wir implementieren werden, ist ein
Strang-Vorrat (thread pool).</p>
<h3><a class="header" href="#verbessern-des-durchsatzes-mit-einem-strang-vorrat" id="verbessern-des-durchsatzes-mit-einem-strang-vorrat">Verbessern des Durchsatzes mit einem Strang-Vorrat</a></h3>
<p>Ein <em>Strang-Vorrat</em> (thread pool) ist eine Gruppe von erzeugten Strängen, die
warten und bereit sind, eine Aufgabe zu bearbeiten. Wenn das Programm eine neue
Aufgabe erhält, ordnet es einen der Stränge im Pool der Aufgabe zu, und dieser
Strang wird die Aufgabe bearbeiten. Die verbleibenden Stränge im Pool stehen
für alle anderen Aufgaben zur Verfügung, die während der Verarbeitung des
ersten Strangs hereinkommen. Wenn der erste Strang mit der Verarbeitung seiner
Aufgabe fertig ist, kehrt er in den Vorrat der unbeschäftigten Stränge zurück
und ist bereit, eine neue Aufgabe zu bearbeiten. Ein Strang-Vorrat ermöglicht
es dir, Verbindungen gleichzeitig zu verarbeiten und so den Durchsatz deines
Servers zu erhöhen.</p>
<p>Wir beschränken die Anzahl der Stränge im Vorrat auf eine kleine Anzahl, um uns
vor Dienstverweigerungsangriffen (Denial-of-Service, kurz DoS) zu schützen;
wenn unser Programm für jede eingehende Anfrage einen neuen Strang erstellen
würde, könnte jemand, der 10 Millionen Anfragen an unseren Server stellt, ein
Chaos anrichten, indem er alle Ressourcen unseres Servers aufbraucht und die
Bearbeitung der Anfragen zum Erliegen bringt.</p>
<p>Anstatt unbegrenzt viele Stränge zu erzeugen, werden wir eine feste Anzahl von
Strängen im Vorrat warten lassen. Wenn Anfragen eingehen, werden sie zur
Verarbeitung an den Vorrat geschickt. Der Vorrat verwaltet eine Warteschlange
für eingehende Anfragen. Jeder der Stränge im Vorrat wird eine Anfrage aus
dieser Warteschlange holen, die Anfrage bearbeiten und dann die Warteschlange
um eine weitere Anfrage fragen. Mit diesem Design können wir <code>N</code> Anfragen
gleichzeitig bearbeiten, wobei <code>N</code> die Anzahl der Stränge ist. Wenn jeder
Strang auf eine lang laufende Anfrage antwortet, können sich nachfolgende
Anfragen immer noch in der Warteschlange rückstauen, aber wir haben die Anzahl
der lang laufenden Anfragen erhöht, die wir bearbeiten können, bevor wir diesen
Punkt erreichen.</p>
<p>Diese Technik ist nur eine von vielen Möglichkeiten, den Durchsatz eines
Webservers zu verbessern. Weitere Optionen, die du untersuchen könntest, sind
das Fork/Join-Modell und das asynchrone E/A-Modell mit einem Strang. Wenn du an
diesem Thema interessiert bist, kannst du mehr über andere Lösungen lesen und
versuchen, sie in Rust zu implementieren; mit einer systemnahen Sprache wie
Rust sind alle diese Optionen möglich.</p>
<p>Bevor wir mit der Implementierung eines Strang-Vorrats beginnen, lass uns
darüber sprechen, wie die Verwendung des Vorrats aussehen sollte. Wenn du
versuchst, Code zu entwerfen, kann das Schreiben der Client-Benutzeroberfläche
beim Entwurf helfen. Schreibe die API des Codes so, dass sie so strukturiert
ist, wie du sie aufrufen möchtest; implementiere dann die Funktionalität
innerhalb dieser Struktur, anstatt zuerst die Funktionalität zu implementieren
und danach die öffentliche API zu entwerfen.</p>
<p>Ähnlich wie wir die testgetriebene Entwicklung im Projekt in Kapitel 12
angewendet haben, werden wir hier die compilergetriebene Entwicklung verwenden.
Wir werden den Code schreiben, der die von uns gewünschten Funktionen aufruft,
und dann schauen wir uns Fehler des Compilers an, um zu bestimmen, was wir als
Nächstes ändern sollten, damit der Code funktioniert.</p>
<h4><a class="header" href="#code-struktur-wenn-wir-für-jede-anfrage-einen-strang-erstellen-könnten" id="code-struktur-wenn-wir-für-jede-anfrage-einen-strang-erstellen-könnten">Code-Struktur, wenn wir für jede Anfrage einen Strang erstellen könnten</a></h4>
<p>Lass uns zunächst untersuchen, wie unser Code aussehen könnte, wenn er für jede
Verbindung einen neuen Strang erstellen würde. Wie bereits erwähnt, ist dies
nicht unser endgültiger Plan aufgrund der Probleme, eine unbegrenzte Anzahl von
Threads zu erzeugen, aber es ist ein Ausgangspunkt. Codeblock 20-11 zeigt die
Änderungen, die an <code>main</code> vorzunehmen sind, um einen neuen Strang zu erzeugen,
der jeden Strom innerhalb der <code>for</code>-Schleife behandelt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-11: Erstellen eines neuen Strangs für jeden
Strom</span></p>
<p>Wie du in Kapitel 16 gelernt hast, wird <code>thread::spawn</code> einen neuen Strang
erstellen und dann den Code im Funktionsabschluss (closure) im neuen Strang
ausführen. Wenn du diesen Code ausführst und <em>/sleep</em> in deinem Browser lädst,
dann <code>/</code> in zwei weiteren Browser-Tabs, wirst du in der Tat sehen, dass die
Anfragen an <code>/</code> nicht auf die Beendigung von <em>/sleep</em> warten müssen. Aber wie
wir bereits erwähnt haben, wird dies letztendlich das System überfordern, weil
du neue Stränge ohne jede Begrenzung erstellen würdest.</p>
<h4><a class="header" href="#erstellen-einer-ähnlichen-schnittstelle-für-eine-endliche-anzahl-von-strängen" id="erstellen-einer-ähnlichen-schnittstelle-für-eine-endliche-anzahl-von-strängen">Erstellen einer ähnlichen Schnittstelle für eine endliche Anzahl von Strängen</a></h4>
<p>Wir möchten, dass unser Strang-Vorrat in einer ähnlichen, vertrauten Weise
arbeitet, sodass der Wechsel von Strängen zu einem Strang-Vorrat keine großen
Änderungen am Code erfordert, der unsere API verwendet. Codeblock 20-12 zeigt
die hypothetische Schnittstelle für eine Struktur (struct) <code>ThreadPool</code>, die
wir anstelle von <code>thread::spawn</code> verwenden wollen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 20-12: Unsere ideale
<code>ThreadPool</code>-Schnittstelle</span></p>
<p>Wir verwenden <code>ThreadPool::new</code>, um einen neuen Strang-Vorrat mit einer
konfigurierbaren Anzahl von Strängen zu erstellen, in diesem Fall vier. In der
<code>for</code>-Schleife hat <code>pool.execute</code> eine ähnliche Schnittstelle wie
<code>thread::spawn</code>, indem es einen Funktionsabschluss entgegennimmt, den der
Vorrat für jeden Strom ausführen soll. Wir müssen <code>pool.execute</code>
implementieren, sodass es den Funktionsabschluss entgegennimmt und ihn einem
Strang im Vorrat zur Ausführung übergibt. Dieser Code lässt sich noch nicht
kompilieren, aber wir werden es versuchen, damit der Compiler uns anleiten
kann, wie wir das Problem beheben können.</p>
<h4><a class="header" href="#aufbau-der-struktur-threadpool-mit-compilergetriebener-entwicklung" id="aufbau-der-struktur-threadpool-mit-compilergetriebener-entwicklung">Aufbau der Struktur <code>ThreadPool</code> mit compilergetriebener Entwicklung</a></h4>
<p>Nimm die Änderungen in Codeblock 20-12 an <em>src/main.rs</em> vor und lass uns dann
die Kompilierfehler von <code>cargo check</code> verwenden, um unsere Entwicklung
voranzutreiben. Hier ist der erste Fehler, den wir erhalten:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type or module `ThreadPool`
  --&gt; src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type or module `ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Großartig! Dieser Fehler sagt uns, dass wir einen Typ oder ein Modul
<code>ThreadPool</code> benötigen, also werden wir jetzt eines bauen. Unsere
<code>ThreadPool</code>-Implementierung wird unabhängig von der Art der Arbeit unseres
Webservers sein. Lass uns also die Kiste (crate) <code>hello</code> von einer Binär-Kiste
(binary crate) auf eine Bibliotheks-Kiste (library crate) umstellen, um unsere
<code>ThreadPool</code>-Implementierung aufzunehmen. Nachdem wir zu einer Bibliothekskiste
umgestellt haben, könnten wir die separate Strang-Vorrats-Bibliothek auch für
alle Arbeiten verwenden, die wir mit einem Strang-Vorrat durchführen wollen,
nicht nur für die Bedienung von Webanfragen.</p>
<p>Erstelle eine Datei <em>src/lib.rs</em>, die das Folgende enthält, was die einfachste
Definition einer <code>ThreadPool</code>-Struktur ist, die wir im Moment haben können:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}
</span></code></pre></pre>
<p>Erstelle dann ein neues Verzeichnis <em>src/bin</em> und verschiebe die Binärkiste,
die in <em>src/main.rs</em> enthalten ist, in <em>src/bin/main.rs</em>. Dadurch wird die
Bibliothekskiste zur primären Kiste im Verzeichnis <em>hello</em>; wir können die
Binärdatei in <em>src/bin/main.rs</em> immer noch unter Verwendung von <code>cargo run</code>
ausführen. Nachdem du die Datei <em>main.rs</em> verschoben hast, editiere sie, um die
Bibliothekskiste einzubinden und <code>ThreadPool</code> in den Gültigkeitsbereich zu
bringen, indem du den folgenden Code am Anfang von <em>src/bin/main.rs</em>
hinzufügst:</p>
<p><span class="filename">Dateiname: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p>Dieser Code wird immer noch nicht funktionieren, aber lass uns ihn noch einmal
überprüfen, um den nächsten Fehler zu erhalten, den wir beheben müssen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieser Fehler deutet darauf hin, dass wir als Nächstes eine zugehörige Funktion
namens <code>new</code> für <code>ThreadPool</code> erstellen müssen. Wir wissen auch, dass <code>new</code>
einen Parameter haben muss, der <code>4</code> als Argument akzeptieren kann und eine
<code>ThreadPool</code>-Instanz zurückgeben sollte. Lass uns die einfachste Funktion <code>new</code>
implementieren, die diese Eigenschaften haben wird:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wir haben <code>usize</code> als Typ des Parameters <code>size</code> gewählt, weil wir wissen, dass
eine negative Anzahl von Strängen keinen Sinn macht. Wir wissen auch, dass wir
diese 4 als die Anzahl der Elemente in einer Kollektion von Strängen verwenden
werden, wofür der Typ <code>usize</code> gedacht ist, wie im Abschnitt
<a href="ch03-02-data-types.html#ganzzahl-typen">„Ganzzahl-Typen“</a> in Kapitel 3 besprochen.</p>
<p>Lass uns den Code noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler tritt jetzt auf, weil wir keine Methode <code>execute</code> auf <code>ThreadPool</code>
haben. Erinnere dich an den Abschnitt <a href="ch20-02-multithreaded.html#erstellen-einer-%C3%A4hnlichen-schnittstelle-f%C3%BCr-eine-endliche-anzahl-von-str%C3%A4ngen">„Erstellen einer ähnlichen Schnittstelle
für eine endliche Anzahl von Strängen“</a>, dass wir
beschlossen haben, dass unser Strang-Vorrat eine ähnliche Schnittstelle wie
<code>thread::spawn</code> haben sollte. Zusätzlich werden wir die Funktion <code>execute</code>
implementieren, sodass sie den Funktionsabschluss, der ihr gegeben wird, nimmt
und sie einem unbeschäftigten Strang im Vorrat zur Ausführung übergibt.</p>
<p>Wir werden die Methode <code>execute</code> auf <code>ThreadPool</code> definieren, um einen
Funktionsabschluss als Parameter zu nehmen. Aus dem Abschnitt <a href="ch13-01-closures.html#speichern-von-funktionsabschl%C3%BCssen-unter-verwendung-generischer-parameter-und-fn-merkmalen-traits">„Speichern von
Funktionsabschlüssen unter Verwendung generischer Parameter und Fn-Merkmalen
(traits)“</a> in Kapitel 13 erinnern wir uns, dass wir
Funktionsabschlüsse als Parameter mit drei verschiedenen Merkmalen nehmen
können: <code>Fn</code>, <code>FnMut</code> und <code>FnOnce</code>. Wir müssen entscheiden, welche Art von
Funktionsabschluss wir hier verwenden. Wir wissen, dass wir am Ende etwas
Ähnliches wie die Implementierung <code>thread::spawn</code> der Standardbibliothek tun
werden, sodass wir uns ansehen können, welche Abgrenzungen die Signatur von
<code>thread::spawn</code> in ihrem Parameter hat. Die Dokumentation zeigt uns Folgendes:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>Der Parameter vom Typ <code>F</code> ist derjenige, um den es hier geht; der Parameter vom
Typ <code>T</code> bezieht sich auf den Rückgabewert, und darum geht es uns nicht. Wir
können sehen, dass <code>spawn</code> <code>FnOnce</code> als Merkmal (trait) verwendet, das an <code>F</code>
gebunden ist. Das ist wahrscheinlich auch das, was wir wollen, denn wir werden
das Argument, das wir bei <code>execute</code> bekommen, letztendlich an <code>spawn</code>
weitergeben. Wir können weiterhin zuversichtlich sein, dass <code>FnOnce</code> das
Merkmal ist, das wir verwenden wollen, weil der Strang zum Ausführen einer
Anfrage den Funktionsabschluss dieser Anfrage nur einmal ausführt, was zu
<code>Once</code> in <code>FnOnce</code> passt.</p>
<p>Der Parameter vom Typ <code>F</code> hat auch die Merkmalsabgrenzung <code>Send</code> und die
Lebensdauer <code>'static</code>, die in unserer Situation nützlich sind: Wir brauchen
<code>Send</code>, um den Merkmalsabgrenzung von einem Strang zu einem anderen zu
übertragen und <code>'static</code>, weil wir nicht wissen, wie lange die Ausführung des
Strangs dauern wird. Lass uns eine Methode <code>execute</code> auf <code>ThreadPool</code>
erstellen, die einen generischen Parameter vom Typ <code>F</code> mit diesen Abgrenzungen
annimmt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wir verwenden immer noch <code>()</code> nach <code>FnOnce</code>, weil dieses <code>FnOnce</code> einen
Funktionsabschluss darstellt, der keine Parameter benötigt und den Einheitstyp
<code>()</code> zurückgibt. Genau wie bei Funktionsdefinitionen kann der Rückgabetyp in
der Signatur weggelassen werden, aber selbst wenn wir keine Parameter haben,
benötigen wir immer noch die Klammern.</p>
<p>Auch hier handelt es sich um die einfachste Implementierung der Methode
<code>execute</code>: Sie tut nichts, aber wir versuchen nur, unseren Code kompilieren zu
lassen. Lass es uns noch einmal überprüfen:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>Er kompiliert! Aber beachte, dass du, wenn du <code>cargo run</code> versuchst und eine
Anfrage im Browser stellst, die Fehler im Browser sehen wirst, die wir am
Anfang des Kapitels gesehen haben. Unsere Bibliothek ruft den
Funktionsabschluss, den wir an <code>execute</code> übergeben, noch nicht wirklich auf!</p>
<blockquote>
<p>Hinweis: Ein Sprichwort, das man möglicherweise über Sprachen mit strengen
Compilern wie Haskell und Rust hört, lautet: „Wenn der Code kompiliert,
funktioniert er.“ Aber dieses Sprichwort ist nicht universell wahr. Unser
Projekt kompiliert, aber es tut absolut nichts! Wenn wir ein echtes,
vollständiges Projekt aufbauen würden, wäre dies ein guter Zeitpunkt, mit dem
Schreiben von Unit-Tests zu beginnen, um zu überprüfen, ob der Code
kompiliert <em>und</em> das von uns gewünschte Verhalten aufweist.</p>
</blockquote>
<h4><a class="header" href="#validieren-der-anzahl-der-stränge-in-new" id="validieren-der-anzahl-der-stränge-in-new">Validieren der Anzahl der Stränge in <code>new</code></a></h4>
<p>Wir tun nichts mit den Parametern <code>new</code> und <code>execute</code>. Lass uns die Rümpfe
dieser Funktionen mit dem Verhalten implementieren, das wir wollen. Lass uns
zunächst über <code>new</code> nachdenken. Früher wählten wir einen vorzeichenlosen Typ
für den Parameter <code>size</code>, weil ein Vorrat mit einer negativen Anzahl von
Strängen keinen Sinn ergibt. Ein Vorrat mit null Strängen ergibt jedoch auch
keinen Sinn, dennoch ist null ein vollkommen gültiges <code>usize</code>. Wir fügen Code
hinzu, um zu prüfen, ob <code>size</code> größer als null ist, bevor wir eine
<code>ThreadPool</code>-Instanz zurückgeben, und das Programm abstürzen lassen, wenn er
eine Null erhält, indem wir das Makro <code>assert!</code> verwenden, wie in Codeblock
20-13 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-13: Implementierung von <code>ThreadPool::new</code>
stürzt ab, wenn <code>size</code> gleich Null ist</span></p>
<p>Wir haben etwas Dokumentation für unseren <code>ThreadPool</code> mit
Dokumentationskommentaren (doc comments) hinzugefügt. Beachte, dass wir uns an
gute Dokumentationspraktiken gehalten haben, indem wir einen Abschnitt
hinzugefügt haben, der die Situationen aufzeigt, in denen unsere Funktion
abstürzen kann, wie in Kapitel 14 besprochen. Versuche, <code>cargo doc --open</code>
auszuführen und die Struktur <code>ThreadPool</code> anzuklicken, um zu sehen, wie die
generierte Dokumentation für <code>new</code> aussieht!</p>
<p>Anstatt das Makro <code>assert!</code> hinzuzufügen, wie wir es hier getan haben, könnten
wir <code>new</code> ein <code>Result</code> zurückgeben lassen, wie wir es mit <code>Config::new</code> im
E/A-Projekt in Codeblock 12-9 getan haben. Aber wir haben in diesem Fall
entschieden, dass der Versuch, einen Strang-Vorrat ohne Stränge zu erstellen,
ein nicht behebbarer Fehler sein sollte. Wenn du ehrgeizig bist, versuche, eine
Version von <code>new</code> mit der folgenden Signatur zu schreiben, um beide Versionen
zu vergleichen:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4><a class="header" href="#platz-zum-speichern-der-stränge-schaffen" id="platz-zum-speichern-der-stränge-schaffen">Platz zum Speichern der Stränge schaffen</a></h4>
<p>Jetzt, da wir eine Möglichkeit haben, zu wissen, dass wir eine gültige Anzahl
von Strängen im Vorrat haben, können wir diese Stränge erstellen und sie in der
Struktur <code>ThreadPool</code> speichern, bevor wir sie zurückgeben. Aber wie
„speichern“ wir einen Strang? Werfen wir noch einmal einen Blick auf die
Signatur von <code>Thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>Die Funktion <code>spawn</code> gibt einen <code>JoinHandle&lt;T&gt;</code> zurück, wobei <code>T</code> der Typ ist,
den der Funktionsabschluss zurückgibt. Lass uns versuchen, auch <code>JoinHandle</code> zu
benutzen und sehen, was passiert. In unserem Fall werden die
Funktionsabschlüsse, die wir an den Strang-Vorrat übergeben, die Verbindung
behandeln und nichts zurückgeben, also wird <code>T</code> der Unit-Typ <code>()</code> sein.</p>
<p>Der Code in Codeblock 20-14 lässt sich kompilieren, erzeugt aber noch keine
Stränge. Wir haben die Definition von <code>ThreadPool</code> so geändert, dass sie einen
Vektor von <code>thread::JoinHandle&lt;()&gt;</code>-Instanzen enthält, den Vektor mit der
Kapazität <code>size</code> initialisiert, eine <code>for</code>-Schleife eingerichtet, die etwas
Code zum Erzeugen der Stränge ausführt, und eine <code>ThreadPool</code>-Instanz
zurückgibt, die diese enthält.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // einige Stränge erstellen und im Vektor speichern
        }

        ThreadPool { threads }
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Codeblock 20-14: Erstellen eines Vektors für <code>ThreadPool</code>
zum Aufnehmen der Stränge</span></p>
<p>Wir haben <code>std::thread</code> in der Bibliothekskiste in den Gültigkeitsbereich
gebracht, weil wir <code>thread::JoinHandle</code> als den Typ der Elemente im Vektor in
<code>ThreadPool</code> verwenden.</p>
<p>Sobald wir eine gültige Größe erhalten haben, erzeugt unser <code>ThreadPool</code> einen
neuen Vektor, der <code>size</code> Elemente aufnehmen kann. Wir haben in diesem Buch noch
nicht die Funktion <code>with_capacity</code> verwendet, die die gleiche Aufgabe wie
<code>Vec::new</code> erfüllt, aber mit einem wichtigen Unterschied: Sie weist dem Vektor
Platz im Voraus zu. Da wir wissen, dass wir <code>size</code> Elemente im Vektor speichern
müssen, ist diese Allokation im Voraus etwas effizienter als die Verwendung von
<code>Vec::new</code>, das sich selbst in der Größe verändert, wenn Elemente eingefügt
werden.</p>
<p>Wenn du <code>cargo check</code> erneut ausführst, wirst du einige weitere Warnungen
erhalten, aber es sollte gelingen.</p>
<h4><a class="header" href="#struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang" id="struktur-worker-zum-senden-von-code-vom-threadpool-an-einen-strang">Struktur <code>Worker</code> zum Senden von Code vom <code>ThreadPool</code> an einen Strang</a></h4>
<p>Wir haben einen Kommentar in der <code>for</code>-Schleife in Codeblock 20-14 bezüglich
der Erstellung von Strängen hinterlassen. Hier werden wir uns ansehen, wie wir
tatsächlich Stränge erstellen. Die Standardbibliothek bietet <code>thread::spawn</code>
als eine Möglichkeit, Stränge zu erstellen, und <code>thread::spawn</code> erwartet, dass
es Code erhält, den der Strang ausführen soll, sobald der Strang erstellt ist.
In unserem Fall wollen wir jedoch die Stränge erstellen und sie auf Code
<em>warten</em> lassen, den wir später senden werden. Die Implementierung von Strängen
in der Standardbibliothek enthält keine Möglichkeit, dies zu tun; wir müssen
sie manuell implementieren.</p>
<p>Wir werden dieses Verhalten implementieren, indem wir eine neue Datenstruktur
zwischen dem <code>ThreadPool</code> und den Strängen, die dieses neue Verhalten verwalten
werden, einführen. Wir nennen diese Datenstruktur <code>Worker</code>, was ein gängiger
Begriff in Vorrats-Implementierungen ist. Denke an Menschen, die in der Küche
eines Restaurants arbeiten: Die Arbeiter warten, bis Bestellungen von Kunden
eingehen, und dann sind sie dafür verantwortlich, diese Bestellungen
entgegenzunehmen und auszuführen.</p>
<p>Anstatt einen Vektor von <code>JoinHandle&lt;()&gt;</code>-Instanzen im Strang-Vorrat zu
speichern, werden wir Instanzen der <code>Worker</code>-Struktur speichern. Jeder <code>Worker</code>
wird eine einzelne <code>JoinHandle&lt;()&gt;</code>-Instanz speichern. Dann werden wir eine
Methode auf <code>Worker</code> implementieren, die einen Funktionsabschluss zur
Ausführung benötigt und ihn zur Ausführung an den bereits laufenden Strang
sendet. Wir werden auch jedem <code>Worker</code> eine <code>id</code> geben, damit wir beim
Protokollieren oder Debuggen zwischen den verschiedenen <code>Worker</code> im Vorrat
unterscheiden können.</p>
<p>Lass uns die folgenden Änderungen daran vornehmen, was passiert, wenn wir einen
<code>ThreadPool</code> erstellen. Wir implementieren den Code, der den Funktionsabschluss
an den Strang sendet, nachdem wir <code>Worker</code> auf diese Weise eingerichtet haben:</p>
<ol>
<li>Definiere eine Struktur <code>Worker</code>, die eine <code>id</code> und einen <code>JoinHandle&lt;()&gt;</code>
enthält.</li>
<li>Ändere <code>ThreadPool</code>, um einen Vektor von <code>Worker</code>-Instanzen zu halten.</li>
<li>Definiere eine Funktion <code>Worker::new</code>, die eine <code>id</code>-Nummer nimmt und eine
<code>Worker</code>-Instanz zurückgibt, die die <code>id</code> enthält, sowie einen Strang, der
mit einem leeren Funktionsabschluss erzeugt wurde.</li>
<li>Verwende in <code>ThreadPool::new</code> den <code>for</code>-Schleifenzähler, um eine <code>id</code> zu
erzeugen, erzeuge einen neuen <code>Worker</code> mit dieser <code>id</code> und speichere den
<code>Worker</code> im Vektor.</li>
</ol>
<p>Wenn du zu einer Herausforderung bereit bist, versuche, diese Änderungen selbst
zu implementieren, bevor du dir den Code in Codeblock 20-15 ansiehst.</p>
<p>Bereit? Hier ist Codeblock 20-15 mit einer Möglichkeit, die vorhergehenden
Änderungen vorzunehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-15: Modifizieren von <code>ThreadPool</code>, um
<code>Worker</code>-Instanzen zu halten, anstatt Stränge direkt zu halten</span></p>
<p>Wir haben den Namen des Feldes in <code>ThreadPool</code> von <code>threads</code> in <code>workers</code>
geändert, weil es jetzt <code>Worker</code>-Instanzen statt <code>JoinHandle&lt;()&gt;</code>-Instanzen
enthält. Wir benutzen den Zähler in der <code>for</code>-Schleife als Argument für
<code>Worker::new</code> und wir speichern jeden neuen <code>Worker</code> im Vektor mit dem Namen
<code>workers</code>.</p>
<p>Externer Code (wie unser Server in <em>src/bin/main.rs</em>) muss die
Implementierungsdetails bezüglich der Verwendung einer <code>Worker</code>-Struktur
innerhalb von <code>ThreadPool</code> nicht kennen, also machen wir die <code>Worker</code>-Struktur
und ihre Funktion <code>new</code> privat. Die Funktion <code>Worker::new</code> verwendet die <code>id</code>,
die wir ihr geben, und speichert eine <code>JoinHandle&lt;()&gt;</code>-Instanz, die durch das
Erzeugen eines neuen Strangs unter Verwendung eines leeren Funktionsabschlusses
erzeugt wird.</p>
<p>Dieser Code kompiliert und speichert die Anzahl der <code>Worker</code>-Instanzen, die wir
als Argument für <code>ThreadPool::new</code> angegeben haben. Aber wir <em>verarbeiten</em> noch
nicht den Funktionsabschluss, den wir in <code>execute</code> erhalten. Schauen wir uns
als Nächstes an, wie wir das machen.</p>
<h4><a class="header" href="#senden-von-anfragen-an-stränge-über-kanäle" id="senden-von-anfragen-an-stränge-über-kanäle">Senden von Anfragen an Stränge über Kanäle</a></h4>
<p>Nun werden wir das Problem angehen, dass die Funktionsabschlüsse bei
<code>thread::spawn</code> absolut nichts bewirken. Gegenwärtig erhalten wir den
Funktionsabschluss, den wir ausführen wollen, mit der Methode <code>execute</code>. Aber
wir müssen <code>thread::spawn</code> einen Funktionsabschluss geben, der ausgeführt
werden soll, wenn wir jeden <code>Worker</code> während der Erstellung des <code>ThreadPool</code>
erstellen.</p>
<p>Wir möchten, dass die Struktur <code>Worker</code>, die wir gerade erstellt haben, um Code
aus einer Warteschlange im <code>ThreadPool</code> zu holen und diesen Code zur Ausführung
an seinen Strang zu senden.</p>
<p>In Kapitel 16 hast du etwas über <em>Kanäle</em> (channels) gelernt – eine
einfache Art der Kommunikation zwischen zwei Strängen –, die für diesen
Anwendungsfall perfekt geeignet ist. Wir verwenden einen Kanal, der als
Warteschlange von Aufträgen fungiert, und <code>execute</code> sendet einen Auftrag aus
dem <code>ThreadPool</code> an die <code>Worker</code>-Instanzen, die den Auftrag an ihren Strang
sendet. Hier ist der Plan:</p>
<ol>
<li>Der <code>ThreadPool</code> erstellt einen Kanal und hält die Sendeseite des Kanals.</li>
<li>Jeder <code>Worker</code> hält die Empfangsseite des Kanals.</li>
<li>Wir werden eine neue Struktur <code>Job</code> erstellen, die den Funktionsabschluss
aufnimmt, den wir über den Kanal senden wollen.</li>
<li>Die Methode <code>execute</code> sendet den Auftrag, der ausgeführt werden soll, in
die Sendeseite des Kanals.</li>
<li>In seinem Strang wird der <code>Worker</code> an der Empfangsseite des Kanals warten
und die Funktionsabschlüsse aller Aufträge, die er erhält, ausführen.</li>
</ol>
<p>Beginnen wir damit, einen Kanal in <code>ThreadPool::new</code> zu erstellen und die
Sendeseite in der <code>ThreadPool</code>-Instanz zu halten, wie in Codeblock 20-16
gezeigt. Die Struktur <code>Job</code> enthält vorerst nichts, aber sie wird die Art von
Element sein, die wir in den Kanal senden.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span>// --abschneiden--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-16: Ändern von <code>ThreadPool</code>, um das sendende
Ende eines Kanals zu speichern, der <code>Job</code>-Instanzen sendet</span></p>
<p>In <code>ThreadPool::new</code> erstellen wir unseren neuen Kanal und lassen den Pool das
sendende Ende halten. Dies wird erfolgreich kompiliert, immer noch mit
Warnungen.</p>
<p>Lass uns versuchen, ein empfangendes Ende des Kanals an jeden <code>Worker</code>
weiterzugeben, während der Strang-Vorrat den Kanal erstellt. Wir wissen, dass
wir das empfangende Ende in dem Strang verwenden wollen, den der <code>Worker</code> hat,
also werden wir den Parameter <code>receiver</code> im Funktionsabschluss referenzieren.
Der Code in Codeblock 20-17 lässt sich noch nicht ganz kompilieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Codeblock 20-17: Übergeben des Empfangsteils des Kanals
an die <code>Worker</code></span></p>
<p>Wir haben einige kleine und unkomplizierte Änderungen vorgenommen: Wir geben
das empfangende Ende des Kanals an <code>Worker::new</code> und dann verwenden wir es
innerhalb des Funktionsabschlusses.</p>
<p>Wenn wir versuchen, diesen Code zu überprüfen, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Code versucht, <code>receiver</code> an mehrere <code>Worker</code>-Instanzen weiterzugeben. Das
wird nicht funktionieren, wie du dich aus Kapitel 16 erinnern wirst: Die
Kanalimplementierung, die Rust bietet, erlaubt mehrere <em>Produzenten</em> und einen
einzigen <em>Konsumenten</em>. Das bedeutet, dass wir nicht einfach das konsumierende
Ende des Kanals klonen können, um diesen Code zu reparieren. Selbst wenn wir
das könnten, ist das nicht die Technik, die wir anwenden wollen; stattdessen
wollen wir die Aufträge auf mehrere Stränge verteilen, indem wir den einzigen
<code>receiver</code> unter allen <code>Worker</code> aufteilen.</p>
<p>Außerdem erfordert das Entfernen eines Auftrags aus der Warteschlange des
Kanals eine Mutation von <code>receiver</code>, sodass die Stränge einen sicheren Weg
benötigen, um <code>receiver</code> gemeinsam zu nutzen und zu modifizieren; andernfalls
könnten wir Wettlaufsituationen (race conditions) erhalten (wie in Kapitel 16
behandelt).</p>
<p>Erinnere dich an die Strang-sicheren intelligenten Zeiger, die in Kapitel 16
besprochen wurden: Um die Eigentümerschaft über mehrere Stränge zu teilen und
den Strängen zu erlauben, den Wert zu mutieren, müssen wir <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
verwenden. Der Typ <code>Arc</code> ermöglicht es mehreren <code>Worker</code>, den Empfänger zu
besitzen, und <code>Mutex</code> stellt sicher, dass immer nur ein <code>Worker</code> zur gleichen
Zeit einen Auftrag vom Empfänger erhält. Der Codeblock 20-18 zeigt die
Änderungen, die wir vornehmen müssen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span>use std::sync::Arc;
use std::sync::Mutex;
// --abschneiden--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --abschneiden--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --abschneiden--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --abschneiden--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-18: Das empfangende Ende des Kanals unter
den <code>Worker</code> teilen, die <code>Arc</code> und <code>Mutex</code> benutzen</span></p>
<p>In <code>ThreadPool::new</code> setzen wir das empfangende Ende des Kanals in einen <code>Arc</code>
und einen <code>Mutex</code>. Für jeden neuen <code>Worker</code> klonen wir den <code>Arc</code>, um die
Referenzzählung zu erhöhen, sodass die <code>Worker</code> die Eigentümerschaft am
empfangenden Ende teilen können.</p>
<p>Mit diesen Änderungen kompiliert der Code! Wir haben es geschafft!</p>
<h4><a class="header" href="#implementieren-der-methode-execute" id="implementieren-der-methode-execute">Implementieren der Methode <code>execute</code></a></h4>
<p>Lass uns endlich die Methode <code>execute</code> auf <code>ThreadPool</code> implementieren. Wir
werden auch <code>Job</code> von einer Struktur in einen Typ-Alias für ein Merkmalsobjekt
(trait object) ändern, das den Typ des Funktionsabschlusses enthält, den
<code>execute</code> erhält. Wie im Abschnitt <a href="ch19-04-advanced-types.html#erstellen-von-typ-synonymen-mit-typ-alias">„Erstellen von Typ-Synonymen mit
Typ-Alias“</a> in Kapitel 19 besprochen, ermöglichen uns
Typ-Aliase, lange Typen kürzer zu machen. Siehe Codeblock 20-19.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --abschneiden--
<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --abschneiden--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-19: Erstellen eines Alias vom Typ <code>Job</code> für
eine <code>Box</code>, die jeden Funktionsabschluss enthält, und danach Senden des
Auftrags in den Kanal</span></p>
<p>Nachdem wir eine neue <code>Job</code>-Instanz unter Verwendung des Funktionsabschlusses,
den wir in <code>execute</code> erhalten, erstellt haben, senden wir diesen Auftrag an das
sendende Ende des Kanals. Wir rufen <code>unwrap</code> auf <code>send</code> auf für den Fall, dass
das Senden fehlschlägt. Das kann zum Beispiel passieren, wenn wir alle unsere
Stränge von der Ausführung abhalten, was bedeutet, dass das empfangende Ende
keine neuen Nachrichten mehr empfängt. Im Moment können wir die Ausführung
unserer Stränge nicht stoppen: Unsere Stränge werden so lange ausgeführt, wie
der Vorrat existiert. Der Grund, warum wir <code>unwrap</code> verwenden, ist, dass wir
wissen, dass der Fehlerfall nicht passieren wird, aber der Compiler das nicht
weiß.</p>
<p>Aber wir sind noch nicht ganz fertig! Im <code>Worker</code> wird unser Funktionsabschluss
an <code>thread::spawn</code> weitergereicht, der immer noch nur auf das empfangende Ende
des Kanals <em>referenziert</em>. Stattdessen müssen wir den Funktionsabschluss für
immer in einer Schleife laufen lassen, indem wir das empfangende Ende des
Kanals um einen Auftrag bitten und den Auftrag ausführen, wenn er einen
bekommt. Lass uns die in Codeblock 20-20 gezeigte Änderung in <code>Worker::new</code>
vornehmen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);

            job();
        });

        Worker { id, thread }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-20: Empfangen und Ausführen der Aufträge im
Strang des <code>Worker</code></span></p>
<p>Hier rufen wir zuerst <code>lock</code> auf <code>receiver</code> auf, um den Mutex zu erwerben, und
dann rufen wir <code>unwrap</code> auf, um das Programm bei eventuellen Fehlern abstürzen
zu lassen. Das Akquirieren einer Sperre kann fehlschlagen, wenn sich der Mutex
in einem <em>vergifteten</em> Zustand befindet, was passieren kann, wenn ein anderer
Strang abstürzt, während er die Sperre hält, anstatt sie freizugeben. In dieser
Situation ist der Aufruf von <code>unwrap</code>, damit dieser Strang abstürzt, die
richtige Maßnahme. Fühle dich frei, dieses <code>unwrap</code> in ein <code>expect</code> mit einer
Fehlermeldung zu ändern, die für dich von Bedeutung ist.</p>
<p>Wenn wir die Sperre auf dem Mutex erhalten, rufen wir <code>recv</code> auf, um einen
<code>Job</code> vom Kanal zu empfangen. Ein abschließendes <code>unwrap</code> geht auch hier an
eventuellen Fehlern vorbei, die auftreten könnten, wenn sich der Strang, der
die sendende Seite des Kanals hält, beendet hat, ähnlich wie die <code>send</code>-Methode
<code>Err</code> zurückgibt, wenn die empfangende Seite abschaltet.</p>
<p>Der Aufruf von <code>recv</code> blockiert, wenn also noch kein Auftrag vorhanden ist,
wartet der aktuelle Strang, bis ein Auftrag verfügbar wird. Der <code>Mutex&lt;T&gt;</code>
stellt sicher, dass immer nur ein <code>Worker</code>-Strang zur gleichen Zeit versucht,
einen Auftrag anzufordern.</p>
<p>Mit der Umsetzung dieses Tricks ist unser Strang-Vorrat in einem
funktionierenden Zustand! Führe <code>cargo run</code> aus und stelle einige Anfragen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
Worker 1 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 2 hat einen Auftrag erhalten; führe ihn aus.
</code></pre>
<p>Erfolg! Wir haben jetzt einen Strang-Vorrat, der Verbindungen asynchron
ausführt. Es werden nie mehr als vier Stränge erzeugt, sodass unser System
nicht überlastet wird, wenn der Server viele Anfragen erhält. Wenn wir eine
Anfrage an <em>/sleep</em> stellen, ist der Server immer noch in der Lage, andere
Anfragen zu bedienen, indem er sie von einem anderen Strang ausführen lässt.</p>
<blockquote>
<p>Hinweis: Wenn du <em>/sleep</em> in mehreren Browser-Fenstern gleichzeitig öffnest,
werden diese möglicherweise in 5-Sekunden-Intervallen nacheinander geladen.
Einige Web-Browser führen aus Gründen der Zwischenspeicherung mehrere
Instanzen der gleichen Anfrage nacheinander aus. Diese Beschränkung wird
nicht durch unseren Webserver verursacht.</p>
</blockquote>
<p>Nachdem du die <code>while let</code>-Schleife in Kapitel 18 kennengelernt hast, fragst du
dich vielleicht, warum wir den Code für den <code>Worker</code>-Strang nicht geschrieben
haben, wie in Codeblock 20-21 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --abschneiden--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);

                job();
            }
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Codeblock 20-21: Eine alternative Implementierung von
<code>Worker::new</code> unter Verwendung von <code>while let</code></span></p>
<p>Dieser Code wird kompiliert und ausgeführt, führt aber nicht zum gewünschten
Strang-Verhalten: Eine langsame Anfrage führt immer noch dazu, dass andere
Anfragen auf ihre Bearbeitung warten. Der Grund dafür ist etwas subtil: Die
Struktur <code>Mutex</code> hat keine öffentliche Methode <code>unlock</code>, weil die
Eigentümerschaft der Sperre auf der Lebensdauer von <code>MutexGuard&lt;T&gt;</code> innerhalb
von <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> basiert, die die Methode <code>lock</code> zurückgibt. Zur
Kompilierzeit kann der Ausleihenprüfer (borrow checker) dann die Regel
durchsetzen, dass auf eine von einem <code>Mutex</code> bewachte Ressource nicht
zugegriffen werden kann, wenn wir die Sperre nicht halten. Diese
Implementierung kann aber auch dazu führen, dass die Sperre länger als
beabsichtigt gehalten wird, wenn wir nicht sorgfältig über die Lebensdauer von
<code>MutexGuard&lt;T&gt;</code> nachdenken. Da die Werte im <code>while let</code>-Ausdruck für die Dauer
der Sperre im Gültigkeitsbereich bleiben, bleibt die Sperre für die Dauer des
Aufrufs von <code>job()</code> bestehen, was bedeutet, dass andere <code>Worker</code> keine Aufträge
erhalten können.</p>
<p>Wenn du stattdessen <code>loop</code> verwendest und die Sperre erwirbst, ohne sie einer
Variablen zuzuweisen, wird der temporäre <code>MutexGuard</code>, der von der Methode
<code>lock</code> zurückgegeben wird, verworfen, sobald die Anweisung <code>let job</code> endet.
Dies stellt sicher, dass die Sperre während des Aufrufs von <code>recv</code> gehalten
wird, aber sie wird vor dem Aufruf von <code>job()</code> freigegeben, sodass mehrere
Anfragen gleichzeitig bedient werden können.</p>
<h2><a class="header" href="#kontrolliertes-beenden-und-aufräumen" id="kontrolliertes-beenden-und-aufräumen">Kontrolliertes Beenden und Aufräumen</a></h2>
<p>Der Code in Codeblock 20-20 antwortet auf Anfragen asynchron durch die
Verwendung eines Strang-Vorrats (thread pool), wie von uns beabsichtigt. Wir
erhalten einige Warnungen über die Felder <code>workers</code>, <code>id</code> und <code>thread</code>, die wir
nicht direkt benutzen, was uns daran erinnert, dass wir nichts aufräumen. Wenn
wir die weniger elegante Methode <span class="keystroke">Strg+c</span>
verwenden, um den Hauptstrang (main thread) anzuhalten, werden auch alle
anderen Stränge sofort gestoppt, selbst wenn sie gerade dabei sind, eine
Anfrage zu bedienen.</p>
<p>Jetzt werden wir das Merkmal (trait) <code>Drop</code> implementieren, um <code>join</code> für jeden
der Stränge im Vorrat aufzurufen, damit sie die Anfragen, an denen sie
arbeiten, vor dem Schließen beenden können. Dann werden wir einen Weg
implementieren, um den Strängen mitzuteilen, dass sie keine neuen Anfragen mehr
annehmen und herunterfahren sollen. Um diesen Code in Aktion zu sehen, werden
wir unseren Server so modifizieren, dass er nur zwei Anfragen annimmt, bevor er
seinen Strang-Vorrat kontrolliert herunterfährt.</p>
<h3><a class="header" href="#implementieren-des-merkmals-drop-auf-threadpool" id="implementieren-des-merkmals-drop-auf-threadpool">Implementieren des Merkmals <code>Drop</code> auf <code>ThreadPool</code></a></h3>
<p>Lass uns damit beginnen, <code>Drop</code> auf unseren Strang-Vorrat zu implementieren.
Wenn der Vorrat aufgeräumt wird, sollten wir auf das Ende unsere Stränge
warten, um sicherzustellen, dass sie ihre Arbeit beenden. Codeblock 20-22 zeigt
einen ersten Versuch einer <code>Drop</code>-Implementierung; dieser Code wird noch nicht
ganz funktionieren.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-22: Warten auf das Ende der einzelnen
Stränge, wenn der Strang-Vorrat den Gültigkeitsbereich verlässt</span></p>
<p>Zuerst iterieren wir über alle <code>workers</code> im Strang-Vorrat. Wir verwenden dafür
<code>&amp;mut</code>, weil <code>self</code> eine veränderliche Referenz ist und wir auch in der Lage
sein müssen, <code>worker</code> zu verändern. Für jeden <code>worker</code> geben wir eine Nachricht
aus, die besagt, dass dieser bestimmte <code>worker</code> heruntergefahren wird, und dann
rufen wir auf dem Strang <code>join</code> auf. Wenn der Aufruf von <code>join</code> fehlschlägt,
benutzen wir <code>unwrap</code>, um das Programm abstürzen zu lassen.</p>
<p>Hier ist der Fehler, den wir erhalten, wenn wir diesen Code kompilieren:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `std::thread::JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler sagt uns, dass wir <code>join</code> nicht aufrufen können, weil wir nur eine
veränderliche Ausleihe von jedem <code>worker</code> haben und <code>join</code> die Eigentümerschaft
für sein Argument übernimmt. Um dieses Problem zu lösen, müssen wir den Strang
<code>thread</code> aus der <code>Worker</code>-Instanz herausnehmen, damit <code>join</code> den Strang
konsumieren kann. Wir haben dies in Codeblock 17-15 getan: Wenn <code>Worker</code>
stattdessen ein <code>Option&lt;Thread::JoinHandle&lt;()&gt;&gt;</code> hält, können wir die Methode
<code>take</code> auf <code>Option</code> aufrufen, um den Wert aus der Variante <code>Some</code>
herauszuverschieben und eine Variante <code>None</code> an ihrer Stelle zu belassen. Mit
anderen Worten, ein <code>Worker</code>, der läuft, wird eine Variante <code>Some</code> in <code>thread</code>
haben, und wenn wir einen <code>Worker</code> aufräumen wollen, ersetzen wir <code>Some</code> durch
<code>None</code>, sodass der <code>Worker</code> keinen Strang zum Laufen hat.</p>
<p>Wir wissen also, dass wir die Definition von <code>Worker</code> so aktualisieren wollen:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Nun wollen wir uns auf den Compiler stützen, um die anderen Stellen zu finden,
die geändert werden müssen. Wenn wir diesen Code überprüfen, erhalten wir zwei
Fehler:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(thread)`
   |
   = note: expected enum `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
            found struct `std::thread::JoinHandle&lt;_&gt;`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Lass uns den zweiten Fehler beheben, der auf den Code am Ende von <code>Worker::new</code>
verweist; wir müssen den Wert <code>thread</code> in <code>Some</code> einpacken, wenn wir einen
neuen <code>Worker</code> erstellen. Nimm die folgenden Änderungen vor, um diesen Fehler
zu beheben:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --abschneiden--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Der erste Fehler liegt in unserer <code>Drop</code>-Implementierung. Wir haben bereits
erwähnt, dass wir beabsichtigten, <code>take</code> auf dem <code>Option</code>-Wert aufzurufen, um
<code>thread</code> aus <code>worker</code> heraus zu verschieben. Die folgenden Änderungen werden
dies tun:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wie in Kapitel 17 besprochen, nimmt die Methode <code>take</code> auf <code>Option</code> die
Variante <code>Some</code> heraus und lässt an ihrer Stelle <code>None</code> stehen. Wir benutzen
<code>if let</code>, um die <code>Some</code> zu destrukturieren und den Strang zu erhalten; dann
rufen wir <code>join</code> auf dem Strang auf. Wenn der Strang eines <code>Worker</code> bereits
<code>None</code> ist, wissen wir, dass der Strang bereits aufgeräumt wurde, also passiert
in diesem Fall nichts.</p>
<h3><a class="header" href="#den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen" id="den-strängen-signalisieren-nicht-mehr-nach-aufträgen-zu-lauschen">Den Strängen signalisieren, nicht mehr nach Aufträgen zu lauschen</a></h3>
<p>Mit all den Änderungen, die wir vorgenommen haben, lässt sich unser Code ohne
jede Warnung kompilieren. Aber die schlechte Nachricht ist, dass dieser Code
noch nicht so funktioniert, wie wir es uns wünschen. Der Schlüssel ist die
Logik in den Funktionsabschlüssen, die von den Strängen der <code>Worker</code>-Instanzen
ausgeführt werden: Im Moment rufen wir <code>join</code> auf, aber das wird die Stränge
nicht herunterfahren, weil sie sich in einer Endlosschleife auf der Suche nach
Aufträgen befinden. Wenn wir versuchen, unseren <code>ThreadPool</code> mit unserer
aktuellen Implementierung von <code>Drop</code> aufräumen zu lassen, wird der Hauptstrang
für immer blockieren und auf das Beenden des ersten Strangs warten.</p>
<p>Um dieses Problem zu beheben, werden wir die Stränge so modifizieren, dass sie
entweder auf einen <code>Job</code> warten, der ausgeführt werden soll, oder auf ein
Signal, dass sie aufhören sollen zu lauschen und die Endlosschleife verlassen.
Anstelle von <code>Job</code>-Instanzen sendet unser Kanal eine dieser beiden
Aufzählungsvarianten.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Diese Aufzählung <code>Message</code> wird entweder eine <code>NewJob</code>-Variante sein, die den
<code>Job</code> enthält, den der Strang ausführen soll, oder es wird eine
<code>Terminate</code>-Variante sein, die den Strang veranlasst, seine Schleife zu
verlassen und anzuhalten.</p>
<p>Wir müssen den Kanal so einstellen, dass er Werte vom Typ <code>Message</code> und nicht
vom Typ <code>Job</code> verwendet, wie in Codeblock 20-23 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --abschneiden--

<span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NewJob(Job),
</span><span class="boring">    Terminate,
</span><span class="boring">}
</span><span class="boring">
</span>impl ThreadPool {
    // --abschneiden--

<span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --abschneiden--

<span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Worker {} herunterfahren&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) =&gt; {
                    println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);

                    job();
                }
                Message::Terminate =&gt; {
                    println!(&quot;Worker {} wurde aufgefordert sich zu beenden.&quot;, id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-23: Senden und Empfangen von
<code>Message</code>-Werten und Verlassen der Schleife, wenn ein <code>Worker</code> den Auftrag
<code>Message::Terminate</code> empfängt</span></p>
<p>Um die Aufzählung <code>Message</code> aufzunehmen, müssen wir an zwei Stellen <code>Job</code> in
<code>Message</code> ändern: Die Definition von <code>ThreadPool</code> und die Signatur von
<code>Worker::new</code>. Die Methode <code>execute</code> von <code>ThreadPool</code> muss Aufträge senden, die
in der Variante <code>Message::NewJob</code> verpackt sind. Dann wird in <code>Worker::new</code>,
wenn eine <code>Message</code> vom Kanal empfangen wird, der Auftrag verarbeitet, wenn die
Variante <code>NewJob</code> empfangen wird, und der Strang wird die Schleife verlassen,
wenn die Variante <code>Terminate</code> empfangen wird.</p>
<p>Mit diesen Änderungen wird der Code auf die gleiche Weise kompiliert und weiter
funktionieren wie nach Codeblock 20-20. Aber wir werden eine Warnung erhalten,
weil wir keine Nachricht der Variante <code>Terminate</code> erstellen. Lass uns diese
Warnung beheben, indem wir unsere <code>Drop</code>-Implementierung so ändern, dass sie
wie Codeblock 20-24 aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NewJob(Job),
</span><span class="boring">    Terminate,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Erzeuge einen neuen ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// Die Größe ist die Anzahl der Stränge im Vorrat.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(Message::NewJob(job)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sende eine Beendigungsnachricht an alle worker.&quot;);

        for _ in &amp;self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Fahre alle Worker herunter.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let message = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            match message {
</span><span class="boring">                Message::NewJob(job) =&gt; {
</span><span class="boring">                    println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    job();
</span><span class="boring">                }
</span><span class="boring">                Message::Terminate =&gt; {
</span><span class="boring">                    println!(&quot;Worker {} wurde aufgefordert sich zu beenden.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 20-24: Senden von <code>Message::Terminate</code> an die
<code>Worker</code> vor dem Aufrufen von <code>join</code> auf jedem Strang</span></p>
<p>Wir iterieren jetzt zweimal über die <code>Worker</code>: Einmal, um jedem <code>Worker</code> eine
<code>Terminate</code>-Nachricht zu senden, und einmal, um auf dem Strang <code>join</code>
aufzurufen. Wenn wir versuchen würden, eine Nachricht zu senden und sofort in
der gleichen Schleife <code>join</code> aufzurufen, könnten wir nicht garantieren, dass
der <code>Worker</code> in der aktuellen Iteration derjenige ist, der die Nachricht vom
Kanal erhält.</p>
<p>Um besser zu verstehen, warum wir zwei getrennte Schleifen brauchen, stell dir
ein Szenario mit zwei <code>Worker</code> vor. Wenn wir eine einzige Schleife verwenden
würden, um über jeden <code>Worker</code> zu iterieren, würde bei der ersten Iteration
eine Beendigungsnachricht durch den Kanal gesendet und auf dem Strang des
ersten <code>Worker</code> <code>join</code> aufgerufen. Wenn der erste <code>Worker</code> zu diesem Zeitpunkt
mit der Bearbeitung einer Anfrage beschäftigt war, holte sich der zweite
<code>Worker</code> die Beendigungsnachricht aus dem Kanal und schaltete ab. Wir würden
darauf warten müssen, dass der erste <code>Worker</code> herunterfährt, aber das würde er
nie tun, weil der zweite Strang die Beendigungsnachricht abgeholt hat.
Deadlock!</p>
<p>Um dieses Szenario zu verhindern, senden wir zunächst in einer Schleife alle
unsere <code>Terminate</code>-Nachrichten in den Kanal; dann warten wir auf das Ende aller
Stränge in einer weiteren Schleife. Jeder <code>Worker</code> hört auf, Anfragen auf dem
Kanal zu empfangen, sobald er eine Beendigungsnachricht erhält. Wir können also
sicher sein, dass, wenn wir die gleiche Anzahl von Beendigungsnachrichten
senden, wie es <code>Worker</code> gibt, jeder <code>Worker</code> eine Beendigungsnachricht erhält,
bevor für seinen Strang <code>join</code> aufgerufen wird.</p>
<p>Um diesen Code in Aktion zu sehen, modifizieren wir <code>main</code> so, dass nur zwei
Anfragen akzeptiert werden, bevor der Server kontrolliert heruntergefahren
wird, wie in Codeblock 20-25 gezeigt.</p>
<p><span class="filename">Dateiname: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Fahre herunter.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 20-25: Herunterfahren des Servers, nachdem er
zwei Anfragen bearbeitet hat, durch Verlassen der Schleife</span></p>
<p>Du würdest nicht wollen, dass ein Webserver aus der realen Welt
heruntergefahren wird, nachdem er nur zwei Anfragen bearbeitet hat. Dieser Code
zeigt nur, dass das kontrollierte Herunterfahren und Aufräumen funktioniert.</p>
<p>Die Methode <code>take</code> ist im Merkmal <code>Iterator</code> definiert und beschränkt die
Iteration auf die ersten beiden Elemente. Der <code>ThreadPool</code> wird am Ende von
<code>main</code> den Gültigkeitsbereich verlassen und die <code>drop</code>-Implementierung
ausgeführt werden.</p>
<p>Starte den Server mit <code>cargo run</code> und stelle drei Anfragen. Die dritte Anfrage
sollte fehlerhaft sein und in deinem Terminal solltest du eine ähnliche Ausgabe
wie diese sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
Worker 0 hat einen Auftrag erhalten; führe ihn aus.
Worker 3 hat einen Auftrag erhalten; führe ihn aus.
Fahre herunter.
Sende eine Beendigungsnachricht an alle worker.
Fahre alle Worker herunter.
Worker 0 herunterfahren
Worker 1 wurde aufgefordert sich zu beenden.
Worker 2 wurde aufgefordert sich zu beenden.
Worker 0 wurde aufgefordert sich zu beenden.
Worker 3 wurde aufgefordert sich zu beenden.
Worker 1 herunterfahren
Worker 2 herunterfahren
Worker 3 herunterfahren
</code></pre>
<p>Möglicherweise siehst du eine andere Reihenfolge der <code>Worker</code> und der
ausgegebenen Nachrichten. Wir können anhand der Nachrichten sehen, wie dieser
Code funktioniert: <code>Worker</code> 0 und 3 erhielten die ersten beiden Anfragen und
bei der dritten Anfrage hörte der Server auf, Verbindungen anzunehmen. Wenn der
<code>ThreadPool</code> am Ende von <code>main</code> den Gültigkeitsbereich verlässt, tritt seine
<code>Drop</code>-Implementierung in Kraft, und der Vorrat weist alle <code>Worker</code> an, sich zu
beenden. Die <code>Worker</code> geben jeweils eine Nachricht aus, wenn sie die
Beendigungsnachricht erhalten, und dann ruft der Strang-Vorrat <code>join</code> auf, um
auf das Ende jedes Strangs zu warten.</p>
<p>Beachte einen interessanten Aspekt diesem speziellen Programmlauf: Der
<code>ThreadPool</code> schickte die Beendigungsnachricht durch den Kanal und bevor
irgendein <code>Worker</code> die Nachrichten erhielt, versuchten wir, auf <code>Worker</code> 0 zu
warten. <code>Worker</code> 0 hatte die Beendigungsnachricht noch nicht erhalten, also
war der Hauptstrang durch das Warten auf das Ende von <code>Worker</code> 0 blockiert. In
der Zwischenzeit erhielt jeder der <code>Worker</code> die Beendigungsnachricht. Wenn
<code>Worker</code> 0 beendet war, wartete der Hauptstrang auf das Beenden der restlichen
<code>Worker</code>. Zu diesem Zeitpunkt hatten sie alle die Beendigungsnachricht erhalten
und konnten sich beenden.</p>
<p>Herzlichen Glückwunsch! Wir haben jetzt unser Projekt abgeschlossen; wir haben
einen einfachen Webserver, der einen Strang-Vorrat verwendet, um asynchron zu
antworten. Wir sind in der Lage, den Server kontrolliert herunterzufahren,
wodurch alle Stränge im Vorrat aufgeräumt werden.</p>
<p>Hier ist der vollständige Code als Referenz:</p>
<p><span class="filename">Dateiname: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Fahre herunter.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    /// Erzeuge einen neuen ThreadPool.
    ///
    /// Die Größe ist die Anzahl der Stränge im Vorrat.
    ///
    /// # Panics
    ///
    /// Die Funktion `new` stürzt ab, wenn die Größe Null ist.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sende eine Beendigungsnachricht an alle worker.&quot;);

        for _ in &amp;self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Fahre alle Worker herunter.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Worker {} herunterfahren&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) =&gt; {
                    println!(&quot;Worker {} hat einen Auftrag erhalten; führe ihn aus.&quot;, id);

                    job();
                }
                Message::Terminate =&gt; {
                    println!(&quot;Worker {} wurde aufgefordert sich zu beenden.&quot;, id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wir könnten hier mehr tun! Wenn du dieses Projekt weiter verbessern willst,
findest du hier einige Ideen:</p>
<ul>
<li>Füge weitere Dokumentation zu <code>ThreadPool</code> und seinen öffentlichen Methoden
hinzu.</li>
<li>Füge Tests der Funktionalität der Bibliothek hinzu.</li>
<li>Ändere Aufrufe von <code>unwrap</code> in eine robustere Fehlerbehandlung.</li>
<li>Verwende <code>ThreadPool</code>, um eine andere Aufgabe als das Beantworten von
Web-Anfragen durchzuführen.</li>
<li>Suche eine Strang-Vorrats-Kiste auf <a href="https://crates.io/">crates.io</a> und
implementiere damit einen ähnlichen Webserver unter Verwendung der Kiste.
Vergleiche dann dessen API und Robustheit mit dem von uns implementierten
Strang-Vorrat.</li>
</ul>
<h2><a class="header" href="#zusammenfassung-19" id="zusammenfassung-19">Zusammenfassung</a></h2>
<p>Gut gemacht! Du hast es bis ans Ende des Buchs geschafft! Wir möchten dir
danken, dass du uns auf dieser Tour durch Rust begleitet hast. Du bist nun
bereit, deine eigenen Rust-Projekte umzusetzen und bei den Projekten anderer zu
helfen. Denke daran, dass es eine gastfreundliche Gemeinschaft von anderen
Rust-Entwicklern gibt, die dir bei allen Herausforderungen, denen du auf deiner
Rust-Reise begegnest, gerne helfen würden.</p>
<h1><a class="header" href="#anhang" id="anhang">Anhang</a></h1>
<p>Die folgenden Abschnitte enthalten Referenzmaterial, das dir auf deiner
Rust-Reise nützlich sein könnten.</p>
<h2><a class="header" href="#anhang-a-schlüsselwörter" id="anhang-a-schlüsselwörter">Anhang A: Schlüsselwörter</a></h2>
<p>Die folgende Liste enthält Schlüsselwörter, die für die gegenwärtige oder
zukünftige Verwendung durch die Sprache Rust reserviert sind. Als solche können
sie nicht als Bezeichner verwendet werden (außer als Roh-Bezeichner, die wir im
Abschnitt <a href="appendix-01-keywords.html#roh-bezeichner">„Roh-Bezeichner“</a> besprechen werden),
einschließlich Namen von Funktionen, Variablen, Parametern, Strukturfeldern
(struct fields), Modulen, Kisten (crates), Konstanten, Makros, statischen
Werten, Attributen, Typen, Merkmalen (traits) und Lebensdauern (lifetimes).</p>
<h3><a class="header" href="#derzeit-verwendete-schlüsselwörter" id="derzeit-verwendete-schlüsselwörter">Derzeit verwendete Schlüsselwörter</a></h3>
<p>Die folgenden Schlüsselwörter haben derzeit die beschriebene Funktionalität.</p>
<ul>
<li><code>as</code> – primitive Typen umwandeln; ein spezifisches Merkmal mit einem
Element eindeutig machen; Elemente in <code>use</code>- und <code>extern crate</code>-Anweisungen
umbenennen </li>
<li><code>async</code> – ein <code>Future</code> zurückgeben, anstatt den aktuellen Strang
(thread) zu blockieren</li>
<li><code>await</code> – Ausführung anhalten, bis das Ergebnis eines <code>Future</code> vorliegt</li>
<li><code>break</code> – Schleife sofort verlassen</li>
<li><code>const</code> – konstante Elemente oder konstante Roh-Referenzen definieren</li>
<li><code>continue</code> – weiter zur nächsten Schleifeniteration</li>
<li><code>crate</code> – externe Kiste (crate) oder Makrovariable, die die Kiste
repräsentiert, in der das Makro definiert ist, verlinken</li>
<li><code>dyn</code> – dynamischer Aufruf (dispatch) eines Merkmalsobjekts (trait
object)</li>
<li><code>else</code> – Ersatzkontrollflusszweig bei <code>if</code> und <code>if let</code></li>
<li><code>enum</code> – eine Aufzählung (enumeration) definieren</li>
<li><code>extern</code> – externe Kiste (crate), Funktion oder Variable verlinken</li>
<li><code>false</code> – Boolesches Literal für „falsch“</li>
<li><code>fn</code> – Funktion oder Funktionsreferenztyp definieren</li>
<li><code>for</code> – wiederhole über Elemente einer Iteration; ein Merkmal (trait)
implementieren; eine höherrangige Lebensdauer angeben</li>
<li><code>if</code> – Verzweigen abhängig vom Ergebnis eines Bedingungsausdrucks</li>
<li><code>impl</code> – Implementieren einer inhärenten oder Merkmalsfunktionalität
(trait functionality)</li>
<li><code>in</code> – Teil der <code>for</code>-Schleifensyntax</li>
<li><code>let</code> – eine Variable binden</li>
<li><code>loop</code> – wiederhole bedingungslos</li>
<li><code>match</code> – einen Wert mit Muster abgleichen</li>
<li><code>mod</code> – ein Modul definieren</li>
<li><code>move</code> – Funktionsabschluss (closure) übernimmt Eigentümerschaft
(ownership) all seiner Parameter</li>
<li><code>mut</code> – Referenzen, Roh-Referenzen und Variablenbindungen als
veränderlich kennzeichnen</li>
<li><code>pub</code> – Strukturfelder (struct fields), <code>impl</code>-Blöcke und Module als
öffentlich sichtbar kennzeichnen </li>
<li><code>ref</code> – als Referenz binden</li>
<li><code>return</code> – aus Funktion zurückkehren</li>
<li><code>Self</code> – Typ-Alias für den zu definierenden oder implementierenden Typ</li>
<li><code>self</code> – Methoden-Instanzobjekt; aktuelles Modul</li>
<li><code>static</code> – globale Variable oder Lebensdauer während der gesamten
Programmausführung</li>
<li><code>struct</code> – eine Struktur definieren</li>
<li><code>super</code> – Elternmodul des aktuellen Moduls</li>
<li><code>trait</code> – ein Merkmal (trait) definieren</li>
<li><code>true</code> – Boolesches Literal für „wahr“</li>
<li><code>type</code> – einen Typ-Alias oder assoziierten Typ definieren</li>
<li><code>union</code> – eine <a href="https://doc.rust-lang.org/reference/items/unions.html">Vereinigung (union)</a> definieren; ist nur ein
Schlüsselwort innerhalb einer Vereinigungdeklaration</li>
<li><code>unsafe</code> – Code, Funktionen, Merkmale (traits) und Implementierungen
als unsicher kennzeichnen</li>
<li><code>use</code> – Symbole in den Gültigkeitsbereich bringen</li>
<li><code>where</code> – Klauseln zur Typabgrenzung angeben</li>
<li><code>while</code> – wiederhole abhängig vom Ergebnis eines Bedingungsausdrucks</li>
</ul>
<h3><a class="header" href="#schlüsselwörter-reserviert-für-zukünftige-verwendung" id="schlüsselwörter-reserviert-für-zukünftige-verwendung">Schlüsselwörter reserviert für zukünftige Verwendung</a></h3>
<p>Die folgenden Schlüsselwörter haben keine Funktionalität, sondern sind von Rust
für eine mögliche zukünftige Verwendung reserviert.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#roh-bezeichner" id="roh-bezeichner">Roh-Bezeichner</a></h3>
<p><em>Roh-Bezeichner</em> (raw identifiers) sind eine Syntax, die es dir ermöglicht,
Schlüsselwörter dort zu verwenden, wo sie normalerweise nicht erlaubt wären. Du
verwendest einen Roh-Bezeichner, indem du einem Schlüsselwort das Präfix <code>r#</code>
voranstellst.</p>
<p>Zum Beispiel ist <code>match</code> ein Schlüsselwort. Versuche, folgende Funktion zu
kompilieren, die <code>match</code> als Namen benutzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}
</span></code></pre></pre>
<p>Dann erhältst du diesen Fehler:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Der Fehler zeigt, dass du das Schlüsselwort <code>match</code> nicht als
Funktionsbezeichner verwenden kannst. Um <code>match</code> als Funktionsnamen zu
verwenden, musst du die Syntax für Roh-Bezeichner wie folgt verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Dieser Code lässt sich fehlerfrei kompilieren. Beachte das <code>r#</code>-Präfix im
Funktionsnamen in seiner Definition sowie an der Stelle, an der die Funktion in
<code>main</code> aufgerufen wird.</p>
<p>Roh-Bezeichner erlauben es dir, jedes beliebige Wort als Bezeichner zu
verwenden, auch wenn dieses Wort ein reserviertes Schlüsselwort ist. Darüber
hinaus ermöglicht dir der Roh-Bezeichner das Verwenden von Bibliotheken, die in
einer anderen Rust-Ausgabe, als deine Kiste verwendet, geschrieben wurden. Zum
Beispiel ist <code>try</code> in Ausgabe 2015 kein Schlüsselwort, aber in Ausgabe 2018
schon. Wenn du auf eine Bibliothek angewiesen bist, die mit Ausgabe 2015
geschrieben wurde und eine Funktion <code>try</code> hat, musst du die
Roh-Bezeichner-Syntax verwenden, in diesem Fall <code>r#try</code>, um diese Funktion von
deinem Code der Ausgabe 2018 aus aufzurufen. Siehe <a href="appendix-05-editions.html">Anhang E</a> für
weitere Informationen zu Ausgaben.</p>
<h2><a class="header" href="#anhang-b-operatoren-und-symbole" id="anhang-b-operatoren-und-symbole">Anhang B: Operatoren und Symbole</a></h2>
<p>Dieser Anhang enthält ein Glossar der Rust-Syntax, einschließlich Operatoren
und anderer Symbole, die allein oder im Zusammenhang mit Pfaden, generischen
Datentypen (generics), Merkmalsabgrenzungen (trait bounds), Makros, Attributen,
Kommentaren, Tupeln und Klammern auftreten.</p>
<h3><a class="header" href="#operatoren" id="operatoren">Operatoren</a></h3>
<p>Tabelle B-1 enthält die Operatoren in Rust, ein Beispiel, wie der Operator im
Kontext erscheinen würde, eine kurze Erklärung und ob dieser Operator überladen
werden kann. Wenn ein Operator überladen werden kann, wird das relevante
Merkmal (trait) aufgeführt, mit dem dieser Operator überladen werden kann.</p>
<p><span class="caption">Tabelle B-1: Operatoren</span></p>
<table><thead><tr><th align="left">Operator</th><th align="left">Beispiel</th><th align="left">Erklärung</th><th align="left">Überladbar?</th></tr></thead><tbody>
<tr><td align="left"><code>!</code></td><td align="left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td align="left">Makro-Expansion</td><td align="left"></td></tr>
<tr><td align="left"><code>!</code></td><td align="left"><code>!expr</code></td><td align="left">Bitweises oder logisches Komplement</td><td align="left"><code>Not</code></td></tr>
<tr><td align="left"><code>!=</code></td><td align="left"><code>var != expr</code></td><td align="left">Vergleich auf Ungleichheit</td><td align="left"><code>PartialEq</code></td></tr>
<tr><td align="left"><code>%</code></td><td align="left"><code>expr % expr</code></td><td align="left">Arithmetischer Restbetrag</td><td align="left"><code>Rem</code></td></tr>
<tr><td align="left"><code>%=</code></td><td align="left"><code>var %= expr</code></td><td align="left">Arithmetischer Restbetrag und Zuweisung</td><td align="left"><code>RemAssign</code></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>&amp;expr</code>,<br> <code>&amp;mut expr</code></td><td align="left">Ausleihe</td><td align="left"></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>&amp;type</code>,<br> <code>&amp;mut type</code>,<br> <code>&amp;'a type</code>,<br> <code>&amp;'a mut type</code></td><td align="left">Ausleih-Referenz-Typ</td><td align="left"></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>expr &amp; expr</code></td><td align="left">Bitweises UND</td><td align="left"><code>BitAnd</code></td></tr>
<tr><td align="left"><code>&amp;=</code></td><td align="left"><code>var &amp;= expr</code></td><td align="left">Bitweises UND und Zuweisung</td><td align="left"><code>BitAndAssign</code></td></tr>
<tr><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>expr &amp;&amp; expr</code></td><td align="left">Logisches UND mit Kurzschlussauswertung</td><td align="left"></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>expr * expr</code></td><td align="left">Arithmetische Multiplikation</td><td align="left"><code>Mul</code></td></tr>
<tr><td align="left"><code>*=</code></td><td align="left"><code>var *= expr</code></td><td align="left">Arithmetische Multiplikation und Zuweisung</td><td align="left"><code>MulAssign</code></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>*expr</code></td><td align="left">Dereferenzierung</td><td align="left"></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>*const type</code>,<br> <code>*mut type</code></td><td align="left">Roh-Referenz</td><td align="left"></td></tr>
<tr><td align="left"><code>+</code></td><td align="left"><code>trait + trait</code>,<br> <code>'a + trait</code></td><td align="left">Verbundtypabgrenzung</td><td align="left"></td></tr>
<tr><td align="left"><code>+</code></td><td align="left"><code>expr + expr</code></td><td align="left">Arithmetische Addition</td><td align="left"><code>Add</code></td></tr>
<tr><td align="left"><code>+=</code></td><td align="left"><code>var += expr</code></td><td align="left">Arithmetische Addition und Zuweisung</td><td align="left"><code>AddAssign</code></td></tr>
<tr><td align="left"><code>,</code></td><td align="left"><code>expr, expr</code></td><td align="left">Argument- und Elementseparator</td><td align="left"></td></tr>
<tr><td align="left"><code>-</code></td><td align="left"><code>- expr</code></td><td align="left">Arithmetische Negation</td><td align="left"><code>Neg</code></td></tr>
<tr><td align="left"><code>-</code></td><td align="left"><code>expr - expr</code></td><td align="left">Arithmetische Subtraktion</td><td align="left"><code>Sub</code></td></tr>
<tr><td align="left"><code>-=</code></td><td align="left"><code>var -= expr</code></td><td align="left">Arithmetische Subtraktion und Zuweisung</td><td align="left"><code>SubAssign</code></td></tr>
<tr><td align="left"><code>-&gt;</code></td><td align="left"><code>fn(...) -&gt; type</code>,<br> <code>|...| -&gt; type</code></td><td align="left">Funktion und Funktionsabschlussrückgabetyp</td><td align="left"></td></tr>
<tr><td align="left"><code>.</code></td><td align="left"><code>expr.ident</code></td><td align="left">Elementzugriff</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>..</code>,<br> <code>expr..</code>,<br> <code>..expr</code>,<br> <code>expr..expr</code></td><td align="left">Rechts-ausschließendes Bereichsliteral</td><td align="left"></td></tr>
<tr><td align="left"><code>..=</code></td><td align="left"><code>..=expr</code>,<br> <code>expr..=expr</code></td><td align="left">Rechts-einschließendes Bereichsliteral</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>..expr</code></td><td align="left">Aktualisierungssyntax für Strukturliterale</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>variant(x, ..)</code>,<br> <code>struct_type { x, .. }</code></td><td align="left">„Und der Rest“-Musterbindung</td><td align="left"></td></tr>
<tr><td align="left"><code>...</code></td><td align="left"><code>expr...expr</code></td><td align="left">In einem Muster: inklusives Bereichsmuster</td><td align="left"></td></tr>
<tr><td align="left"><code>/</code></td><td align="left"><code>expr / expr</code></td><td align="left">Arithmetische Division</td><td align="left"><code>Div</code></td></tr>
<tr><td align="left"><code>/=</code></td><td align="left"><code>var /= expr</code></td><td align="left">Arithmetische Division und Zuweisung</td><td align="left"><code>DivAssign</code></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>pat: type</code>,<br> <code>ident: type</code></td><td align="left">Typabgrenzung</td><td align="left"></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>ident: expr</code></td><td align="left">Struktur-Feld-Initialisierer</td><td align="left"></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>'a: loop {...}</code></td><td align="left">Schleifen-Label</td><td align="left"></td></tr>
<tr><td align="left"><code>;</code></td><td align="left"><code>expr;</code></td><td align="left">Anweisungs- und Element-Endezeichen</td><td align="left"></td></tr>
<tr><td align="left"><code>;</code></td><td align="left"><code>[...; len]</code></td><td align="left">Syntaxteil für Array fester Größe</td><td align="left"></td></tr>
<tr><td align="left"><code>&lt;&lt;</code></td><td align="left"><code>expr &lt;&lt; expr</code></td><td align="left">Bitweise Links-Schiebung</td><td align="left"><code>Shl</code></td></tr>
<tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><code>var &lt;&lt;= expr</code></td><td align="left">Bitweise Links-Schiebung und Zuweisung</td><td align="left"><code>ShlAssign</code></td></tr>
<tr><td align="left"><code>&lt;</code></td><td align="left"><code>expr &lt; expr</code></td><td align="left">Kleiner-als-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&lt;=</code></td><td align="left"><code>expr &lt;= expr</code></td><td align="left">Kleiner-gleich-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>=</code></td><td align="left"><code>var = expr</code>,<br> <code>ident = type</code></td><td align="left">Zuweisung/Äquivalenz</td><td align="left"></td></tr>
<tr><td align="left"><code>==</code></td><td align="left"><code>expr == expr</code></td><td align="left">Gleichheitsvergleich</td><td align="left"><code>PartialEq</code></td></tr>
<tr><td align="left"><code>=&gt;</code></td><td align="left"><code>pat =&gt; expr</code></td><td align="left">Teilsyntax im Abgleichs-Zweig (match arm)</td><td align="left"></td></tr>
<tr><td align="left"><code>&gt;</code></td><td align="left"><code>expr &gt; expr</code></td><td align="left">Größer-als-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&gt;=</code></td><td align="left"><code>expr &gt;= expr</code></td><td align="left">Größer-gleich-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&gt;&gt;</code></td><td align="left"><code>expr &gt;&gt; expr</code></td><td align="left">Bitweise Rechts-Schiebung</td><td align="left"><code>Shr</code></td></tr>
<tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><code>var &gt;&gt;= expr</code></td><td align="left">Bitweise Rechts-Schiebung und Zuweisung</td><td align="left"><code>ShrAssign</code></td></tr>
<tr><td align="left"><code>@</code></td><td align="left"><code>ident @ pat</code></td><td align="left">Muster-Bindung</td><td align="left"></td></tr>
<tr><td align="left"><code>^</code></td><td align="left"><code>expr ^ expr</code></td><td align="left">Bitweises exklusives ODER</td><td align="left"><code>BitXor</code></td></tr>
<tr><td align="left"><code>^=</code></td><td align="left"><code>var ^= expr</code></td><td align="left">Bitweises exklusives ODER und Zuweisung</td><td align="left"><code>BitXorAssign</code></td></tr>
<tr><td align="left"><code>|</code></td><td align="left"><code>pat | pat</code></td><td align="left">Muster-Alternativen</td><td align="left"></td></tr>
<tr><td align="left"><code>|</code></td><td align="left"><code>expr | expr</code></td><td align="left">Bitweises ODER</td><td align="left"><code>BitOr</code></td></tr>
<tr><td align="left"><code>|=</code></td><td align="left"><code>var |= expr</code></td><td align="left">Bitweises ODER und Zuweisung</td><td align="left"><code>BitOrAssign</code></td></tr>
<tr><td align="left"><code>||</code></td><td align="left"><code>expr || expr</code></td><td align="left">Logisches ODER mit Kurzschlussauswertung</td><td align="left"></td></tr>
<tr><td align="left"><code>?</code></td><td align="left"><code>expr?</code></td><td align="left">Fehler-Weitergabe</td><td align="left"></td></tr>
</tbody></table>
<h3><a class="header" href="#nicht-operator-symbole" id="nicht-operator-symbole">Nicht-Operator-Symbole</a></h3>
<p>Die folgende Liste enthält alle nicht-Buchstaben, die nicht als Operatoren
fungieren, d.h. sich nicht wie ein Funktions- oder Methodenaufruf verhalten.</p>
<p>Tabelle B-2 zeigt Symbole, die für sich allein stehen und an verschiedenen
Stellen gültig sind.</p>
<p><span class="caption">Tabelle B-2: Eigenständige Syntax</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>'ident</code></td><td align="left">Benannte Lebensdauer oder Schleifenbeschriftung</td></tr>
<tr><td align="left"><code>...u8</code>,<br> <code>...i32</code>,<br> <code>...f64</code>,<br> <code>...usize</code><br> usw.</td><td align="left">Numerisches Literal eines bestimmten Typs</td></tr>
<tr><td align="left"><code>&quot;...&quot;</code></td><td align="left">Zeichenketten-Literal</td></tr>
<tr><td align="left"><code>r&quot;...&quot;</code>,<br> <code>r#&quot;...&quot;#</code>,<br> <code>r##&quot;...&quot;##</code><br> usw.</td><td align="left">Roh-Zeichenketten-Literal, Escape-Zeichen werden nicht verarbeitet</td></tr>
<tr><td align="left"><code>b&quot;...&quot;</code></td><td align="left">Byte-Zeichenkettenliteral, konstruiert ein <code>[u8]</code> anstelle einer Zeichenkette</td></tr>
<tr><td align="left"><code>br&quot;...&quot;</code>,<br> <code>br#&quot;...&quot;#</code>,<br> <code>br##&quot;...&quot;##</code><br> usw.</td><td align="left">Roh-Byte-Zeichenkettenliteral, Kombination aus Roh- und Byte-Zeichenkettenliteral</td></tr>
<tr><td align="left"><code>'...'</code></td><td align="left">Zeichen-Literal</td></tr>
<tr><td align="left"><code>b'...'</code></td><td align="left">ASCII-Byte-Literal</td></tr>
<tr><td align="left"><code>|...| expr</code></td><td align="left">Funktionsabschluss (closure)</td></tr>
<tr><td align="left"><code>!</code></td><td align="left">Leerer Typ (bottom type) für nicht-endende Funktionen</td></tr>
<tr><td align="left"><code>_</code></td><td align="left">Musterbindung für „sonstige“; wird auch verwendet, um Ganzzahl-Literale lesbar zu machen</td></tr>
</tbody></table>
<p>Tabelle B-3 zeigt Symbole, die im Zusammenhang mit Pfaden für die
Modulhierarchie eines Elements vorkommen.</p>
<p><span class="caption">Tabelle B-3: Pfad-bezogene Syntax</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>ident::ident</code></td><td align="left">Namensraum-Pfad</td></tr>
<tr><td align="left"><code>::path</code></td><td align="left">Pfad relativ zur Kistenwurzel<br> (d.h. ein explizit absoluter Pfad)</td></tr>
<tr><td align="left"><code>self::path</code></td><td align="left">Pfad relativ zum aktuellen Modul<br> (d.h. ein explizit relativer Pfad)</td></tr>
<tr><td align="left"><code>super::path</code></td><td align="left">Pfad relativ zum Elternmodul</td></tr>
<tr><td align="left"><code>type::ident</code>,<br> <code>&lt;type as trait&gt;::ident</code></td><td align="left">Zugehörige Konstanten, Funktionen<br> und Typen</td></tr>
<tr><td align="left"><code>&lt;type&gt;::...</code></td><td align="left">Zugehöriges Element für einen Typ,<br> der nicht direkt benannt werden kann<br> (z.B. <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;:::...</code> usw.)</td></tr>
<tr><td align="left"><code>trait::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Merkmals eindeutig machen</td></tr>
<tr><td align="left"><code>type::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Typs eindeutig machen</td></tr>
<tr><td align="left"><code>&lt;type as trait&gt;::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Merkmals und Typs eindeutig machen</td></tr>
</tbody></table>
<p>Tabelle B-4 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
auftreten.</p>
<p><span class="caption">Tabelle B-4: Generische Datentypen</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>path&lt;...&gt;</code></td><td align="left">Spezifiziert Parameter zum generischen Typ in einem Typ<br> (z.B. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td align="left"><code>path::&lt;...&gt;</code>,<br> <code>method::&lt;...&gt;</code></td><td align="left">Spezifiziert Parameter zu einem generischen Typ,<br> einer Funktion oder Methode in einem Ausdruck;<br> oft als „turbofish“ bezeichnet (z.B. <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td align="left"><code>fn ident&lt;...&gt; ...</code></td><td align="left">Generische Funktion definieren</td></tr>
<tr><td align="left"><code>struct ident&lt;...&gt; ...</code></td><td align="left">Generische Struktur definieren</td></tr>
<tr><td align="left"><code>enum ident&lt;...&gt; ...</code></td><td align="left">Generische Aufzählung definieren</td></tr>
<tr><td align="left"><code>impl&lt;...&gt; ...</code></td><td align="left">Generische Implementierung definieren</td></tr>
<tr><td align="left"><code>for&lt;...&gt; type</code></td><td align="left">Höherstufige Lebensdauerbegrenzungen</td></tr>
<tr><td align="left"><code>type&lt;ident=type&gt;</code></td><td align="left">Generischer Typ, bei dem ein oder mehrere assoziierte<br> Typen bestimmte Zuordnungen haben<br> (z.B. <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<p>Tabelle B-5 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
mit Merkmalsabgrenzung (trait bounds) auftreten.</p>
<p><span class="caption">Tabelle B-5: Merkmalsabgrenzungen</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>T: U</code></td><td align="left">Generischer Parameter <code>T</code>, beschränkt auf Typen,<br> die <code>U</code> implementieren</td></tr>
<tr><td align="left"><code>T: 'a</code></td><td align="left">Generischer Typ <code>T</code>, der die Lebensdauer <code>'a</code> überdauert<br> (d.h. der Typ darf transitiv keine Referenzen mit einer<br> kürzeren Lebensdauer als <code>'a</code> enthalten)</td></tr>
<tr><td align="left"><code>T : 'static</code></td><td align="left">Generischer Typ <code>T</code> mit Lebensdauer <code>'static</code></td></tr>
<tr><td align="left"><code>'b: 'a</code></td><td align="left">Generische Lebensdauer <code>'b</code>, muss Lebensdauer <code>'a</code> überdauern</td></tr>
<tr><td align="left"><code>T: ?Sized</code></td><td align="left">Erlaube einen generischen Typparameter, der ein<br> dynamisch dimensionierter Typ ist</td></tr>
<tr><td align="left"><code>'a + trait</code>,<br> <code>trait + trait</code></td><td align="left">Zusammengesetzte Typabgrenzung</td></tr>
</tbody></table>
<p>Tabelle B-6 zeigt Symbole, die im Zusammenhang mit dem Aufruf oder der
Definition von Makros und der Angabe von Attributen an einem Element
vorkommen.</p>
<p><span class="caption">Tabelle B-6: Makros und Attribute</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>#[meta]</code></td><td align="left">Äußeres Attribut</td></tr>
<tr><td align="left"><code>#![meta]</code></td><td align="left">Inneres Attribut</td></tr>
<tr><td align="left"><code>$ident</code></td><td align="left">Makro-Ersetzung</td></tr>
<tr><td align="left"><code>$ident:kind</code></td><td align="left">Makro-Erfassung</td></tr>
<tr><td align="left"><code>$(…)…</code></td><td align="left">Makro-Wiederholung</td></tr>
<tr><td align="left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td align="left">Makro-Aufruf</td></tr>
</tbody></table>
<p>Tabelle B-7 zeigt Symbole, die Kommentare erzeugen.</p>
<p><span class="caption">Tabelle B-7: Kommentare</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>//</code></td><td align="left">Einzeiliger Kommentar</td></tr>
<tr><td align="left"><code>//!</code></td><td align="left">Einzeiliger Dokumentationskommentar innen</td></tr>
<tr><td align="left"><code>///</code></td><td align="left">Einzeiliger Dokumentationskommentar außen</td></tr>
<tr><td align="left"><code>/*...*/</code></td><td align="left">Block-Kommentar</td></tr>
<tr><td align="left"><code>/*!...*/</code></td><td align="left">Mehrzeiliger Dokumentationskommentar innen</td></tr>
<tr><td align="left"><code>/**...*/</code></td><td align="left">Mehrzeiliger Dokumentationskommentar außen</td></tr>
</tbody></table>
<p>Tabelle B-8 zeigt Symbole, die im Zusammenhang mit der Verwendung von Tupeln
auftreten.</p>
<p><span class="caption">Tabelle B-8: Tupel</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>()</code></td><td align="left">Leeres Tupel (auch Einheit (unit) genannt), Literal und Typ</td></tr>
<tr><td align="left"><code>(expr)</code></td><td align="left">Eingeklammerter Ausdruck</td></tr>
<tr><td align="left"><code>(expr,)</code></td><td align="left">Ein-Element-Tupel-Ausdruck</td></tr>
<tr><td align="left"><code>(type,)</code></td><td align="left">Ein-Element-Tupel-Typ</td></tr>
<tr><td align="left"><code>(expr, ...)</code></td><td align="left">Tupel-Ausdruck</td></tr>
<tr><td align="left"><code>(type, ...)</code></td><td align="left">Tupel-Typ</td></tr>
<tr><td align="left"><code>expr(expr, ...)</code></td><td align="left">Funktionsaufruf-Ausdruck; wird auch zur Initialisierung von<br> Tupel-Strukturen und Tupel-Aufzählungs-Varianten verwendet</td></tr>
<tr><td align="left"><code>expr.0</code>,<br> <code>expr.1</code> usw.</td><td align="left">Tupel-Indexierung</td></tr>
</tbody></table>
<p>Tabelle B-9 zeigt die Kontexte, in denen geschweifte Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-9: Geschweifte Klammern</span></p>
<table><thead><tr><th align="left">Context</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>{...}</code></td><td align="left">Block-Ausdruck</td></tr>
<tr><td align="left"><code>Type {...}</code></td><td align="left"><code>struct</code>-Literal</td></tr>
</tbody></table>
<p>Tabelle B-10 zeigt die Kontexte, in denen eckige Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-10: Eckige Klammern</span></p>
<table><thead><tr><th align="left">Context</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>[...]</code></td><td align="left">Array-Literal</td></tr>
<tr><td align="left"><code>[expr; len]</code></td><td align="left">Array-Literal mit <code>len</code> Kopien von <code>expr</code></td></tr>
<tr><td align="left"><code>[type; len]</code></td><td align="left">Array-Typ mit <code>len</code> Instanzen von <code>type</code></td></tr>
<tr><td align="left"><code>expr[expr]</code></td><td align="left">Sammlungs-Indexierung, ist überladbar (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td align="left"><code>expr[..]</code>,<br> <code>expr[a..]</code>,<br> <code>expr[..b]</code>,<br> <code>expr[a..b]</code></td><td align="left">Sammlungs-Indexierung, die wie ein Sammlungsanteil aussieht,<br> unter Verwendung von <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> oder<br> <code>RangeFull</code> als „Index“</td></tr>
</tbody></table>
<h2><a class="header" href="#anhang-c-ableitbare-merkmale-traits" id="anhang-c-ableitbare-merkmale-traits">Anhang C: Ableitbare Merkmale (traits)</a></h2>
<p>An verschiedenen Stellen im Buch haben wir das Attribut <code>derive</code> besprochen,
das du auf eine Struktur- oder Aufzählungsdefinition anwenden kannst. Das
Attribut <code>derive</code> generiert Code, der ein Merkmal (trait) mit seiner eigenen
Standard-Implementierung auf dem Typ implementiert, den du mit der
<code>derive</code>-Syntax annotiert hast.</p>
<p>In diesem Anhang findest du eine Referenz aller Merkmale in der
Standardbibliothek, die du mit <code>derive</code> verwenden kannst. Jeder Abschnitt
umfasst:</p>
<ul>
<li>Welche Operatoren und Methoden nach Ableiten dieses Merkmals ermöglicht
werden</li>
<li>Was die Implementierung des durch <code>derive</code> bereitgestellten Merkmals bewirkt</li>
<li>Was die Implementierung des Merkmals über den Typ aussagt</li>
<li>Die Bedingungen, unter denen du das Merkmal implementieren darfst oder nicht</li>
<li>Beispiele für Operationen, die dieses Merkmal erfordern</li>
</ul>
<p>Wenn du ein anderes Verhalten wünschst als das, das durch das Attribut <code>derive</code>
bereitgestellt wird, schaue in die <a href="https://doc.rust-lang.org/std/index.html">Standard-Bibliotheksdokumentation</a>
zu den Merkmalen, um zu erfahren, wie sie manuell implementiert werden können.</p>
<p>Der Rest der in der Standardbibliothek definierten Merkmale kann bei deinen
Typen nicht mit <code>derive</code> implementiert werden. Diese Merkmale haben kein
wahrnehmbares Standardverhalten, es liegt also an dir, sie so zu
implementieren, dass sie für das, was du erreichen willst, sinnvoll sind.</p>
<p>Ein Beispiel für ein Merkmal, das nicht abgeleitet werden kann, ist <code>Display</code>,
das die Formatierung für Endbenutzer übernimmt. Du solltest immer eine
geeignete Art und Weise in Betracht ziehen, einen Typ für einen Endbenutzer
anzuzeigen. Welche Teile des Typs sollte ein Endbenutzer sehen dürfen? Welche
Teile würden sie für relevant halten? Welches Datenformat wäre für sie am
relevantesten? Der Rust-Compiler verfügt nicht über dieses Wissen, sodass er
kein angemessenes Standardverhalten für dich bereitstellen kann.</p>
<p>Die Liste der ableitbaren Merkmale in diesem Anhang ist nicht vollständig:
Bibliotheken können <code>derive</code> für ihre eigenen Merkmale implementieren, sodass
die Liste der Merkmale, die du mit <code>derive</code> verwenden kannst, wahrlich
unbegrenzt ist. Das Implementieren von <code>derive</code> verwendet ein prozedurales
Makro, das im Abschnitt <a href="ch19-06-macros.html">„Makros“</a> in Kapitel 19 behandelt wird.</p>
<h3><a class="header" href="#debug-für-die-programmierer-ausgabe" id="debug-für-die-programmierer-ausgabe"><code>Debug</code> für die Programmierer-Ausgabe</a></h3>
<p>Das Merkmal <code>Debug</code> ermöglicht das Debuggen von Formatierungen in
Formatierungszeichenketten, die du durch Angeben von <code>:?</code> innerhalb Platzhalter
<code>{}</code> angibst.</p>
<p>Das Merkmal <code>Debug</code> erlaubt es dir, Instanzen eines Typs zu Debugging-Zwecken
auszugeben, sodass du und andere Programmierer, die deinen Typ verwenden, eine
Instanz zu einem bestimmten Zeitpunkt der Programmausführung untersuchen
können.</p>
<p>Das Merkmal <code>Debug</code> ist beispielsweise beim Verwenden des Makros <code>assert_eq!</code>
erforderlich. Dieses Makro gibt die Werte der Instanzen, die als Argumente
angegeben wurden, aus, wenn die Gleichheitszusicherung fehlschlägt, damit
Programmierer sehen können, warum die beiden Instanzen nicht gleich waren.</p>
<h3><a class="header" href="#partialeq-und-eq-für-gleichheitsvergleiche" id="partialeq-und-eq-für-gleichheitsvergleiche"><code>PartialEq</code> und <code>Eq</code> für Gleichheitsvergleiche</a></h3>
<p>Das Merkmal <code>PartialEq</code> erlaubt dir, Instanzen eines Typs auf Gleichheit zu
prüfen und ermöglicht das Verwenden der Operatoren <code>==</code> und <code>!=</code>.</p>
<p>Das Ableiten von <code>PartialEq</code> implementiert die Methode <code>eq</code>. Wenn <code>PartialEq</code>
für Strukturen abgeleitet wird, sind zwei Instanzen nur dann gleich, wenn
<em>alle</em> Felder gleich sind, und die Instanzen sind nicht gleich, wenn wenigstens
ein Feld nicht gleich ist. Beim Ableiten für Aufzählungen ist jede Variante
gleich sich selbst und nicht gleich den anderen Varianten.</p>
<p>Das Merkmal <code>PartialEq</code> ist beispielsweise beim Verwenden des Makros
<code>assert_eq!</code> erforderlich, das in der Lage sein muss, zwei Instanzen eines Typs
auf Gleichheit zu prüfen.</p>
<p>Das Merkmal <code>Eq</code> hat keine Methoden. Sein Zweck ist es, zu signalisieren, dass
für jeden Wert des annotierten Typs der Wert gleich sich selbst ist. Das
Merkmal <code>Eq</code> kann nur auf Typen angewandt werden, die auch <code>PartialEq</code>
implementieren, obwohl nicht alle Typen, die <code>PartialEq</code> implementieren, <code>Eq</code>
implementieren können. Ein Beispiel dafür sind Fließkomma-Zahlentypen: Die
Implementierung von Fließkomma-Zahlen besagt, dass zwei Instanzen des
Keine-Zahl-Wertes (<code>NaN</code>) nicht gleichwertig sind.</p>
<p>Ein Beispiel dafür, wann <code>Eq</code> erforderlich ist, ist für Schlüssel in einer
<code>HashMap&lt;K, V&gt;</code>, damit <code>HashMap&lt;K, V&gt;</code> erkennen kann, ob zwei Schlüssel gleich
sind.</p>
<h3><a class="header" href="#partialord-und-ord-für-sortiervergleiche" id="partialord-und-ord-für-sortiervergleiche"><code>PartialOrd</code> und <code>Ord</code> für Sortiervergleiche</a></h3>
<p>Das Merkmal <code>PartialOrd</code> erlaubt dir, Instanzen eines Typs zum Sortieren zu
vergleichen. Ein Typ, der <code>PartialOrd</code> implementiert, kann mit den Operatoren
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> und <code>&gt;=</code> verwendet werden. Du kannst das Merkmal <code>PartialOrd</code>
nur auf Typen anwenden, die auch <code>PartialEq</code> implementieren.</p>
<p>Das Ableiten von <code>PartialOrd</code> implementiert die Methode <code>partial_cmp</code>, die eine
<code>Option&lt;Ordering&gt;</code> zurückgibt, die <code>None</code> ist, wenn die angegebenen Werte nicht
vergleichbar sind. Ein Beispiel für einen Wert, der nicht vergleichbar ist,
obwohl die meisten Werte dieses Typs verglichen werden können, ist die
Fließkommazahl <code>NaN</code>. Der Aufruf von <code>partial_cmp</code> mit einer beliebigen
Fließkommazahl und dem Fließkommawert <code>NaN</code> ergibt <code>None</code>.</p>
<p>Beim Ableiten auf Strukturen vergleicht <code>PartialOrd</code> zwei Instanzen, indem es
den Wert in jedem Feld in der Reihenfolge vergleicht, in der die Felder in der
Strukturdefinition erscheinen. Beim Ableiten auf Aufzählungen werden Varianten,
die in der Aufzählungsdefinition früher deklariert sind, als kleiner als die
später aufgeführten Varianten betrachtet.</p>
<p>Das Merkmal <code>PartialOrd</code> ist z.B. für die Methode <code>gen_range</code> aus der Kiste
<code>rand</code> erforderlich, die einen Zufallswert aus einem Wertebereich erzeugt, der
durch einen niedrigen und einen hohen Wert festgelegt wird.</p>
<p>Das Merkmal <code>Ord</code> erlaubt dir zu wissen, dass für zwei beliebige Werte des
annotierten Typs eine gültige Reihenfolge existiert. Das Merkmal <code>Ord</code>
implementiert die Methode <code>cmp</code>, die <code>Ordering</code> statt <code>Option&lt;Ordering&gt;</code>
zurückgibt, weil eine gültige Reihenfolge immer möglich sein wird. Du kannst
das Merkmal <code>Ord</code> nur auf Typen anwenden, die auch <code>PartialOrd</code> und <code>Eq</code>
implementieren (und <code>Eq</code> erfordert <code>PartialEq</code>). Beim Ableiten auf Strukturen
und Aufzählungen verhält sich <code>cmp</code> genauso wie die abgeleitete Implementierung
für <code>partial_cmp</code> mit <code>PartialOrd</code>.</p>
<p>Ein Beispiel dafür, wann <code>Ord</code> erforderlich ist, ist das Speichern von Werten
in einem <code>BTreeSet&lt;T&gt;</code>, einer Datenstruktur, die Daten auf Grundlage der
Sortierreihenfolge der Werte speichert.</p>
<h3><a class="header" href="#clone-und-copy-zum-duplizieren-von-werten" id="clone-und-copy-zum-duplizieren-von-werten"><code>Clone</code> und <code>Copy</code> zum Duplizieren von Werten</a></h3>
<p>Das Merkmal <code>Clone</code> erlaubt es dir, explizit eine tiefe Kopie eines Wertes zu
erstellen, und der Vervielfältigungsprozess könnte die Ausführung von
beliebigem Code und das Kopieren von Daten im Haldenspeicher beinhalten.
Siehe den Abschnitt <a href="ch04-01-what-is-ownership.html#wege-wie-variablen-und-daten-interagieren-klonen-clone">„Wege, wie Variablen und Daten interagieren: Klonen
(clone)“</a> in Kapitel 4 für weitere
Informationen zu <code>Clone</code>.</p>
<p>Das Ableiten von <code>Clone</code> implementiert die Methode <code>clone</code>, die, wenn sie für
den gesamten Typ implementiert ist, <code>clone</code> auf jedem der Teile des Typs
aufruft. Das bedeutet, dass alle Felder oder Werte des Typs auch <code>Clone</code>
implementieren müssen, um <code>Clone</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Clone</code> erforderlich ist, ist der Aufruf der Methode
<code>to_vec</code> auf einem Anteilstyp. Der Anteilstyp besitzt die Typ-Instanzen nicht,
die er enthält, aber der von <code>to_vec</code> zurückgegebene Vektor muss seine
Instanzen besitzen, also ruft <code>to_vec</code> bei jedem Element <code>clone</code> auf. Daher
muss der im Anteilstyp gespeicherte Typ <code>Clone</code> implementieren.</p>
<p>Das Merkmal <code>Copy</code> erlaubt es dir, einen Wert zu duplizieren, indem nur die auf
dem Stapelspeicher gespeicherten Bits kopiert werden; es ist kein spezieller
Code notwendig. Weitere Informationen zu <code>Copy</code> findest du im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur
Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel 4.</p>
<p>Das Merkmal <code>Copy</code> definiert keine Methoden, um Programmierer daran zu hindern,
diese Methoden zu überladen und die Annahme zu verletzen, dass kein spezieller
Code ausgeführt wird. Auf diese Weise können alle Programmierer davon ausgehen,
dass das Kopieren eines Wertes sehr schnell gehen wird.</p>
<p>Du kannst <code>Copy</code> auf jeden Typ ableiten, dessen Teile alle <code>Copy</code>
implementieren. Du kannst das Merkmal <code>Copy</code> nur auf Typen anwenden, die auch
<code>Clone</code> implementieren, weil ein Typ, der <code>Copy</code> implementiert, eine triviale
Implementierung von <code>Clone</code> hat, das die gleiche Aufgabe wie <code>Copy</code> erfüllt.</p>
<p>Das Merkmal <code>Copy</code> ist selten erforderlich; Typen, die <code>Copy</code> implementieren,
verfügen über Optimierungen, d.h. du mussst nicht <code>clone</code> aufrufen, was den
Code prägnanter macht.</p>
<p>Alles, was mit <code>Copy</code> möglich ist, kannst du auch mit <code>Clone</code> erreichen, aber
der Code könnte langsamer sein oder an manchen Stellen <code>clone</code> erforderlich
machen.</p>
<h3><a class="header" href="#hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe" id="hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><code>Hash</code> für die Abbildung eines Wertes auf einen Wert fester Größe</a></h3>
<p>Das Merkmal <code>Hash</code> erlaubt es dir, eine Instanz eines Typs beliebiger Größe zu
nehmen und diese Instanz mithilfe einer Hash-Funktion auf einen Wert fester
Größe abzubilden. Das Ableiten von <code>Hash</code> implementiert die Methode <code>hash</code>. Die
abgeleitete Implementierung der Methode <code>hash</code> kombiniert das Ergebnis des
Aufrufs von <code>hash</code> für alle Teile des Typs, d.h. alle Felder oder Werte müssen
ebenfalls <code>Hash</code> implementieren, um <code>Hash</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Hash</code> erforderlich ist, ist das Speichern von
Schlüsseln in einer <code>HashMap&lt;K, V&gt;</code>, um Daten effizient zu speichern.</p>
<h3><a class="header" href="#default-für-standardwerte" id="default-für-standardwerte"><code>Default</code> für Standardwerte</a></h3>
<p>Das Merkmal <code>Default</code> erlaubt es dir, einen Standardwert für einen Typ zu
definieren. Das Ableiten von <code>Default</code> implementiert die Funktion <code>default</code>.
Die abgeleitete Implementierung der Funktion <code>default</code> ruft die Funktion
<code>default</code> für jeden Teil des Typs auf, d.h. alle Felder oder Werte in dem Typ
müssen auch <code>Default</code> implementieren, um <code>Default</code> abzuleiten.</p>
<p>Die Funktion <code>Default::default</code> wird häufig in Kombination mit der Syntax zur
Aktualisierung von Strukturen verwendet, die im Abschnitt <a href="ch05-01-defining-structs.html#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">„Instanzen aus
anderen Instanzen erzeugen mit der
Strukturaktualisierungssyntax“</a>
in Kapitel 5 besprochen wird. Du kannst einige Felder einer Struktur anpassen
und dann einen Standardwert für den Rest der Felder festlegen und verwenden,
indem du <code>...Default::default()</code> schreibst.</p>
<p>Das Merkmal <code>Default</code> ist erforderlich, wenn du die Methode <code>unwrap_or_default</code>
z.B. auf Instanzen von <code>Option&lt;T&gt;</code> verwendest. Wenn die <code>Option&lt;T&gt;</code> den Wert
<code>None</code> hat, gibt die Methode <code>unwrap_or_default</code> das Ergebnis von
<code>Default::default</code> für den Typ <code>T</code> zurück, der in <code>Option&lt;T&gt;</code> gespeichert ist.</p>
<h2><a class="header" href="#anhang-d---nützliche-entwicklungswerkzeuge" id="anhang-d---nützliche-entwicklungswerkzeuge">Anhang D - Nützliche Entwicklungswerkzeuge</a></h2>
<p>In diesem Anhang sprechen wir über einige nützliche Entwicklungswerkzeuge, die
das Rust-Projekt bietet. Wir werden uns mit automatischer Formatierung,
schnellen Möglichkeiten zum Beheben von Warnhinweisen, einem Tool zur
statischen Code-Analyse (linter) und der Integration in integrierte
Entwicklungsumgebungen (IDEs) befassen.</p>
<h3><a class="header" href="#automatische-formatierung-mit-rustfmt" id="automatische-formatierung-mit-rustfmt">Automatische Formatierung mit <code>rustfmt</code></a></h3>
<p>Das Tool <code>rustfmt</code> formatiert deinen Code entsprechend des Community-Codestils.
Viele kollaborative Projekte verwenden <code>rustfmt</code>, um Diskussionen zum Stil beim
Schreiben von Rust zu vermeiden: Jeder formatiert seinen Code mithilfe des
Tools.</p>
<p>Um <code>rustfmt</code> zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Dieser Befehl stellt dir <code>rustfmt</code> und <code>cargo-fmt</code> zur Verfügung, ähnlich wie
Rust sowohl <code>rustc</code> als auch <code>cargo</code> bereitstellt. Um ein beliebiges
Cargo-Projekt zu formatieren, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Durch Ausführen dieses Befehls wird der gesamte Rust-Code in der aktuellen
Kiste (crate) neu formatiert. Dies sollte nur den Codestil, nicht aber die
Codesemantik ändern. Weitere Informationen zu <code>rustfmt</code> findest du in <a href="https://github.com/rust-lang/rustfmt">seiner
Dokumentation</a>.</p>
<h3><a class="header" href="#korrigiere-deinen-code-mit-rustfix" id="korrigiere-deinen-code-mit-rustfix">Korrigiere deinen Code mit <code>rustfix</code></a></h3>
<p>Das Werkzeug rustfix ist in Rust-Installationen enthalten und kann automatisch
einige Compiler-Warnungen beheben. Wenn du Code in Rust geschrieben hast,
hast du wahrscheinlich Compiler-Warnungen gesehen. Betrachte zum Beispiel
diesen Code:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Hier rufen wir die Funktion <code>do_something</code> 100 Mal auf, aber wir verwenden die
Variable <code>i</code> im Rumpf der <code>for</code>-Schleife nicht. Rust warnt uns davor:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Die Warnung empfiehlt, stattdessen <code>_i</code> als Namen zu verwenden: Der Unterstrich
zeigt an, dass wir diese Variable nicht verwenden wollen. Wir können diesen
Vorschlag mit dem Werkzeug <code>rustfix</code> automatisch übernehmen, indem wir das
Kommando <code>cargo fix</code> ausführen:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Wenn wir uns <em>src/main.rs</em> noch einmal ansehen, werden wir sehen, dass
<code>cargo fix</code> den Code geändert hat:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Die <code>for</code>-Schleifenvariable heißt jetzt <code>_i</code> und die Warnung erscheint nicht
mehr.</p>
<p>Du kannst den Befehl <code>cargo fix</code> auch dazu verwenden, deinen Code zwischen
verschiedenen Rust-Ausgaben zu konvertieren. Die Ausgaben sind in <a href="appendix-05-editions.html">Anhang
E</a> aufgeführt.</p>
<h3><a class="header" href="#mehr-statische-codeanalyse-mit-clippy" id="mehr-statische-codeanalyse-mit-clippy">Mehr statische Codeanalyse mit Clippy</a></h3>
<p>Das Tool Clippy ist eine Sammlung von Tools zur statischen Codeanalyse, mit dem
du häufige Fehler aufspüren und deinen Rust-Code verbessern kannst.</p>
<p>Um Clippy zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Um Clippy bei einem Cargo-Projekt auszuführen, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Angenommen, du schreibst ein Programm, das eine Annäherung an eine
mathematische Konstante wie Pi verwendet, wie dieses Programm es tut:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Das Ausführen von <code>cargo clippy</code> in diesem Projekt führt zu diesem Fehler:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Dieser Fehler lässt dich wissen, dass Rust diese Konstante genauer definiert
hat und dass dein Programm korrekter wäre, wenn du stattdessen die Konstante
verwenden würdest. Du würdest dann deinen Code ändern, um die Konstante <code>PI</code> zu
verwenden. Der folgende Code führt zu keinen Fehlern oder Warnungen von Clippy:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Für weitere Informationen über Clippy siehe <a href="https://github.com/rust-lang/rust-clippy">seine Dokumentation</a>.</p>
<h3><a class="header" href="#ide-integration-mittels-rust-sprach-server" id="ide-integration-mittels-rust-sprach-server">IDE-Integration mittels Rust-Sprach-Server</a></h3>
<p>Um die IDE-Integration zu erleichtern, verteilt das Rust-Projekt den
<em>Rust-Sprach-Server</em> (Rust Language Server, <code>rls</code>).</p>
<p>Dieses Werkzeug spricht das <a href="http://langserver.org/">Sprach-Server-Protokoll (Language Server
Protocol)</a>, das eine Spezifikation für IDEs und Programmiersprachen zur
Kommunikation untereinander ist. Verschiedene Clients können den <code>rls</code>
verwenden, z.B. <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">das Rust-Plugin für Visual Studio Code</a>.</p>
<p>Um den <code>rls</code> zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<p>Installiere dann die Sprachserver-Unterstützung in deiner speziellen IDE; du
bekommst Fähigkeiten wie Autovervollständigung, Sprung zur Definition und im
Code eingeblendete Fehlermeldungen.</p>
<p>Für weitere Informationen über den <code>rls</code> siehe <a href="https://github.com/rust-lang/rls">seine Dokumentation</a>.</p>
<h2><a class="header" href="#anhang-e---ausgaben" id="anhang-e---ausgaben">Anhang E - Ausgaben</a></h2>
<p>In Kapitel 1 hast du gesehen, dass <code>cargo new</code> Metadaten zur Ausgabe (edition)
in deiner Datei <em>Cargo.toml</em> hinzufügt. Dieser Anhang erläutert, was das
bedeutet!</p>
<p>Die Sprache Rust und der Compiler haben einen sechswöchigen
Veröffentlichungs-Zyklus, was bedeutet, dass die Nutzer einen konstanten Strom
neuer Funktionen erhalten. Andere Programmiersprachen geben weniger oft größere
Änderungen heraus; Rust gibt häufiger kleinere Aktualisierungen heraus. Nach
einer Weile summieren sich all diese kleinen Änderungen. Aber von
Veröffentlichung zu Veröffentlichung kann es schwierig sein, zurückzublicken
und zu sagen: &quot;Wow, zwischen Rust 1.10 und Rust 1.31 hat sich Rust sehr
verändert!</p>
<p>Alle zwei oder drei Jahre gibt das Rust-Team eine neue <em>Rust-Ausgabe</em> (edition)
heraus. Jede Ausgabe fasst die neuen Funktionalitäten in einem übersichtlichen
Paket mit vollständig aktualisierter Dokumentation und Werkzeugausstattung
zusammen. Neue Ausgaben werden im Rahmen des üblichen sechswöchigen
Freigabeprozesses ausgeliefert.</p>
<p>Ausgaben dienen unterschiedlichen Zwecken für verschiedene Menschen:</p>
<ul>
<li>Für aktive Rust-Nutzer fasst eine neue Ausgabe inkrementelle Änderungen in
einem leicht verständlichen Paket zusammen.</li>
<li>Für Nicht-Nutzer signalisiert eine neue Ausgabe, dass einige wichtige
Fortschritte hinzugekommen sind, sodass sich ein erneuter Blick auf Rust
lohnen könnte.</li>
<li>Für diejenigen, die Rust entwickeln, stellt eine neue Ausgabe einen
Treffpunkt für das gesamte Projekt dar.</li>
</ul>
<p>Zum Verfassungszeitpunkt dieses Artikels sind zwei Rust-Ausgaben verfügbar:
Rust 2015 und Rust 2018. Dieses Buch wurde unter Verwendung der Rust-Ausgabe
2018 geschrieben.</p>
<p>Der Schlüssel <code>edition</code> in <em>Cargo.toml</em> gibt an, welche Ausgabe der Compiler
für deinen Code verwenden soll. Wenn der Schlüssel nicht existiert, verwendet
Rust aus Gründen der Abwärtskompatibilität die Edition <code>2015</code>.</p>
<p>Jedes Projekt kann sich für eine Ausgabe abweichend von der Standardausgabe
2015 entscheiden. Ausgaben können inkompatible Änderungen enthalten, z.B. die
Aufnahme eines neuen Schlüsselworts, das mit Bezeichnern im Code in Konflikt
steht. Selbst wenn du dich nicht für diese Änderungen entscheidest, wird dein
Code weiterhin kompilieren, auch wenn du die verwendete
Rust-Compiler-Version aktualisierst.</p>
<p>Alle Rust-Compiler-Versionen unterstützen jede Ausgabe, die vor der
Veröffentlichung dieses Compilers existierte, und es können Kisten (crates)
aller unterstützten Ausgaben miteinander verknüpft werden. Ausgabenänderungen
wirken sich nur auf die Art und Weise aus, wie der Compiler anfangs den Code
analysiert. Wenn du also Rust 2015 verwendest und eine deiner Abhängigkeiten
Rust 2018 verwendet, wird dein Projekt diese Abhängigkeit kompilieren und
nutzen können. Die umgekehrte Situation, in der dein Projekt Rust 2018
und eine Abhängigkeit Rust 2015 verwendet, funktioniert ebenfalls.</p>
<p>Um es klar zu sagen: Die meisten Funktionen werden in allen Ausgaben verfügbar
sein. Entwickler, die eine beliebige Rust-Ausgabe verwenden, werden auch
weiterhin Verbesserungen sehen, wenn neue stabile Versionen erstellt werden. In
einigen Fällen, vor allem wenn neue Schlüsselwörter hinzugefügt werden, sind
einige neue Funktionalitäten jedoch möglicherweise erst in späteren Ausgaben
verfügbar. Du wirst die Ausgabe wechseln müssen, wenn du die Vorteile solcher
Funktionalitäten nutzen möchtest.</p>
<p>Für weitere Einzelheiten schaue in den <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Ausgabe-Leitfaden</em> (Edition
Guide)</a>, einem vollständigen Buch über Ausgaben, das die
Unterschiede zwischen den Ausgaben aufzählt und erklärt, wie du deinen Code
automatisch per <code>cargo fix</code> auf eine neue Ausgabe aktualisieren kannst.</p>
<h2><a class="header" href="#anhang-f-Übersetzungen-des-buchs" id="anhang-f-Übersetzungen-des-buchs">Anhang F: Übersetzungen des Buchs</a></h2>
<p>Für Ressourcen in anderen Sprachen als Englisch. Die meisten sind noch in
Arbeit; siehe das <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Label <code>Translations</code></a>, um zu helfen oder uns über
eine neue Übersetzung zu informieren!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português (BR)</a>
– <a href="https://rust-br.github.io/rust-book-pt-br/">HTML-Version</a></li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português (PT)</a></li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a>
– <a href="https://kaisery.github.io/trpl-zh-cn/">HTML-Version</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a> </li>
<li><a href="https://github.com/ManRR/rust-book-es">Español</a>
– <a href="https://doc.rust-lang.ru/book/">HTML-Version</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a>
– <a href="https://doc.rust-lang.ru/book/">HTML-Version</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a>
– <a href="https://rinthel.github.io/rust-lang-book-ko/">HTML-Version</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a>
– <a href="https://doc.rust-jp.rs/book/second-edition/">HTML-Version</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a>
– <a href="https://jimskapt.github.io/rust-book-fr/">HTML-Version</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a>
– <a href="https://pouriamokhtari.ir/rust-book-fa/">HTML-Version</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a>
– <a href="https://rust-lang-de.github.io/rustbook-de/">HTML-Version</a></li>
<li><a href="https://github.com/RustDili/dokuman/tree/master/ceviriler">Turkish</a>
– <a href="https://rustdili.github.io/">HTML-Version</a></li>
</ul>
<h2><a class="header" href="#anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust" id="anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust">Anhang G - Wie Rust erstellt wird und „nächtliches Rust“</a></h2>
<p>In diesem Anhang geht es darum, wie Rust erstellt wird und wie sich das auf
dich als Rust-Entwickler auswirkt.</p>
<h3><a class="header" href="#stabilität-ohne-stillstand" id="stabilität-ohne-stillstand">Stabilität ohne Stillstand</a></h3>
<p>Als Sprache kümmert sich Rust <em>viel</em> um die Stabilität deines Codes. Wir
wollen, dass Rust ein felsenfestes Fundament ist, auf dem du aufbauen kannst,
und wenn sich die Dinge ständig ändern würden, wäre das unmöglich. Gleichzeitig
werden wir, wenn wir nicht mit neuen Funktionen experimentieren können,
wichtige Mängel vielleicht erst nach ihrer Veröffentlichung entdecken, wenn wir
die Dinge nicht mehr ändern können.</p>
<p>Unsere Lösung für dieses Problem ist das, was wir „Stabilität ohne Stillstand“
nennen, und unser Leitsatz lautet: Du solltest niemals Angst vor einem Upgrade
auf eine neue Version des stabilen Rust haben müssen. Jedes Upgrade sollte
schmerzlos sein, aber auch neue Funktionalitäten, weniger Fehler und schnellere
Kompilierzeiten mit sich bringen.</p>
<h3><a class="header" href="#tüff-tüff-veröffentlichungs-kanäle-und-zugfahren" id="tüff-tüff-veröffentlichungs-kanäle-und-zugfahren">Tüff, tüff! Veröffentlichungs-Kanäle und Zugfahren</a></h3>
<p>Die Rust-Entwicklung erfolgt nach einem <em>Zugfahrplan</em> (train schedule). Das
bedeutet, dass die gesamte Entwicklung auf dem <code>master</code>-Zweig der
Rust-Versionsverwaltung durchgeführt wird. Die Veröffentlichungen folgen einem
Software-Veröffentlichungs-Zugmodell, das von Cisco IOS und anderen
Softwareprojekten verwendet wurde. Es gibt drei <em>Veröffentlichungskanäle</em>
(release channels) für Rust:</p>
<ul>
<li>Nächtlich (nightly)</li>
<li>Beta</li>
<li>Stabil (stable)</li>
</ul>
<p>Die meisten Rust-Entwickler verwenden in erster Linie den stabilen Kanal, aber
diejenigen, die experimentelle neue Funktionen ausprobieren wollen, können
nächtlich oder beta verwenden.</p>
<p>Hier ist ein Beispiel dafür, wie der Entwicklungs- und Veröffentlichungsprozess
funktioniert: Nehmen wir an, das Rust-Team arbeitet an der Veröffentlichung von
Rust 1.5. Diese Veröffentlichung erfolgte im Dezember 2015, aber sie wird uns
realistische Versionsnummern liefern. Eine neue Funktionalität wird zu Rust
hinzugefügt: Eine neue Änderung (commit) kommt in den <code>master</code>-Zweig. Jede
Nacht wird eine neue nächtliche Version von Rust produziert. Jeder Tag ist ein
Veröffentlichungs-Tag und diese Veröffentlichungen werden automatisch von
unserer Veröffentlichungs-Infrastruktur erstellt. Mit der Zeit sehen unsere
Veröffentlichungen also so aus, einmal pro Nacht:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
</code></pre>
<p>Alle sechs Wochen ist es an der Zeit, eine neue Version vorzubereiten! Der
<code>beta</code>-Zweig der Rust-Versionsverwaltung verzweigt vom <code>master</code>-Zweig, der von
„nächtlich“ benutzt wird. Jetzt gibt es zwei Versionen:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Die meisten Rust-Nutzer verwenden Beta-Versionen nicht aktiv, sondern testen
gegen die Beta-Version in ihrem CI-System, um Rust bei der Entdeckung möglicher
Regressionen zu unterstützen. In der Zwischenzeit gibt es immer noch jede Nacht
eine nächtliche Veröffentlichung:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Sagen wir, es wird eine Regression gefunden. Gut, dass wir etwas Zeit hatten,
die Beta-Version zu testen, bevor sich die Regression in eine stabile Version
eingeschlichen hat! Die Fehlerkorrektur wird auf <code>master</code> angewendet, sodass
„nächtlich“ korrigiert wird, und dann wird die Fehlerkorrektur in den
<code>beta</code>-Zweig zurückportiert und eine neue Version der Beta erzeugt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - *
                       |
beta:                  * - - - - - - - - *
</code></pre>
<p>Sechs Wochen nachdem die erste Beta-Version erstellt wurde, ist es Zeit für
eine stabile Veröffentlichung! Der <code>stable</code>-Zweig wird aus dem <code>beta</code>-Zweig
erstellt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |
beta:                  * - - - - - - - - *
                                         |
stabil:                                  *
</code></pre>
<p>Hurra! Rust 1.5 ist geschafft! Eines haben wir jedoch vergessen: Da die sechs
Wochen vergangen sind, brauchen wir auch eine neue Beta der <em>nächsten</em> Version,
Rust 1.6. Nachdem also <code>stable</code> von <code>beta</code> abzweigt, zweigt die nächste Version
von <code>beta</code> wieder von <code>nightly</code> ab:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |                         |
beta:                  * - - - - - - - - *       *
                                         |
stabil:                                  *
</code></pre>
<p>Dies wird als „Zugmodell“ (train model) bezeichnet, weil alle sechs Wochen eine
Veröffentlichung „den Bahnhof verlässt“, aber immer noch eine Reise durch den
Betakanal machen muss, bevor sie als stabile Version ankommt.</p>
<p>Alle sechs Wochen veröffentlicht Rust eine Version, wie ein Uhrwerk. Wenn du
das Datum einer Rust-Veröffentlichung kennst, kennst du auch das Datum der
nächsten: Sie ist sechs Wochen später. Ein schöner Aspekt der alle sechs Wochen
geplanten Veröffentlichungen ist, dass der nächste Zug bald kommt. Wenn eine
Funktionalität eine bestimmte Veröffentlichung verpasst, brauchst du dir keine
Sorgen zu machen: In kurzer Zeit kommt die nächste! Dies trägt dazu bei, den
Druck zu verringern, bevor sich möglicherweise unausgefeilte Funktionalitäten
kurz vor Ablauf der Veröffentlichungsfrist einschleichen.</p>
<p>Dank dieses Prozesses kannst du jederzeit die nächste Rust-Version ausprobieren
und dich selbst davon überzeugen, dass ein Upgrade leicht möglich ist: Wenn
eine Beta-Version nicht wie erwartet funktioniert, kannst du dies dem Team
melden und sie vor der nächsten stabilen Version korrigieren lassen! Ein Bruch
in einer Beta-Version ist relativ selten, aber <code>rustc</code> ist immer noch ein Stück
Software und es gibt Fehler.</p>
<h3><a class="header" href="#instabile-funktionalitäten" id="instabile-funktionalitäten">Instabile Funktionalitäten</a></h3>
<p>Bei diesem Veröffentlichungsmodell gibt es noch einen weiteren Haken: Instabile
Funktionalitäten. Rust verwendet eine Technik namens „Funktionalitäts-Schalter“
(feature flags), um festzulegen, welche Funktionalitäten in einer bestimmten
Version aktiviert sind. Wenn eine neue Funktionalität aktiv entwickelt wird,
landet sie auf dem <code>master</code> und damit in „nächtlich“, aber hinter einem
<em>Funktionalitäts-Schalter</em>. Wenn du als Nutzer eine in Entwicklung befindliche
Funktionalität ausprobieren möchtest, kannst du dies tun, aber du musst eine
nächtliche Version von Rust verwenden und deinen Quellcode mit dem
entsprechenden Schalter versehen, um sie nutzen zu können.</p>
<p>Wenn du eine Beta- oder stabile Version von Rust verwendest, kannst du keine
Funktionalitäts-Schalter verwenden. Dies ist der Schlüssel, der es uns
ermöglicht, neue Funktionen praktisch zu nutzen, bevor wir sie für immer für
stabil erklären. Diejenigen, die sich für das Allerneueste entscheiden wollen,
können dies tun, und diejenigen, die eine felsenfeste Erfahrung machen wollen,
können bei der stabilen Version bleiben und wissen, dass ihr Code nicht brechen
wird. Stabilität ohne Stillstand. Dieses Buch enthält nur Informationen über
stabile Funktionalitäten, da sich in Entwicklung befindliche Funktionalitäten
noch ändern, und sicherlich werden sie sich zwischen dem Zeitpunkt, an dem
dieses Buch geschrieben wurde, und dem Zeitpunkt, an dem sie in stabilen
Versionen aktiviert werden, unterscheiden. Die Dokumentation für die nur
nächtlich verfügbaren Funktionalitäten findest du online.</p>
<h3><a class="header" href="#rustup-und-die-rolle-des-nächtlichen-rust" id="rustup-und-die-rolle-des-nächtlichen-rust">Rustup und die Rolle des nächtlichen Rust</a></h3>
<p>Rustup macht es einfach, zwischen verschiedenen Veröffentlichungskanälen von
Rust zu wechseln, auf globaler oder projektbezogener Basis. Standardmäßig hast
du stabiles Rust installiert. Um die nächtliche Version zu installieren, mache
folgenden Aufruf:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Du kannst auch alle <em>Werkzeugketten</em> (toolchains) (Versionen von Rust und
zugehörigen Komponenten) sehen, die du mit <code>rustup</code> installiert hast. Hier ist
ein Beispiel auf dem Windows-Rechner einer deiner Autoren:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Wie du sehen kannst, ist die stabile Werkzeugkette die Standardeinstellung. Die
meisten Rust-Nutzer verwenden meistens die stabile Version. Vielleicht möchtest
du die meiste Zeit die stabile Version verwenden, aber für ein bestimmtes
Projekt mit der nächtlichen Version arbeiten, weil dir eine innovative
Funktionalität wichtig ist. Um dies zu tun, kannst du <code>rustup override</code> im
Verzeichnis dieses Projekts benutzen, um die nächtliche Werkzeugkette als
diejenige zu setzen, die <code>rustup</code> benutzen soll, wenn du dich in diesem
Verzeichnis befindest:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Jedes Mal, wenn du nun <code>rustc</code> oder <code>cargo</code> innerhalb von
<em>~/projects/needs-nightly</em> aufrufst, stellt <code>rustup</code> sicher, dass du das
nächtliche Rust verwendest und nicht dein standardmäßiges, stabiles Rust. Das
ist praktisch, wenn du viele Rust-Projekte hast!</p>
<h3><a class="header" href="#der-rfc-prozess-und-die-teams" id="der-rfc-prozess-und-die-teams">Der RFC-Prozess und die Teams</a></h3>
<p>Wie erfährst du also von diesen neuen Funktionalitäten? Das Entwicklungsmodell
von Rust folgt einem <em>Bitte-um-Kommentare-Prozess</em> (Request For Comments, RFC). 
Wenn du eine Verbesserung von Rust wünschst, kannst du einen Vorschlag
schreiben, einen sogenannten RFC.</p>
<p>Jeder kann RFCs zur Verbesserung von Rust schreiben und die Vorschläge werden
vom Rust-Team, das aus vielen thematischen Unterteams besteht, geprüft und
diskutiert. Es gibt eine vollständige Liste der Teams auf der
<a href="https://www.rust-lang.org/governance">Rust-Website</a>, in der die Teams für jeden Projektbereich
aufgeführt sind: Sprachdesign, Compiler-Implementierung, Infrastruktur,
Dokumentation und weitere. Das zuständige Team liest den Vorschlag und die
Kommentare, schreibt einige eigene Kommentare und schließlich gibt es einen
Konsens, die Funktionalität anzunehmen oder abzulehnen.</p>
<p>Wenn die Funktionalität angenommen wird, wird ein Ticket (issue) in der
Rust-Versionsverwaltung eröffnet, und jemand kann es implementieren. Die
Person, die es sehr gut umsetzt, ist möglicherweise nicht die Person, die die
Funktionalität ursprünglich vorgeschlagen hat! Wenn die Implementierung fertig
ist, landet sie auf dem <code>master</code>-Zweig hinter einem Funktionalitäts-Schalter,
wie wir im Abschnitt <a href="appendix-07-nightly-rust.html#instabile-funktionalit%C3%A4ten">„Instabile
Funktionalitäten“</a> besprochen haben.</p>
<p>Nach einiger Zeit, in der Rust-Entwickler die neue Funktionalität in den
nächtlichen Veröffentlichungen ausprobieren konnten, werden die Teammitglieder
die Ausarbeitung der Funktionalität im nächtlichen Zweig diskutieren und
entscheiden, ob sie ins stabile Rust kommen soll oder nicht. Wenn die
Entscheidung positiv ist, wird das Funktionalitätstor (feature gate) entfernt
und die Funktionalität gilt jetzt als stabil! Sie fährt mit den Zügen in eine
neue stabile Version von Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
